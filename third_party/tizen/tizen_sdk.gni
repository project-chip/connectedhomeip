# Copyright (c) 2020 Project CHIP Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import("//build_overrides/build.gni")
import("//build_overrides/chip.gni")
import("//build_overrides/tizen.gni")

import("${build_root}/config/tizen/config.gni")

tizen_dev_certificate = get_path_info("tizen_dev_certificate.py", "abspath")
tizen_manifest_parser = get_path_info("tizen_manifest_parser.py", "abspath")
tizen_qemu = get_path_info("tizen_qemu.py", "abspath")

# Run Tizen Studio CLI as a project builder.
#
# Parameters:
#   project_build_dir: Directory to build the project in.
#   project_app_name: Name of the application within the project.
#   args: List of arguments to pass to the CLI.
#   outputs: List of created output files.
#   deps: List of dependencies.
template("tizen_sdk") {
  forward_variables_from(invoker,
                         [
                           "project_build_dir",
                           "project_app_name",
                         ])

  if (!defined(project_app_name)) {
    project_app_name = "tizen-app"
  }

  # Create a dummy project definition file, so the Tizen Studio CLI
  # will recognize our build directory as a Tizen project.
  write_file("${project_build_dir}/project_def.prop",
             [
               "# Generated by the GN script. DO NOT EDIT!",
               "APPNAME = " + project_app_name,
               "type = app",
             ])

  # Create a dummy project file, so the Tizen Studio CLI will not
  # complain about invalid XPath (this file is not used anyway...)
  write_file("${project_build_dir}/.project",
             [
               "<!-- Generated by the build script. DO NOT EDIT! -->",
               "<projectDescription></projectDescription>",
             ])

  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "outputs",
                           ])
    script = "${build_root}/gn_run_binary.py"
    args = [ "${tizen_sdk_root}/tools/ide/bin/tizen" ] + invoker.args
  }
}

# Generate author certificate and security profile.
#
# Parameters:
#   author_certificate_name: Author certificate name field.
#   author_certificate_email: Author certificate email field.
#   author_certificate_password: Password for the author certificate.
#   sign_security_profile: Name of the security profile to add.
template("tizen_sdk_certificate") {
  assert(defined(invoker.author_certificate_password),
         "It is required to specify `author_certificate_password`.")
  assert(defined(invoker.sign_security_profile),
         "It is required to specify a `sign_security_profile` which " +
             "should be added to Tizen security profiles.")
  stamp_file = "${root_out_dir}/.tizen_sdk_dev_certificate_stamp"
  action(target_name) {
    forward_variables_from(invoker, [ "deps" ])
    script = tizen_dev_certificate
    args = [
      "--author-certificate-name=" + invoker.author_certificate_name,
      "--author-certificate-email=" + invoker.author_certificate_email,
      "--author-certificate-password=" + invoker.author_certificate_password,
      "--sign-security-profile=" + invoker.sign_security_profile,
      "--stamp-file=" + rebase_path(stamp_file),
    ]
    outputs = [ stamp_file ]
  }
}

# Package Tizen application as a TPK bundle.
#
# Parameters:
#   manifest: The path to Tizen XML manifest file to use.
#   sign_security_profile: Name of the security profile to use for signing.
#   deps: List of dependencies.
template("tizen_sdk_package") {
  assert(defined(invoker.manifest),
         "It is required to specify Tizen `manifest` XML file.")
  assert(defined(invoker.sign_security_profile),
         "It is required to specify a `sign_security_profile` which " +
             "should be used for signing TPK package.")

  # Extract data from Tizen XML manifest.
  manifest = exec_script(tizen_manifest_parser,
                         [ rebase_path(invoker.manifest) ],
                         "json")
  manifest_package = manifest["package"]
  manifest_package_name = manifest_package["name"]
  manifest_package_version = manifest_package["version"]
  manifest_apps = manifest["apps"]

  # Output directory where packaging will occur. We need a separate directory
  # for this, because Tizen Studio CLI scans "res" (resources), "shared" and
  # "lib" directories for items to pack. In our case it could include in the
  # TPK package libraries available in ${root_out_dir}/lib directory.
  tizen_package_dir = "${root_out_dir}/${manifest_package_name}"
  tizen_package_out_dir = "${tizen_package_dir}/out"

  # Copy Tizen manifest from the source directory.
  copy("${target_name}:manifest") {
    sources = [ invoker.manifest ]
    outputs = [ "${tizen_package_dir}/{{source_file_part}}" ]
    deps = invoker.deps
  }

  # List of dependencies for Tizen Studio CLI packager.
  dependencies = [ ":${target_name}:manifest" ]

  # Copy executable(s) to temporary output directory. This action is required,
  # because Tizen Studio CLI expects particular directory layout - it is not
  # possible to specify input files manually.
  if (manifest_apps["service"] != "") {
    dependencies += [ ":${target_name}:app:service" ]
    copy("${target_name}:app:service") {
      sources = [ root_out_dir + "/" + manifest_apps["service"] ]
      outputs = [ "${tizen_package_out_dir}/{{source_file_part}}" ]
      deps = invoker.deps
    }
  }

  tpk = "${manifest_package_name}-${manifest_package_version}.tpk"
  tizen_sdk(target_name) {
    deps = invoker.deps + dependencies
    outputs = [ "${tizen_package_out_dir}/${tpk}" ]
    project_build_dir = tizen_package_dir
    args = [
      "package",
      "--type",
      "tpk",
      "--sign",
      invoker.sign_security_profile,
      "--",
      rebase_path(tizen_package_out_dir),
    ]
  }
}

# Create ISO image for Tizen QEMU.
#
# Parameters:
#   runner: Path to the Tizen QEMU runner script.
#   assets: List of assets to copy to the ISO image.
template("tizen_qemu_mkisofs") {
  # This target shall only be used for testing purposes.
  testonly = true

  assert(defined(invoker.runner), "It is required to specify runner script.")
  assert(get_path_info(invoker.runner, "file") == "runner.sh",
         "Runner script must be named 'runner.sh'")

  image_file = "${target_gen_dir}/${target_name}.iso"

  action(target_name) {
    forward_variables_from(invoker, [ "deps" ])
    inputs = [ invoker.runner ]
    outputs = [ image_file ]

    args = [
      "mkisofs",
      "-input-charset=default",
      "-VCHIP",  # Volume ID = CHIP
      "-JRU",  # Joliet + Rock Ridge with untranslated filenames
    ]

    # Exclude files from the ISO image which might otherwise be included
    # by non-tracked assets in case of adding entire directory. This will
    # not exclude files added explicitly.
    if (defined(invoker.assets_non_tracked_exclude_globs)) {
      foreach(glob, invoker.assets_non_tracked_exclude_globs) {
        args += [
          "-m",
          glob,
        ]
      }
    }

    args += [
      "-o",
      rebase_path(image_file),
      rebase_path(invoker.runner),
    ]

    if (defined(invoker.assets)) {
      args += invoker.assets
      inputs += invoker.assets
    }
    if (defined(invoker.assets_non_tracked)) {
      args += invoker.assets_non_tracked
    }

    script = "${build_root}/gn_run_binary.py"
  }
}

# Run Tizen in QEMU.
#
# Parameters:
#   iso_image: The path to ISO image with the runner script.
#   virtio_net: Enable external network access.
template("tizen_qemu_run") {
  # This target shall only be used for testing purposes.
  testonly = true

  assert(defined(invoker.iso_image),
         "It is required to specify ISO runner image.")

  # Store QEMU output in a dedicated log file.
  output_log_file = "${root_out_dir}/tizen-qemu-" + target_name + ".log"

  action(target_name) {
    forward_variables_from(invoker, [ "deps" ])
    inputs = [ invoker.iso_image ]
    outputs = [ output_log_file ]

    args = [
      "--image-iso=" + invoker.iso_image,
      "--output=" + rebase_path(output_log_file),
    ]
    if (defined(invoker.virtio_net) && invoker.virtio_net) {
      args += [ "--virtio-net" ]
    }

    script = tizen_qemu
  }
}
