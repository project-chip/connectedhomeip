diff --git a/externals/mbedtls/include/mbedtls/config.h b/externals/mbedtls/include/mbedtls/config.h
index ab6ae2b..ac8a08d 100644
--- a/externals/mbedtls/include/mbedtls/config.h
+++ b/externals/mbedtls/include/mbedtls/config.h
@@ -132,7 +132,7 @@
  *
  * Comment if your system does not support time functions
  */
-//#define MBEDTLS_HAVE_TIME
+#define MBEDTLS_HAVE_TIME
 
 /**
  * \def MBEDTLS_HAVE_TIME_DATE
diff --git a/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c b/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c
index e56fbc2..da79af0 100644
--- a/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c
+++ b/optiga/comms/ifx_i2c/ifx_i2c_physical_layer.c
@@ -568,6 +568,7 @@ _STATIC_H void ifx_i2c_pl_frame_event_handler(ifx_i2c_context_t * p_ctx, optiga_
                     break;
                 }
             }
+            [[fallthrough]];
             //lint -fallthrough "For write frame, polling of i2c status register is skipped"
             // Do read/write frame
             case PL_STATE_DATA_AVAILABLE:
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal.c
new file mode 100644
index 0000000..63058a2
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal.c
@@ -0,0 +1,81 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal.c
+*
+* \brief    This file implements the platform abstraction layer APIs.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+
+#include "optiga/pal/pal.h"
+#include "optiga/pal/pal_gpio.h"
+#include "optiga/pal/pal_i2c.h"
+#include "optiga/pal/pal_os_event.h"
+#include "optiga/pal/pal_os_timer.h"
+#include "pal_psoc_gpio_mapping.h"
+#include "optiga_lib_config.h"
+
+#ifdef OPTIGA_TRUSTM_VDD
+extern pal_gpio_t optiga_vdd_0;
+#endif
+
+#ifdef OPTIGA_TRUSTM_RST
+extern pal_gpio_t optiga_reset_0;
+#endif
+
+
+pal_status_t pal_init(void)
+{
+    // This function call is used to create a semaphore outside of the ISR
+    pal_i2c_init(NULL);
+
+    #ifdef OPTIGA_TRUSTM_VDD
+    pal_gpio_init(&optiga_vdd_0);
+    #endif
+
+    #ifdef OPTIGA_TRUSTM_RST
+    pal_gpio_init(&optiga_reset_0);
+    #endif
+    return PAL_STATUS_SUCCESS;
+}
+
+
+pal_status_t pal_deinit(void)
+{
+    // This function call is used to destroy a semaphore outside of the ISR
+    pal_i2c_deinit(NULL);
+    return PAL_STATUS_SUCCESS;
+}
+
+/**
+* @}
+*/
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_gpio.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_gpio.c
new file mode 100644
index 0000000..d12c895
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_gpio.c
@@ -0,0 +1,93 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_gpio.c
+*
+* \brief   This file implements the platform abstraction layer APIs for GPIO.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+//#include <DAVE.h>
+#include "optiga/pal/pal_ifx_i2c_config.h"
+#include "optiga/pal/pal_gpio.h"
+#include "pal_psoc_gpio_mapping.h"
+
+
+#include "cy_pdl.h"
+#include "cyhal.h"
+#include "cybsp.h"
+
+//lint --e{714,715} suppress "This is implemented for overall completion of API"
+pal_status_t pal_gpio_init(const pal_gpio_t * p_gpio_context)
+{
+    pal_status_t cy_hal_status = PAL_STATUS_SUCCESS;
+    pal_psoc_gpio_t* pin_config = (pal_psoc_gpio_t *)p_gpio_context->p_gpio_hw;
+    cy_hal_status = cyhal_gpio_init(pin_config->gpio,
+                                       CYHAL_GPIO_DIR_OUTPUT, 
+                                       CYHAL_GPIO_DRIVE_STRONG, 
+                                       pin_config->init_state);
+    if (CY_RSLT_SUCCESS != cy_hal_status)
+    {
+        cy_hal_status = PAL_STATUS_FAILURE;
+    }
+
+    return (cy_hal_status);
+}
+
+//lint --e{714,715} suppress "This is implemented for overall completion of API"
+pal_status_t pal_gpio_deinit(const pal_gpio_t * p_gpio_context)
+{
+    pal_psoc_gpio_t* pin_config = (pal_psoc_gpio_t *)p_gpio_context->p_gpio_hw;
+    cyhal_gpio_free(pin_config->gpio);
+    return (PAL_STATUS_SUCCESS);
+}
+
+void pal_gpio_set_high(const pal_gpio_t * p_gpio_context)
+{
+    if ((p_gpio_context != NULL) && (p_gpio_context->p_gpio_hw != NULL))
+    {
+        pal_psoc_gpio_t* pin_config = (pal_psoc_gpio_t *)p_gpio_context->p_gpio_hw;
+        cyhal_gpio_write((cyhal_gpio_t)(pin_config->gpio), true);
+    }
+}
+
+void pal_gpio_set_low(const pal_gpio_t * p_gpio_context)
+{
+    if ((p_gpio_context != NULL) && (p_gpio_context->p_gpio_hw != NULL))
+    {
+        pal_psoc_gpio_t* pin_config = (pal_psoc_gpio_t *)p_gpio_context->p_gpio_hw;
+        cyhal_gpio_write((cyhal_gpio_t)(pin_config->gpio), false);
+    }
+}
+
+/**
+* @}
+*/
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_i2c.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_i2c.c
new file mode 100644
index 0000000..14fce98
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_i2c.c
@@ -0,0 +1,345 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_i2c.c
+*
+* \brief   This file implements the platform abstraction layer(pal) APIs for I2C.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_i2c.h"
+#include "pal_psoc_i2c_mapping.h"
+#include "cy_pdl.h"
+#include "cyhal.h"
+#include "cybsp.h"
+#include "cyhal_scb_common.h"
+
+#include "FreeRTOS.h"
+#include "task.h"
+#include "semphr.h"
+
+#define PAL_I2C_MASTER_MAX_BITRATE  (400U)
+#define PAL_I2C_MASTER_INTR_PRIO    (3U)
+/// @cond hidden
+
+_STATIC_H volatile uint32_t g_entry_count = 0;
+_STATIC_H const pal_i2c_t * gp_pal_i2c_current_ctx;
+_STATIC_H uint8_t g_pal_i2c_init_flag = 0;
+_STATIC_H TaskHandle_t i2c_taskhandle = NULL;
+_STATIC_H SemaphoreHandle_t xIicSemaphoreHandle;
+
+
+// I2C acquire bus function
+//lint --e{715} suppress the unused p_i2c_context variable lint error , since this is kept for future enhancements
+static pal_status_t pal_i2c_acquire(const void* p_i2c_context)
+{
+    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+
+    if ( xSemaphoreTakeFromISR(xIicSemaphoreHandle, &xHigherPriorityTaskWoken) == pdTRUE )
+        return PAL_STATUS_SUCCESS;
+    else
+        return PAL_STATUS_FAILURE;
+}
+
+// I2C release bus function
+//lint --e{715} suppress the unused p_i2c_context variable lint, since this is kept for future enhancements
+static void pal_i2c_release(const void* p_i2c_context)
+{
+    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+
+    xSemaphoreGiveFromISR(xIicSemaphoreHandle, &xHigherPriorityTaskWoken);
+}
+
+
+static void i2c_task(void *pvParameters)
+{
+  upper_layer_callback_t upper_layer_handler;
+  uint32_t event = 0;
+
+  while(1)
+  {
+    xTaskNotifyWait(0, 0xffffffff, &event, portMAX_DELAY);
+
+    upper_layer_handler = (upper_layer_callback_t)gp_pal_i2c_current_ctx->upper_layer_event_handler;
+    
+    if (0UL != (CYHAL_I2C_MASTER_ERR_EVENT & event))
+    {
+        /* In case of error abort transfer */
+        cyhal_i2c_abort_async(((pal_psoc_i2c_t *)(gp_pal_i2c_current_ctx->p_i2c_hw_config))->i2c_master_channel);
+        upper_layer_handler(gp_pal_i2c_current_ctx->p_upper_layer_ctx, PAL_I2C_EVENT_ERROR);
+    }
+    /* Check write complete event */
+    else if (0UL != (CYHAL_I2C_MASTER_WR_CMPLT_EVENT & event))
+    {
+        /* Perform the required functions */
+        upper_layer_handler(gp_pal_i2c_current_ctx->p_upper_layer_ctx, PAL_I2C_EVENT_SUCCESS);
+    }
+    /* Check read complete event */
+    else if (0UL != (CYHAL_I2C_MASTER_RD_CMPLT_EVENT & event))
+    {
+        /* Perform the required functions */
+        upper_layer_handler(gp_pal_i2c_current_ctx->p_upper_layer_ctx, PAL_I2C_EVENT_SUCCESS);
+    }
+
+    pal_i2c_release(gp_pal_i2c_current_ctx->p_upper_layer_ctx);
+
+  }
+}
+
+/* Defining master callback handler */
+void i2c_master_event_handler(void *callback_arg, cyhal_i2c_event_t event)
+{
+    BaseType_t xHigherPriorityTaskWoken= pdFALSE;
+
+    xTaskNotifyFromISR(i2c_taskhandle, event, eSetBits, &xHigherPriorityTaskWoken);
+
+    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
+}
+
+pal_status_t pal_i2c_init(const pal_i2c_t * p_i2c_context)
+{
+    cy_rslt_t cy_hal_status;
+    pal_status_t result = PAL_STATUS_FAILURE;
+    /* Define the I2C master configuration structure */
+    cyhal_i2c_cfg_t i2c_master_config = {false,    // is slave?
+                                         0,        // address of this resource; set to 0 for master
+                                         400000    // bus frequency in Hz
+                                        };
+    
+    do
+    {
+        if (i2c_taskhandle == NULL)
+        {
+            xIicSemaphoreHandle = xSemaphoreCreateBinary();
+
+            if (xTaskCreate(i2c_task, "i2c_task", configMINIMAL_STACK_SIZE * 2, NULL, configMAX_PRIORITIES - 1, &i2c_taskhandle) != pdPASS)
+            {
+                break;
+            }
+
+            pal_i2c_release((void * )p_i2c_context);
+
+            return PAL_STATUS_SUCCESS;
+        }
+
+        if (g_pal_i2c_init_flag == 0)
+        {
+            // Init I2C driver
+            cy_hal_status = cyhal_i2c_init(((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->i2c_master_channel,
+                                            ((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->sda,
+                                            ((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->scl,
+                                            NULL);
+
+            if (CY_RSLT_SUCCESS != cy_hal_status)
+            {
+                break;
+            }
+
+            //Configure the I2C resource to be master
+            cy_hal_status = cyhal_i2c_configure(((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->i2c_master_channel,
+                                                &i2c_master_config);
+            if (CY_RSLT_SUCCESS != cy_hal_status)
+            {
+                break;
+            }
+
+            // Register i2c master callback
+            cyhal_i2c_register_callback(((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->i2c_master_channel,
+                                        (cyhal_i2c_event_callback_t) i2c_master_event_handler,
+                                        NULL);
+
+            // Enable interrupts for I2C master
+            cyhal_i2c_enable_event(((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->i2c_master_channel,
+                                    (cyhal_i2c_event_t)(CYHAL_I2C_MASTER_WR_CMPLT_EVENT \
+                                    | CYHAL_I2C_MASTER_RD_CMPLT_EVENT \
+                                    | CYHAL_I2C_MASTER_ERR_EVENT),    \
+                                    PAL_I2C_MASTER_INTR_PRIO ,
+                                    true);
+            g_pal_i2c_init_flag = 1;
+        }
+
+        result = (pal_status_t)PAL_STATUS_SUCCESS;
+
+    } while (FALSE);
+
+    return result;
+}
+
+pal_status_t pal_i2c_deinit(const pal_i2c_t * p_i2c_context)
+{
+    if ((g_pal_i2c_init_flag == 1) && (p_i2c_context != NULL))
+    {
+        cyhal_i2c_free(((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->i2c_master_channel);
+
+        return (PAL_STATUS_SUCCESS);
+    }
+    
+    if (i2c_taskhandle != NULL && (p_i2c_context == NULL))
+    {
+        vTaskDelete(i2c_taskhandle);
+        i2c_taskhandle = NULL;
+        vSemaphoreDelete(xIicSemaphoreHandle);
+    }
+    return (PAL_STATUS_SUCCESS);
+}
+
+pal_status_t pal_i2c_write(const pal_i2c_t * p_i2c_context, uint8_t * p_data, uint16_t length)
+{
+    pal_status_t status = PAL_STATUS_FAILURE;
+
+    //Acquire the I2C bus before read/write
+    if (PAL_STATUS_SUCCESS == pal_i2c_acquire(p_i2c_context))
+    {
+        gp_pal_i2c_current_ctx = p_i2c_context;
+        //Invoke the low level i2c master driver API to write to the bus
+        if (CY_RSLT_SUCCESS != cyhal_i2c_master_transfer_async(((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->i2c_master_channel,
+                                                                p_i2c_context->slave_address,
+                                                                p_data,
+                                                                length,
+                                                                NULL,
+                                                                0))
+        {
+            //If I2C Master fails to invoke the write operation, invoke upper layer event handler with error.
+            //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+            ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                       (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_ERROR);
+            
+            //Release I2C Bus
+            pal_i2c_release((void * )p_i2c_context);
+        }
+        else
+        {
+            status = PAL_STATUS_SUCCESS;
+        }
+    }
+    else
+    {
+        status = PAL_STATUS_I2C_BUSY;
+        //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+        ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                        (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_BUSY);
+    }
+    return (status);
+}
+
+pal_status_t pal_i2c_read(const pal_i2c_t * p_i2c_context, uint8_t * p_data, uint16_t length)
+{
+    pal_status_t status = PAL_STATUS_FAILURE;
+
+    //Acquire the I2C bus before read/write
+    if (PAL_STATUS_SUCCESS == pal_i2c_acquire(p_i2c_context))
+    {
+        gp_pal_i2c_current_ctx = p_i2c_context;
+
+        //Invoke the low level i2c master driver API to read from the bus
+        if (CY_RSLT_SUCCESS != cyhal_i2c_master_transfer_async(((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->i2c_master_channel,
+                                                                p_i2c_context->slave_address,
+                                                                NULL,
+                                                                0,
+                                                                p_data,
+                                                                length))
+        {
+            //If I2C Master fails to invoke the read operation, invoke upper layer event handler with error.
+            //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+            ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                       (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_ERROR);
+
+            //Release I2C Bus
+            pal_i2c_release((void * )p_i2c_context);
+        }
+        else
+        {
+            status = PAL_STATUS_SUCCESS;
+        }
+    }
+    else
+    {
+        status = PAL_STATUS_I2C_BUSY;
+        //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+        ((upper_layer_callback_t)(p_i2c_context->upper_layer_event_handler))
+                                                        (p_i2c_context->p_upper_layer_ctx , PAL_I2C_EVENT_BUSY);
+    }
+    return (status);
+}
+
+pal_status_t pal_i2c_set_bitrate(const pal_i2c_t * p_i2c_context, uint16_t bitrate)
+{
+
+    cyhal_i2c_t * i2cObj = (cyhal_i2c_t * )(((pal_psoc_i2c_t *)(p_i2c_context->p_i2c_hw_config))->i2c_master_channel);
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+    optiga_lib_status_t event = PAL_I2C_EVENT_ERROR;
+    uint32_t setDataRate;
+
+    //Acquire the I2C bus before setting the bitrate
+    if (PAL_STATUS_SUCCESS == pal_i2c_acquire(p_i2c_context))
+    {
+        // If the user provided bitrate is greater than the I2C master hardware maximum supported value,
+        // set the I2C master to its maximum supported value.
+        if (bitrate > PAL_I2C_MASTER_MAX_BITRATE)
+        {
+            bitrate = PAL_I2C_MASTER_MAX_BITRATE;
+        }
+
+        setDataRate = _cyhal_i2c_set_peri_divider(i2cObj, 1, (bitrate * 1000), false);
+        if (0 == setDataRate)
+        {
+
+             return_status = PAL_STATUS_FAILURE;
+        }
+        else
+        {
+             return_status = PAL_STATUS_SUCCESS;
+             event = PAL_I2C_EVENT_SUCCESS;
+        }
+    }
+    else
+    {
+        return_status = PAL_STATUS_I2C_BUSY;
+        event = PAL_I2C_EVENT_BUSY;
+    }
+
+    if (0 != p_i2c_context->upper_layer_event_handler)
+    {
+        //lint --e{611} suppress "void* function pointer is type casted to upper_layer_callback_t type"
+        ((callback_handler_t)(p_i2c_context->upper_layer_event_handler))(p_i2c_context->p_upper_layer_ctx , event);
+    }
+    //Release I2C Bus if its acquired 
+    if (PAL_STATUS_I2C_BUSY != return_status)
+    {
+        pal_i2c_release((void * )p_i2c_context);
+    }
+
+    return (return_status);
+}
+
+/**
+* @}
+*/
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_ifx_i2c_config.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_ifx_i2c_config.c
new file mode 100644
index 0000000..372b6cf
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_ifx_i2c_config.c
@@ -0,0 +1,119 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_ifx_i2c_config.c
+*
+* \brief   This file implements platform abstraction layer configurations for ifx i2c protocol.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_gpio.h"
+#include "optiga/pal/pal_i2c.h"
+#include "optiga/ifx_i2c/ifx_i2c_config.h"
+#include "optiga/pal/pal_ifx_i2c_config.h"
+#include "optiga_lib_config.h"
+#include "pal_psoc_i2c_mapping.h"
+#include "pal_psoc_gpio_mapping.h"
+#include "cy_pdl.h"
+#include "cyhal.h"
+#include "cybsp.h"
+
+// i2c driver related
+cyhal_i2c_t i2c_master_obj;
+
+#ifdef OPTIGA_TRUSTM_VDD
+pal_psoc_gpio_t optiga_vdd_config =
+{
+    .gpio = OPTIGA_TRUSTM_VDD,
+    .init_state = true
+};
+#endif
+
+#ifdef OPTIGA_TRUSTM_RST
+pal_psoc_gpio_t optiga_reset_config =
+{
+    .gpio = OPTIGA_TRUSTM_RST,
+    .init_state = true
+};
+#endif
+
+pal_psoc_i2c_t optiga_i2c_master_config =
+{
+    .i2c_master_channel = &i2c_master_obj,
+    .scl = OPTIGA_TRUSTM_SCL,
+    .sda = OPTIGA_TRUSTM_SDA
+};
+
+/**
+* \brief PAL vdd pin configuration for OPTIGA. 
+ */
+pal_gpio_t optiga_vdd_0 =
+{
+#ifdef OPTIGA_TRUSTM_VDD
+    // Platform specific GPIO context for the pin used to toggle Vdd.
+    (void * )&optiga_vdd_config
+#else
+    NULL
+#endif
+};
+
+/**
+ * \brief PAL reset pin configuration for OPTIGA.
+ */
+pal_gpio_t optiga_reset_0 =
+{
+#ifdef OPTIGA_TRUSTM_RST
+    // Platform specific GPIO context for the pin used to toggle Reset.
+    (void * )&optiga_reset_config
+#else
+    NULL
+#endif
+};
+
+/**
+ * \brief PAL I2C configuration for OPTIGA.
+ */
+pal_i2c_t optiga_pal_i2c_context_0 =
+{
+    /// Pointer to I2C master platform specific context
+    (void*)&optiga_i2c_master_config,
+    /// Upper layer context
+    NULL,
+    /// Callback event handler
+    NULL,
+    /// Slave address
+    0x30
+};
+
+
+/**
+* @}
+*/
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_logger.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_logger.c
new file mode 100644
index 0000000..f995e1b
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_logger.c
@@ -0,0 +1,87 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+ *
+ * \file    pal_logger.c
+ *
+ * \brief   This file provides the prototypes declarations for pal logger.
+ *
+ * \ingroup grPAL
+ *
+ * @{
+ */
+#include "optiga/pal/pal_logger.h"
+
+/// @cond hidden
+
+//lint --e{552,714} suppress "Accessed by user of this structure" 
+pal_logger_t logger_console =
+{
+        .logger_config_ptr = NULL,
+        .logger_rx_flag = 1,
+        .logger_tx_flag = 1
+};
+
+/// @endcond
+
+pal_status_t pal_logger_read_byte_length(void * p_logger_context, uint8_t * p_log_data, uint32_t log_data_length)
+{
+    return 1;
+}
+
+pal_status_t pal_logger_init(void * p_logger_context)
+{
+    return PAL_STATUS_SUCCESS;
+}
+
+
+pal_status_t pal_logger_deinit(void * p_logger_context)
+{
+    return PAL_STATUS_SUCCESS;
+}
+
+
+pal_status_t pal_logger_write(void * p_logger_context, const uint8_t * p_log_data, uint32_t log_data_length)
+{
+    printf("%.*s",(int)log_data_length, p_log_data);
+
+    return (PAL_STATUS_SUCCESS);
+}
+
+pal_status_t pal_logger_read(void * p_logger_context, uint8_t * p_log_data, uint32_t log_data_length)
+{
+    char str[4] = "%";
+    char str_1[4];
+    sprintf(str_1, "%ds", (int)log_data_length);
+    strcat(str, str_1);
+    //scanf(str, p_log_data);
+
+    return (PAL_STATUS_SUCCESS);
+}
+/**
+ * @}
+ */
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_datastore.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_datastore.c
new file mode 100644
index 0000000..a567eb8
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_datastore.c
@@ -0,0 +1,192 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_datastore.c
+*
+* \brief   This file implements the platform abstraction layer APIs for data store.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_os_datastore.h"
+/// @cond hidden
+
+/// Size of length field 
+#define LENGTH_SIZE                (0x02)
+/// Size of data store buffer to hold the shielded connection manage context information (2 bytes length field + 64(0x40) bytes context)
+#define MANAGE_CONTEXT_BUFFER_SIZE      (0x42)
+
+//Internal buffer to store the shielded connection manage context information (length field + Data)
+uint8_t data_store_manage_context_buffer [LENGTH_SIZE + MANAGE_CONTEXT_BUFFER_SIZE];
+
+//Internal buffer to store the optiga application context data during hibernate(length field + Data)
+uint8_t data_store_app_context_buffer [LENGTH_SIZE + APP_CONTEXT_SIZE];
+
+//Internal buffer to store the generated platform binding shared secret on Host (length field + shared secret)
+uint8_t optiga_platform_binding_shared_secret [LENGTH_SIZE + OPTIGA_SHARED_SECRET_MAX_LENGTH] = 
+{
+    // Length of the shared secret, followed after the length information
+    0x00 ,0x40, 
+    // Shared secret. Buffer is defined to the maximum supported length [64 bytes]. 
+    // But the actual size used is to be specified in the length field.
+    0x01 ,0x02 ,0x03 ,0x04 ,0x05 ,0x06 ,0x07 ,0x08 ,0x09 ,0x0A ,0x0B ,0x0C ,0x0D ,0x0E ,0x0F ,0x10,
+    0x11 ,0x12 ,0x13 ,0x14 ,0x15 ,0x16 ,0x17 ,0x18 ,0x19 ,0x1A ,0x1B ,0x1C ,0x1D ,0x1E ,0x1F ,0x20,
+    0x21 ,0x22 ,0x23 ,0x24 ,0x25 ,0x26 ,0x27 ,0x28 ,0x29 ,0x2A ,0x2B ,0x2C ,0x2D ,0x2E ,0x2F ,0x30,
+    0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 ,0x38 ,0x39 ,0x3A ,0x3B ,0x3C ,0x3D ,0x3E ,0x3F ,0x40
+};
+
+
+pal_status_t pal_os_datastore_write(uint16_t datastore_id,
+                                    const uint8_t * p_buffer,
+                                    uint16_t length)
+{
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+    uint8_t offset = 0;
+
+    switch(datastore_id)
+    {
+        case OPTIGA_PLATFORM_BINDING_SHARED_SECRET_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only, in case of updating
+            // the platform binding shared secret during the runtime into NVM.
+            // In current implementation, platform binding shared secret is 
+            // stored in RAM.
+            if (length <= OPTIGA_SHARED_SECRET_MAX_LENGTH)
+            {
+                optiga_platform_binding_shared_secret[offset++] = (uint8_t)(length>>8);
+                optiga_platform_binding_shared_secret[offset++] = (uint8_t)(length);
+                memcpy(&optiga_platform_binding_shared_secret[offset], p_buffer, length);
+                return_status = PAL_STATUS_SUCCESS;
+            }
+            break;
+        }
+        case OPTIGA_COMMS_MANAGE_CONTEXT_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only, in case of storing 
+            // the manage context information in non-volatile memory 
+            // to reuse for later during hard reset scenarios where the 
+            // RAM gets flushed out.
+            data_store_manage_context_buffer[offset++] = (uint8_t)(length>>8);
+            data_store_manage_context_buffer[offset++] = (uint8_t)(length);
+            memcpy(&data_store_manage_context_buffer[offset],p_buffer,length);
+            return_status = PAL_STATUS_SUCCESS;
+            break;
+        }
+        case OPTIGA_HIBERNATE_CONTEXT_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only, in case of storing 
+            // the application context information in non-volatile memory 
+            // to reuse for later during hard reset scenarios where the 
+            // RAM gets flushed out.
+            data_store_app_context_buffer[offset++] = (uint8_t)(length>>8);
+            data_store_app_context_buffer[offset++] = (uint8_t)(length);
+            memcpy(&data_store_app_context_buffer[offset],p_buffer,length);
+            return_status = PAL_STATUS_SUCCESS;
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+    return return_status;
+}
+
+
+pal_status_t pal_os_datastore_read(uint16_t datastore_id, 
+                                   uint8_t * p_buffer, 
+                                   uint16_t * p_buffer_length)
+{
+    pal_status_t return_status = PAL_STATUS_FAILURE;
+    uint16_t data_length;
+    uint8_t offset = 0;
+
+    switch(datastore_id)
+    {
+        case OPTIGA_PLATFORM_BINDING_SHARED_SECRET_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only,
+            // if the platform binding shared secret is stored in non-volatile 
+            // memory with a specific location and not as a context segment 
+            // else updating the share secret content is good enough.
+
+            data_length = (uint16_t) (optiga_platform_binding_shared_secret[offset++] << 8);
+            data_length |= (uint16_t)(optiga_platform_binding_shared_secret[offset++]);
+            if (data_length <= OPTIGA_SHARED_SECRET_MAX_LENGTH)
+            {
+                memcpy(p_buffer,&optiga_platform_binding_shared_secret[offset], data_length);
+                *p_buffer_length = data_length;
+                return_status = PAL_STATUS_SUCCESS;
+            }
+            break;
+        }
+        case OPTIGA_COMMS_MANAGE_CONTEXT_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only,
+            // if manage context information is stored in NVM during the hibernate, 
+            // else this is not required to be enhanced.
+            data_length = (uint16_t) (data_store_manage_context_buffer[offset++] << 8);
+            data_length |= (uint16_t)(data_store_manage_context_buffer[offset++]);
+            memcpy(p_buffer, &data_store_manage_context_buffer[offset], data_length);
+            *p_buffer_length = data_length;
+            return_status = PAL_STATUS_SUCCESS;
+            break;
+        }
+        case OPTIGA_HIBERNATE_CONTEXT_ID:
+        {
+            // !!!OPTIGA_LIB_PORTING_REQUIRED
+            // This has to be enhanced by user only,
+            // if application context information is stored in NVM during the hibernate, 
+            // else this is not required to be enhanced.
+            data_length = (uint16_t) (data_store_app_context_buffer[offset++] << 8);
+            data_length |= (uint16_t)(data_store_app_context_buffer[offset++]);
+            memcpy(p_buffer, &data_store_app_context_buffer[offset], data_length);
+            *p_buffer_length = data_length;
+            return_status = PAL_STATUS_SUCCESS;
+            break;
+        }
+        default:
+        {
+            *p_buffer_length = 0;
+            break;
+        }
+    }
+
+    return return_status;
+}
+/// @endcond
+/**
+* @}
+*/
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_event.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_event.c
new file mode 100644
index 0000000..1f51c84
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_event.c
@@ -0,0 +1,155 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_os_event.c
+*
+* \brief   This file implements the platform abstraction layer APIs for os event/scheduler.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#include "optiga/pal/pal_os_event.h"
+#include "optiga/pal/pal.h"
+
+#include "FreeRTOS.h"
+#include "timers.h"
+
+
+/// @cond hidden
+
+#define PAL_OS_EVENT_INTR_PRIO    (4U)
+#define CYHAL_TIMER_SCALING 10
+
+/* Timer object used */
+cyhal_timer_t pal_os_event_timer_obj;
+
+/* PAL OS Event handler */
+pal_os_event_t pal_os_event_ctx;
+
+/* An internal timer initialisation function */
+int32_t pal_os_event_init(pal_os_event_t* p_pal_os_event_ctx, register_callback callback, void * callback_args);
+
+void pal_os_event_trigger_registered_callback(void) { }
+
+static void pal_os_event_timer_callback(TimerHandle_t xTimer)
+{
+    /* Optionally do something if the pxTimer parameter is NULL. */
+    configASSERT(xTimer);
+
+    pal_os_event_t *p_pal_os_event = (pal_os_event_t *)pvTimerGetTimerID( xTimer );
+    p_pal_os_event->callback_registered(p_pal_os_event->callback_ctx);
+}
+
+void pal_os_event_start(pal_os_event_t * p_pal_os_event, register_callback callback, void * callback_args)
+{
+    if (FALSE == p_pal_os_event->is_event_triggered)
+    {
+        p_pal_os_event->is_event_triggered = TRUE;
+        pal_os_event_register_callback_oneshot(p_pal_os_event,callback,callback_args, 1000);
+    }
+}
+
+void pal_os_event_stop(pal_os_event_t * p_pal_os_event)
+{
+    //lint --e{714} suppress "The API pal_os_event_stop is not exposed in header file but used as extern in 
+    //optiga_cmd.c"
+    p_pal_os_event->is_event_triggered = FALSE;
+}
+
+pal_os_event_t * pal_os_event_create(register_callback callback, void * callback_args)
+{
+    if (!pal_os_event_init(&pal_os_event_ctx, callback, callback_args))
+        return NULL;
+
+    if ((callback != NULL) && (callback_args != NULL))
+    {
+        pal_os_event_start(&pal_os_event_ctx, callback, callback_args);
+    }
+    
+    return (&pal_os_event_ctx);
+}
+
+//lint --e{818,715} suppress "As there is no implementation, pal_os_event is not used"
+void pal_os_event_destroy(pal_os_event_t * p_pal_os_event)
+{
+    if (p_pal_os_event != NULL)
+    {
+        pal_os_event_stop(p_pal_os_event);
+        xTimerDelete(p_pal_os_event->os_timer, 1000);
+    }
+}
+
+void pal_os_event_register_callback_oneshot(pal_os_event_t * p_pal_os_event,
+                                             register_callback callback,
+                                             void * callback_args,
+                                             uint32_t time_us)
+{
+    if (p_pal_os_event != NULL)
+    {
+        p_pal_os_event->callback_registered = callback;
+        p_pal_os_event->callback_ctx = callback_args;
+
+        if (time_us < 1000)
+        {
+        time_us = 1000;
+        }
+
+        xTimerChangePeriod((TimerHandle_t)p_pal_os_event->os_timer, pdMS_TO_TICKS(time_us / 1000), 0);
+    }
+}
+
+int32_t pal_os_event_init(pal_os_event_t* p_pal_os_event_ctx, register_callback callback, void * callback_args)
+{
+    TimerHandle_t xTimer;
+
+    if (p_pal_os_event_ctx != NULL)
+    {
+        p_pal_os_event_ctx->callback_registered = callback;
+        p_pal_os_event_ctx->callback_ctx = callback_args;
+        p_pal_os_event_ctx->is_event_triggered = false;
+
+        xTimer = xTimerCreate(NULL, 1, pdFALSE, ( void * ) p_pal_os_event_ctx, pal_os_event_timer_callback);
+        if (xTimer != NULL)
+        {
+            p_pal_os_event_ctx->os_timer = xTimer;
+        }
+        else
+        {
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+
+/**
+* @}
+*/
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_lock.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_lock.c
new file mode 100644
index 0000000..17bcb87
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_lock.c
@@ -0,0 +1,99 @@
+/**
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+*
+* \file pal_os_lock.c
+*
+* \brief   This file implements the platform abstraction layer APIs for os locks (e.g. semaphore).
+*
+* \ingroup  grPAL
+* @{
+*/
+
+#include "optiga/pal/pal_os_lock.h"
+
+#include "FreeRTOS.h"
+#include "semphr.h"
+
+SemaphoreHandle_t xLockSemaphoreHandle;
+
+volatile uint8_t first_call_flag = 1;
+
+void _lock_init(pal_os_lock_t * p_lock)
+{
+    xLockSemaphoreHandle = xSemaphoreCreateBinary();
+    pal_os_lock_release(p_lock);
+}
+
+void pal_os_lock_create(pal_os_lock_t * p_lock, uint8_t lock_type)
+{
+    p_lock->type = lock_type;
+    p_lock->lock = 0;
+}
+
+//lint --e{715} suppress "p_lock is not used here as it is placeholder for future."
+//lint --e{818} suppress "Not declared as pointer as nothing needs to be updated in the pointer."
+void pal_os_lock_destroy(pal_os_lock_t * p_lock)
+{
+
+}
+
+
+pal_status_t pal_os_lock_acquire(pal_os_lock_t * p_lock)
+{
+    (void) p_lock;
+    vPortEnterCritical();
+    if (first_call_flag)
+    {
+        _lock_init(p_lock);
+        first_call_flag = 0;
+    }
+    vPortExitCritical();
+
+    if ( xSemaphoreTake(xLockSemaphoreHandle, portMAX_DELAY) == pdTRUE )
+        return PAL_STATUS_SUCCESS;
+    else {
+        return PAL_STATUS_FAILURE;
+    }
+}
+
+void pal_os_lock_release(pal_os_lock_t * p_lock)
+{
+    (void) p_lock;
+
+    xSemaphoreGive(xLockSemaphoreHandle);
+}
+
+void pal_os_lock_enter_critical_section()
+{
+    vPortEnterCritical();
+}
+
+void pal_os_lock_exit_critical_section()
+{
+    vPortExitCritical();
+}
+
+/**
+* @}
+*/
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_memory.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_memory.c
new file mode 100644
index 0000000..9122bc1
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_memory.c
@@ -0,0 +1,68 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_gpio.c
+*
+* \brief   This file implements the platform abstraction layer APIs for GPIO.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+//#include <DAVE.h>
+#include "optiga/pal/pal_os_memory.h"
+
+void * pal_os_malloc(uint32_t block_size)
+{
+    return (malloc(block_size));
+}
+
+void * pal_os_calloc(uint32_t number_of_blocks , uint32_t block_size)
+{
+    return (calloc(number_of_blocks, block_size));
+}
+
+void pal_os_free(void * p_block)
+{
+    free(p_block);
+}
+
+void pal_os_memcpy(void * p_destination, const void * p_source, uint32_t size)
+{
+    memcpy(p_destination, p_source, size);
+}
+
+void pal_os_memset(void * p_buffer, uint32_t value, uint32_t size)
+{
+    memset(p_buffer, (int32_t)value, size);
+}
+
+/**
+* @}
+*/
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_timer.c b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_timer.c
new file mode 100644
index 0000000..ccb8bd9
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_os_timer.c
@@ -0,0 +1,94 @@
+/**
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+*
+* \file
+*
+* \brief This file implements the platform abstraction layer APIs for timer.
+*
+* \ingroup  grPAL
+* @{
+*/
+
+/**********************************************************************************************************************
+ * HEADER FILES
+ *********************************************************************************************************************/
+#include "optiga/pal/pal_os_timer.h"
+#include "FreeRTOS.h"
+#include "task.h"
+#include "stdio.h"
+/**********************************************************************************************************************
+ * MACROS
+ *********************************************************************************************************************/
+ 
+/// @cond hidden 
+/*********************************************************************************************************************
+ * LOCAL DATA
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * LOCAL ROUTINES
+ *********************************************************************************************************************/
+
+
+/// @endcond
+/**********************************************************************************************************************
+ * API IMPLEMENTATION
+ *********************************************************************************************************************/
+
+uint32_t pal_os_timer_get_time_in_microseconds(void)
+{
+    // !!!OPTIGA_LIB_PORTING_REQUIRED
+    // This API is needed to support optiga cmd scheduler.
+    static uint32_t count = 0;
+    // The implementation must ensure that every invocation of this API returns a unique value.
+    return (count++);
+}
+
+/**
+* Get the current time in milliseconds<br>
+*
+*
+* \retval  uint32_t time in milliseconds
+*/
+uint32_t pal_os_timer_get_time_in_milliseconds(void)
+{
+    return xTaskGetTickCount();
+}
+
+/**
+* Waits or delays until the given milliseconds time
+* 
+* \param[in] milliseconds Delay value in milliseconds
+*
+*/
+void pal_os_timer_delay_in_milliseconds(uint16_t milliseconds)
+{
+    const TickType_t xDelay = milliseconds / portTICK_PERIOD_MS;
+    vTaskDelay( xDelay );
+}
+
+/**
+* @}
+*/
+
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_psoc_gpio_mapping.h b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_psoc_gpio_mapping.h
new file mode 100644
index 0000000..67dc952
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_psoc_gpio_mapping.h
@@ -0,0 +1,68 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_psoc_gpio_mapping.h
+*
+* \brief   This file provides the PSOC specific gpio pin mapping.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#ifndef PAL_PSOC_GPIO_MAPPING
+#define PAL_PSOC_GPIO_MAPPING
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pal.h"
+#include "cyhal.h"
+
+/**
+ * \brief Structure defines PSOC6 gpio pin configuration.
+ */
+typedef struct pal_psoc_gpio
+{
+    cyhal_gpio_t  gpio;
+    bool_t        init_state;
+
+} pal_psoc_gpio_t;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PAL_PSOC_GPIO_MAPPING */
+
+/**
+* @}
+*/
+
diff --git a/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_psoc_i2c_mapping.h b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_psoc_i2c_mapping.h
new file mode 100644
index 0000000..d1ba134
--- /dev/null
+++ b/pal/COMPONENT_PSOC6_FREERTOS/COMPONENT_CM4/pal_psoc_i2c_mapping.h
@@ -0,0 +1,67 @@
+/**
+* \copyright
+* MIT License
+*
+* Copyright (c) 2022 Infineon Technologies AG
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in all
+* copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE
+*
+* \endcopyright
+*
+* \author Infineon Technologies AG
+*
+* \file pal_psoc_i2c_mapping.h
+*
+* \brief   This file provides the PSOC specific I2C pin mapping.
+*
+* \ingroup  grPAL
+*
+* @{
+*/
+
+#ifndef PAL_PSOC_I2C_MAPPING
+#define PAL_PSOC_I2C_MAPPING
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pal.h"
+#include "cyhal_i2c.h"
+/**
+ * \brief Structure defines PSOC6 gpio pin configuration.
+ */
+typedef struct pal_psoc_i2c
+{
+    cyhal_i2c_t *     i2c_master_channel;
+    cyhal_gpio_t      sda;
+    cyhal_gpio_t      scl;
+}   pal_psoc_i2c_t;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PAL_PSOC_I2C_MAPPING */
+
+/**
+* @}
+*/
+
