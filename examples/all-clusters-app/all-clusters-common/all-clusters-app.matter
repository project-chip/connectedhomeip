// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

enum AreaTypeTag : enum8 {
  kAisle = 0;
  kAttic = 1;
  kBackDoor = 2;
  kBackYard = 3;
  kBalcony = 4;
  kBallroom = 5;
  kBathroom = 6;
  kBedroom = 7;
  kBorder = 8;
  kBoxroom = 9;
  kBreakfastRoom = 10;
  kCarport = 11;
  kCellar = 12;
  kCloakroom = 13;
  kCloset = 14;
  kConservatory = 15;
  kCorridor = 16;
  kCraftRoom = 17;
  kCupboard = 18;
  kDeck = 19;
  kDen = 20;
  kDining = 21;
  kDrawingRoom = 22;
  kDressingRoom = 23;
  kDriveway = 24;
  kElevator = 25;
  kEnsuite = 26;
  kEntrance = 27;
  kEntryway = 28;
  kFamilyRoom = 29;
  kFoyer = 30;
  kFrontDoor = 31;
  kFrontYard = 32;
  kGameRoom = 33;
  kGarage = 34;
  kGarageDoor = 35;
  kGarden = 36;
  kGardenDoor = 37;
  kGuestBathroom = 38;
  kGuestBedroom = 39;
  kGuestRoom = 41;
  kGym = 42;
  kHallway = 43;
  kHearthRoom = 44;
  kKidsRoom = 45;
  kKidsBedroom = 46;
  kKitchen = 47;
  kLaundryRoom = 49;
  kLawn = 50;
  kLibrary = 51;
  kLivingRoom = 52;
  kLounge = 53;
  kMediaTVRoom = 54 [spec_name = "Media/TV Room"];
  kMudRoom = 55;
  kMusicRoom = 56;
  kNursery = 57;
  kOffice = 58;
  kOutdoorKitchen = 59;
  kOutside = 60;
  kPantry = 61;
  kParkingLot = 62;
  kParlor = 63;
  kPatio = 64;
  kPlayRoom = 65;
  kPoolRoom = 66;
  kPorch = 67;
  kPrimaryBathroom = 68;
  kPrimaryBedroom = 69;
  kRamp = 70;
  kReceptionRoom = 71;
  kRecreationRoom = 72;
  kRoof = 74;
  kSauna = 75;
  kScullery = 76;
  kSewingRoom = 77;
  kShed = 78;
  kSideDoor = 79;
  kSideYard = 80;
  kSittingRoom = 81;
  kSnug = 82;
  kSpa = 83;
  kStaircase = 84;
  kSteamRoom = 85;
  kStorageRoom = 86;
  kStudio = 87;
  kStudy = 88;
  kSunRoom = 89;
  kSwimmingPool = 90;
  kTerrace = 91;
  kUtilityRoom = 92;
  kWard = 93;
  kWorkshop = 94;
  kToilet = 95;
}

enum AtomicRequestTypeEnum : enum8 {
  kBeginWrite = 0;
  kCommitWrite = 1;
  kRollbackWrite = 2;
}

enum LandmarkTag : enum8 {
  kAirConditioner = 0;
  kAirPurifier = 1;
  kBackDoor = 2;
  kBarStool = 3;
  kBathMat = 4;
  kBathtub = 5;
  kBed = 6;
  kBookshelf = 7;
  kChair = 8;
  kChristmasTree = 9;
  kCoatRack = 10;
  kCoffeeTable = 11;
  kCookingRange = 12;
  kCouch = 13;
  kCountertop = 14;
  kCradle = 15;
  kCrib = 16;
  kDesk = 17;
  kDiningTable = 18;
  kDishwasher = 19;
  kDoor = 20;
  kDresser = 21;
  kLaundryDryer = 22;
  kFan = 23;
  kFireplace = 24;
  kFreezer = 25;
  kFrontDoor = 26;
  kHighChair = 27;
  kKitchenIsland = 28;
  kLamp = 29;
  kLitterBox = 30;
  kMirror = 31;
  kNightstand = 32;
  kOven = 33;
  kPetBed = 34;
  kPetBowl = 35;
  kPetCrate = 36;
  kRefrigerator = 37;
  kScratchingPost = 38;
  kShoeRack = 39;
  kShower = 40;
  kSideDoor = 41;
  kSink = 42;
  kSofa = 43;
  kStove = 44;
  kTable = 45;
  kToilet = 46;
  kTrashCan = 47;
  kLaundryWasher = 48;
  kWindow = 49;
  kWineCooler = 50;
}

enum LocationTag : enum8 {
  kIndoor = 0;
  kOutdoor = 1;
  kInside = 2;
  kOutside = 3;
}

enum MeasurementTypeEnum : enum16 {
  kUnspecified = 0;
  kVoltage = 1;
  kActiveCurrent = 2;
  kReactiveCurrent = 3;
  kApparentCurrent = 4;
  kActivePower = 5;
  kReactivePower = 6;
  kApparentPower = 7;
  kRMSVoltage = 8;
  kRMSCurrent = 9;
  kRMSPower = 10;
  kFrequency = 11;
  kPowerFactor = 12;
  kNeutralCurrent = 13;
  kElectricalEnergy = 14;
  kReactiveEnergy = 15;
  kApparentEnergy = 16;
  kSoilMoisture = 17;
}

enum PositionTag : enum8 {
  kLeft = 0;
  kRight = 1;
  kTop = 2;
  kBottom = 3;
  kMiddle = 4;
  kRow = 5;
  kColumn = 6;
}

enum PowerThresholdSourceEnum : enum8 {
  kContract = 0;
  kRegulator = 1;
  kEquipment = 2;
}

enum RelativePositionTag : enum8 {
  kUnder = 0;
  kNextTo = 1;
  kAround = 2;
  kOn = 3;
  kAbove = 4;
  kFrontOf = 5;
  kBehind = 6;
}

enum StreamUsageEnum : enum8 {
  kInternal = 0;
  kRecording = 1;
  kAnalysis = 2;
  kLiveView = 3;
}

enum TariffPriceTypeEnum : enum8 {
  kStandard = 0;
  kCritical = 1;
  kVirtual = 2;
  kIncentive = 3;
  kIncentiveSignal = 4;
}

enum TariffUnitEnum : enum8 {
  kKWh = 0;
  kKVAh = 1;
}

enum TestGlobalEnum : enum8 {
  kSomeValue = 0;
  kSomeOtherValue = 1;
  kFinalValue = 2;
}

enum ThreeLevelAutoEnum : enum8 {
  kAuto = 0;
  kLow = 1;
  kMedium = 2;
  kHigh = 3;
}

enum WebRTCEndReasonEnum : enum8 {
  kICEFailed = 0;
  kICETimeout = 1;
  kUserHangup = 2;
  kUserBusy = 3;
  kReplaced = 4;
  kNoUserMedia = 5;
  kInviteTimeout = 6;
  kAnsweredElsewhere = 7;
  kOutOfResources = 8;
  kMediaTimeout = 9;
  kLowPower = 10;
  kPrivacyMode = 11;
  kUnknownReason = 12;
}

bitmap TestGlobalBitmap : bitmap32 {
  kFirstBit = 0x1;
  kSecondBit = 0x2;
}

struct CurrencyStruct {
  int16u currency = 0;
  int8u decimalPoints = 1;
}

struct PriceStruct {
  money amount = 0;
  CurrencyStruct currency = 1;
}

struct MeasurementAccuracyRangeStruct {
  int64s rangeMin = 0;
  int64s rangeMax = 1;
  optional percent100ths percentMax = 2;
  optional percent100ths percentMin = 3;
  optional percent100ths percentTypical = 4;
  optional int64u fixedMax = 5;
  optional int64u fixedMin = 6;
  optional int64u fixedTypical = 7;
}

struct MeasurementAccuracyStruct {
  MeasurementTypeEnum measurementType = 0;
  boolean measured = 1;
  int64s minMeasuredValue = 2;
  int64s maxMeasuredValue = 3;
  MeasurementAccuracyRangeStruct accuracyRanges[] = 4;
}

struct AtomicAttributeStatusStruct {
  attrib_id attributeID = 0;
  status statusCode = 1;
}

struct ICECandidateStruct {
  char_string candidate = 0;
  nullable char_string SDPMid = 1;
  nullable int16u SDPMLineIndex = 2;
}

struct ICEServerStruct {
  char_string URLs[] = 0;
  optional long_char_string<508> username = 1;
  optional long_char_string<512> credential = 2;
  optional int16u caid = 3;
}

struct LocationDescriptorStruct {
  char_string<128> locationName = 0;
  nullable int16s floorNumber = 1;
  nullable AreaTypeTag areaType = 2;
}

struct PowerThresholdStruct {
  optional power_mw powerThreshold = 0;
  optional power_mva apparentPowerThreshold = 1;
  nullable PowerThresholdSourceEnum powerThresholdSource = 2;
}

struct TestGlobalStruct {
  char_string<128> name = 0;
  nullable TestGlobalBitmap myBitmap = 1;
  optional nullable TestGlobalEnum myEnum = 2;
}

struct ViewportStruct {
  int16u x1 = 0;
  int16u y1 = 1;
  int16u x2 = 2;
  int16u y2 = 3;
}

fabric_scoped struct WebRTCSessionStruct {
  int16u id = 0;
  node_id peerNodeID = 1;
  endpoint_no peerEndpointID = 2;
  StreamUsageEnum streamUsage = 3;
  nullable int16u videoStreamID = 4;
  nullable int16u audioStreamID = 5;
  boolean metadataEnabled = 6;
  fabric_idx fabricIndex = 254;
}

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
cluster Identify = 3 {
  revision 5;

  enum EffectIdentifierEnum : enum8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum EffectVariantEnum : enum8 {
    kDefault = 0;
  }

  enum IdentifyTypeEnum : enum8 {
    kNone = 0;
    kLightOutput = 1;
    kVisibleIndicator = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute IdentifyTypeEnum identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    int16u identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    EffectVariantEnum effectVariant = 1;
  }

  /** This command starts or stops the receiving device identifying itself. */
  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  /** This command allows the support of feedback to the user, such as a certain light effect. */
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** Attributes and commands for group configuration and manipulation. */
cluster Groups = 4 {
  revision 4;

  bitmap Feature : bitmap32 {
    kGroupNames = 0x1;
  }

  bitmap NameSupportBitmap : bitmap8 {
    kGroupNames = 0x80;
  }

  readonly attribute NameSupportBitmap nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  response struct ViewGroupResponse = 1 {
    enum8 status = 0;
    group_id groupID = 1;
    char_string<16> groupName = 2;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable int8u capacity = 0;
    group_id groupList[] = 1;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  response struct RemoveGroupResponse = 3 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  /** The AddGroup command allows a client to add group membership in a particular group for the server endpoint. */
  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  /** The ViewGroup command allows a client to request that the server responds with a ViewGroupResponse command containing the name string for a particular group. */
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  /** The GetGroupMembership command allows a client to inquire about the group membership of the server endpoint, in a number of ways. */
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  /** The RemoveGroup command allows a client to request that the server removes the membership for the server endpoint, if any, in a particular group. */
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  /** The RemoveAllGroups command allows a client to direct the server to remove all group associations for the server endpoint. */
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  /** The AddGroupIfIdentifying command allows a client to add group membership in a particular group for the server endpoint, on condition that the endpoint is identifying itself. */
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

/** Attributes and commands for switching devices between 'On' and 'Off' states. */
cluster OnOff = 6 {
  revision 6;

  enum DelayedAllOffEffectVariantEnum : enum8 {
    kDelayedOffFastFade = 0;
    kNoFade = 1;
    kDelayedOffSlowFade = 2;
  }

  enum DyingLightEffectVariantEnum : enum8 {
    kDyingLightFadeOff = 0;
  }

  enum EffectIdentifierEnum : enum8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum StartUpOnOffEnum : enum8 {
    kOff = 0;
    kOn = 1;
    kToggle = 2;
  }

  bitmap Feature : bitmap32 {
    kLighting = 0x1;
    kDeadFrontBehavior = 0x2;
    kOffOnly = 0x4;
  }

  bitmap OnOffControlBitmap : bitmap8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute optional boolean globalSceneControl = 16384;
  attribute optional int16u onTime = 16385;
  attribute optional int16u offWaitTime = 16386;
  attribute access(write: manage) optional nullable StartUpOnOffEnum startUpOnOff = 16387;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OffWithEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    enum8 effectVariant = 1;
  }

  request struct OnWithTimedOffRequest {
    OnOffControlBitmap onOffControl = 0;
    int16u onTime = 1;
    int16u offWaitTime = 2;
  }

  /** On receipt of this command, a device SHALL enter its ‘Off’ state. This state is device dependent, but it is recommended that it is used for power off or similar functions. On receipt of the Off command, the OnTime attribute SHALL be set to 0. */
  command Off(): DefaultSuccess = 0;
  /** On receipt of this command, a device SHALL enter its ‘On’ state. This state is device dependent, but it is recommended that it is used for power on or similar functions. On receipt of the On command, if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. */
  command On(): DefaultSuccess = 1;
  /** On receipt of this command, if a device is in its ‘Off’ state it SHALL enter its ‘On’ state. Otherwise, if it is in its ‘On’ state it SHALL enter its ‘Off’ state. On receipt of the Toggle command, if the value of the OnOff attribute is equal to FALSE and if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. If the value of the OnOff attribute is equal to TRUE, the OnTime attribute SHALL be set to 0. */
  command Toggle(): DefaultSuccess = 2;
  /** The OffWithEffect command allows devices to be turned off using enhanced ways of fading. */
  command OffWithEffect(OffWithEffectRequest): DefaultSuccess = 64;
  /** This command allows the recall of the settings when the device was turned off. */
  command OnWithRecallGlobalScene(): DefaultSuccess = 65;
  /** This command allows devices to be turned on for a specific duration with a guarded off duration so that SHOULD the device be subsequently turned off, further OnWithTimedOff commands, received during this time, are prevented from turning the devices back on. */
  command OnWithTimedOff(OnWithTimedOffRequest): DefaultSuccess = 66;
}

/** Attributes and commands for switching devices between 'On' and 'Off' states. */
cluster OnOff = 6 {
  revision 6;

  enum DelayedAllOffEffectVariantEnum : enum8 {
    kDelayedOffFastFade = 0;
    kNoFade = 1;
    kDelayedOffSlowFade = 2;
  }

  enum DyingLightEffectVariantEnum : enum8 {
    kDyingLightFadeOff = 0;
  }

  enum EffectIdentifierEnum : enum8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum StartUpOnOffEnum : enum8 {
    kOff = 0;
    kOn = 1;
    kToggle = 2;
  }

  bitmap Feature : bitmap32 {
    kLighting = 0x1;
    kDeadFrontBehavior = 0x2;
    kOffOnly = 0x4;
  }

  bitmap OnOffControlBitmap : bitmap8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute optional boolean globalSceneControl = 16384;
  attribute optional int16u onTime = 16385;
  attribute optional int16u offWaitTime = 16386;
  attribute access(write: manage) optional nullable StartUpOnOffEnum startUpOnOff = 16387;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OffWithEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    enum8 effectVariant = 1;
  }

  request struct OnWithTimedOffRequest {
    OnOffControlBitmap onOffControl = 0;
    int16u onTime = 1;
    int16u offWaitTime = 2;
  }

  /** On receipt of this command, a device SHALL enter its ‘Off’ state. This state is device dependent, but it is recommended that it is used for power off or similar functions. On receipt of the Off command, the OnTime attribute SHALL be set to 0. */
  command Off(): DefaultSuccess = 0;
  /** On receipt of this command, a device SHALL enter its ‘On’ state. This state is device dependent, but it is recommended that it is used for power on or similar functions. On receipt of the On command, if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. */
  command On(): DefaultSuccess = 1;
  /** On receipt of this command, if a device is in its ‘Off’ state it SHALL enter its ‘On’ state. Otherwise, if it is in its ‘On’ state it SHALL enter its ‘Off’ state. On receipt of the Toggle command, if the value of the OnOff attribute is equal to FALSE and if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. If the value of the OnOff attribute is equal to TRUE, the OnTime attribute SHALL be set to 0. */
  command Toggle(): DefaultSuccess = 2;
  /** The OffWithEffect command allows devices to be turned off using enhanced ways of fading. */
  command OffWithEffect(OffWithEffectRequest): DefaultSuccess = 64;
  /** This command allows the recall of the settings when the device was turned off. */
  command OnWithRecallGlobalScene(): DefaultSuccess = 65;
  /** This command allows devices to be turned on for a specific duration with a guarded off duration so that SHOULD the device be subsequently turned off, further OnWithTimedOff commands, received during this time, are prevented from turning the devices back on. */
  command OnWithTimedOff(OnWithTimedOffRequest): DefaultSuccess = 66;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
cluster LevelControl = 8 {
  revision 6;

  enum MoveModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute optional int16u remainingTime = 1;
  readonly attribute optional int8u minLevel = 2;
  readonly attribute optional int8u maxLevel = 3;
  readonly attribute optional int16u currentFrequency = 4;
  readonly attribute optional int16u minFrequency = 5;
  readonly attribute optional int16u maxFrequency = 6;
  attribute OptionsBitmap options = 15;
  attribute optional int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute optional nullable int16u onTransitionTime = 18;
  attribute optional nullable int16u offTransitionTime = 19;
  attribute optional nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) optional nullable int8u startUpCurrentLevel = 16384;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToClosestFrequencyRequest {
    int16u frequency = 0;
  }

  /** Command description for MoveToLevel */
  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  /** Command description for Move */
  command Move(MoveRequest): DefaultSuccess = 1;
  /** Command description for Step */
  command Step(StepRequest): DefaultSuccess = 2;
  /** Command description for Stop */
  command Stop(StopRequest): DefaultSuccess = 3;
  /** Command description for MoveToLevelWithOnOff */
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  /** Command description for MoveWithOnOff */
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  /** Command description for StepWithOnOff */
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  /** Command description for StopWithOnOff */
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
  /** Change the currrent frequency to the provided one, or a close
        approximation if the exact provided one is not possible. */
  command MoveToClosestFrequency(MoveToClosestFrequencyRequest): DefaultSuccess = 8;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
cluster Descriptor = 29 {
  revision 3;

  bitmap Feature : bitmap32 {
    kTagList = 0x1;
  }

  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  struct SemanticTagStruct {
    nullable vendor_id mfgCode = 0;
    enum8 namespaceID = 1;
    enum8 tag = 2;
    optional nullable char_string<64> label = 3;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute cluster_id serverList[] = 1;
  readonly attribute cluster_id clientList[] = 2;
  readonly attribute endpoint_no partsList[] = 3;
  readonly attribute optional SemanticTagStruct tagList[] = 4;
  readonly attribute optional char_string<32> endpointUniqueID = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Binding Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table. */
cluster Binding = 30 {
  revision 1;

  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(write: manage) TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
cluster AccessControl = 31 {
  revision 2;

  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1 [spec_name = "PASE"];
    kCASE = 2 [spec_name = "CASE"];
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum AccessRestrictionTypeEnum : enum8 {
    kAttributeAccessForbidden = 0;
    kAttributeWriteForbidden = 1;
    kCommandForbidden = 2;
    kEventForbidden = 3;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  bitmap Feature : bitmap32 {
    kExtension = 0x1;
    kManagedDevice = 0x2;
  }

  struct AccessRestrictionStruct {
    AccessRestrictionTypeEnum type = 0;
    nullable int32u id = 1;
  }

  struct CommissioningAccessRestrictionEntryStruct {
    endpoint_no endpoint = 0;
    cluster_id cluster = 1;
    AccessRestrictionStruct restrictions[] = 2;
  }

  fabric_scoped struct AccessRestrictionEntryStruct {
    fabric_sensitive endpoint_no endpoint = 0;
    fabric_sensitive cluster_id cluster = 1;
    fabric_sensitive AccessRestrictionStruct restrictions[] = 2;
    fabric_idx fabricIndex = 254;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) FabricRestrictionReviewUpdate = 2 {
    int64u token = 0;
    optional long_char_string instruction = 1;
    optional long_char_string ARLRequestFlowUrl = 2;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute optional CommissioningAccessRestrictionEntryStruct commissioningARL[] = 5;
  readonly attribute optional AccessRestrictionEntryStruct arl[] = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ReviewFabricRestrictionsRequest {
    CommissioningAccessRestrictionEntryStruct arl[] = 0;
  }

  response struct ReviewFabricRestrictionsResponse = 1 {
    int64u token = 0;
  }

  /** This command signals to the service associated with the device vendor that the fabric administrator would like a review of the current restrictions on the accessing fabric. */
  fabric command access(invoke: administer) ReviewFabricRestrictions(ReviewFabricRestrictionsRequest): ReviewFabricRestrictionsResponse = 0;
}

/** This cluster provides a standardized way for a Node (typically a Bridge, but could be any Node) to expose action information. */
cluster Actions = 37 {
  revision 1;

  enum ActionErrorEnum : enum8 {
    kUnknown = 0;
    kInterrupted = 1;
  }

  enum ActionStateEnum : enum8 {
    kInactive = 0;
    kActive = 1;
    kPaused = 2;
    kDisabled = 3;
  }

  enum ActionTypeEnum : enum8 {
    kOther = 0;
    kScene = 1;
    kSequence = 2;
    kAutomation = 3;
    kException = 4;
    kNotification = 5;
    kAlarm = 6;
  }

  enum EndpointListTypeEnum : enum8 {
    kOther = 0;
    kRoom = 1;
    kZone = 2;
  }

  bitmap CommandBits : bitmap16 {
    kInstantAction = 0x1;
    kInstantActionWithTransition = 0x2;
    kStartAction = 0x4;
    kStartActionWithDuration = 0x8;
    kStopAction = 0x10;
    kPauseAction = 0x20;
    kPauseActionWithDuration = 0x40;
    kResumeAction = 0x80;
    kEnableAction = 0x100;
    kEnableActionWithDuration = 0x200;
    kDisableAction = 0x400;
    kDisableActionWithDuration = 0x800;
  }

  struct ActionStruct {
    int16u actionID = 0;
    char_string<128> name = 1;
    ActionTypeEnum type = 2;
    int16u endpointListID = 3;
    CommandBits supportedCommands = 4;
    ActionStateEnum state = 5;
  }

  struct EndpointListStruct {
    int16u endpointListID = 0;
    char_string<128> name = 1;
    EndpointListTypeEnum type = 2;
    endpoint_no endpoints[] = 3;
  }

  info event StateChanged = 0 {
    int16u actionID = 0;
    int32u invokeID = 1;
    ActionStateEnum newState = 2;
  }

  info event ActionFailed = 1 {
    int16u actionID = 0;
    int32u invokeID = 1;
    ActionStateEnum newState = 2;
    ActionErrorEnum error = 3;
  }

  readonly attribute ActionStruct actionList[] = 0;
  readonly attribute EndpointListStruct endpointLists[] = 1;
  readonly attribute optional long_char_string<512> setupURL = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct InstantActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct InstantActionWithTransitionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int16u transitionTime = 2;
  }

  request struct StartActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct StartActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct StopActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct PauseActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct PauseActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct ResumeActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct EnableActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct EnableActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct DisableActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct DisableActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  /** This command is used to trigger an instantaneous action. */
  command InstantAction(InstantActionRequest): DefaultSuccess = 0;
  /** This command is used to trigger an instantaneous action with a transition over a given time. */
  command InstantActionWithTransition(InstantActionWithTransitionRequest): DefaultSuccess = 1;
  /** This command is used to trigger the commencement of an action. */
  command StartAction(StartActionRequest): DefaultSuccess = 2;
  /** This command is used to trigger the commencement of an action with a duration. */
  command StartActionWithDuration(StartActionWithDurationRequest): DefaultSuccess = 3;
  /** This command is used to stop an action. */
  command StopAction(StopActionRequest): DefaultSuccess = 4;
  /** This command is used to pause an action. */
  command PauseAction(PauseActionRequest): DefaultSuccess = 5;
  /** This command is used to pause an action with a duration. */
  command PauseActionWithDuration(PauseActionWithDurationRequest): DefaultSuccess = 6;
  /** This command is used to resume an action. */
  command ResumeAction(ResumeActionRequest): DefaultSuccess = 7;
  /** This command is used to enable an action. */
  command EnableAction(EnableActionRequest): DefaultSuccess = 8;
  /** This command is used to enable an action with a duration. */
  command EnableActionWithDuration(EnableActionWithDurationRequest): DefaultSuccess = 9;
  /** This command is used to disable an action. */
  command DisableAction(DisableActionRequest): DefaultSuccess = 10;
  /** This command is used to disable an action with a duration. */
  command DisableActionWithDuration(DisableActionWithDurationRequest): DefaultSuccess = 11;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
cluster BasicInformation = 40 {
  revision 5;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  attribute access(write: manage) optional boolean localConfigDisabled = 16;
  readonly attribute optional boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute int32u specificationVersion = 21;
  readonly attribute int16u maxPathsPerInvoke = 22;
  readonly attribute int32u configurationVersion = 24;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command MfgSpecificPing(): DefaultSuccess = 0;
}

/** Provides an interface for providing OTA software updates */
cluster OtaSoftwareUpdateProvider = 41 {
  revision 1; // NOTE: Default/not specifically set

  enum ApplyUpdateActionEnum : enum8 {
    kProceed = 0;
    kAwaitNextAction = 1;
    kDiscontinue = 2;
  }

  enum DownloadProtocolEnum : enum8 {
    kBDXSynchronous = 0;
    kBDXAsynchronous = 1;
    kHTTPS = 2 [spec_name = "HTTPS"];
    kVendorSpecific = 3;
  }

  enum StatusEnum : enum8 {
    kUpdateAvailable = 0;
    kBusy = 1;
    kNotAvailable = 2;
    kDownloadProtocolNotSupported = 3;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct QueryImageRequest {
    vendor_id vendorID = 0;
    int16u productID = 1;
    int32u softwareVersion = 2;
    DownloadProtocolEnum protocolsSupported[] = 3;
    optional int16u hardwareVersion = 4;
    optional char_string<2> location = 5;
    optional boolean requestorCanConsent = 6;
    optional octet_string<512> metadataForProvider = 7;
  }

  response struct QueryImageResponse = 1 {
    StatusEnum status = 0;
    optional int32u delayedActionTime = 1;
    optional char_string<256> imageURI = 2;
    optional int32u softwareVersion = 3;
    optional char_string<64> softwareVersionString = 4;
    optional octet_string<32> updateToken = 5;
    optional boolean userConsentNeeded = 6;
    optional octet_string<512> metadataForRequestor = 7;
  }

  request struct ApplyUpdateRequestRequest {
    octet_string<32> updateToken = 0;
    int32u newVersion = 1;
  }

  response struct ApplyUpdateResponse = 3 {
    ApplyUpdateActionEnum action = 0;
    int32u delayedActionTime = 1;
  }

  request struct NotifyUpdateAppliedRequest {
    octet_string<32> updateToken = 0;
    int32u softwareVersion = 1;
  }

  /** Determine availability of a new Software Image */
  command QueryImage(QueryImageRequest): QueryImageResponse = 0;
  /** Determine next action to take for a downloaded Software Image */
  command ApplyUpdateRequest(ApplyUpdateRequestRequest): ApplyUpdateResponse = 2;
  /** Notify OTA Provider that an update was applied */
  command NotifyUpdateApplied(NotifyUpdateAppliedRequest): DefaultSuccess = 4;
}

/** Provides an interface for downloading and applying OTA software updates */
cluster OtaSoftwareUpdateRequestor = 42 {
  revision 1; // NOTE: Default/not specifically set

  enum AnnouncementReasonEnum : enum8 {
    kSimpleAnnouncement = 0;
    kUpdateAvailable = 1;
    kUrgentUpdateAvailable = 2;
  }

  enum ChangeReasonEnum : enum8 {
    kUnknown = 0;
    kSuccess = 1;
    kFailure = 2;
    kTimeOut = 3;
    kDelayByProvider = 4;
  }

  enum UpdateStateEnum : enum8 {
    kUnknown = 0;
    kIdle = 1;
    kQuerying = 2;
    kDelayedOnQuery = 3;
    kDownloading = 4;
    kApplying = 5;
    kDelayedOnApply = 6;
    kRollingBack = 7;
    kDelayedOnUserConsent = 8;
  }

  fabric_scoped struct ProviderLocation {
    node_id providerNodeID = 1;
    endpoint_no endpoint = 2;
    fabric_idx fabricIndex = 254;
  }

  info event StateTransition = 0 {
    UpdateStateEnum previousState = 0;
    UpdateStateEnum newState = 1;
    ChangeReasonEnum reason = 2;
    nullable int32u targetSoftwareVersion = 3;
  }

  critical event VersionApplied = 1 {
    int32u softwareVersion = 0;
    int16u productID = 1;
  }

  info event DownloadError = 2 {
    int32u softwareVersion = 0;
    int64u bytesDownloaded = 1;
    nullable int8u progressPercent = 2;
    nullable int64s platformCode = 3;
  }

  attribute access(write: administer) ProviderLocation defaultOTAProviders[] = 0;
  readonly attribute boolean updatePossible = 1;
  readonly attribute UpdateStateEnum updateState = 2;
  readonly attribute nullable int8u updateStateProgress = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AnnounceOTAProviderRequest {
    node_id providerNodeID = 0;
    vendor_id vendorID = 1;
    AnnouncementReasonEnum announcementReason = 2;
    optional octet_string<512> metadataForNode = 3;
    endpoint_no endpoint = 4;
  }

  /** Announce the presence of an OTA Provider */
  command access(invoke: administer) AnnounceOTAProvider(AnnounceOTAProviderRequest): DefaultSuccess = 0;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
cluster LocalizationConfiguration = 43 {
  revision 1;

  attribute access(write: manage) char_string<35> activeLocale = 0;
  readonly attribute char_string supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for how dates and times are conveyed. As such, Nodes that visually
      or audibly convey time information need a mechanism by which they can be configured to use a
      user’s preferred format. */
cluster TimeFormatLocalization = 44 {
  revision 1;

  enum CalendarTypeEnum : enum8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
    kUseActiveLocale = 255;
  }

  enum HourFormatEnum : enum8 {
    k12hr = 0;
    k24hr = 1;
    kUseActiveLocale = 255;
  }

  bitmap Feature : bitmap32 {
    kCalendarFormat = 0x1;
  }

  attribute access(write: manage) HourFormatEnum hourFormat = 0;
  attribute access(write: manage) optional CalendarTypeEnum activeCalendarType = 1;
  readonly attribute optional CalendarTypeEnum supportedCalendarTypes[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for the units in which values are conveyed in communication to a
      user. As such, Nodes that visually or audibly convey measurable values to the user need a
      mechanism by which they can be configured to use a user’s preferred unit. */
cluster UnitLocalization = 45 {
  revision 2;

  enum TempUnitEnum : enum8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap Feature : bitmap32 {
    kTemperatureUnit = 0x1;
  }

  attribute access(write: manage) optional TempUnitEnum temperatureUnit = 0;
  provisional readonly attribute optional TempUnitEnum supportedTemperatureUnits[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to describe the configuration and capabilities of a Device's power system. */
cluster PowerSourceConfiguration = 46 {
  revision 1;

  readonly attribute endpoint_no sources[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to describe the configuration and capabilities of a physical power source that provides power to the Node. */
cluster PowerSource = 47 {
  revision 1; // NOTE: Default/not specifically set

  enum BatApprovedChemistryEnum : enum16 {
    kUnspecified = 0;
    kAlkaline = 1;
    kLithiumCarbonFluoride = 2;
    kLithiumChromiumOxide = 3;
    kLithiumCopperOxide = 4;
    kLithiumIronDisulfide = 5;
    kLithiumManganeseDioxide = 6;
    kLithiumThionylChloride = 7;
    kMagnesium = 8;
    kMercuryOxide = 9;
    kNickelOxyhydride = 10;
    kSilverOxide = 11;
    kZincAir = 12;
    kZincCarbon = 13;
    kZincChloride = 14;
    kZincManganeseDioxide = 15;
    kLeadAcid = 16;
    kLithiumCobaltOxide = 17;
    kLithiumIon = 18;
    kLithiumIonPolymer = 19;
    kLithiumIronPhosphate = 20;
    kLithiumSulfur = 21;
    kLithiumTitanate = 22;
    kNickelCadmium = 23;
    kNickelHydrogen = 24;
    kNickelIron = 25;
    kNickelMetalHydride = 26;
    kNickelZinc = 27;
    kSilverZinc = 28;
    kSodiumIon = 29;
    kSodiumSulfur = 30;
    kZincBromide = 31;
    kZincCerium = 32;
  }

  enum BatChargeFaultEnum : enum8 {
    kUnspecified = 0;
    kAmbientTooHot = 1;
    kAmbientTooCold = 2;
    kBatteryTooHot = 3;
    kBatteryTooCold = 4;
    kBatteryAbsent = 5;
    kBatteryOverVoltage = 6;
    kBatteryUnderVoltage = 7;
    kChargerOverVoltage = 8;
    kChargerUnderVoltage = 9;
    kSafetyTimeout = 10;
  }

  enum BatChargeLevelEnum : enum8 {
    kOK = 0 [spec_name = "OK"];
    kWarning = 1;
    kCritical = 2;
  }

  enum BatChargeStateEnum : enum8 {
    kUnknown = 0;
    kIsCharging = 1;
    kIsAtFullCharge = 2;
    kIsNotCharging = 3;
  }

  enum BatCommonDesignationEnum : enum16 {
    kUnspecified = 0;
    kAAA = 1 [spec_name = "AAA"];
    kAA = 2 [spec_name = "AA"];
    kC = 3;
    kD = 4;
    k4v5 = 5;
    k6v0 = 6;
    k9v0 = 7;
    k12AA = 8 [spec_name = "1_2AA"];
    kAAAA = 9 [spec_name = "AAAA"];
    kA = 10;
    kB = 11;
    kF = 12;
    kN = 13;
    kNo6 = 14;
    kSubC = 15;
    kA23 = 16;
    kA27 = 17;
    kBA5800 = 18 [spec_name = "BA5800"];
    kDuplex = 19;
    k4SR44 = 20 [spec_name = "4SR44"];
    k523 = 21;
    k531 = 22;
    k15v0 = 23;
    k22v5 = 24;
    k30v0 = 25;
    k45v0 = 26;
    k67v5 = 27;
    kJ = 28;
    kCR123A = 29 [spec_name = "CR123A"];
    kCR2 = 30 [spec_name = "CR2"];
    k2CR5 = 31 [spec_name = "2CR5"];
    kCRP2 = 32 [spec_name = "CR_P2"];
    kCRV3 = 33 [spec_name = "CR_V3"];
    kSR41 = 34 [spec_name = "SR41"];
    kSR43 = 35 [spec_name = "SR43"];
    kSR44 = 36 [spec_name = "SR44"];
    kSR45 = 37 [spec_name = "SR45"];
    kSR48 = 38 [spec_name = "SR48"];
    kSR54 = 39 [spec_name = "SR54"];
    kSR55 = 40 [spec_name = "SR55"];
    kSR57 = 41 [spec_name = "SR57"];
    kSR58 = 42 [spec_name = "SR58"];
    kSR59 = 43 [spec_name = "SR59"];
    kSR60 = 44 [spec_name = "SR60"];
    kSR63 = 45 [spec_name = "SR63"];
    kSR64 = 46 [spec_name = "SR64"];
    kSR65 = 47 [spec_name = "SR65"];
    kSR66 = 48 [spec_name = "SR66"];
    kSR67 = 49 [spec_name = "SR67"];
    kSR68 = 50 [spec_name = "SR68"];
    kSR69 = 51 [spec_name = "SR69"];
    kSR516 = 52 [spec_name = "SR516"];
    kSR731 = 53 [spec_name = "SR731"];
    kSR712 = 54 [spec_name = "SR712"];
    kLR932 = 55 [spec_name = "LR932"];
    kA5 = 56;
    kA10 = 57;
    kA13 = 58;
    kA312 = 59;
    kA675 = 60;
    kAC41E = 61 [spec_name = "AC41E"];
    k10180 = 62;
    k10280 = 63;
    k10440 = 64;
    k14250 = 65;
    k14430 = 66;
    k14500 = 67;
    k14650 = 68;
    k15270 = 69;
    k16340 = 70;
    kRCR123A = 71 [spec_name = "RCR123A"];
    k17500 = 72;
    k17670 = 73;
    k18350 = 74;
    k18500 = 75;
    k18650 = 76;
    k19670 = 77;
    k25500 = 78;
    k26650 = 79;
    k32600 = 80;
  }

  enum BatFaultEnum : enum8 {
    kUnspecified = 0;
    kOverTemp = 1;
    kUnderTemp = 2;
  }

  enum BatReplaceabilityEnum : enum8 {
    kUnspecified = 0;
    kNotReplaceable = 1;
    kUserReplaceable = 2;
    kFactoryReplaceable = 3;
  }

  enum PowerSourceStatusEnum : enum8 {
    kUnspecified = 0;
    kActive = 1;
    kStandby = 2;
    kUnavailable = 3;
  }

  enum WiredCurrentTypeEnum : enum8 {
    kAC = 0 [spec_name = "AC"];
    kDC = 1 [spec_name = "DC"];
  }

  enum WiredFaultEnum : enum8 {
    kUnspecified = 0;
    kOverVoltage = 1;
    kUnderVoltage = 2;
  }

  bitmap Feature : bitmap32 {
    kWired = 0x1;
    kBattery = 0x2;
    kRechargeable = 0x4;
    kReplaceable = 0x8;
  }

  struct BatChargeFaultChangeType {
    BatChargeFaultEnum current[] = 0;
    BatChargeFaultEnum previous[] = 1;
  }

  struct BatFaultChangeType {
    BatFaultEnum current[] = 0;
    BatFaultEnum previous[] = 1;
  }

  struct WiredFaultChangeType {
    WiredFaultEnum current[] = 0;
    WiredFaultEnum previous[] = 1;
  }

  info event WiredFaultChange = 0 {
    WiredFaultEnum current[] = 0;
    WiredFaultEnum previous[] = 1;
  }

  info event BatFaultChange = 1 {
    BatFaultEnum current[] = 0;
    BatFaultEnum previous[] = 1;
  }

  info event BatChargeFaultChange = 2 {
    BatChargeFaultEnum current[] = 0;
    BatChargeFaultEnum previous[] = 1;
  }

  readonly attribute PowerSourceStatusEnum status = 0;
  readonly attribute int8u order = 1;
  readonly attribute char_string<60> description = 2;
  readonly attribute optional nullable int32u wiredAssessedInputVoltage = 3;
  readonly attribute optional nullable int16u wiredAssessedInputFrequency = 4;
  readonly attribute optional WiredCurrentTypeEnum wiredCurrentType = 5;
  readonly attribute optional nullable int32u wiredAssessedCurrent = 6;
  readonly attribute optional int32u wiredNominalVoltage = 7;
  readonly attribute optional int32u wiredMaximumCurrent = 8;
  readonly attribute optional boolean wiredPresent = 9;
  readonly attribute optional WiredFaultEnum activeWiredFaults[] = 10;
  readonly attribute optional nullable int32u batVoltage = 11;
  readonly attribute optional nullable int8u batPercentRemaining = 12;
  readonly attribute optional nullable int32u batTimeRemaining = 13;
  readonly attribute optional BatChargeLevelEnum batChargeLevel = 14;
  readonly attribute optional boolean batReplacementNeeded = 15;
  readonly attribute optional BatReplaceabilityEnum batReplaceability = 16;
  readonly attribute optional boolean batPresent = 17;
  readonly attribute optional BatFaultEnum activeBatFaults[] = 18;
  readonly attribute optional char_string<60> batReplacementDescription = 19;
  readonly attribute optional BatCommonDesignationEnum batCommonDesignation = 20;
  readonly attribute optional char_string<20> batANSIDesignation = 21;
  readonly attribute optional char_string<20> batIECDesignation = 22;
  readonly attribute optional BatApprovedChemistryEnum batApprovedChemistry = 23;
  readonly attribute optional int32u batCapacity = 24;
  readonly attribute optional int8u batQuantity = 25;
  readonly attribute optional BatChargeStateEnum batChargeState = 26;
  readonly attribute optional nullable int32u batTimeToFullCharge = 27;
  readonly attribute optional boolean batFunctionalWhileCharging = 28;
  readonly attribute optional nullable int32u batChargingCurrent = 29;
  readonly attribute optional BatChargeFaultEnum activeBatChargeFaults[] = 30;
  readonly attribute endpoint_no endpointList[] = 31;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
cluster GeneralCommissioning = 48 {
  revision 2;

  enum CommissioningErrorEnum : enum8 {
    kOK = 0 [spec_name = "OK"];
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
    kRequiredTCNotAccepted = 5;
    kTCAcknowledgementsNotReceived = 6;
    kTCMinVersionNotMet = 7;
  }

  enum NetworkRecoveryReasonEnum : enum8 {
    kUnspecified = 0;
    kAuth = 1;
    kVisibility = 2;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  bitmap Feature : bitmap32 {
    kTermsAndConditions = 0x1;
    kNetworkRecovery = 0x2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  provisional readonly attribute access(read: administer) optional int16u TCAcceptedVersion = 5;
  provisional readonly attribute access(read: administer) optional int16u TCMinRequiredVersion = 6;
  provisional readonly attribute access(read: administer) optional bitmap16 TCAcknowledgements = 7;
  provisional readonly attribute access(read: administer) optional boolean TCAcknowledgementsRequired = 8;
  provisional readonly attribute access(read: administer) optional nullable int32u TCUpdateDeadline = 9;
  provisional readonly attribute access(read: manage) optional octet_string<8> recoveryIdentifier = 10;
  provisional readonly attribute access(read: manage) optional nullable NetworkRecoveryReasonEnum networkRecoveryReason = 11;
  provisional readonly attribute optional boolean isCommissioningWithoutPower = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string<128> debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string<2> countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  request struct SetTCAcknowledgementsRequest {
    int16u TCVersion = 0;
    bitmap16 TCUserResponse = 1;
  }

  response struct SetTCAcknowledgementsResponse = 7 {
    CommissioningErrorEnum errorCode = 0;
  }

  /** This command is used to arm or disarm the fail-safe timer. */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** This command is used to set the regulatory configuration for the device. */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** This command is used to indicate that the commissioning process is complete. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
  /** This command is used to set the user acknowledgements received in the Enhanced Setup Flow Terms & Conditions into the node. */
  command access(invoke: administer) SetTCAcknowledgements(SetTCAcknowledgementsRequest): SetTCAcknowledgementsResponse = 6;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
cluster NetworkCommissioning = 49 {
  revision 2;

  enum NetworkCommissioningStatusEnum : enum8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBandEnum : enum8 {
    k2G4 = 0 [spec_name = "2G4"];
    k3G65 = 1 [spec_name = "3G65"];
    k5G = 2 [spec_name = "5G"];
    k6G = 3 [spec_name = "6G"];
    k60G = 4 [spec_name = "60G"];
    k1G = 5 [spec_name = "1G"];
  }

  bitmap Feature : bitmap32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
    kPerDeviceCredentials = 0x8;
  }

  bitmap ThreadCapabilitiesBitmap : bitmap16 {
    kIsBorderRouterCapable = 0x1;
    kIsRouterCapable = 0x2;
    kIsSleepyEndDeviceCapable = 0x4;
    kIsFullThreadDevice = 0x8;
    kIsSynchronizedSleepyEndDeviceCapable = 0x10;
  }

  bitmap WiFiSecurityBitmap : bitmap8 {
    kUnencrypted = 0x1;
    kWEP = 0x2 [spec_name = "WEP"];
    kWPAPersonal = 0x4 [spec_name = "WPA-PERSONAL"];
    kWPA2Personal = 0x8 [spec_name = "WPA2-PERSONAL"];
    kWPA3Personal = 0x10 [spec_name = "WPA3-PERSONAL"];
    kWPA3MatterPDC = 0x20 [spec_name = "WPA3-Matter-PDC"];
  }

  struct NetworkInfoStruct {
    octet_string<32> networkID = 0;
    boolean connected = 1;
    optional nullable octet_string<20> networkIdentifier = 2;
    optional nullable octet_string<20> clientIdentifier = 3;
  }

  struct ThreadInterfaceScanResultStruct {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResultStruct {
    WiFiSecurityBitmap security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBandEnum wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfoStruct networks[] = 1;
  readonly attribute optional int8u scanMaxTimeSeconds = 2;
  readonly attribute optional int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatusEnum lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  provisional readonly attribute optional WiFiBandEnum supportedWiFiBands[] = 8;
  provisional readonly attribute optional ThreadCapabilitiesBitmap supportedThreadFeatures = 9;
  provisional readonly attribute optional int16u threadVersion = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable octet_string<32> ssid = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    optional WiFiInterfaceScanResultStruct wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResultStruct threadScanResults[] = 3;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    octet_string<32> ssid = 0;
    octet_string<64> credentials = 1;
    optional int64u breadcrumb = 2;
    optional octet_string<140> networkIdentity = 3;
    optional octet_string<20> clientIdentifier = 4;
    optional octet_string<32> possessionNonce = 5;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    octet_string<254> operationalDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string<512> debugText = 1;
    optional int8u networkIndex = 2;
    optional octet_string<140> clientIdentity = 3;
    optional octet_string<64> possessionSignature = 4;
  }

  request struct ConnectNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    nullable int32s errorValue = 2;
  }

  request struct ReorderNetworkRequest {
    octet_string<32> networkID = 0;
    int8u networkIndex = 1;
    optional int64u breadcrumb = 2;
  }

  request struct QueryIdentityRequest {
    octet_string<20> keyIdentifier = 0;
    optional octet_string<32> possessionNonce = 1;
  }

  response struct QueryIdentityResponse = 10 {
    octet_string<140> identity = 0;
    optional octet_string<64> possessionSignature = 1;
  }

  /** Detemine the set of networks the device sees as available. */
  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  /** Add or update the credentials for a given Wi-Fi network. */
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  /** Add or update the credentials for a given Thread network. */
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  /** Remove the definition of a given network (including its credentials). */
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  /** Connect to the specified network, using previously-defined credentials. */
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  /** Modify the order in which networks will be presented in the Networks attribute. */
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
  /** Retrieve details about and optionally proof of possession of a network client identity. */
  command access(invoke: administer) QueryIdentity(QueryIdentityRequest): QueryIdentityResponse = 9;
}

/** The cluster provides commands for retrieving unstructured diagnostic logs from a Node that may be used to aid in diagnostics. */
cluster DiagnosticLogs = 50 {
  revision 1;

  enum IntentEnum : enum8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : enum8 {
    kResponsePayload = 0;
    kBDX = 1 [spec_name = "BDX"];
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional char_string<32> transferFileDesignator = 2;
  }

  response struct RetrieveLogsResponse = 1 {
    StatusEnum status = 0;
    long_octet_string<1024> logContent = 1;
    optional epoch_us UTCTimeStamp = 2;
    optional systime_us timeSinceBoot = 3;
  }

  /** Reception of this command starts the process of retrieving diagnostic logs from a Node. */
  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster GeneralDiagnostics = 51 {
  revision 2;

  enum BootReasonEnum : enum8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : enum8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : enum8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : enum8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  bitmap Feature : bitmap32 {
    kDataModelTest = 0x1;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute optional int64u upTime = 2;
  readonly attribute optional int32u totalOperationalHours = 3;
  readonly attribute optional BootReasonEnum bootReason = 4;
  readonly attribute optional HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute optional RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute optional NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    octet_string<16> enableKey = 0;
    int64u eventTrigger = 1;
  }

  response struct TimeSnapshotResponse = 2 {
    systime_ms systemTimeMs = 0;
    nullable posix_ms posixTimeMs = 1;
  }

  request struct PayloadTestRequestRequest {
    octet_string<16> enableKey = 0;
    int8u value = 1;
    int16u count = 2;
  }

  response struct PayloadTestResponse = 4 {
    octet_string payload = 0;
  }

  /** Provide a means for certification tests to trigger some test-plan-specific events */
  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
  /** Take a snapshot of system time and epoch time. */
  command TimeSnapshot(): TimeSnapshotResponse = 1;
  /** Request a variable length payload response. */
  command access(invoke: manage) PayloadTestRequest(PayloadTestRequestRequest): PayloadTestResponse = 3;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster SoftwareDiagnostics = 52 {
  revision 1;

  bitmap Feature : bitmap32 {
    kWatermarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    int64u id = 0;
    optional char_string name = 1;
    optional long_octet_string faultRecording = 2;
  }

  readonly attribute optional ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute optional int64u currentHeapFree = 1;
  readonly attribute optional int64u currentHeapUsed = 2;
  readonly attribute optional int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command is used to reset the high watermarks for heap and stack memory. */
  command access(invoke: manage) ResetWatermarks(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
cluster ThreadNetworkDiagnostics = 53 {
  revision 3;

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRoleEnum : enum8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kREED = 4 [spec_name = "REED"];
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTableStruct {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTableStruct {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRoleEnum routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute NeighborTableStruct neighborTable[] = 7;
  readonly attribute RouteTableStruct routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int16u weighting = 10;
  readonly attribute nullable int16u dataVersion = 11;
  readonly attribute nullable int16u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute optional int16u detachedRoleCount = 14;
  readonly attribute optional int16u childRoleCount = 15;
  readonly attribute optional int16u routerRoleCount = 16;
  readonly attribute optional int16u leaderRoleCount = 17;
  readonly attribute optional int16u attachAttemptCount = 18;
  readonly attribute optional int16u partitionIdChangeCount = 19;
  readonly attribute optional int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute optional int16u parentChangeCount = 21;
  readonly attribute optional int32u txTotalCount = 22;
  readonly attribute optional int32u txUnicastCount = 23;
  readonly attribute optional int32u txBroadcastCount = 24;
  readonly attribute optional int32u txAckRequestedCount = 25;
  readonly attribute optional int32u txAckedCount = 26;
  readonly attribute optional int32u txNoAckRequestedCount = 27;
  readonly attribute optional int32u txDataCount = 28;
  readonly attribute optional int32u txDataPollCount = 29;
  readonly attribute optional int32u txBeaconCount = 30;
  readonly attribute optional int32u txBeaconRequestCount = 31;
  readonly attribute optional int32u txOtherCount = 32;
  readonly attribute optional int32u txRetryCount = 33;
  readonly attribute optional int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute optional int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute optional int32u txErrCcaCount = 36;
  readonly attribute optional int32u txErrAbortCount = 37;
  readonly attribute optional int32u txErrBusyChannelCount = 38;
  readonly attribute optional int32u rxTotalCount = 39;
  readonly attribute optional int32u rxUnicastCount = 40;
  readonly attribute optional int32u rxBroadcastCount = 41;
  readonly attribute optional int32u rxDataCount = 42;
  readonly attribute optional int32u rxDataPollCount = 43;
  readonly attribute optional int32u rxBeaconCount = 44;
  readonly attribute optional int32u rxBeaconRequestCount = 45;
  readonly attribute optional int32u rxOtherCount = 46;
  readonly attribute optional int32u rxAddressFilteredCount = 47;
  readonly attribute optional int32u rxDestAddrFilteredCount = 48;
  readonly attribute optional int32u rxDuplicatedCount = 49;
  readonly attribute optional int32u rxErrNoFrameCount = 50;
  readonly attribute optional int32u rxErrUnknownNeighborCount = 51;
  readonly attribute optional int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute optional int32u rxErrSecCount = 53;
  readonly attribute optional int32u rxErrFcsCount = 54;
  readonly attribute optional int32u rxErrOtherCount = 55;
  readonly attribute optional nullable int64u activeTimestamp = 56;
  readonly attribute optional nullable int64u pendingTimestamp = 57;
  readonly attribute optional nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFaultEnum activeNetworkFaultsList[] = 62;
  provisional readonly attribute nullable int64u extAddress = 63;
  provisional readonly attribute nullable int16u rloc16 = 64;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the following attributes to 0: */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** The Wi-Fi Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster WiFiNetworkDiagnostics = 54 {
  revision 1;

  enum AssociationFailureCauseEnum : enum8 {
    kUnknown = 0;
    kAssociationFailed = 1;
    kAuthenticationFailed = 2;
    kSsidNotFound = 3;
  }

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum SecurityTypeEnum : enum8 {
    kUnspecified = 0;
    kNone = 1;
    kWEP = 2 [spec_name = "WEP"];
    kWPA = 3 [spec_name = "WPA"];
    kWPA2 = 4 [spec_name = "WPA2"];
    kWPA3 = 5 [spec_name = "WPA3"];
  }

  enum WiFiVersionEnum : enum8 {
    kA = 0;
    kB = 1;
    kG = 2;
    kN = 3;
    kAc = 4;
    kAx = 5;
    kAh = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  info event Disconnection = 0 {
    int16u reasonCode = 0;
  }

  info event AssociationFailure = 1 {
    AssociationFailureCauseEnum associationFailureCause = 0;
    int16u status = 1;
  }

  info event ConnectionStatus = 2 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  readonly attribute nullable octet_string<6> bssid = 0;
  readonly attribute nullable SecurityTypeEnum securityType = 1;
  readonly attribute nullable WiFiVersionEnum wiFiVersion = 2;
  readonly attribute nullable int16u channelNumber = 3;
  readonly attribute nullable int8s rssi = 4;
  readonly attribute optional nullable int32u beaconLostCount = 5;
  readonly attribute optional nullable int32u beaconRxCount = 6;
  readonly attribute optional nullable int32u packetMulticastRxCount = 7;
  readonly attribute optional nullable int32u packetMulticastTxCount = 8;
  readonly attribute optional nullable int32u packetUnicastRxCount = 9;
  readonly attribute optional nullable int32u packetUnicastTxCount = 10;
  readonly attribute optional nullable int64u currentMaxRate = 11;
  readonly attribute optional nullable int64u overrunCount = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command is used to reset the count attributes. */
  command ResetCounts(): DefaultSuccess = 0;
}

/** The Ethernet Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster EthernetNetworkDiagnostics = 55 {
  revision 1;

  enum PHYRateEnum : enum8 {
    kRate10M = 0;
    kRate100M = 1;
    kRate1G = 2;
    kRate25G = 3 [spec_name = "Rate2_5G"];
    kRate5G = 4;
    kRate10G = 5;
    kRate40G = 6;
    kRate100G = 7;
    kRate200G = 8;
    kRate400G = 9;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  readonly attribute optional nullable PHYRateEnum PHYRate = 0;
  readonly attribute optional nullable boolean fullDuplex = 1;
  readonly attribute optional int64u packetRxCount = 2;
  readonly attribute optional int64u packetTxCount = 3;
  readonly attribute optional int64u txErrCount = 4;
  readonly attribute optional int64u collisionCount = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute optional nullable boolean carrierDetect = 7;
  readonly attribute optional int64u timeSinceReset = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command is used to reset the count attributes. */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** Accurate time is required for a number of reasons, including scheduling, display and validating security materials. */
cluster TimeSynchronization = 56 {
  revision 2;

  enum GranularityEnum : enum8 {
    kNoTimeGranularity = 0;
    kMinutesGranularity = 1;
    kSecondsGranularity = 2;
    kMillisecondsGranularity = 3;
    kMicrosecondsGranularity = 4;
  }

  enum StatusCode : enum8 {
    kTimeNotAccepted = 2;
  }

  enum TimeSourceEnum : enum8 {
    kNone = 0;
    kUnknown = 1;
    kAdmin = 2;
    kNodeTimeCluster = 3;
    kNonMatterSNTP = 4;
    kNonMatterNTP = 5;
    kMatterSNTP = 6;
    kMatterNTP = 7;
    kMixedNTP = 8;
    kNonMatterSNTPNTS = 9;
    kNonMatterNTPNTS = 10;
    kMatterSNTPNTS = 11;
    kMatterNTPNTS = 12;
    kMixedNTPNTS = 13;
    kCloudSource = 14;
    kPTP = 15 [spec_name = "PTP"];
    kGNSS = 16 [spec_name = "GNSS"];
  }

  enum TimeZoneDatabaseEnum : enum8 {
    kFull = 0;
    kPartial = 1;
    kNone = 2;
  }

  bitmap Feature : bitmap32 {
    kTimeZone = 0x1;
    kNTPClient = 0x2;
    kNTPServer = 0x4;
    kTimeSyncClient = 0x8;
  }

  struct DSTOffsetStruct {
    int32s offset = 0;
    epoch_us validStarting = 1;
    nullable epoch_us validUntil = 2;
  }

  struct FabricScopedTrustedTimeSourceStruct {
    node_id nodeID = 0;
    endpoint_no endpoint = 1;
  }

  struct TimeZoneStruct {
    int32s offset = 0;
    epoch_us validAt = 1;
    optional char_string<64> name = 2;
  }

  struct TrustedTimeSourceStruct {
    fabric_idx fabricIndex = 0;
    node_id nodeID = 1;
    endpoint_no endpoint = 2;
  }

  info event DSTTableEmpty = 0 {
  }

  info event DSTStatus = 1 {
    boolean DSTOffsetActive = 0;
  }

  info event TimeZoneStatus = 2 {
    int32s offset = 0;
    optional char_string name = 1;
  }

  info event TimeFailure = 3 {
  }

  info event MissingTrustedTimeSource = 4 {
  }

  readonly attribute nullable epoch_us UTCTime = 0;
  readonly attribute GranularityEnum granularity = 1;
  readonly attribute optional TimeSourceEnum timeSource = 2;
  readonly attribute optional nullable TrustedTimeSourceStruct trustedTimeSource = 3;
  readonly attribute optional nullable char_string<128> defaultNTP = 4;
  readonly attribute optional TimeZoneStruct timeZone[] = 5;
  readonly attribute optional DSTOffsetStruct DSTOffset[] = 6;
  readonly attribute optional nullable epoch_us localTime = 7;
  readonly attribute optional TimeZoneDatabaseEnum timeZoneDatabase = 8;
  readonly attribute optional boolean NTPServerAvailable = 9;
  readonly attribute optional int8u timeZoneListMaxSize = 10;
  readonly attribute optional int8u DSTOffsetListMaxSize = 11;
  readonly attribute optional boolean supportsDNSResolve = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetUTCTimeRequest {
    epoch_us UTCTime = 0;
    GranularityEnum granularity = 1;
    optional TimeSourceEnum timeSource = 2;
  }

  request struct SetTrustedTimeSourceRequest {
    nullable FabricScopedTrustedTimeSourceStruct trustedTimeSource = 0;
  }

  request struct SetTimeZoneRequest {
    TimeZoneStruct timeZone[] = 0;
  }

  response struct SetTimeZoneResponse = 3 {
    boolean DSTOffsetRequired = 0;
  }

  request struct SetDSTOffsetRequest {
    DSTOffsetStruct DSTOffset[] = 0;
  }

  request struct SetDefaultNTPRequest {
    nullable char_string<128> defaultNTP = 0;
  }

  /** This command MAY be issued by Administrator to set the time. */
  command access(invoke: administer) SetUTCTime(SetUTCTimeRequest): DefaultSuccess = 0;
  /** This command SHALL set TrustedTimeSource. */
  fabric command access(invoke: administer) SetTrustedTimeSource(SetTrustedTimeSourceRequest): DefaultSuccess = 1;
  /** This command SHALL set TimeZone. */
  command access(invoke: manage) SetTimeZone(SetTimeZoneRequest): SetTimeZoneResponse = 2;
  /** This command SHALL set DSTOffset. */
  command access(invoke: manage) SetDSTOffset(SetDSTOffsetRequest): DefaultSuccess = 4;
  /** This command is used to set DefaultNTP. */
  command access(invoke: administer) SetDefaultNTP(SetDefaultNTPRequest): DefaultSuccess = 5;
}

/** This cluster exposes interactions with a switch device, for the purpose of using those interactions by other devices.
Two types of switch devices are supported: latching switch (e.g. rocker switch) and momentary switch (e.g. push button), distinguished with their feature flags.
Interactions with the switch device are exposed as attributes (for the latching switch) and as events (for both types of switches). An interested party MAY subscribe to these attributes/events and thus be informed of the interactions, and can perform actions based on this, for example by sending commands to perform an action such as controlling a light or a window shade. */
cluster Switch = 59 {
  revision 2;

  bitmap Feature : bitmap32 {
    kLatchingSwitch = 0x1;
    kMomentarySwitch = 0x2;
    kMomentarySwitchRelease = 0x4;
    kMomentarySwitchLongPress = 0x8;
    kMomentarySwitchMultiPress = 0x10;
    kActionSwitch = 0x20;
  }

  info event SwitchLatched = 0 {
    int8u newPosition = 0;
  }

  info event InitialPress = 1 {
    int8u newPosition = 0;
  }

  info event LongPress = 2 {
    int8u newPosition = 0;
  }

  info event ShortRelease = 3 {
    int8u previousPosition = 0;
  }

  info event LongRelease = 4 {
    int8u previousPosition = 0;
  }

  info event MultiPressOngoing = 5 {
    int8u newPosition = 0;
    int8u currentNumberOfPressesCounted = 1;
  }

  info event MultiPressComplete = 6 {
    int8u previousPosition = 0;
    int8u totalNumberOfPressesCounted = 1;
  }

  readonly attribute int8u numberOfPositions = 0;
  readonly attribute int8u currentPosition = 1;
  readonly attribute optional int8u multiPressMax = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
cluster AdministratorCommissioning = 60 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningWindowStatusEnum : enum8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : enum8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  bitmap Feature : bitmap32 {
    kBasic = 0x1;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable vendor_id adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
    octet_string PAKEPasscodeVerifier = 1;
    int16u discriminator = 2;
    int32u iterations = 3;
    octet_string<32> salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
  }

  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using enhanced commissioning method. */
  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using basic commissioning method, if the node supports it. */
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  /** This command is used by a current Administrator to instruct a Node to revoke any active Open Commissioning Window or Open Basic Commissioning Window command. */
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
cluster OperationalCredentials = 62 {
  revision 2;

  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0 [spec_name = "OK"];
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    optional octet_string<85> VIDVerificationStatement = 6;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    octet_string<400> noc = 1;
    nullable octet_string<400> icac = 2;
    optional octet_string<400> vvsc = 3;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string<400> rootCACertificate = 0;
  }

  request struct SetVIDVerificationStatementRequest {
    optional vendor_id vendorID = 0;
    optional octet_string<85> VIDVerificationStatement = 1;
    optional octet_string<400> vvsc = 2;
  }

  request struct SignVIDVerificationRequestRequest {
    fabric_idx fabricIndex = 0;
    octet_string<32> clientChallenge = 1;
  }

  response struct SignVIDVerificationResponse = 14 {
    fabric_idx fabricIndex = 0;
    int8u fabricBindingVersion = 1;
    octet_string signature = 2;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** This command SHALL replace the NOC and optional associated ICAC (if present) scoped under the accessing fabric upon successful validation of all arguments and preconditions. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
  /** This command SHALL be used to update any of the accessing fabric's associated VendorID, VidVerificatioNStatement or VVSC (Vendor Verification Signing Certificate). */
  fabric command access(invoke: administer) SetVIDVerificationStatement(SetVIDVerificationStatementRequest): DefaultSuccess = 12;
  /** This command SHALL be used to request that the server authenticate the fabric associated with the FabricIndex given. */
  command access(invoke: administer) SignVIDVerificationRequest(SignVIDVerificationRequestRequest): SignVIDVerificationResponse = 13;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
cluster GroupKeyManagement = 63 {
  revision 1; // NOTE: Default/not specifically set

  enum GroupKeySecurityPolicyEnum : enum8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  bitmap Feature : bitmap32 {
    kCacheAndSync = 0x1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetRemoveRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    int16u groupKeySetIDs[] = 0;
  }

  /** Write a new set of keys for the given key set id. */
  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  /** Read the keys for a given key set id. */
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  /** Revoke a Root Key from a Group */
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  /** Return the list of Group Key Sets associated with the accessing fabric */
  fabric command access(invoke: administer) KeySetReadAllIndices(): KeySetReadAllIndicesResponse = 4;
}

/** The Fixed Label Cluster provides a feature for the device to tag an endpoint with zero or more read only
labels. */
cluster FixedLabel = 64 {
  revision 1; // NOTE: Default/not specifically set

  shared struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The User Label Cluster provides a feature to tag an endpoint with zero or more labels. */
cluster UserLabel = 65 {
  revision 1; // NOTE: Default/not specifically set

  shared struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  attribute access(write: manage) LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface to a boolean state called StateValue. */
cluster BooleanState = 69 {
  revision 1;

  info event StateChange = 0 {
    boolean stateValue = 0;
  }

  readonly attribute boolean stateValue = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster supports remotely monitoring and, where supported, changing the operational state of an Oven. */
cluster OvenCavityOperationalState = 72 {
  revision 1;

  enum ErrorStateEnum : enum8 {
    kNoError = 0;
    kUnableToStartOrResume = 1;
    kUnableToCompleteOperation = 2;
    kCommandInvalidInState = 3;
  }

  enum OperationalStateEnum : enum8 {
    kStopped = 0;
    kRunning = 1;
    kPaused = 2;
    kError = 3;
  }

  shared struct ErrorStateStruct {
    enum8 errorStateID = 0;
    optional char_string<64> errorStateLabel = 1;
    optional char_string<64> errorStateDetails = 2;
  }

  shared struct OperationalStateStruct {
    enum8 operationalStateID = 0;
    optional char_string<64> operationalStateLabel = 1;
  }

  critical event OperationalError = 0 {
    ErrorStateStruct errorState = 0;
  }

  info event OperationCompletion = 1 {
    enum8 completionErrorCode = 0;
    optional nullable elapsed_s totalOperationalTime = 1;
    optional nullable elapsed_s pausedTime = 2;
  }

  readonly attribute nullable char_string phaseList[] = 0;
  readonly attribute nullable int8u currentPhase = 1;
  readonly attribute optional nullable elapsed_s countdownTime = 2;
  readonly attribute OperationalStateStruct operationalStateList[] = 3;
  readonly attribute OperationalStateEnum operationalState = 4;
  readonly attribute ErrorStateStruct operationalError = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct OperationalCommandResponse = 4 {
    ErrorStateStruct commandResponseState = 0;
  }

  /** Upon receipt, the device SHALL stop its operation if it is at a position where it is safe to do so and/or permitted. */
  command Stop(): OperationalCommandResponse = 1;
  /** Upon receipt, the device SHALL start its operation if it is safe to do so and the device is in an operational state from which it can be started. */
  command Start(): OperationalCommandResponse = 2;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster OvenMode = 73 {
  revision 1;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kBake = 16384;
    kConvection = 16385;
    kGrill = 16386;
    kRoast = 16387;
    kClean = 16388;
    kConvectionBake = 16389;
    kConvectionRoast = 16390;
    kWarming = 16391;
    kProofing = 16392;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  shared struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  shared struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string<64> statusText = 1;
  }

  /** This command is used to change device modes. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** This cluster provides a way to access options associated with the operation of
            a laundry dryer device type. */
cluster LaundryDryerControls = 74 {
  revision 1;

  enum DrynessLevelEnum : enum8 {
    kLow = 0;
    kNormal = 1;
    kExtra = 2;
    kMax = 3;
  }

  readonly attribute DrynessLevelEnum supportedDrynessLevels[] = 0;
  attribute nullable DrynessLevelEnum selectedDrynessLevel = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster ModeSelect = 80 {
  revision 2;

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct SemanticTagStruct {
    vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    SemanticTagStruct semanticTags[] = 2;
  }

  readonly attribute char_string<64> description = 0;
  readonly attribute nullable enum16 standardNamespace = 1;
  readonly attribute ModeOptionStruct supportedModes[] = 2;
  readonly attribute int8u currentMode = 3;
  attribute optional nullable int8u startUpMode = 4;
  attribute optional nullable int8u onMode = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
  readonly attribute optional int8u manufacturerExtension = 4293984257;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  /** On receipt of this command, if the NewMode field indicates a valid mode transition within the supported list, the server SHALL set the CurrentMode attribute to the NewMode value, otherwise, the server SHALL respond with an INVALID_COMMAND status response. */
  command ChangeToMode(ChangeToModeRequest): DefaultSuccess = 0;
  /** Sample manufacturer specific extension command */
  command SampleMfgExtensionCommand(): DefaultSuccess = 4293984257;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster LaundryWasherMode = 81 {
  revision 2;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kNormal = 16384;
    kDelicate = 16385;
    kHeavy = 16386;
    kWhites = 16387;
  }

  shared struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  shared struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string<64> statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster RefrigeratorAndTemperatureControlledCabinetMode = 82 {
  revision 2;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kRapidCool = 16384;
    kRapidFreeze = 16385;
  }

  shared struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  shared struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string<64> statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** This cluster supports remotely monitoring and controlling the different types of functionality available to a washing device, such as a washing machine. */
cluster LaundryWasherControls = 83 {
  revision 1;

  enum NumberOfRinsesEnum : enum8 {
    kNone = 0;
    kNormal = 1;
    kExtra = 2;
    kMax = 3;
  }

  bitmap Feature : bitmap32 {
    kSpin = 0x1;
    kRinse = 0x2;
  }

  readonly attribute optional char_string spinSpeeds[] = 0;
  attribute optional nullable int8u spinSpeedCurrent = 1;
  attribute optional NumberOfRinsesEnum numberOfRinses = 2;
  readonly attribute optional NumberOfRinsesEnum supportedRinses[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster RvcRunMode = 84 {
  revision 3;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kIdle = 16384;
    kCleaning = 16385;
    kMapping = 16386;
  }

  enum StatusCode : enum8 {
    kStuck = 65;
    kDustBinMissing = 66;
    kDustBinFull = 67;
    kWaterTankEmpty = 68;
    kWaterTankMissing = 69;
    kWaterTankLidOpen = 70;
    kMopCleaningPadMissing = 71;
    kBatteryLow = 72;
  }

  bitmap Feature : bitmap32 {
    kDirectModeChange = 0x10000;
  }

  shared struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  shared struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster RvcCleanMode = 85 {
  revision 3;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kDeepClean = 16384;
    kVacuum = 16385;
    kMop = 16386;
    kVacuumThenMop = 16387;
  }

  enum StatusCode : enum8 {
    kCleaningInProgress = 64;
  }

  bitmap Feature : bitmap32 {
    kDirectModeChange = 0x10000;
  }

  shared struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  shared struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes and commands for configuring the temperature control, and reporting temperature. */
cluster TemperatureControl = 86 {
  revision 1;

  bitmap Feature : bitmap32 {
    kTemperatureNumber = 0x1;
    kTemperatureLevel = 0x2;
    kTemperatureStep = 0x4;
  }

  readonly attribute optional temperature temperatureSetpoint = 0;
  readonly attribute optional temperature minTemperature = 1;
  readonly attribute optional temperature maxTemperature = 2;
  readonly attribute optional temperature step = 3;
  readonly attribute optional int8u selectedTemperatureLevel = 4;
  readonly attribute optional char_string supportedTemperatureLevels[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetTemperatureRequest {
    optional temperature targetTemperature = 0;
    optional int8u targetTemperatureLevel = 1;
  }

  /** The SetTemperature command SHALL have the following data fields: */
  command SetTemperature(SetTemperatureRequest): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the Refrigerator alarm. */
cluster RefrigeratorAlarm = 87 {
  revision 1;

  bitmap AlarmBitmap : bitmap32 {
    kDoorOpen = 0x1;
  }

  info event Notify = 0 {
    AlarmBitmap active = 0;
    AlarmBitmap inactive = 1;
    AlarmBitmap state = 2;
    AlarmBitmap mask = 3;
  }

  readonly attribute AlarmBitmap mask = 0;
  readonly attribute AlarmBitmap state = 2;
  readonly attribute AlarmBitmap supported = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster DishwasherMode = 89 {
  revision 2;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kNormal = 16384;
    kHeavy = 16385;
    kLight = 16386;
  }

  shared struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  shared struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string<64> statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes for reporting air quality classification */
cluster AirQuality = 91 {
  revision 1;

  enum AirQualityEnum : enum8 {
    kUnknown = 0;
    kGood = 1;
    kFair = 2;
    kModerate = 3;
    kPoor = 4;
    kVeryPoor = 5;
    kExtremelyPoor = 6;
  }

  bitmap Feature : bitmap32 {
    kFair = 0x1;
    kModerate = 0x2;
    kVeryPoor = 0x4;
    kExtremelyPoor = 0x8;
  }

  readonly attribute AirQualityEnum airQuality = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for observing and managing the state of smoke and CO alarms. */
cluster SmokeCoAlarm = 92 {
  revision 1;

  enum AlarmStateEnum : enum8 {
    kNormal = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum ContaminationStateEnum : enum8 {
    kNormal = 0;
    kLow = 1;
    kWarning = 2;
    kCritical = 3;
  }

  enum EndOfServiceEnum : enum8 {
    kNormal = 0;
    kExpired = 1;
  }

  enum ExpressedStateEnum : enum8 {
    kNormal = 0;
    kSmokeAlarm = 1;
    kCOAlarm = 2;
    kBatteryAlert = 3;
    kTesting = 4;
    kHardwareFault = 5;
    kEndOfService = 6;
    kInterconnectSmoke = 7;
    kInterconnectCO = 8;
  }

  enum MuteStateEnum : enum8 {
    kNotMuted = 0;
    kMuted = 1;
  }

  enum SensitivityEnum : enum8 {
    kHigh = 0;
    kStandard = 1;
    kLow = 2;
  }

  bitmap Feature : bitmap32 {
    kSmokeAlarm = 0x1;
    kCOAlarm = 0x2 [spec_name = "CO Alarm"];
  }

  critical event SmokeAlarm = 0 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  critical event COAlarm = 1 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event LowBattery = 2 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event HardwareFault = 3 {
  }

  info event EndOfService = 4 {
  }

  info event SelfTestComplete = 5 {
  }

  info event AlarmMuted = 6 {
  }

  info event MuteEnded = 7 {
  }

  critical event InterconnectSmokeAlarm = 8 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  critical event InterconnectCOAlarm = 9 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event AllClear = 10 {
  }

  readonly attribute ExpressedStateEnum expressedState = 0;
  readonly attribute optional AlarmStateEnum smokeState = 1;
  readonly attribute optional AlarmStateEnum COState = 2;
  readonly attribute AlarmStateEnum batteryAlert = 3;
  readonly attribute optional MuteStateEnum deviceMuted = 4;
  readonly attribute boolean testInProgress = 5;
  readonly attribute boolean hardwareFaultAlert = 6;
  readonly attribute EndOfServiceEnum endOfServiceAlert = 7;
  readonly attribute optional AlarmStateEnum interconnectSmokeAlarm = 8;
  readonly attribute optional AlarmStateEnum interconnectCOAlarm = 9;
  readonly attribute optional ContaminationStateEnum contaminationState = 10;
  attribute access(write: manage) optional SensitivityEnum smokeSensitivityLevel = 11;
  readonly attribute optional epoch_s expiryDate = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command SHALL initiate a device self-test. */
  command SelfTestRequest(): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the Dishwasher alarm. */
cluster DishwasherAlarm = 93 {
  revision 1;

  bitmap AlarmBitmap : bitmap32 {
    kInflowError = 0x1;
    kDrainError = 0x2;
    kDoorError = 0x4;
    kTempTooLow = 0x8;
    kTempTooHigh = 0x10;
    kWaterLevelError = 0x20;
  }

  bitmap Feature : bitmap32 {
    kReset = 0x1;
  }

  info event Notify = 0 {
    AlarmBitmap active = 0;
    AlarmBitmap inactive = 1;
    AlarmBitmap state = 2;
    AlarmBitmap mask = 3;
  }

  readonly attribute AlarmBitmap mask = 0;
  readonly attribute optional AlarmBitmap latch = 1;
  readonly attribute AlarmBitmap state = 2;
  readonly attribute AlarmBitmap supported = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ResetRequest {
    AlarmBitmap alarms = 0;
  }

  request struct ModifyEnabledAlarmsRequest {
    AlarmBitmap mask = 0;
  }

  /** This command resets active and latched alarms (if possible). */
  command Reset(ResetRequest): DefaultSuccess = 0;
  /** This command allows a client to request that an alarm be enabled or suppressed at the server. */
  command ModifyEnabledAlarms(ModifyEnabledAlarmsRequest): DefaultSuccess = 1;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster MicrowaveOvenMode = 94 {
  revision 1;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kNormal = 16384;
    kDefrost = 16385;
  }

  shared struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  shared struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster supports remotely monitoring and, where supported, changing the operational state of any device where a state machine is a part of the operation. */
cluster OperationalState = 96 {
  revision 1;

  enum ErrorStateEnum : enum8 {
    kNoError = 0;
    kUnableToStartOrResume = 1;
    kUnableToCompleteOperation = 2;
    kCommandInvalidInState = 3;
  }

  enum OperationalStateEnum : enum8 {
    kStopped = 0;
    kRunning = 1;
    kPaused = 2;
    kError = 3;
  }

  shared struct ErrorStateStruct {
    enum8 errorStateID = 0;
    optional char_string<64> errorStateLabel = 1;
    optional char_string<64> errorStateDetails = 2;
  }

  shared struct OperationalStateStruct {
    enum8 operationalStateID = 0;
    optional char_string<64> operationalStateLabel = 1;
  }

  critical event OperationalError = 0 {
    ErrorStateStruct errorState = 0;
  }

  info event OperationCompletion = 1 {
    enum8 completionErrorCode = 0;
    optional nullable elapsed_s totalOperationalTime = 1;
    optional nullable elapsed_s pausedTime = 2;
  }

  readonly attribute nullable char_string phaseList[] = 0;
  readonly attribute nullable int8u currentPhase = 1;
  readonly attribute optional nullable elapsed_s countdownTime = 2;
  readonly attribute OperationalStateStruct operationalStateList[] = 3;
  readonly attribute OperationalStateEnum operationalState = 4;
  readonly attribute ErrorStateStruct operationalError = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct OperationalCommandResponse = 4 {
    ErrorStateStruct commandResponseState = 0;
  }

  /** Upon receipt, the device SHALL pause its operation if it is possible based on the current function of the server. */
  command Pause(): OperationalCommandResponse = 0;
  /** Upon receipt, the device SHALL stop its operation if it is at a position where it is safe to do so and/or permitted. */
  command Stop(): OperationalCommandResponse = 1;
  /** Upon receipt, the device SHALL start its operation if it is safe to do so and the device is in an operational state from which it can be started. */
  command Start(): OperationalCommandResponse = 2;
  /** Upon receipt, the device SHALL resume its operation from the point it was at when it received the Pause command, or from the point when it was paused by means outside of this cluster (for example by manual button press). */
  command Resume(): OperationalCommandResponse = 3;
}

/** This cluster supports remotely monitoring and, where supported, changing the operational state of a Robotic Vacuum. */
cluster RvcOperationalState = 97 {
  revision 1;

  enum ErrorStateEnum : enum8 {
    kNoError = 0;
    kUnableToStartOrResume = 1;
    kUnableToCompleteOperation = 2;
    kCommandInvalidInState = 3;
    kFailedToFindChargingDock = 64;
    kStuck = 65;
    kDustBinMissing = 66;
    kDustBinFull = 67;
    kWaterTankEmpty = 68;
    kWaterTankMissing = 69;
    kWaterTankLidOpen = 70;
    kMopCleaningPadMissing = 71;
    kLowBattery = 72;
    kCannotReachTargetArea = 73;
    kDirtyWaterTankFull = 74;
    kDirtyWaterTankMissing = 75;
    kWheelsJammed = 76;
    kBrushJammed = 77;
    kNavigationSensorObscured = 78;
  }

  enum OperationalStateEnum : enum8 {
    kStopped = 0;
    kRunning = 1;
    kPaused = 2;
    kError = 3;
    kSeekingCharger = 64;
    kCharging = 65;
    kDocked = 66;
    kEmptyingDustBin = 67;
    kCleaningMop = 68;
    kFillingWaterTank = 69;
    kUpdatingMaps = 70;
  }

  shared struct ErrorStateStruct {
    enum8 errorStateID = 0;
    optional char_string<64> errorStateLabel = 1;
    optional char_string<64> errorStateDetails = 2;
  }

  shared struct OperationalStateStruct {
    enum8 operationalStateID = 0;
    optional char_string<64> operationalStateLabel = 1;
  }

  critical event OperationalError = 0 {
    ErrorStateStruct errorState = 0;
  }

  info event OperationCompletion = 1 {
    enum8 completionErrorCode = 0;
    optional nullable elapsed_s totalOperationalTime = 1;
    optional nullable elapsed_s pausedTime = 2;
  }

  readonly attribute nullable char_string phaseList[] = 0;
  readonly attribute nullable int8u currentPhase = 1;
  readonly attribute optional nullable elapsed_s countdownTime = 2;
  readonly attribute OperationalStateStruct operationalStateList[] = 3;
  readonly attribute enum8 operationalState = 4;
  readonly attribute ErrorStateStruct operationalError = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct OperationalCommandResponse = 4 {
    ErrorStateStruct commandResponseState = 0;
  }

  /** Upon receipt, the device SHALL pause its operation if it is possible based on the current function of the server. */
  command Pause(): OperationalCommandResponse = 0;
  /** Upon receipt, the device SHALL resume its operation from the point it was at when it received the Pause command, or from the point when it was paused by means outside of this cluster (for example by manual button press). */
  command Resume(): OperationalCommandResponse = 3;
  /** On receipt of this command, the device SHALL start seeking the charging dock, if possible in the current state of the device. */
  command GoHome(): OperationalCommandResponse = 128;
}

/** Attributes and commands for scene configuration and manipulation. */
provisional cluster ScenesManagement = 98 {
  revision 1;

  bitmap CopyModeBitmap : bitmap8 {
    kCopyAllScenes = 0x1;
  }

  bitmap Feature : bitmap32 {
    kSceneNames = 0x1;
  }

  struct AttributeValuePairStruct {
    attrib_id attributeID = 0;
    optional int8u valueUnsigned8 = 1;
    optional int8s valueSigned8 = 2;
    optional int16u valueUnsigned16 = 3;
    optional int16s valueSigned16 = 4;
    optional int32u valueUnsigned32 = 5;
    optional int32s valueSigned32 = 6;
    optional int64u valueUnsigned64 = 7;
    optional int64s valueSigned64 = 8;
  }

  struct ExtensionFieldSetStruct {
    cluster_id clusterID = 0;
    AttributeValuePairStruct attributeValueList[] = 1;
  }

  fabric_scoped struct SceneInfoStruct {
    int8u sceneCount = 0;
    fabric_sensitive int8u currentScene = 1;
    fabric_sensitive group_id currentGroup = 2;
    fabric_sensitive boolean sceneValid = 3;
    int8u remainingCapacity = 4;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute int16u sceneTableSize = 1;
  readonly attribute SceneInfoStruct fabricSceneInfo[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
    int32u transitionTime = 2;
    char_string<16> sceneName = 3;
    ExtensionFieldSetStruct extensionFieldSetStructs[] = 4;
  }

  response struct AddSceneResponse = 0 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct ViewSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct ViewSceneResponse = 1 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
    optional int32u transitionTime = 3;
    optional char_string<16> sceneName = 4;
    optional ExtensionFieldSetStruct extensionFieldSetStructs[] = 5;
  }

  request struct RemoveSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct RemoveSceneResponse = 2 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct RemoveAllScenesRequest {
    group_id groupID = 0;
  }

  response struct RemoveAllScenesResponse = 3 {
    status status = 0;
    group_id groupID = 1;
  }

  request struct StoreSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct StoreSceneResponse = 4 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct RecallSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
    optional nullable int32u transitionTime = 2;
  }

  request struct GetSceneMembershipRequest {
    group_id groupID = 0;
  }

  response struct GetSceneMembershipResponse = 6 {
    status status = 0;
    nullable int8u capacity = 1;
    group_id groupID = 2;
    optional int8u sceneList[] = 3;
  }

  request struct CopySceneRequest {
    CopyModeBitmap mode = 0;
    group_id groupIdentifierFrom = 1;
    int8u sceneIdentifierFrom = 2;
    group_id groupIdentifierTo = 3;
    int8u sceneIdentifierTo = 4;
  }

  response struct CopySceneResponse = 64 {
    status status = 0;
    group_id groupIdentifierFrom = 1;
    int8u sceneIdentifierFrom = 2;
  }

  /** Add a scene to the scene table. Extension field sets are input as '{"ClusterID": VALUE, "AttributeValueList":[{"AttributeID": VALUE, "Value*": VALUE}]}'. */
  fabric command access(invoke: manage) AddScene(AddSceneRequest): AddSceneResponse = 0;
  /** Retrieves the requested scene entry from its Scene table. */
  fabric command ViewScene(ViewSceneRequest): ViewSceneResponse = 1;
  /** Removes the requested scene entry, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveScene(RemoveSceneRequest): RemoveSceneResponse = 2;
  /** Remove all scenes, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveAllScenes(RemoveAllScenesRequest): RemoveAllScenesResponse = 3;
  /** Adds the scene entry into its Scene Table along with all extension field sets corresponding to the current state of other clusters on the same endpoint */
  fabric command access(invoke: manage) StoreScene(StoreSceneRequest): StoreSceneResponse = 4;
  /** Set the attributes and corresponding state for each other cluster implemented on the endpoint accordingly to the resquested scene entry in the Scene Table */
  fabric command RecallScene(RecallSceneRequest): DefaultSuccess = 5;
  /** This command can be used to get the used scene identifiers within a certain group, for the endpoint that implements this cluster. */
  fabric command GetSceneMembership(GetSceneMembershipRequest): GetSceneMembershipResponse = 6;
  /** This command allows a client to efficiently copy scenes from one group/scene identifier pair to another group/scene identifier pair. */
  fabric command access(invoke: manage) CopyScene(CopySceneRequest): CopySceneResponse = 64;
}

/** Attributes and commands for monitoring HEPA filters in a device */
cluster HepaFilterMonitoring = 113 {
  revision 1; // NOTE: Default/not specifically set

  shared enum ChangeIndicationEnum : enum8 {
    kOK = 0 [spec_name = "OK"];
    kWarning = 1;
    kCritical = 2;
  }

  shared enum DegradationDirectionEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  shared enum ProductIdentifierTypeEnum : enum8 {
    kUPC = 0 [spec_name = "UPC"];
    kGTIN8 = 1 [spec_name = "GTIN-8"];
    kEAN = 2 [spec_name = "EAN"];
    kGTIN14 = 3 [spec_name = "GTIN-14"];
    kOEM = 4 [spec_name = "OEM"];
  }

  bitmap Feature : bitmap32 {
    kCondition = 0x1;
    kWarning = 0x2;
    kReplacementProductList = 0x4;
  }

  struct ReplacementProductStruct {
    ProductIdentifierTypeEnum productIdentifierType = 0;
    char_string<20> productIdentifierValue = 1;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  attribute optional nullable epoch_s lastChangedTime = 4;
  readonly attribute optional ReplacementProductStruct replacementProductList[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring activated carbon filters in a device */
cluster ActivatedCarbonFilterMonitoring = 114 {
  revision 1; // NOTE: Default/not specifically set

  shared enum ChangeIndicationEnum : enum8 {
    kOK = 0 [spec_name = "OK"];
    kWarning = 1;
    kCritical = 2;
  }

  shared enum DegradationDirectionEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  shared enum ProductIdentifierTypeEnum : enum8 {
    kUPC = 0 [spec_name = "UPC"];
    kGTIN8 = 1 [spec_name = "GTIN-8"];
    kEAN = 2 [spec_name = "EAN"];
    kGTIN14 = 3 [spec_name = "GTIN-14"];
    kOEM = 4 [spec_name = "OEM"];
  }

  bitmap Feature : bitmap32 {
    kCondition = 0x1;
    kWarning = 0x2;
    kReplacementProductList = 0x4;
  }

  struct ReplacementProductStruct {
    ProductIdentifierTypeEnum productIdentifierType = 0;
    char_string<20> productIdentifierValue = 1;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  attribute optional nullable epoch_s lastChangedTime = 4;
  readonly attribute optional ReplacementProductStruct replacementProductList[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** This cluster is used to configure a boolean sensor. */
cluster BooleanStateConfiguration = 128 {
  revision 1;

  bitmap AlarmModeBitmap : bitmap8 {
    kVisual = 0x1;
    kAudible = 0x2;
  }

  bitmap Feature : bitmap32 {
    kVisual = 0x1;
    kAudible = 0x2;
    kAlarmSuppress = 0x4;
    kSensitivityLevel = 0x8;
  }

  bitmap SensorFaultBitmap : bitmap16 {
    kGeneralFault = 0x1;
  }

  info event AlarmsStateChanged = 0 {
    AlarmModeBitmap alarmsActive = 0;
    optional AlarmModeBitmap alarmsSuppressed = 1;
  }

  info event SensorFault = 1 {
    SensorFaultBitmap sensorFault = 0;
  }

  attribute optional int8u currentSensitivityLevel = 0;
  readonly attribute optional int8u supportedSensitivityLevels = 1;
  readonly attribute optional int8u defaultSensitivityLevel = 2;
  readonly attribute optional AlarmModeBitmap alarmsActive = 3;
  readonly attribute optional AlarmModeBitmap alarmsSuppressed = 4;
  readonly attribute optional AlarmModeBitmap alarmsEnabled = 5;
  readonly attribute optional AlarmModeBitmap alarmsSupported = 6;
  readonly attribute optional SensorFaultBitmap sensorFault = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SuppressAlarmRequest {
    AlarmModeBitmap alarmsToSuppress = 0;
  }

  request struct EnableDisableAlarmRequest {
    AlarmModeBitmap alarmsToEnableDisable = 0;
  }

  /** This command is used to suppress the specified alarm mode. */
  command SuppressAlarm(SuppressAlarmRequest): DefaultSuccess = 0;
  /** This command is used to enable or disable the specified alarm mode. */
  command EnableDisableAlarm(EnableDisableAlarmRequest): DefaultSuccess = 1;
}

/** This cluster is used to configure a valve. */
cluster ValveConfigurationAndControl = 129 {
  revision 2;

  enum StatusCodeEnum : enum8 {
    kFailureDueToFault = 2;
  }

  enum ValveStateEnum : enum8 {
    kClosed = 0;
    kOpen = 1;
    kTransitioning = 2;
  }

  bitmap Feature : bitmap32 {
    kTimeSync = 0x1;
    kLevel = 0x2;
  }

  bitmap ValveFaultBitmap : bitmap16 {
    kGeneralFault = 0x1;
    kBlocked = 0x2;
    kLeaking = 0x4;
    kNotConnected = 0x8;
    kShortCircuit = 0x10;
    kCurrentExceeded = 0x20;
  }

  info event ValveStateChanged = 0 {
    ValveStateEnum valveState = 0;
    optional percent valveLevel = 1;
  }

  info event ValveFault = 1 {
    ValveFaultBitmap valveFault = 0;
  }

  readonly attribute nullable elapsed_s openDuration = 0;
  attribute nullable elapsed_s defaultOpenDuration = 1;
  readonly attribute optional nullable epoch_us autoCloseTime = 2;
  readonly attribute nullable elapsed_s remainingDuration = 3;
  readonly attribute nullable ValveStateEnum currentState = 4;
  readonly attribute nullable ValveStateEnum targetState = 5;
  readonly attribute optional nullable percent currentLevel = 6;
  readonly attribute optional nullable percent targetLevel = 7;
  attribute optional percent defaultOpenLevel = 8;
  readonly attribute optional ValveFaultBitmap valveFault = 9;
  readonly attribute optional int8u levelStep = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenRequest {
    optional nullable elapsed_s openDuration = 0;
    optional percent targetLevel = 1;
  }

  /** This command is used to set the valve to its open position. */
  command Open(OpenRequest): DefaultSuccess = 0;
  /** This command is used to set the valve to its closed position. */
  command Close(): DefaultSuccess = 1;
}

/** This cluster provides an interface to specify preferences for how devices should consume energy. */
provisional cluster EnergyPreference = 155 {
  revision 1;

  enum EnergyPriorityEnum : enum8 {
    kComfort = 0;
    kSpeed = 1;
    kEfficiency = 2;
    kWaterConsumption = 3;
  }

  bitmap Feature : bitmap32 {
    kEnergyBalance = 0x1;
    kLowPowerModeSensitivity = 0x2;
  }

  struct BalanceStruct {
    percent step = 0;
    optional char_string<64> label = 1;
  }

  readonly attribute optional BalanceStruct energyBalances[] = 0;
  attribute optional int8u currentEnergyBalance = 1;
  readonly attribute optional EnergyPriorityEnum energyPriorities[] = 2;
  readonly attribute optional BalanceStruct lowPowerModeSensitivities[] = 3;
  attribute optional int8u currentLowPowerModeSensitivity = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Provides an interface for controlling and adjusting automatic window coverings. */
cluster WindowCovering = 258 {
  revision 5;

  enum EndProductType : enum8 {
    kRollerShade = 0;
    kRomanShade = 1;
    kBalloonShade = 2;
    kWovenWood = 3;
    kPleatedShade = 4;
    kCellularShade = 5;
    kLayeredShade = 6;
    kLayeredShade2D = 7;
    kSheerShade = 8;
    kTiltOnlyInteriorBlind = 9;
    kInteriorBlind = 10;
    kVerticalBlindStripCurtain = 11;
    kInteriorVenetianBlind = 12;
    kExteriorVenetianBlind = 13;
    kLateralLeftCurtain = 14;
    kLateralRightCurtain = 15;
    kCentralCurtain = 16;
    kRollerShutter = 17;
    kExteriorVerticalScreen = 18;
    kAwningTerracePatio = 19;
    kAwningVerticalScreen = 20;
    kTiltOnlyPergola = 21;
    kSwingingShutter = 22;
    kSlidingShutter = 23;
    kUnknown = 255;
  }

  enum Type : enum8 {
    kRollerShade = 0;
    kRollerShade2Motor = 1;
    kRollerShadeExterior = 2;
    kRollerShadeExterior2Motor = 3;
    kDrapery = 4;
    kAwning = 5;
    kShutter = 6;
    kTiltBlindTiltOnly = 7;
    kTiltBlindLiftAndTilt = 8;
    kProjectorScreen = 9;
    kUnknown = 255;
  }

  bitmap ConfigStatus : bitmap8 {
    kOperational = 0x1;
    kOnlineReserved = 0x2;
    kLiftMovementReversed = 0x4;
    kLiftPositionAware = 0x8;
    kTiltPositionAware = 0x10;
    kLiftEncoderControlled = 0x20;
    kTiltEncoderControlled = 0x40;
  }

  bitmap Feature : bitmap32 {
    kLift = 0x1;
    kTilt = 0x2;
    kPositionAwareLift = 0x4;
    kAbsolutePosition = 0x8;
    kPositionAwareTilt = 0x10;
  }

  bitmap Mode : bitmap8 {
    kMotorDirectionReversed = 0x1;
    kCalibrationMode = 0x2;
    kMaintenanceMode = 0x4;
    kLedFeedback = 0x8;
  }

  bitmap OperationalStatus : bitmap8 {
    kGlobal = 0x3;
    kLift = 0xC;
    kTilt = 0x30;
  }

  bitmap SafetyStatus : bitmap16 {
    kRemoteLockout = 0x1;
    kTamperDetection = 0x2;
    kFailedCommunication = 0x4;
    kPositionFailure = 0x8;
    kThermalProtection = 0x10;
    kObstacleDetected = 0x20;
    kPower = 0x40;
    kStopInput = 0x80;
    kMotorJammed = 0x100;
    kHardwareFailure = 0x200;
    kManualOperation = 0x400;
    kProtection = 0x800;
  }

  readonly attribute Type type = 0;
  readonly attribute optional int16u physicalClosedLimitLift = 1;
  readonly attribute optional int16u physicalClosedLimitTilt = 2;
  readonly attribute optional nullable int16u currentPositionLift = 3;
  readonly attribute optional nullable int16u currentPositionTilt = 4;
  readonly attribute optional int16u numberOfActuationsLift = 5;
  readonly attribute optional int16u numberOfActuationsTilt = 6;
  readonly attribute ConfigStatus configStatus = 7;
  readonly attribute optional nullable percent currentPositionLiftPercentage = 8;
  readonly attribute optional nullable percent currentPositionTiltPercentage = 9;
  readonly attribute OperationalStatus operationalStatus = 10;
  readonly attribute optional nullable percent100ths targetPositionLiftPercent100ths = 11;
  readonly attribute optional nullable percent100ths targetPositionTiltPercent100ths = 12;
  readonly attribute EndProductType endProductType = 13;
  readonly attribute optional nullable percent100ths currentPositionLiftPercent100ths = 14;
  readonly attribute optional nullable percent100ths currentPositionTiltPercent100ths = 15;
  readonly attribute optional int16u installedOpenLimitLift = 16;
  readonly attribute optional int16u installedClosedLimitLift = 17;
  readonly attribute optional int16u installedOpenLimitTilt = 18;
  readonly attribute optional int16u installedClosedLimitTilt = 19;
  attribute access(write: manage) Mode mode = 23;
  readonly attribute optional SafetyStatus safetyStatus = 26;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GoToLiftValueRequest {
    int16u liftValue = 0;
  }

  request struct GoToLiftPercentageRequest {
    percent100ths liftPercent100thsValue = 0;
  }

  request struct GoToTiltValueRequest {
    int16u tiltValue = 0;
  }

  request struct GoToTiltPercentageRequest {
    percent100ths tiltPercent100thsValue = 0;
  }

  /** Moves window covering to InstalledOpenLimitLift and InstalledOpenLimitTilt */
  command UpOrOpen(): DefaultSuccess = 0;
  /** Moves window covering to InstalledClosedLimitLift and InstalledCloseLimitTilt */
  command DownOrClose(): DefaultSuccess = 1;
  /** Stop any adjusting of window covering */
  command StopMotion(): DefaultSuccess = 2;
  /** Go to lift value specified */
  command GoToLiftValue(GoToLiftValueRequest): DefaultSuccess = 4;
  /** Go to lift percentage specified */
  command GoToLiftPercentage(GoToLiftPercentageRequest): DefaultSuccess = 5;
  /** Go to tilt value specified */
  command GoToTiltValue(GoToTiltValueRequest): DefaultSuccess = 7;
  /** Go to tilt percentage specified */
  command GoToTiltPercentage(GoToTiltPercentageRequest): DefaultSuccess = 8;
}

/** An interface for configuring and controlling pumps. */
cluster PumpConfigurationAndControl = 512 {
  revision 4;

  enum ControlModeEnum : enum8 {
    kConstantSpeed = 0;
    kConstantPressure = 1;
    kProportionalPressure = 2;
    kConstantFlow = 3;
    kConstantTemperature = 5;
    kAutomatic = 7;
  }

  enum OperationModeEnum : enum8 {
    kNormal = 0;
    kMinimum = 1;
    kMaximum = 2;
    kLocal = 3;
  }

  bitmap Feature : bitmap32 {
    kConstantPressure = 0x1;
    kCompensatedPressure = 0x2;
    kConstantFlow = 0x4;
    kConstantSpeed = 0x8;
    kConstantTemperature = 0x10;
    kAutomatic = 0x20;
    kLocalOperation = 0x40;
  }

  bitmap PumpStatusBitmap : bitmap16 {
    kDeviceFault = 0x1;
    kSupplyFault = 0x2;
    kSpeedLow = 0x4;
    kSpeedHigh = 0x8;
    kLocalOverride = 0x10;
    kRunning = 0x20;
    kRemotePressure = 0x40;
    kRemoteFlow = 0x80;
    kRemoteTemperature = 0x100;
  }

  info event SupplyVoltageLow = 0 {
  }

  info event SupplyVoltageHigh = 1 {
  }

  info event PowerMissingPhase = 2 {
  }

  info event SystemPressureLow = 3 {
  }

  info event SystemPressureHigh = 4 {
  }

  critical event DryRunning = 5 {
  }

  info event MotorTemperatureHigh = 6 {
  }

  critical event PumpMotorFatalFailure = 7 {
  }

  info event ElectronicTemperatureHigh = 8 {
  }

  critical event PumpBlocked = 9 {
  }

  info event SensorFailure = 10 {
  }

  info event ElectronicNonFatalFailure = 11 {
  }

  critical event ElectronicFatalFailure = 12 {
  }

  info event GeneralFault = 13 {
  }

  info event Leakage = 14 {
  }

  info event AirDetection = 15 {
  }

  info event TurbineOperation = 16 {
  }

  readonly attribute nullable int16s maxPressure = 0;
  readonly attribute nullable int16u maxSpeed = 1;
  readonly attribute nullable int16u maxFlow = 2;
  readonly attribute optional nullable int16s minConstPressure = 3;
  readonly attribute optional nullable int16s maxConstPressure = 4;
  readonly attribute optional nullable int16s minCompPressure = 5;
  readonly attribute optional nullable int16s maxCompPressure = 6;
  readonly attribute optional nullable int16u minConstSpeed = 7;
  readonly attribute optional nullable int16u maxConstSpeed = 8;
  readonly attribute optional nullable int16u minConstFlow = 9;
  readonly attribute optional nullable int16u maxConstFlow = 10;
  readonly attribute optional nullable int16s minConstTemp = 11;
  readonly attribute optional nullable int16s maxConstTemp = 12;
  readonly attribute optional PumpStatusBitmap pumpStatus = 16;
  readonly attribute OperationModeEnum effectiveOperationMode = 17;
  readonly attribute ControlModeEnum effectiveControlMode = 18;
  readonly attribute nullable int16s capacity = 19;
  readonly attribute optional nullable int16u speed = 20;
  attribute access(write: manage) optional nullable int24u lifetimeRunningHours = 21;
  readonly attribute optional nullable int24u power = 22;
  attribute access(write: manage) optional nullable int32u lifetimeEnergyConsumed = 23;
  attribute access(write: manage) OperationModeEnum operationMode = 32;
  attribute access(write: manage) optional ControlModeEnum controlMode = 33;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** An interface for configuring and controlling the functionality of a thermostat. */
cluster Thermostat = 513 {
  revision 9;

  enum ACCapacityFormatEnum : enum8 {
    kBTUh = 0;
  }

  enum ACCompressorTypeEnum : enum8 {
    kUnknown = 0;
    kT1 = 1;
    kT2 = 2;
    kT3 = 3;
  }

  enum ACLouverPositionEnum : enum8 {
    kClosed = 1;
    kOpen = 2;
    kQuarter = 3;
    kHalf = 4;
    kThreeQuarters = 5;
  }

  enum ACRefrigerantTypeEnum : enum8 {
    kUnknown = 0;
    kR22 = 1;
    kR410a = 2;
    kR407c = 3;
  }

  enum ACTypeEnum : enum8 {
    kUnknown = 0;
    kCoolingFixed = 1;
    kHeatPumpFixed = 2;
    kCoolingInverter = 3;
    kHeatPumpInverter = 4;
  }

  enum ControlSequenceOfOperationEnum : enum8 {
    kCoolingOnly = 0;
    kCoolingWithReheat = 1;
    kHeatingOnly = 2;
    kHeatingWithReheat = 3;
    kCoolingAndHeating = 4;
    kCoolingAndHeatingWithReheat = 5;
  }

  enum PresetScenarioEnum : enum8 {
    kOccupied = 1;
    kUnoccupied = 2;
    kSleep = 3;
    kWake = 4;
    kVacation = 5;
    kGoingToSleep = 6;
    kUserDefined = 254;
  }

  enum SetpointChangeSourceEnum : enum8 {
    kManual = 0;
    kSchedule = 1;
    kExternal = 2;
  }

  enum SetpointRaiseLowerModeEnum : enum8 {
    kHeat = 0;
    kCool = 1;
    kBoth = 2;
  }

  enum StartOfWeekEnum : enum8 {
    kSunday = 0;
    kMonday = 1;
    kTuesday = 2;
    kWednesday = 3;
    kThursday = 4;
    kFriday = 5;
    kSaturday = 6;
  }

  enum SystemModeEnum : enum8 {
    kOff = 0;
    kAuto = 1;
    kCool = 3;
    kHeat = 4;
    kEmergencyHeat = 5;
    kPrecooling = 6;
    kFanOnly = 7;
    kDry = 8;
    kSleep = 9;
  }

  enum TemperatureSetpointHoldEnum : enum8 {
    kSetpointHoldOff = 0;
    kSetpointHoldOn = 1;
  }

  enum ThermostatRunningModeEnum : enum8 {
    kOff = 0;
    kCool = 3;
    kHeat = 4;
  }

  bitmap ACErrorCodeBitmap : bitmap32 {
    kCompressorFail = 0x1;
    kRoomSensorFail = 0x2;
    kOutdoorSensorFail = 0x4;
    kCoilSensorFail = 0x8;
    kFanFail = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHeating = 0x1;
    kCooling = 0x2;
    kOccupancy = 0x4;
    kScheduleConfiguration = 0x8;
    kSetback = 0x10;
    kAutoMode = 0x20;
    kLocalTemperatureNotExposed = 0x40;
    kMatterScheduleConfiguration = 0x80;
    kPresets = 0x100;
    kEvents = 0x200;
  }

  bitmap HVACSystemTypeBitmap : bitmap8 {
    kCoolingStage = 0x3;
    kHeatingStage = 0xC;
    kHeatingIsHeatPump = 0x10;
    kHeatingUsesFuel = 0x20;
  }

  bitmap OccupancyBitmap : bitmap8 {
    kOccupied = 0x1;
  }

  bitmap PresetTypeFeaturesBitmap : bitmap16 {
    kAutomatic = 0x1;
    kSupportsNames = 0x2;
  }

  bitmap ProgrammingOperationModeBitmap : bitmap8 {
    kScheduleActive = 0x1;
    kAutoRecovery = 0x2;
    kEconomy = 0x4;
  }

  bitmap RelayStateBitmap : bitmap16 {
    kHeat = 0x1;
    kCool = 0x2;
    kFan = 0x4;
    kHeatStage2 = 0x8;
    kCoolStage2 = 0x10;
    kFanStage2 = 0x20;
    kFanStage3 = 0x40;
  }

  bitmap RemoteSensingBitmap : bitmap8 {
    kLocalTemperature = 0x1;
    kOutdoorTemperature = 0x2;
    kOccupancy = 0x4;
  }

  bitmap ScheduleDayOfWeekBitmap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
    kAway = 0x80;
  }

  bitmap ScheduleModeBitmap : bitmap8 {
    kHeatSetpointPresent = 0x1;
    kCoolSetpointPresent = 0x2;
  }

  bitmap ScheduleTypeFeaturesBitmap : bitmap16 {
    kSupportsPresets = 0x1;
    kSupportsSetpoints = 0x2;
    kSupportsNames = 0x4;
    kSupportsOff = 0x8;
  }

  bitmap ThermostatSuggestionNotFollowingReasonBitmap : bitmap16 {
    kDemandResponseEvent = 0x1;
    kOngoingHold = 0x2;
    kSchedule = 0x4;
    kOccupancy = 0x8;
    kVacationMode = 0x10;
    kTimeOfUseCostSavings = 0x20;
    kPreCoolingOrPreHeating = 0x40;
  }

  struct ScheduleTransitionStruct {
    ScheduleDayOfWeekBitmap dayOfWeek = 0;
    int16u transitionTime = 1;
    optional octet_string<16> presetHandle = 2;
    optional SystemModeEnum systemMode = 3;
    optional temperature coolingSetpoint = 4;
    optional temperature heatingSetpoint = 5;
  }

  struct ScheduleStruct {
    nullable octet_string<16> scheduleHandle = 0;
    SystemModeEnum systemMode = 1;
    optional char_string<64> name = 2;
    optional octet_string<16> presetHandle = 3;
    ScheduleTransitionStruct transitions[] = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetStruct {
    nullable octet_string<16> presetHandle = 0;
    PresetScenarioEnum presetScenario = 1;
    optional nullable char_string<64> name = 2;
    optional temperature coolingSetpoint = 3;
    optional temperature heatingSetpoint = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetTypeStruct {
    PresetScenarioEnum presetScenario = 0;
    int8u numberOfPresets = 1;
    PresetTypeFeaturesBitmap presetTypeFeatures = 2;
  }

  struct ScheduleTypeStruct {
    SystemModeEnum systemMode = 0;
    int8u numberOfSchedules = 1;
    ScheduleTypeFeaturesBitmap scheduleTypeFeatures = 2;
  }

  struct ThermostatSuggestionStruct {
    int8u uniqueID = 0;
    octet_string<16> presetHandle = 1;
    epoch_s effectiveTime = 2;
    epoch_s expirationTime = 3;
  }

  struct WeeklyScheduleTransitionStruct {
    int16u transitionTime = 0;
    nullable temperature heatSetpoint = 1;
    nullable temperature coolSetpoint = 2;
  }

  info event SystemModeChange = 0 {
    optional SystemModeEnum previousSystemMode = 0;
    SystemModeEnum currentSystemMode = 1;
  }

  info event LocalTemperatureChange = 1 {
    nullable temperature currentLocalTemperature = 0;
  }

  info event OccupancyChange = 2 {
    optional OccupancyBitmap previousOccupancy = 0;
    OccupancyBitmap currentOccupancy = 1;
  }

  info event SetpointChange = 3 {
    SystemModeEnum systemMode = 0;
    optional OccupancyBitmap occupancy = 1;
    optional temperature previousSetpoint = 2;
    temperature currentSetpoint = 3;
  }

  info event RunningStateChange = 4 {
    optional RelayStateBitmap previousRunningState = 0;
    RelayStateBitmap currentRunningState = 1;
  }

  info event RunningModeChange = 5 {
    optional ThermostatRunningModeEnum previousRunningMode = 0;
    ThermostatRunningModeEnum currentRunningMode = 1;
  }

  info event ActiveScheduleChange = 6 {
    optional nullable octet_string previousScheduleHandle = 0;
    nullable octet_string currentScheduleHandle = 1;
  }

  info event ActivePresetChange = 7 {
    optional nullable octet_string previousPresetHandle = 0;
    nullable octet_string currentPresetHandle = 1;
  }

  readonly attribute nullable temperature localTemperature = 0;
  readonly attribute optional nullable temperature outdoorTemperature = 1;
  readonly attribute optional OccupancyBitmap occupancy = 2;
  readonly attribute optional temperature absMinHeatSetpointLimit = 3;
  readonly attribute optional temperature absMaxHeatSetpointLimit = 4;
  readonly attribute optional temperature absMinCoolSetpointLimit = 5;
  readonly attribute optional temperature absMaxCoolSetpointLimit = 6;
  readonly attribute optional int8u PICoolingDemand = 7;
  readonly attribute optional int8u PIHeatingDemand = 8;
  attribute access(write: manage) optional HVACSystemTypeBitmap HVACSystemTypeConfiguration = 9;
  attribute access(write: manage) optional int8s localTemperatureCalibration = 16;
  attribute optional temperature occupiedCoolingSetpoint = 17;
  attribute optional temperature occupiedHeatingSetpoint = 18;
  attribute optional temperature unoccupiedCoolingSetpoint = 19;
  attribute optional temperature unoccupiedHeatingSetpoint = 20;
  attribute access(write: manage) optional temperature minHeatSetpointLimit = 21;
  attribute access(write: manage) optional temperature maxHeatSetpointLimit = 22;
  attribute access(write: manage) optional temperature minCoolSetpointLimit = 23;
  attribute access(write: manage) optional temperature maxCoolSetpointLimit = 24;
  attribute access(write: manage) optional int8s minSetpointDeadBand = 25;
  attribute access(write: manage) optional RemoteSensingBitmap remoteSensing = 26;
  attribute access(write: manage) ControlSequenceOfOperationEnum controlSequenceOfOperation = 27;
  attribute access(write: manage) SystemModeEnum systemMode = 28;
  readonly attribute optional ThermostatRunningModeEnum thermostatRunningMode = 30;
  readonly attribute optional StartOfWeekEnum startOfWeek = 32;
  readonly attribute optional int8u numberOfWeeklyTransitions = 33;
  readonly attribute optional int8u numberOfDailyTransitions = 34;
  attribute access(write: manage) optional TemperatureSetpointHoldEnum temperatureSetpointHold = 35;
  attribute access(write: manage) optional nullable int16u temperatureSetpointHoldDuration = 36;
  attribute access(write: manage) optional ProgrammingOperationModeBitmap thermostatProgrammingOperationMode = 37;
  readonly attribute optional RelayStateBitmap thermostatRunningState = 41;
  readonly attribute optional SetpointChangeSourceEnum setpointChangeSource = 48;
  readonly attribute optional nullable int16s setpointChangeAmount = 49;
  readonly attribute optional epoch_s setpointChangeSourceTimestamp = 50;
  attribute access(write: manage) optional nullable int8u occupiedSetback = 52;
  readonly attribute optional nullable int8u occupiedSetbackMin = 53;
  readonly attribute optional nullable int8u occupiedSetbackMax = 54;
  attribute access(write: manage) optional nullable int8u unoccupiedSetback = 55;
  readonly attribute optional nullable int8u unoccupiedSetbackMin = 56;
  readonly attribute optional nullable int8u unoccupiedSetbackMax = 57;
  attribute access(write: manage) optional int8u emergencyHeatDelta = 58;
  attribute access(write: manage) optional ACTypeEnum ACType = 64;
  attribute access(write: manage) optional int16u ACCapacity = 65;
  attribute access(write: manage) optional ACRefrigerantTypeEnum ACRefrigerantType = 66;
  attribute access(write: manage) optional ACCompressorTypeEnum ACCompressorType = 67;
  attribute access(write: manage) optional ACErrorCodeBitmap ACErrorCode = 68;
  attribute access(write: manage) optional ACLouverPositionEnum ACLouverPosition = 69;
  readonly attribute optional nullable temperature ACCoilTemperature = 70;
  attribute access(write: manage) optional ACCapacityFormatEnum ACCapacityformat = 71;
  readonly attribute optional PresetTypeStruct presetTypes[] = 72;
  readonly attribute optional ScheduleTypeStruct scheduleTypes[] = 73;
  readonly attribute optional int8u numberOfPresets = 74;
  readonly attribute optional int8u numberOfSchedules = 75;
  readonly attribute optional int8u numberOfScheduleTransitions = 76;
  readonly attribute optional nullable int8u numberOfScheduleTransitionPerDay = 77;
  readonly attribute optional nullable octet_string<16> activePresetHandle = 78;
  readonly attribute optional nullable octet_string<16> activeScheduleHandle = 79;
  attribute access(write: manage) optional PresetStruct presets[] = 80;
  attribute access(write: manage) optional ScheduleStruct schedules[] = 81;
  readonly attribute optional nullable epoch_s setpointHoldExpiryTimestamp = 82;
  provisional readonly attribute optional int8u maxThermostatSuggestions = 83;
  provisional readonly attribute optional ThermostatSuggestionStruct thermostatSuggestions[] = 84;
  provisional readonly attribute optional nullable ThermostatSuggestionStruct currentThermostatSuggestion = 85;
  provisional readonly attribute optional nullable ThermostatSuggestionNotFollowingReasonBitmap thermostatSuggestionNotFollowingReason = 86;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetpointRaiseLowerRequest {
    SetpointRaiseLowerModeEnum mode = 0;
    int8s amount = 1;
  }

  response struct GetWeeklyScheduleResponse = 0 {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct SetWeeklyScheduleRequest {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct GetWeeklyScheduleRequest {
    ScheduleDayOfWeekBitmap daysToReturn = 0;
    ScheduleModeBitmap modeToReturn = 1;
  }

  response struct AddThermostatSuggestionResponse = 2 {
    int8u uniqueID = 0;
  }

  request struct SetActiveScheduleRequestRequest {
    octet_string<16> scheduleHandle = 0;
  }

  request struct SetActivePresetRequestRequest {
    nullable octet_string<16> presetHandle = 0;
  }

  request struct AddThermostatSuggestionRequest {
    octet_string<16> presetHandle = 0;
    nullable epoch_s effectiveTime = 1;
    int16u expirationInMinutes = 2;
  }

  request struct RemoveThermostatSuggestionRequest {
    int8u uniqueID = 0;
  }

  response struct AtomicResponse = 253 {
    status statusCode = 0;
    AtomicAttributeStatusStruct attributeStatus[] = 1;
    optional int16u timeout = 2;
  }

  request struct AtomicRequestRequest {
    AtomicRequestTypeEnum requestType = 0;
    attrib_id attributeRequests[] = 1;
    optional int16u timeout = 2;
  }

  /** Upon receipt, the attributes for the indicated setpoint(s) SHALL have the amount specified in the Amount field added to them. */
  command SetpointRaiseLower(SetpointRaiseLowerRequest): DefaultSuccess = 0;
  /** This command is used to update the thermostat weekly setpoint schedule from a management system. */
  command access(invoke: manage) SetWeeklySchedule(SetWeeklyScheduleRequest): DefaultSuccess = 1;
  /** The Current Weekly Schedule Command is sent from the server in response to the Get Weekly Schedule Command. */
  command GetWeeklySchedule(GetWeeklyScheduleRequest): GetWeeklyScheduleResponse = 2;
  /** This command is used to clear the weekly schedule. */
  command access(invoke: manage) ClearWeeklySchedule(): DefaultSuccess = 3;
  /** Upon receipt, if the Schedules attribute contains a ScheduleStruct whose ScheduleHandle field matches the value of the ScheduleHandle field, the server SHALL set the thermostat's ActiveScheduleHandle attribute to the value of the ScheduleHandle field. */
  command SetActiveScheduleRequest(SetActiveScheduleRequestRequest): DefaultSuccess = 5;
  /** ID */
  command SetActivePresetRequest(SetActivePresetRequestRequest): DefaultSuccess = 6;
  command access(invoke: manage) AddThermostatSuggestion(AddThermostatSuggestionRequest): AddThermostatSuggestionResponse = 7;
  command access(invoke: manage) RemoveThermostatSuggestion(RemoveThermostatSuggestionRequest): DefaultSuccess = 8;
  /** Begins, Commits or Cancels an atomic write */
  command access(invoke: manage) AtomicRequest(AtomicRequestRequest): AtomicResponse = 254;
}

/** An interface for controlling a fan in a heating/cooling system. */
cluster FanControl = 514 {
  revision 5;

  enum AirflowDirectionEnum : enum8 {
    kForward = 0;
    kReverse = 1;
  }

  enum FanModeEnum : enum8 {
    kOff = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kOn = 4;
    kAuto = 5;
    kSmart = 6;
  }

  enum FanModeSequenceEnum : enum8 {
    kOffLowMedHigh = 0;
    kOffLowHigh = 1;
    kOffLowMedHighAuto = 2;
    kOffLowHighAuto = 3;
    kOffHighAuto = 4;
    kOffHigh = 5;
  }

  enum StepDirectionEnum : enum8 {
    kIncrease = 0;
    kDecrease = 1;
  }

  bitmap Feature : bitmap32 {
    kMultiSpeed = 0x1;
    kAuto = 0x2;
    kRocking = 0x4;
    kWind = 0x8;
    kStep = 0x10;
    kAirflowDirection = 0x20;
  }

  bitmap RockBitmap : bitmap8 {
    kRockLeftRight = 0x1;
    kRockUpDown = 0x2;
    kRockRound = 0x4;
  }

  bitmap WindBitmap : bitmap8 {
    kSleepWind = 0x1;
    kNaturalWind = 0x2;
  }

  attribute FanModeEnum fanMode = 0;
  readonly attribute FanModeSequenceEnum fanModeSequence = 1;
  attribute nullable percent percentSetting = 2;
  readonly attribute percent percentCurrent = 3;
  readonly attribute optional int8u speedMax = 4;
  attribute optional nullable int8u speedSetting = 5;
  readonly attribute optional int8u speedCurrent = 6;
  readonly attribute optional RockBitmap rockSupport = 7;
  attribute optional RockBitmap rockSetting = 8;
  readonly attribute optional WindBitmap windSupport = 9;
  attribute optional WindBitmap windSetting = 10;
  attribute optional AirflowDirectionEnum airflowDirection = 11;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct StepRequest {
    StepDirectionEnum direction = 0;
    optional boolean wrap = 1;
    optional boolean lowestOff = 2;
  }

  /** This command speeds up or slows down the fan, in steps, without a client having to know the fan speed. */
  command Step(StepRequest): DefaultSuccess = 0;
}

/** An interface for configuring the user interface of a thermostat (which may be remote from the thermostat). */
cluster ThermostatUserInterfaceConfiguration = 516 {
  revision 2;

  enum KeypadLockoutEnum : enum8 {
    kNoLockout = 0;
    kLockout1 = 1;
    kLockout2 = 2;
    kLockout3 = 3;
    kLockout4 = 4;
    kLockout5 = 5;
  }

  enum ScheduleProgrammingVisibilityEnum : enum8 {
    kScheduleProgrammingPermitted = 0;
    kScheduleProgrammingDenied = 1;
  }

  enum TemperatureDisplayModeEnum : enum8 {
    kCelsius = 0;
    kFahrenheit = 1;
  }

  attribute TemperatureDisplayModeEnum temperatureDisplayMode = 0;
  attribute access(write: manage) KeypadLockoutEnum keypadLockout = 1;
  attribute access(write: manage) optional ScheduleProgrammingVisibilityEnum scheduleProgrammingVisibility = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for controlling the color properties of a color-capable light. */
cluster ColorControl = 768 {
  revision 7;

  enum ColorLoopActionEnum : enum8 {
    kDeactivate = 0;
    kActivateFromColorLoopStartEnhancedHue = 1;
    kActivateFromEnhancedCurrentHue = 2;
  }

  enum ColorLoopDirectionEnum : enum8 {
    kDecrement = 0;
    kIncrement = 1;
  }

  enum ColorModeEnum : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperatureMireds = 2;
  }

  enum DirectionEnum : enum8 {
    kShortest = 0;
    kLongest = 1;
    kUp = 2;
    kDown = 3;
  }

  enum DriftCompensationEnum : enum8 {
    kNone = 0;
    kOtherOrUnknown = 1;
    kTemperatureMonitoring = 2;
    kOpticalLuminanceMonitoringAndFeedback = 3;
    kOpticalColorMonitoringAndFeedback = 4;
  }

  enum EnhancedColorModeEnum : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperatureMireds = 2;
    kEnhancedCurrentHueAndCurrentSaturation = 3;
  }

  enum MoveModeEnum : enum8 {
    kStop = 0;
    kUp = 1;
    kDown = 3;
  }

  enum StepModeEnum : enum8 {
    kUp = 1;
    kDown = 3;
  }

  bitmap ColorCapabilitiesBitmap : bitmap16 {
    kHueSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8 [spec_name = "XY"];
    kColorTemperature = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHueAndSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8 [spec_name = "XY"];
    kColorTemperature = 0x10;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
  }

  bitmap UpdateFlagsBitmap : bitmap8 {
    kUpdateAction = 0x1;
    kUpdateDirection = 0x2;
    kUpdateTime = 0x4;
    kUpdateStartHue = 0x8;
  }

  readonly attribute optional int8u currentHue = 0;
  readonly attribute optional int8u currentSaturation = 1;
  readonly attribute optional int16u remainingTime = 2;
  readonly attribute optional int16u currentX = 3;
  readonly attribute optional int16u currentY = 4;
  readonly attribute optional DriftCompensationEnum driftCompensation = 5;
  readonly attribute optional char_string<254> compensationText = 6;
  readonly attribute optional int16u colorTemperatureMireds = 7;
  readonly attribute ColorModeEnum colorMode = 8;
  attribute OptionsBitmap options = 15;
  readonly attribute nullable int8u numberOfPrimaries = 16;
  readonly attribute optional int16u primary1X = 17;
  readonly attribute optional int16u primary1Y = 18;
  readonly attribute optional nullable int8u primary1Intensity = 19;
  readonly attribute optional int16u primary2X = 21;
  readonly attribute optional int16u primary2Y = 22;
  readonly attribute optional nullable int8u primary2Intensity = 23;
  readonly attribute optional int16u primary3X = 25;
  readonly attribute optional int16u primary3Y = 26;
  readonly attribute optional nullable int8u primary3Intensity = 27;
  readonly attribute optional int16u primary4X = 32;
  readonly attribute optional int16u primary4Y = 33;
  readonly attribute optional nullable int8u primary4Intensity = 34;
  readonly attribute optional int16u primary5X = 36;
  readonly attribute optional int16u primary5Y = 37;
  readonly attribute optional nullable int8u primary5Intensity = 38;
  readonly attribute optional int16u primary6X = 40;
  readonly attribute optional int16u primary6Y = 41;
  readonly attribute optional nullable int8u primary6Intensity = 42;
  readonly attribute optional int16u whitePointX = 48;
  readonly attribute optional int16u whitePointY = 49;
  readonly attribute optional int16u colorPointRX = 50;
  readonly attribute optional int16u colorPointRY = 51;
  readonly attribute optional nullable int8u colorPointRIntensity = 52;
  readonly attribute optional int16u colorPointGX = 54;
  readonly attribute optional int16u colorPointGY = 55;
  readonly attribute optional nullable int8u colorPointGIntensity = 56;
  readonly attribute optional int16u colorPointBX = 58;
  readonly attribute optional int16u colorPointBY = 59;
  readonly attribute optional nullable int8u colorPointBIntensity = 60;
  readonly attribute optional int16u enhancedCurrentHue = 16384;
  readonly attribute EnhancedColorModeEnum enhancedColorMode = 16385;
  readonly attribute optional int8u colorLoopActive = 16386;
  readonly attribute optional int8u colorLoopDirection = 16387;
  readonly attribute optional int16u colorLoopTime = 16388;
  readonly attribute optional int16u colorLoopStartEnhancedHue = 16389;
  readonly attribute optional int16u colorLoopStoredEnhancedHue = 16390;
  readonly attribute ColorCapabilitiesBitmap colorCapabilities = 16394;
  readonly attribute optional int16u colorTempPhysicalMinMireds = 16395;
  readonly attribute optional int16u colorTempPhysicalMaxMireds = 16396;
  readonly attribute optional int16u coupleColorTempToLevelMinMireds = 16397;
  attribute access(write: manage) optional nullable int16u startUpColorTemperatureMireds = 16400;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToHueRequest {
    int8u hue = 0;
    DirectionEnum direction = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveHueRequest {
    MoveModeEnum moveMode = 0;
    int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepHueRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToSaturationRequest {
    int8u saturation = 0;
    int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveSaturationRequest {
    MoveModeEnum moveMode = 0;
    int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepSaturationRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToHueAndSaturationRequest {
    int8u hue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToColorRequest {
    int16u colorX = 0;
    int16u colorY = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveColorRequest {
    int16s rateX = 0;
    int16s rateY = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepColorRequest {
    int16s stepX = 0;
    int16s stepY = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToColorTemperatureRequest {
    int16u colorTemperatureMireds = 0;
    int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct EnhancedMoveToHueRequest {
    int16u enhancedHue = 0;
    DirectionEnum direction = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct EnhancedMoveHueRequest {
    MoveModeEnum moveMode = 0;
    int16u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct EnhancedStepHueRequest {
    StepModeEnum stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct EnhancedMoveToHueAndSaturationRequest {
    int16u enhancedHue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct ColorLoopSetRequest {
    UpdateFlagsBitmap updateFlags = 0;
    ColorLoopActionEnum action = 1;
    ColorLoopDirectionEnum direction = 2;
    int16u time = 3;
    int16u startHue = 4;
    OptionsBitmap optionsMask = 5;
    OptionsBitmap optionsOverride = 6;
  }

  request struct StopMoveStepRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveColorTemperatureRequest {
    MoveModeEnum moveMode = 0;
    int16u rate = 1;
    int16u colorTemperatureMinimumMireds = 2;
    int16u colorTemperatureMaximumMireds = 3;
    OptionsBitmap optionsMask = 4;
    OptionsBitmap optionsOverride = 5;
  }

  request struct StepColorTemperatureRequest {
    StepModeEnum stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    int16u colorTemperatureMinimumMireds = 3;
    int16u colorTemperatureMaximumMireds = 4;
    OptionsBitmap optionsMask = 5;
    OptionsBitmap optionsOverride = 6;
  }

  /** Move to specified hue. */
  command MoveToHue(MoveToHueRequest): DefaultSuccess = 0;
  /** Move hue up or down at specified rate. */
  command MoveHue(MoveHueRequest): DefaultSuccess = 1;
  /** Step hue up or down by specified size at specified rate. */
  command StepHue(StepHueRequest): DefaultSuccess = 2;
  /** Move to specified saturation. */
  command MoveToSaturation(MoveToSaturationRequest): DefaultSuccess = 3;
  /** Move saturation up or down at specified rate. */
  command MoveSaturation(MoveSaturationRequest): DefaultSuccess = 4;
  /** Step saturation up or down by specified size at specified rate. */
  command StepSaturation(StepSaturationRequest): DefaultSuccess = 5;
  /** Move to hue and saturation. */
  command MoveToHueAndSaturation(MoveToHueAndSaturationRequest): DefaultSuccess = 6;
  /** Move to specified color. */
  command MoveToColor(MoveToColorRequest): DefaultSuccess = 7;
  /** Moves the color. */
  command MoveColor(MoveColorRequest): DefaultSuccess = 8;
  /** Steps the lighting to a specific color. */
  command StepColor(StepColorRequest): DefaultSuccess = 9;
  /** Move to a specific color temperature. */
  command MoveToColorTemperature(MoveToColorTemperatureRequest): DefaultSuccess = 10;
  /** Command description for EnhancedMoveToHue */
  command EnhancedMoveToHue(EnhancedMoveToHueRequest): DefaultSuccess = 64;
  /** Command description for EnhancedMoveHue */
  command EnhancedMoveHue(EnhancedMoveHueRequest): DefaultSuccess = 65;
  /** Command description for EnhancedStepHue */
  command EnhancedStepHue(EnhancedStepHueRequest): DefaultSuccess = 66;
  /** Command description for EnhancedMoveToHueAndSaturation */
  command EnhancedMoveToHueAndSaturation(EnhancedMoveToHueAndSaturationRequest): DefaultSuccess = 67;
  /** Command description for ColorLoopSet */
  command ColorLoopSet(ColorLoopSetRequest): DefaultSuccess = 68;
  /** Command description for StopMoveStep */
  command StopMoveStep(StopMoveStepRequest): DefaultSuccess = 71;
  /** Command description for MoveColorTemperature */
  command MoveColorTemperature(MoveColorTemperatureRequest): DefaultSuccess = 75;
  /** Command description for StepColorTemperature */
  command StepColorTemperature(StepColorTemperatureRequest): DefaultSuccess = 76;
}

/** Attributes and commands for configuring a lighting ballast. */
provisional cluster BallastConfiguration = 769 {
  revision 4;

  bitmap BallastStatusBitmap : bitmap8 {
    kBallastNonOperational = 0x1;
    kLampFailure = 0x2;
  }

  bitmap LampAlarmModeBitmap : bitmap8 {
    kLampBurnHours = 0x1;
  }

  readonly attribute int8u physicalMinLevel = 0;
  readonly attribute int8u physicalMaxLevel = 1;
  readonly attribute optional BallastStatusBitmap ballastStatus = 2;
  attribute access(write: manage) int8u minLevel = 16;
  attribute access(write: manage) int8u maxLevel = 17;
  attribute access(write: manage) optional nullable int8u intrinsicBallastFactor = 20;
  attribute access(write: manage) optional nullable int8u ballastFactorAdjustment = 21;
  readonly attribute int8u lampQuantity = 32;
  attribute access(write: manage) optional char_string<16> lampType = 48;
  attribute access(write: manage) optional char_string<16> lampManufacturer = 49;
  attribute access(write: manage) optional nullable int24u lampRatedHours = 50;
  attribute access(write: manage) optional nullable int24u lampBurnHours = 51;
  attribute access(write: manage) optional LampAlarmModeBitmap lampAlarmMode = 52;
  attribute access(write: manage) optional nullable int24u lampBurnHoursTripPoint = 53;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of illuminance, and reporting illuminance measurements. */
cluster IlluminanceMeasurement = 1024 {
  revision 3;

  enum LightSensorTypeEnum : enum8 {
    kPhotodiode = 0;
    kCMOS = 1 [spec_name = "CMOS"];
  }

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable LightSensorTypeEnum lightSensorType = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of temperature, and reporting temperature measurements. */
cluster TemperatureMeasurement = 1026 {
  revision 4;

  readonly attribute nullable temperature measuredValue = 0;
  readonly attribute nullable temperature minMeasuredValue = 1;
  readonly attribute nullable temperature maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of pressure, and reporting pressure measurements. */
cluster PressureMeasurement = 1027 {
  revision 3;

  bitmap Feature : bitmap32 {
    kExtended = 0x1;
  }

  readonly attribute nullable int16s measuredValue = 0;
  readonly attribute nullable int16s minMeasuredValue = 1;
  readonly attribute nullable int16s maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable int16s scaledValue = 16;
  readonly attribute optional nullable int16s minScaledValue = 17;
  readonly attribute optional nullable int16s maxScaledValue = 18;
  readonly attribute optional int16u scaledTolerance = 19;
  readonly attribute optional int8s scale = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of flow, and reporting flow measurements. */
cluster FlowMeasurement = 1028 {
  revision 3;

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of relative humidity, and reporting relative humidity measurements. */
cluster RelativeHumidityMeasurement = 1029 {
  revision 3;

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The server cluster provides an interface to occupancy sensing functionality based on one or more sensing modalities, including configuration and provision of notifications of occupancy status. */
cluster OccupancySensing = 1030 {
  revision 5;

  enum OccupancySensorTypeEnum : enum8 {
    kPIR = 0 [spec_name = "PIR"];
    kUltrasonic = 1;
    kPIRAndUltrasonic = 2;
    kPhysicalContact = 3;
  }

  bitmap Feature : bitmap32 {
    kOther = 0x1;
    kPassiveInfrared = 0x2;
    kUltrasonic = 0x4;
    kPhysicalContact = 0x8;
    kActiveInfrared = 0x10;
    kRadar = 0x20;
    kRFSensing = 0x40;
    kVision = 0x80;
  }

  bitmap OccupancyBitmap : bitmap8 {
    kOccupied = 0x1;
  }

  bitmap OccupancySensorTypeBitmap : bitmap8 {
    kPIR = 0x1 [spec_name = "PIR"];
    kUltrasonic = 0x2;
    kPhysicalContact = 0x4;
  }

  struct HoldTimeLimitsStruct {
    int16u holdTimeMin = 0;
    int16u holdTimeMax = 1;
    int16u holdTimeDefault = 2;
  }

  info event OccupancyChanged = 0 {
    OccupancyBitmap occupancy = 0;
  }

  readonly attribute OccupancyBitmap occupancy = 0;
  readonly attribute OccupancySensorTypeEnum occupancySensorType = 1;
  readonly attribute OccupancySensorTypeBitmap occupancySensorTypeBitmap = 2;
  attribute access(write: manage) optional int16u holdTime = 3;
  readonly attribute optional HoldTimeLimitsStruct holdTimeLimits = 4;
  attribute access(write: manage) optional int16u PIROccupiedToUnoccupiedDelay = 16;
  attribute access(write: manage) optional int16u PIRUnoccupiedToOccupiedDelay = 17;
  attribute access(write: manage) optional int8u PIRUnoccupiedToOccupiedThreshold = 18;
  attribute access(write: manage) optional int16u ultrasonicOccupiedToUnoccupiedDelay = 32;
  attribute access(write: manage) optional int16u ultrasonicUnoccupiedToOccupiedDelay = 33;
  attribute access(write: manage) optional int8u ultrasonicUnoccupiedToOccupiedThreshold = 34;
  attribute access(write: manage) optional int16u physicalContactOccupiedToUnoccupiedDelay = 48;
  attribute access(write: manage) optional int16u physicalContactUnoccupiedToOccupiedDelay = 49;
  attribute access(write: manage) optional int8u physicalContactUnoccupiedToOccupiedThreshold = 50;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting carbon monoxide concentration measurements */
cluster CarbonMonoxideConcentrationMeasurement = 1036 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting carbon dioxide concentration measurements */
cluster CarbonDioxideConcentrationMeasurement = 1037 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting nitrogen dioxide concentration measurements */
cluster NitrogenDioxideConcentrationMeasurement = 1043 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting ozone concentration measurements */
cluster OzoneConcentrationMeasurement = 1045 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM2.5 concentration measurements */
cluster Pm25ConcentrationMeasurement = 1066 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting formaldehyde concentration measurements */
cluster FormaldehydeConcentrationMeasurement = 1067 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM1 concentration measurements */
cluster Pm1ConcentrationMeasurement = 1068 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM10 concentration measurements */
cluster Pm10ConcentrationMeasurement = 1069 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting total volatile organic compounds concentration measurements */
cluster TotalVolatileOrganicCompoundsConcentrationMeasurement = 1070 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting radon concentration measurements */
cluster RadonConcentrationMeasurement = 1071 {
  revision 3;

  shared enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  shared enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  shared enum MeasurementUnitEnum : enum8 {
    kPPM = 0 [spec_name = "PPM"];
    kPPB = 1 [spec_name = "PPB"];
    kPPT = 2 [spec_name = "PPT"];
    kMGM3 = 3 [spec_name = "MGM3"];
    kUGM3 = 4 [spec_name = "UGM3"];
    kNGM3 = 5 [spec_name = "NGM3"];
    kPM3 = 6 [spec_name = "PM3"];
    kBQM3 = 7 [spec_name = "BQM3"];
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface to soil measurement functionality, including configuration and provision of notifications of soil measurements. */
provisional cluster SoilMeasurement = 1072 {
  revision 1;

  readonly attribute MeasurementAccuracyStruct soilMoistureMeasurementLimits = 0;
  readonly attribute nullable percent soilMoistureMeasuredValue = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for managing low power mode on a device that supports the Wake On LAN protocol. */
cluster WakeOnLan = 1283 {
  revision 1;

  readonly attribute optional char_string<12> MACAddress = 0;
  provisional readonly attribute optional octet_string<16> linkLocalAddress = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for managing low power mode on a device. */
cluster LowPower = 1288 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command shall put the device into low power mode. */
  command Sleep(): DefaultSuccess = 0;
}

/** The Camera AV Stream Management cluster is used to allow clients to manage, control, and configure various audio, video, and snapshot streams on a camera. */
provisional cluster CameraAvStreamManagement = 1361 {
  revision 1;

  enum AudioCodecEnum : enum8 {
    kOPUS = 0 [spec_name = "OPUS"];
    kAACLC = 1 [spec_name = "AAC-LC"];
  }

  enum ImageCodecEnum : enum8 {
    kJPEG = 0 [spec_name = "JPEG"];
  }

  enum TriStateAutoEnum : enum8 {
    kOff = 0;
    kOn = 1;
    kAuto = 2;
  }

  enum TwoWayTalkSupportTypeEnum : enum8 {
    kNotSupported = 0;
    kHalfDuplex = 1;
    kFullDuplex = 2;
  }

  enum VideoCodecEnum : enum8 {
    kH264 = 0;
    kHEVC = 1 [spec_name = "HEVC"];
    kVVC = 2 [spec_name = "VVC"];
    kAV1 = 3 [spec_name = "AV1"];
  }

  bitmap Feature : bitmap32 {
    kAudio = 0x1;
    kVideo = 0x2;
    kSnapshot = 0x4;
    kPrivacy = 0x8;
    kSpeaker = 0x10;
    kImageControl = 0x20;
    kWatermark = 0x40;
    kOnScreenDisplay = 0x80;
    kLocalStorage = 0x100;
    kHighDynamicRange = 0x200;
    kNightVision = 0x400;
  }

  struct VideoResolutionStruct {
    int16u width = 0;
    int16u height = 1;
  }

  struct VideoStreamStruct {
    int16u videoStreamID = 0;
    StreamUsageEnum streamUsage = 1;
    VideoCodecEnum videoCodec = 2;
    int16u minFrameRate = 3;
    int16u maxFrameRate = 4;
    VideoResolutionStruct minResolution = 5;
    VideoResolutionStruct maxResolution = 6;
    int32u minBitRate = 7;
    int32u maxBitRate = 8;
    int16u keyFrameInterval = 9;
    optional boolean watermarkEnabled = 10;
    optional boolean OSDEnabled = 11;
    int8u referenceCount = 12;
  }

  struct SnapshotStreamStruct {
    int16u snapshotStreamID = 0;
    ImageCodecEnum imageCodec = 1;
    int16u frameRate = 2;
    VideoResolutionStruct minResolution = 3;
    VideoResolutionStruct maxResolution = 4;
    int8u quality = 5;
    int8u referenceCount = 6;
    boolean encodedPixels = 7;
    boolean hardwareEncoder = 8;
    optional boolean watermarkEnabled = 9;
    optional boolean OSDEnabled = 10;
  }

  struct SnapshotCapabilitiesStruct {
    VideoResolutionStruct resolution = 0;
    int16u maxFrameRate = 1;
    ImageCodecEnum imageCodec = 2;
    boolean requiresEncodedPixels = 3;
    optional boolean requiresHardwareEncoder = 4;
  }

  struct RateDistortionTradeOffPointsStruct {
    VideoCodecEnum codec = 0;
    VideoResolutionStruct resolution = 1;
    int32u minBitRate = 2;
  }

  struct AudioCapabilitiesStruct {
    int8u maxNumberOfChannels = 0;
    AudioCodecEnum supportedCodecs[] = 1;
    int32u supportedSampleRates[] = 2;
    int8u supportedBitDepths[] = 3;
  }

  struct AudioStreamStruct {
    int16u audioStreamID = 0;
    StreamUsageEnum streamUsage = 1;
    AudioCodecEnum audioCodec = 2;
    int8u channelCount = 3;
    int32u sampleRate = 4;
    int32u bitRate = 5;
    int8u bitDepth = 6;
    int8u referenceCount = 7;
  }

  struct VideoSensorParamsStruct {
    int16u sensorWidth = 0;
    int16u sensorHeight = 1;
    int16u maxFPS = 2;
    optional int16u maxHDRFPS = 3;
  }

  readonly attribute optional int8u maxConcurrentEncoders = 0;
  readonly attribute optional int32u maxEncodedPixelRate = 1;
  readonly attribute optional VideoSensorParamsStruct videoSensorParams = 2;
  readonly attribute optional boolean nightVisionUsesInfrared = 3;
  readonly attribute optional VideoResolutionStruct minViewportResolution = 4;
  readonly attribute optional RateDistortionTradeOffPointsStruct rateDistortionTradeOffPoints[] = 5;
  readonly attribute int32u maxContentBufferSize = 6;
  readonly attribute optional AudioCapabilitiesStruct microphoneCapabilities = 7;
  readonly attribute optional AudioCapabilitiesStruct speakerCapabilities = 8;
  readonly attribute optional TwoWayTalkSupportTypeEnum twoWayTalkSupport = 9;
  readonly attribute optional SnapshotCapabilitiesStruct snapshotCapabilities[] = 10;
  readonly attribute int32u maxNetworkBandwidth = 11;
  readonly attribute optional int16u currentFrameRate = 12;
  attribute access(read: manage, write: manage) optional boolean HDRModeEnabled = 13;
  readonly attribute StreamUsageEnum supportedStreamUsages[] = 14;
  readonly attribute optional VideoStreamStruct allocatedVideoStreams[] = 15;
  readonly attribute optional AudioStreamStruct allocatedAudioStreams[] = 16;
  readonly attribute optional SnapshotStreamStruct allocatedSnapshotStreams[] = 17;
  readonly attribute StreamUsageEnum streamUsagePriorities[] = 18;
  attribute optional boolean softRecordingPrivacyModeEnabled = 19;
  attribute optional boolean softLivestreamPrivacyModeEnabled = 20;
  readonly attribute optional boolean hardPrivacyModeOn = 21;
  attribute access(read: manage, write: manage) optional TriStateAutoEnum nightVision = 22;
  attribute access(read: manage, write: manage) optional TriStateAutoEnum nightVisionIllum = 23;
  attribute access(read: manage, write: manage) optional ViewportStruct viewport = 24;
  attribute access(read: manage, write: manage) optional boolean speakerMuted = 25;
  attribute access(read: manage, write: manage) optional int8u speakerVolumeLevel = 26;
  readonly attribute access(read: manage) optional int8u speakerMaxLevel = 27;
  readonly attribute access(read: manage) optional int8u speakerMinLevel = 28;
  attribute access(read: manage, write: manage) optional boolean microphoneMuted = 29;
  attribute access(read: manage, write: manage) optional int8u microphoneVolumeLevel = 30;
  readonly attribute access(read: manage) optional int8u microphoneMaxLevel = 31;
  readonly attribute access(read: manage) optional int8u microphoneMinLevel = 32;
  attribute access(read: manage, write: manage) optional boolean microphoneAGCEnabled = 33;
  attribute access(read: manage, write: manage) optional int16u imageRotation = 34;
  attribute access(read: manage, write: manage) optional boolean imageFlipHorizontal = 35;
  attribute access(read: manage, write: manage) optional boolean imageFlipVertical = 36;
  attribute access(read: manage, write: manage) optional boolean localVideoRecordingEnabled = 37;
  attribute access(read: manage, write: manage) optional boolean localSnapshotRecordingEnabled = 38;
  attribute access(read: manage, write: manage) optional boolean statusLightEnabled = 39;
  attribute access(read: manage, write: manage) optional ThreeLevelAutoEnum statusLightBrightness = 40;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AudioStreamAllocateRequest {
    StreamUsageEnum streamUsage = 0;
    AudioCodecEnum audioCodec = 1;
    int8u channelCount = 2;
    int32u sampleRate = 3;
    int32u bitRate = 4;
    int8u bitDepth = 5;
  }

  response struct AudioStreamAllocateResponse = 1 {
    int16u audioStreamID = 0;
  }

  request struct AudioStreamDeallocateRequest {
    int16u audioStreamID = 0;
  }

  request struct VideoStreamAllocateRequest {
    StreamUsageEnum streamUsage = 0;
    VideoCodecEnum videoCodec = 1;
    int16u minFrameRate = 2;
    int16u maxFrameRate = 3;
    VideoResolutionStruct minResolution = 4;
    VideoResolutionStruct maxResolution = 5;
    int32u minBitRate = 6;
    int32u maxBitRate = 7;
    int16u keyFrameInterval = 8;
    optional boolean watermarkEnabled = 9;
    optional boolean OSDEnabled = 10;
  }

  response struct VideoStreamAllocateResponse = 4 {
    int16u videoStreamID = 0;
  }

  request struct VideoStreamModifyRequest {
    int16u videoStreamID = 0;
    optional boolean watermarkEnabled = 1;
    optional boolean OSDEnabled = 2;
  }

  request struct VideoStreamDeallocateRequest {
    int16u videoStreamID = 0;
  }

  request struct SnapshotStreamAllocateRequest {
    ImageCodecEnum imageCodec = 0;
    int16u maxFrameRate = 1;
    VideoResolutionStruct minResolution = 2;
    VideoResolutionStruct maxResolution = 3;
    int8u quality = 4;
    optional boolean watermarkEnabled = 5;
    optional boolean OSDEnabled = 6;
  }

  response struct SnapshotStreamAllocateResponse = 8 {
    int16u snapshotStreamID = 0;
  }

  request struct SnapshotStreamModifyRequest {
    int16u snapshotStreamID = 0;
    optional boolean watermarkEnabled = 1;
    optional boolean OSDEnabled = 2;
  }

  request struct SnapshotStreamDeallocateRequest {
    int16u snapshotStreamID = 0;
  }

  request struct SetStreamPrioritiesRequest {
    StreamUsageEnum streamPriorities[] = 0;
  }

  request struct CaptureSnapshotRequest {
    nullable int16u snapshotStreamID = 0;
    VideoResolutionStruct requestedResolution = 1;
  }

  response struct CaptureSnapshotResponse = 13 {
    octet_string data = 0;
    ImageCodecEnum imageCodec = 1;
    VideoResolutionStruct resolution = 2;
  }

  /** This command SHALL allocate an audio stream on the camera and return an allocated audio stream identifier. */
  command access(invoke: manage) AudioStreamAllocate(AudioStreamAllocateRequest): AudioStreamAllocateResponse = 0;
  /** This command SHALL deallocate an audio stream on the camera, corresponding to the given audio stream identifier. */
  command access(invoke: manage) AudioStreamDeallocate(AudioStreamDeallocateRequest): DefaultSuccess = 2;
  /** This command SHALL allocate a video stream on the camera and return an allocated video stream identifier. */
  command access(invoke: manage) VideoStreamAllocate(VideoStreamAllocateRequest): VideoStreamAllocateResponse = 3;
  /** This command SHALL be used to modify a stream specified by the VideoStreamID. */
  command access(invoke: manage) VideoStreamModify(VideoStreamModifyRequest): DefaultSuccess = 5;
  /** This command SHALL deallocate a video stream on the camera, corresponding to the given video stream identifier. */
  command access(invoke: manage) VideoStreamDeallocate(VideoStreamDeallocateRequest): DefaultSuccess = 6;
  /** This command SHALL allocate a snapshot stream on the device and return an allocated snapshot stream identifier. */
  command access(invoke: manage) SnapshotStreamAllocate(SnapshotStreamAllocateRequest): SnapshotStreamAllocateResponse = 7;
  /** This command SHALL be used to modify a stream specified by the VideoStreamID. */
  command access(invoke: manage) SnapshotStreamModify(SnapshotStreamModifyRequest): DefaultSuccess = 9;
  /** This command SHALL deallocate an snapshot stream on the camera, corresponding to the given snapshot stream identifier. */
  command access(invoke: manage) SnapshotStreamDeallocate(SnapshotStreamDeallocateRequest): DefaultSuccess = 10;
  /** This command SHALL set the relative priorities of the various stream usages on the camera. */
  command access(invoke: administer) SetStreamPriorities(SetStreamPrioritiesRequest): DefaultSuccess = 11;
  /** This command SHALL return a Snapshot from the camera. */
  command CaptureSnapshot(CaptureSnapshotRequest): CaptureSnapshotResponse = 12;
}

/** This cluster provides an interface into controls associated with the operation of a device that provides pan, tilt, and zoom functions, either mechanically, or against a digital image. */
provisional cluster CameraAvSettingsUserLevelManagement = 1362 {
  revision 1;

  bitmap Feature : bitmap32 {
    kDigitalPTZ = 0x1;
    kMechanicalPan = 0x2;
    kMechanicalTilt = 0x4;
    kMechanicalZoom = 0x8;
    kMechanicalPresets = 0x10;
  }

  struct MPTZStruct {
    optional int16s pan = 0;
    optional int16s tilt = 1;
    optional int8u zoom = 2;
  }

  struct MPTZPresetStruct {
    int8u presetID = 0;
    char_string<32> name = 1;
    MPTZStruct settings = 2;
  }

  struct DPTZStruct {
    int16u videoStreamID = 0;
    ViewportStruct viewport = 1;
  }

  readonly attribute optional MPTZStruct MPTZPosition = 0;
  readonly attribute optional int8u maxPresets = 1;
  readonly attribute optional MPTZPresetStruct MPTZPresets[] = 2;
  readonly attribute optional DPTZStruct DPTZStreams[] = 3;
  readonly attribute optional int8u zoomMax = 4;
  readonly attribute optional int16s tiltMin = 5;
  readonly attribute optional int16s tiltMax = 6;
  readonly attribute optional int16s panMin = 7;
  readonly attribute optional int16s panMax = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MPTZSetPositionRequest {
    optional int16s pan = 0;
    optional int16s tilt = 1;
    optional int8u zoom = 2;
  }

  request struct MPTZRelativeMoveRequest {
    optional int16s panDelta = 0;
    optional int16s tiltDelta = 1;
    optional int8s zoomDelta = 2;
  }

  request struct MPTZMoveToPresetRequest {
    int8u presetID = 0;
  }

  request struct MPTZSavePresetRequest {
    optional int8u presetID = 0;
    char_string<32> name = 1;
  }

  request struct MPTZRemovePresetRequest {
    int8u presetID = 0;
  }

  request struct DPTZSetViewportRequest {
    int16u videoStreamID = 0;
    ViewportStruct viewport = 1;
  }

  request struct DPTZRelativeMoveRequest {
    int16u videoStreamID = 0;
    optional int16s deltaX = 1;
    optional int16s deltaY = 2;
    optional int8s zoomDelta = 3;
  }

  /** This command SHALL set the values for the pan, tilt, and zoom in the mechanical PTZ. */
  command MPTZSetPosition(MPTZSetPositionRequest): DefaultSuccess = 0;
  /** This command SHALL move the camera by the delta values relative to the currently defined position. */
  command MPTZRelativeMove(MPTZRelativeMoveRequest): DefaultSuccess = 1;
  /** This command SHALL move the camera to the positions specified by the Preset passed. */
  command MPTZMoveToPreset(MPTZMoveToPresetRequest): DefaultSuccess = 2;
  /** This command allows creating a new preset or updating the values of an existing one. */
  command MPTZSavePreset(MPTZSavePresetRequest): DefaultSuccess = 3;
  /** This command SHALL remove a preset entry from the PresetMptzTable. */
  command MPTZRemovePreset(MPTZRemovePresetRequest): DefaultSuccess = 4;
  /** This command allows for setting the digital viewport for a specific Video Stream. */
  command DPTZSetViewport(DPTZSetViewportRequest): DefaultSuccess = 5;
  /** This command SHALL change the per stream viewport by the amount specified in a relative fashion. */
  command DPTZRelativeMove(DPTZRelativeMoveRequest): DefaultSuccess = 6;
}

/** This cluster implements the upload of Audio and Video streams from the Push AV Stream Transport Cluster using suitable push-based transports. */
provisional cluster PushAvStreamTransport = 1365 {
  revision 1;

  enum CMAFInterfaceEnum : enum8 {
    kInterface1 = 0;
    kInterface2DASH = 1;
    kInterface2HLS = 2;
  }

  enum ContainerFormatEnum : enum8 {
    kCMAF = 0 [spec_name = "CMAF"];
  }

  enum IngestMethodsEnum : enum8 {
    kCMAFIngest = 0;
  }

  enum StatusCodeEnum : enum8 {
    kInvalidTLSEndpoint = 2;
    kInvalidStream = 3;
    kInvalidURL = 4;
    kInvalidZone = 5;
    kInvalidCombination = 6;
    kInvalidTriggerType = 7;
    kInvalidTransportStatus = 8;
    kInvalidOptions = 9;
    kInvalidStreamUsage = 10;
  }

  enum TransportStatusEnum : enum8 {
    kActive = 0;
    kInactive = 1;
  }

  enum TransportTriggerTypeEnum : enum8 {
    kCommand = 0;
    kMotion = 1;
    kContinuous = 2;
  }

  enum TriggerActivationReasonEnum : enum8 {
    kUserInitiated = 0;
    kAutomation = 1;
    kEmergency = 2;
  }

  bitmap Feature : bitmap32 {
    kPerZoneSensitivity = 0x1;
    kMetadata = 0x2;
  }

  struct TransportMotionTriggerTimeControlStruct {
    int16u initialDuration = 0;
    int16u augmentationDuration = 1;
    elapsed_s maxDuration = 2;
    int16u blindDuration = 3;
  }

  struct TransportZoneOptionsStruct {
    nullable int16u zone = 0;
    optional int8u sensitivity = 1;
  }

  struct TransportTriggerOptionsStruct {
    TransportTriggerTypeEnum triggerType = 0;
    optional nullable TransportZoneOptionsStruct motionZones[] = 1;
    optional nullable int8u motionSensitivity = 2;
    optional TransportMotionTriggerTimeControlStruct motionTimeControl = 3;
    optional int16u maxPreRollLen = 4;
  }

  struct CMAFContainerOptionsStruct {
    CMAFInterfaceEnum CMAFInterface = 0;
    int16u segmentDuration = 1;
    int16u chunkDuration = 2;
    int8u sessionGroup = 3;
    char_string<16> trackName = 4;
    optional octet_string<16> CENCKey = 5;
    optional octet_string<16> CENCKeyID = 6;
    optional boolean metadataEnabled = 7;
  }

  struct ContainerOptionsStruct {
    ContainerFormatEnum containerType = 0;
    optional CMAFContainerOptionsStruct CMAFContainerOptions = 1;
  }

  struct TransportOptionsStruct {
    StreamUsageEnum streamUsage = 0;
    optional nullable int16u videoStreamID = 1;
    optional nullable int16u audioStreamID = 2;
    int16u endpointID = 3;
    long_char_string<2000> url = 4;
    TransportTriggerOptionsStruct triggerOptions = 5;
    IngestMethodsEnum ingestMethod = 6;
    ContainerOptionsStruct containerOptions = 7;
    optional epoch_s expiryTime = 8;
  }

  fabric_scoped struct TransportConfigurationStruct {
    int16u connectionID = 0;
    TransportStatusEnum transportStatus = 1;
    optional TransportOptionsStruct transportOptions = 2;
    fabric_idx fabricIndex = 254;
  }

  struct SupportedFormatStruct {
    ContainerFormatEnum containerFormat = 0;
    IngestMethodsEnum ingestMethod = 1;
  }

  info event PushTransportBegin = 0 {
    int16u connectionID = 0;
    TransportTriggerTypeEnum triggerType = 1;
    optional TriggerActivationReasonEnum activationReason = 2;
  }

  info event PushTransportEnd = 1 {
    int16u connectionID = 0;
    TransportTriggerTypeEnum triggerType = 1;
    optional TriggerActivationReasonEnum activationReason = 2;
  }

  readonly attribute SupportedFormatStruct supportedFormats[] = 0;
  readonly attribute TransportConfigurationStruct currentConnections[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AllocatePushTransportRequest {
    TransportOptionsStruct transportOptions = 0;
  }

  response struct AllocatePushTransportResponse = 1 {
    TransportConfigurationStruct transportConfiguration = 0;
  }

  request struct DeallocatePushTransportRequest {
    int16u connectionID = 0;
  }

  request struct ModifyPushTransportRequest {
    int16u connectionID = 0;
    TransportOptionsStruct transportOptions = 1;
  }

  request struct SetTransportStatusRequest {
    nullable int16u connectionID = 0;
    TransportStatusEnum transportStatus = 1;
  }

  request struct ManuallyTriggerTransportRequest {
    int16u connectionID = 0;
    TriggerActivationReasonEnum activationReason = 1;
    optional TransportMotionTriggerTimeControlStruct timeControl = 2;
    optional long_octet_string<256> userDefined = 3;
  }

  request struct FindTransportRequest {
    nullable int16u connectionID = 0;
  }

  response struct FindTransportResponse = 7 {
    TransportConfigurationStruct transportConfigurations[] = 0;
  }

  /** This command SHALL allocate a transport and return a PushTransportConnectionID. */
  fabric command access(invoke: manage) AllocatePushTransport(AllocatePushTransportRequest): AllocatePushTransportResponse = 0;
  /** This command SHALL be generated to request the Node deallocates the specified transport. */
  fabric command access(invoke: manage) DeallocatePushTransport(DeallocatePushTransportRequest): DefaultSuccess = 2;
  /** This command is used to request the Node modifies the configuration of the specified push transport. */
  fabric command access(invoke: manage) ModifyPushTransport(ModifyPushTransportRequest): DefaultSuccess = 3;
  /** This command SHALL be generated to request the Node modifies the Transport Status of a specified transport or all transports. */
  fabric command access(invoke: manage) SetTransportStatus(SetTransportStatusRequest): DefaultSuccess = 4;
  /** This command SHALL be generated to request the Node to manually start the specified push transport. */
  fabric command ManuallyTriggerTransport(ManuallyTriggerTransportRequest): DefaultSuccess = 5;
  /** This command SHALL return the Transport Configuration for the specified push transport or all allocated transports for the fabric if null. */
  fabric command FindTransport(FindTransportRequest): FindTransportResponse = 6;
}

/** This cluster provides facilities to configure and play Chime sounds, such as those used in a doorbell. */
provisional cluster Chime = 1366 {
  revision 1;

  struct ChimeSoundStruct {
    int8u chimeID = 0;
    char_string<48> name = 1;
  }

  readonly attribute ChimeSoundStruct installedChimeSounds[] = 0;
  attribute int8u selectedChime = 1;
  attribute boolean enabled = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command PlayChimeSound(): DefaultSuccess = 0;
}

/** This Cluster is used to manage TLS Client Certificates and to provision
      TLS endpoints with enough information to facilitate subsequent connection. */
provisional cluster TlsCertificateManagement = 2049 {
  revision 1;

  enum StatusCodeEnum : enum8 {
    kCertificateAlreadyInstalled = 2;
    kDuplicateKey = 3;
  }

  fabric_scoped struct TLSCertStruct {
    int16u caid = 0;
    optional long_octet_string<3000> certificate = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct TLSClientCertificateDetailStruct {
    int16u ccdid = 0;
    optional long_octet_string<3000> clientCertificate = 1;
    optional octet_string intermediateCertificates[] = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute int8u maxRootCertificates = 0;
  readonly attribute TLSCertStruct provisionedRootCertificates[] = 1;
  readonly attribute int8u maxClientCertificates = 2;
  readonly attribute TLSClientCertificateDetailStruct provisionedClientCertificates[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ProvisionRootCertificateRequest {
    long_octet_string<3000> certificate = 0;
    nullable int16u caid = 1;
  }

  response struct ProvisionRootCertificateResponse = 1 {
    int16u caid = 0;
  }

  request struct FindRootCertificateRequest {
    nullable int16u caid = 0;
  }

  response struct FindRootCertificateResponse = 3 {
    TLSCertStruct certificateDetails[] = 0;
  }

  request struct LookupRootCertificateRequest {
    octet_string<64> fingerprint = 0;
  }

  response struct LookupRootCertificateResponse = 5 {
    int16u caid = 0;
  }

  request struct RemoveRootCertificateRequest {
    int16u caid = 0;
  }

  request struct TLSClientCSRRequest {
    octet_string<128> nonce = 0;
  }

  response struct TLSClientCSRResponse = 8 {
    int16u ccdid = 0;
    long_octet_string<3000> csr = 1;
    octet_string<128> nonce = 2;
  }

  request struct ProvisionClientCertificateRequest {
    int16u ccdid = 0;
    TLSClientCertificateDetailStruct clientCertificateDetails = 1;
  }

  request struct FindClientCertificateRequest {
    nullable int16u ccdid = 0;
  }

  response struct FindClientCertificateResponse = 11 {
    TLSClientCertificateDetailStruct certificateDetails[] = 0;
  }

  request struct LookupClientCertificateRequest {
    octet_string<64> fingerprint = 0;
  }

  response struct LookupClientCertificateResponse = 13 {
    int16u ccdid = 0;
  }

  request struct RemoveClientCertificateRequest {
    int16u ccdid = 0;
  }

  /** This command SHALL provision a newly provided certificate, or rotate an existing one, based on the contents of the CAID field. */
  fabric command access(invoke: administer) ProvisionRootCertificate(ProvisionRootCertificateRequest): ProvisionRootCertificateResponse = 0;
  /** This command SHALL return the specified TLS root certificate, or all TLS provisioned root certificates, based on the contents of the CAID field. */
  fabric command FindRootCertificate(FindRootCertificateRequest): FindRootCertificateResponse = 2;
  /** This command SHALL return the CAID for the passed in fingerprint. */
  fabric command LookupRootCertificate(LookupRootCertificateRequest): LookupRootCertificateResponse = 4;
  /** This command SHALL be generated to request the server removes the certificate provisioned to the provided Certificate Authority ID. */
  fabric command access(invoke: administer) RemoveRootCertificate(RemoveRootCertificateRequest): DefaultSuccess = 6;
  /** This command SHALL be generated to request the Node generates a Certificate Signing Request. */
  fabric command access(invoke: administer) TLSClientCSR(TLSClientCSRRequest): TLSClientCSRResponse = 7;
  /** This command SHALL be generated to request the Node provisions newly provided Client Certificate Details, or rotate an existing client certificate. */
  fabric command access(invoke: administer) ProvisionClientCertificate(ProvisionClientCertificateRequest): DefaultSuccess = 9;
  /** This command SHALL return the TLSClientCertificateDetailStruct for the passed in CCDID, or all TLS client certificates, based on the contents of the CCDID field. */
  fabric command FindClientCertificate(FindClientCertificateRequest): FindClientCertificateResponse = 10;
  /** This command SHALL return the CCDID for the passed in Fingerprint. */
  fabric command LookupClientCertificate(LookupClientCertificateRequest): LookupClientCertificateResponse = 12;
  /** This command SHALL be used to request the Node removes all stored information for the provided CCDID. */
  fabric command access(invoke: administer) RemoveClientCertificate(RemoveClientCertificateRequest): DefaultSuccess = 14;
}

/** This Cluster is used to provision TLS Endpoints with enough information to facilitate subsequent connection. */
provisional cluster TlsClientManagement = 2050 {
  revision 1;

  enum StatusCodeEnum : enum8 {
    kEndpointAlreadyInstalled = 2;
    kRootCertificateNotFound = 3;
    kClientCertificateNotFound = 4;
    kEndpointInUse = 5;
  }

  enum TLSEndpointStatusEnum : enum8 {
    kProvisioned = 0;
    kInUse = 1;
  }

  fabric_scoped struct TLSEndpointStruct {
    int16u endpointID = 0;
    octet_string<253> hostname = 1;
    int16u port = 2;
    int16u caid = 3;
    nullable int16u ccdid = 4;
    TLSEndpointStatusEnum status = 5;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute int8u maxProvisioned = 0;
  readonly attribute TLSEndpointStruct provisionedEndpoints[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ProvisionEndpointRequest {
    octet_string<253> hostname = 0;
    int16u port = 1;
    int16u caid = 2;
    nullable int16u ccdid = 3;
    nullable int16u endpointID = 4;
  }

  response struct ProvisionEndpointResponse = 1 {
    int16u endpointID = 0;
  }

  request struct FindEndpointRequest {
    int16u endpointID = 0;
  }

  response struct FindEndpointResponse = 3 {
    TLSEndpointStruct endpoint = 0;
  }

  request struct RemoveEndpointRequest {
    int16u endpointID = 0;
  }

  /** This command is used to provision a TLS Endpoint for the provided HostName / Port combination. */
  fabric command access(invoke: administer) ProvisionEndpoint(ProvisionEndpointRequest): ProvisionEndpointResponse = 0;
  /** This command is used to find a TLS Endpoint by its ID. */
  fabric command FindEndpoint(FindEndpointRequest): FindEndpointResponse = 2;
  /** This command is used to remove a TLS Endpoint by its ID. */
  fabric command access(invoke: administer) RemoveEndpoint(RemoveEndpointRequest): DefaultSuccess = 4;
}

/** The Test Cluster is meant to validate the generated code */
internal cluster UnitTesting = 4294048773 {
  revision 1; // NOTE: Default/not specifically set

  enum SimpleEnum : enum8 {
    kUnspecified = 0;
    kValueA = 1;
    kValueB = 2;
    kValueC = 3;
  }

  bitmap Bitmap16MaskMap : bitmap16 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x4000;
  }

  bitmap Bitmap32MaskMap : bitmap32 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x40000000;
  }

  bitmap Bitmap64MaskMap : bitmap64 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x4000000000000000;
  }

  bitmap Bitmap8MaskMap : bitmap8 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x40;
  }

  bitmap SimpleBitmap : bitmap8 {
    kValueA = 0x1;
    kValueB = 0x2;
    kValueC = 0x4;
  }

  struct SimpleStruct {
    int8u a = 0;
    boolean b = 1;
    SimpleEnum c = 2;
    octet_string d = 3;
    char_string e = 4;
    SimpleBitmap f = 5;
    single g = 6;
    double h = 7;
    optional TestGlobalEnum i = 8;
  }

  fabric_scoped struct TestFabricScoped {
    fabric_sensitive int8u fabricSensitiveInt8u = 1;
    optional fabric_sensitive int8u optionalFabricSensitiveInt8u = 2;
    nullable fabric_sensitive int8u nullableFabricSensitiveInt8u = 3;
    optional nullable fabric_sensitive int8u nullableOptionalFabricSensitiveInt8u = 4;
    fabric_sensitive char_string fabricSensitiveCharString = 5;
    fabric_sensitive SimpleStruct fabricSensitiveStruct = 6;
    fabric_sensitive int8u fabricSensitiveInt8uList[] = 7;
    fabric_idx fabricIndex = 254;
  }

  struct NullablesAndOptionalsStruct {
    nullable int16u nullableInt = 0;
    optional int16u optionalInt = 1;
    optional nullable int16u nullableOptionalInt = 2;
    nullable char_string nullableString = 3;
    optional char_string optionalString = 4;
    optional nullable char_string nullableOptionalString = 5;
    nullable SimpleStruct nullableStruct = 6;
    optional SimpleStruct optionalStruct = 7;
    optional nullable SimpleStruct nullableOptionalStruct = 8;
    nullable SimpleEnum nullableList[] = 9;
    optional SimpleEnum optionalList[] = 10;
    optional nullable SimpleEnum nullableOptionalList[] = 11;
  }

  struct NestedStruct {
    int8u a = 0;
    boolean b = 1;
    SimpleStruct c = 2;
    optional TestGlobalStruct d = 3;
  }

  struct NestedStructList {
    int8u a = 0;
    boolean b = 1;
    SimpleStruct c = 2;
    SimpleStruct d[] = 3;
    int32u e[] = 4;
    octet_string f[] = 5;
    int8u g[] = 6;
  }

  struct DoubleNestedStructList {
    NestedStructList a[] = 0;
  }

  struct TestListStructOctet {
    int64u member1 = 0;
    octet_string<32> member2 = 1;
  }

  info event TestEvent = 1 {
    int8u arg1 = 1;
    SimpleEnum arg2 = 2;
    boolean arg3 = 3;
    SimpleStruct arg4 = 4;
    SimpleStruct arg5[] = 5;
    SimpleEnum arg6[] = 6;
  }

  fabric_sensitive info event TestFabricScopedEvent = 2 {
    fabric_idx fabricIndex = 254;
  }

  info event TestDifferentVendorMeiEvent = 4294050030 {
    int8u arg1 = 1;
  }

  attribute boolean boolean = 0;
  attribute Bitmap8MaskMap bitmap8 = 1;
  attribute Bitmap16MaskMap bitmap16 = 2;
  attribute Bitmap32MaskMap bitmap32 = 3;
  attribute Bitmap64MaskMap bitmap64 = 4;
  attribute int8u int8u = 5;
  attribute int16u int16u = 6;
  attribute int24u int24u = 7;
  attribute int32u int32u = 8;
  attribute int40u int40u = 9;
  attribute int48u int48u = 10;
  attribute int56u int56u = 11;
  attribute int64u int64u = 12;
  attribute int8s int8s = 13;
  attribute int16s int16s = 14;
  attribute int24s int24s = 15;
  attribute int32s int32s = 16;
  attribute int40s int40s = 17;
  attribute int48s int48s = 18;
  attribute int56s int56s = 19;
  attribute int64s int64s = 20;
  attribute enum8 enum8 = 21;
  attribute enum16 enum16 = 22;
  attribute single floatSingle = 23;
  attribute double floatDouble = 24;
  attribute octet_string<10> octetString = 25;
  attribute int8u listInt8u[] = 26;
  attribute octet_string listOctetString[] = 27;
  attribute TestListStructOctet listStructOctetString[] = 28;
  attribute long_octet_string<1000> longOctetString = 29;
  attribute char_string<10> charString = 30;
  attribute long_char_string<1000> longCharString = 31;
  attribute epoch_us epochUs = 32;
  attribute epoch_s epochS = 33;
  attribute vendor_id vendorId = 34;
  attribute NullablesAndOptionalsStruct listNullablesAndOptionalsStruct[] = 35;
  attribute SimpleEnum enumAttr = 36;
  attribute SimpleStruct structAttr = 37;
  attribute int8u rangeRestrictedInt8u = 38;
  attribute int8s rangeRestrictedInt8s = 39;
  attribute int16u rangeRestrictedInt16u = 40;
  attribute int16s rangeRestrictedInt16s = 41;
  attribute long_octet_string listLongOctetString[] = 42;
  attribute TestFabricScoped listFabricScoped[] = 43;
  timedwrite attribute boolean timedWriteBoolean = 48;
  attribute boolean generalErrorBoolean = 49;
  attribute boolean clusterErrorBoolean = 50;
  attribute TestGlobalEnum globalEnum = 51;
  attribute TestGlobalStruct globalStruct = 52;
  attribute access(read: administer, write: administer) optional boolean unsupportedAttributeRequiringAdminPrivilege = 254;
  attribute optional boolean unsupported = 255;
  attribute optional int8u readFailureCode = 12288;
  attribute optional int32u failureInt32U = 12289;
  attribute nullable boolean nullableBoolean = 16384;
  attribute nullable Bitmap8MaskMap nullableBitmap8 = 16385;
  attribute nullable Bitmap16MaskMap nullableBitmap16 = 16386;
  attribute nullable Bitmap32MaskMap nullableBitmap32 = 16387;
  attribute nullable Bitmap64MaskMap nullableBitmap64 = 16388;
  attribute nullable int8u nullableInt8u = 16389;
  attribute nullable int16u nullableInt16u = 16390;
  attribute nullable int24u nullableInt24u = 16391;
  attribute nullable int32u nullableInt32u = 16392;
  attribute nullable int40u nullableInt40u = 16393;
  attribute nullable int48u nullableInt48u = 16394;
  attribute nullable int56u nullableInt56u = 16395;
  attribute nullable int64u nullableInt64u = 16396;
  attribute nullable int8s nullableInt8s = 16397;
  attribute nullable int16s nullableInt16s = 16398;
  attribute nullable int24s nullableInt24s = 16399;
  attribute nullable int32s nullableInt32s = 16400;
  attribute nullable int40s nullableInt40s = 16401;
  attribute nullable int48s nullableInt48s = 16402;
  attribute nullable int56s nullableInt56s = 16403;
  attribute nullable int64s nullableInt64s = 16404;
  attribute nullable enum8 nullableEnum8 = 16405;
  attribute nullable enum16 nullableEnum16 = 16406;
  attribute nullable single nullableFloatSingle = 16407;
  attribute nullable double nullableFloatDouble = 16408;
  attribute nullable octet_string<10> nullableOctetString = 16409;
  attribute nullable char_string<10> nullableCharString = 16414;
  attribute nullable SimpleEnum nullableEnumAttr = 16420;
  attribute nullable SimpleStruct nullableStruct = 16421;
  attribute nullable int8u nullableRangeRestrictedInt8u = 16422;
  attribute nullable int8s nullableRangeRestrictedInt8s = 16423;
  attribute nullable int16u nullableRangeRestrictedInt16u = 16424;
  attribute nullable int16s nullableRangeRestrictedInt16s = 16425;
  writeonly attribute optional int8u writeOnlyInt8u = 16426;
  attribute nullable TestGlobalEnum nullableGlobalEnum = 16435;
  attribute nullable TestGlobalStruct nullableGlobalStruct = 16436;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
  attribute int8u meiInt8u = 4294070017;

  response struct TestSpecificResponse = 0 {
    int8u returnValue = 0;
  }

  response struct TestAddArgumentsResponse = 1 {
    int8u returnValue = 0;
  }

  response struct TestSimpleArgumentResponse = 2 {
    boolean returnValue = 0;
  }

  response struct TestStructArrayArgumentResponse = 3 {
    NestedStructList arg1[] = 0;
    SimpleStruct arg2[] = 1;
    SimpleEnum arg3[] = 2;
    boolean arg4[] = 3;
    SimpleEnum arg5 = 4;
    boolean arg6 = 5;
  }

  request struct TestAddArgumentsRequest {
    int8u arg1 = 0;
    int8u arg2 = 1;
  }

  response struct TestListInt8UReverseResponse = 4 {
    int8u arg1[] = 0;
  }

  request struct TestSimpleArgumentRequestRequest {
    boolean arg1 = 0;
  }

  response struct TestEnumsResponse = 5 {
    vendor_id arg1 = 0;
    SimpleEnum arg2 = 1;
  }

  request struct TestStructArrayArgumentRequestRequest {
    NestedStructList arg1[] = 0;
    SimpleStruct arg2[] = 1;
    SimpleEnum arg3[] = 2;
    boolean arg4[] = 3;
    SimpleEnum arg5 = 4;
    boolean arg6 = 5;
  }

  response struct TestNullableOptionalResponse = 6 {
    boolean wasPresent = 0;
    optional boolean wasNull = 1;
    optional int8u value = 2;
    optional nullable int8u originalValue = 3;
  }

  request struct TestStructArgumentRequestRequest {
    SimpleStruct arg1 = 0;
  }

  response struct TestComplexNullableOptionalResponse = 7 {
    boolean nullableIntWasNull = 0;
    optional int16u nullableIntValue = 1;
    boolean optionalIntWasPresent = 2;
    optional int16u optionalIntValue = 3;
    boolean nullableOptionalIntWasPresent = 4;
    optional boolean nullableOptionalIntWasNull = 5;
    optional int16u nullableOptionalIntValue = 6;
    boolean nullableStringWasNull = 7;
    optional char_string nullableStringValue = 8;
    boolean optionalStringWasPresent = 9;
    optional char_string optionalStringValue = 10;
    boolean nullableOptionalStringWasPresent = 11;
    optional boolean nullableOptionalStringWasNull = 12;
    optional char_string nullableOptionalStringValue = 13;
    boolean nullableStructWasNull = 14;
    optional SimpleStruct nullableStructValue = 15;
    boolean optionalStructWasPresent = 16;
    optional SimpleStruct optionalStructValue = 17;
    boolean nullableOptionalStructWasPresent = 18;
    optional boolean nullableOptionalStructWasNull = 19;
    optional SimpleStruct nullableOptionalStructValue = 20;
    boolean nullableListWasNull = 21;
    optional SimpleEnum nullableListValue[] = 22;
    boolean optionalListWasPresent = 23;
    optional SimpleEnum optionalListValue[] = 24;
    boolean nullableOptionalListWasPresent = 25;
    optional boolean nullableOptionalListWasNull = 26;
    optional SimpleEnum nullableOptionalListValue[] = 27;
  }

  request struct TestNestedStructArgumentRequestRequest {
    NestedStruct arg1 = 0;
  }

  response struct BooleanResponse = 8 {
    boolean value = 0;
  }

  request struct TestListStructArgumentRequestRequest {
    SimpleStruct arg1[] = 0;
  }

  response struct SimpleStructResponse = 9 {
    SimpleStruct arg1 = 0;
  }

  request struct TestListInt8UArgumentRequestRequest {
    int8u arg1[] = 0;
  }

  response struct TestEmitTestEventResponse = 10 {
    int64u value = 0;
  }

  request struct TestNestedStructListArgumentRequestRequest {
    NestedStructList arg1 = 0;
  }

  response struct TestEmitTestFabricScopedEventResponse = 11 {
    int64u value = 0;
  }

  request struct TestListNestedStructListArgumentRequestRequest {
    NestedStructList arg1[] = 0;
  }

  response struct TestBatchHelperResponse = 12 {
    octet_string<800> buffer = 0;
  }

  request struct TestListInt8UReverseRequestRequest {
    int8u arg1[] = 0;
  }

  response struct StringEchoResponse = 13 {
    octet_string payload = 0;
  }

  request struct TestEnumsRequestRequest {
    vendor_id arg1 = 0;
    SimpleEnum arg2 = 1;
  }

  response struct GlobalEchoResponse = 14 {
    TestGlobalStruct field1 = 0;
    TestGlobalEnum field2 = 1;
  }

  request struct TestNullableOptionalRequestRequest {
    optional nullable int8u arg1 = 0;
  }

  request struct TestComplexNullableOptionalRequestRequest {
    nullable int16u nullableInt = 0;
    optional int16u optionalInt = 1;
    optional nullable int16u nullableOptionalInt = 2;
    nullable char_string nullableString = 3;
    optional char_string optionalString = 4;
    optional nullable char_string nullableOptionalString = 5;
    nullable SimpleStruct nullableStruct = 6;
    optional SimpleStruct optionalStruct = 7;
    optional nullable SimpleStruct nullableOptionalStruct = 8;
    nullable SimpleEnum nullableList[] = 9;
    optional SimpleEnum optionalList[] = 10;
    optional nullable SimpleEnum nullableOptionalList[] = 11;
  }

  request struct SimpleStructEchoRequestRequest {
    SimpleStruct arg1 = 0;
  }

  request struct TestSimpleOptionalArgumentRequestRequest {
    optional boolean arg1 = 0;
  }

  request struct TestEmitTestEventRequestRequest {
    int8u arg1 = 0;
    SimpleEnum arg2 = 1;
    boolean arg3 = 2;
  }

  request struct TestEmitTestFabricScopedEventRequestRequest {
    int8u arg1 = 0;
  }

  request struct TestBatchHelperRequestRequest {
    int16u sleepBeforeResponseTimeMs = 0;
    int16u sizeOfResponseBuffer = 1;
    int8u fillCharacter = 2;
  }

  request struct TestSecondBatchHelperRequestRequest {
    int16u sleepBeforeResponseTimeMs = 0;
    int16u sizeOfResponseBuffer = 1;
    int8u fillCharacter = 2;
  }

  request struct StringEchoRequestRequest {
    octet_string payload = 0;
  }

  request struct GlobalEchoRequestRequest {
    TestGlobalStruct field1 = 0;
    TestGlobalEnum field2 = 1;
  }

  request struct TestDifferentVendorMeiRequestRequest {
    int8u arg1 = 0;
  }

  response struct TestDifferentVendorMeiResponse = 4294049979 {
    int8u arg1 = 0;
    int64u eventNumber = 1;
  }

  /** Simple command without any parameters and without a specific response.
        To aid in unit testing, this command will re-initialize attribute storage to defaults. */
  command Test(): DefaultSuccess = 0;
  /** Simple command without any parameters and without a specific response not handled by the server */
  command TestNotHandled(): DefaultSuccess = 1;
  /** Simple command without any parameters and with a specific response */
  command TestSpecific(): TestSpecificResponse = 2;
  /** Simple command that should not be added to the server. */
  command TestUnknownCommand(): DefaultSuccess = 3;
  /** Command that takes two arguments and returns their sum. */
  command TestAddArguments(TestAddArgumentsRequest): TestAddArgumentsResponse = 4;
  /** Command that takes an argument which is bool */
  command TestSimpleArgumentRequest(TestSimpleArgumentRequestRequest): TestSimpleArgumentResponse = 5;
  /** Command that takes various arguments that are arrays, including an array of structs which have a list member. */
  command TestStructArrayArgumentRequest(TestStructArrayArgumentRequestRequest): TestStructArrayArgumentResponse = 6;
  /** Command that takes an argument which is struct.  The response echoes the
        'b' field of the single arg. */
  command TestStructArgumentRequest(TestStructArgumentRequestRequest): BooleanResponse = 7;
  /** Command that takes an argument which is nested struct.  The response
        echoes the 'b' field of ar1.c. */
  command TestNestedStructArgumentRequest(TestNestedStructArgumentRequestRequest): BooleanResponse = 8;
  /** Command that takes an argument which is a list of structs.  The response
        returns false if there is some struct in the list whose 'b' field is
        false, and true otherwise (including if the list is empty). */
  command TestListStructArgumentRequest(TestListStructArgumentRequestRequest): BooleanResponse = 9;
  /** Command that takes an argument which is a list of INT8U.  The response
        returns false if the list contains a 0 in it, true otherwise (including
        if the list is empty). */
  command TestListInt8UArgumentRequest(TestListInt8UArgumentRequestRequest): BooleanResponse = 10;
  /** Command that takes an argument which is a Nested Struct List.  The
        response returns false if there is some struct in arg1 (either directly
        in arg1.c or in the arg1.d list) whose 'b' field is false, and true
        otherwise. */
  command TestNestedStructListArgumentRequest(TestNestedStructListArgumentRequestRequest): BooleanResponse = 11;
  /** Command that takes an argument which is a list of Nested Struct List.
        The response returns false if there is some struct in arg1 (either
        directly in as the 'c' field of an entry 'd' list of an entry) whose 'b'
        field is false, and true otherwise (including if the list is empty). */
  command TestListNestedStructListArgumentRequest(TestListNestedStructListArgumentRequestRequest): BooleanResponse = 12;
  /** Command that takes an argument which is a list of INT8U and expects a
        response that reverses the list. */
  command TestListInt8UReverseRequest(TestListInt8UReverseRequestRequest): TestListInt8UReverseResponse = 13;
  /** Command that sends a vendor id and an enum.  The server is expected to
        echo them back. */
  command TestEnumsRequest(TestEnumsRequestRequest): TestEnumsResponse = 14;
  /** Command that takes an argument which is nullable and optional.  The
        response returns a boolean indicating whether the argument was present,
        if that's true a boolean indicating whether the argument was null, and
        if that' false the argument it received. */
  command TestNullableOptionalRequest(TestNullableOptionalRequestRequest): TestNullableOptionalResponse = 15;
  /** Command that takes various arguments which can be nullable and/or optional.  The
        response returns information about which things were received and what
        their state was. */
  command TestComplexNullableOptionalRequest(TestComplexNullableOptionalRequestRequest): TestComplexNullableOptionalResponse = 16;
  /** Command that takes an argument which is a struct.  The response echoes
        the struct back. */
  command SimpleStructEchoRequest(SimpleStructEchoRequestRequest): SimpleStructResponse = 17;
  /** Command that just responds with a success status if the timed invoke
        conditions are met. */
  timed command TimedInvokeRequest(): DefaultSuccess = 18;
  /** Command that takes an optional argument which is bool. It responds with a success value if the optional is set to any value. */
  command TestSimpleOptionalArgumentRequest(TestSimpleOptionalArgumentRequestRequest): DefaultSuccess = 19;
  /** Command that takes identical arguments to the fields of the TestEvent and logs the TestEvent to the buffer.  Command returns an event ID as the response. */
  command TestEmitTestEventRequest(TestEmitTestEventRequestRequest): TestEmitTestEventResponse = 20;
  /** Command that takes identical arguments to the fields of the TestFabricScopedEvent and logs the TestFabricScopedEvent to the buffer.  Command returns an event ID as the response. */
  command TestEmitTestFabricScopedEventRequest(TestEmitTestFabricScopedEventRequestRequest): TestEmitTestFabricScopedEventResponse = 21;
  /** Command that responds after sleepBeforeResponseTimeMs with an octet_string the size requested with fillCharacter. */
  command TestBatchHelperRequest(TestBatchHelperRequestRequest): TestBatchHelperResponse = 22;
  /** Second command that responds after sleepBeforeResponseTimeMs with an octet_string the size requested with fillCharacter. */
  command TestSecondBatchHelperRequest(TestSecondBatchHelperRequestRequest): TestBatchHelperResponse = 23;
  /** Command that takes an argument which is an octet string.  The response echoes
        the string back. If the string is large then it would require a session that
        supports large payloads. */
  command StringEchoRequest(StringEchoRequestRequest): StringEchoResponse = 24;
  /** Command that takes arguments that are global structs/enums and the
        response just echoes them back. */
  command GlobalEchoRequest(GlobalEchoRequestRequest): GlobalEchoResponse = 25;
  /** Command that returns Success if the CommandFlags pass all checks at the IM layer.
        Otherwise, return appropriate StatusCode back. */
  fabric timed command TestCheckCommandFlags(): DefaultSuccess = 26;
  /** Command having a different MEI vendor ID than the cluster. Also emits TestDifferentVendorMeiEvent. */
  command TestDifferentVendorMeiRequest(TestDifferentVendorMeiRequestRequest): TestDifferentVendorMeiResponse = 4294049962;
}

/** The Fault Injection Cluster provide a means for a test harness to configure faults(for example triggering a fault in the system). */
internal cluster FaultInjection = 4294048774 {
  revision 1; // NOTE: Default/not specifically set

  enum FaultType : enum8 {
    kUnspecified = 0;
    kSystemFault = 1;
    kInetFault = 2;
    kChipFault = 3;
    kCertFault = 4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct FailAtFaultRequest {
    FaultType type = 0;
    int32u id = 1;
    int32u numCallsToSkip = 2;
    int32u numCallsToFail = 3;
    boolean takeMutex = 4;
  }

  request struct FailRandomlyAtFaultRequest {
    FaultType type = 0;
    int32u id = 1;
    int8u percentage = 2;
  }

  /** Configure a fault to be triggered deterministically */
  command access(invoke: manage) FailAtFault(FailAtFaultRequest): DefaultSuccess = 0;
  /** Configure a fault to be triggered randomly, with a given probability defined as a percentage */
  command access(invoke: manage) FailRandomlyAtFault(FailRandomlyAtFaultRequest): DefaultSuccess = 1;
}

endpoint 0 {
  device type ma_rootdevice = 22, version 3;
  device type ma_powersource = 17, version 1;

  binding cluster OtaSoftwareUpdateProvider;

  server cluster Groups {
    ram      attribute nameSupport;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command AddGroup;
    handle command AddGroupResponse;
    handle command ViewGroup;
    handle command ViewGroupResponse;
    handle command GetGroupMembership;
    handle command GetGroupMembershipResponse;
    handle command RemoveGroup;
    handle command RemoveGroupResponse;
    handle command RemoveAllGroups;
    handle command AddGroupIfIdentifying;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute tagList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster Binding {
    callback attribute binding;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    emits event AccessControlExtensionChanged;
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry;
    callback attribute targetsPerAccessControlEntry;
    callback attribute accessControlEntriesPerFabric;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    callback attribute dataModelRevision;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    callback attribute nodeLabel;
    callback attribute location;
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate;
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    callback attribute localConfigDisabled;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    callback attribute productAppearance;
    callback attribute specificationVersion;
    callback attribute maxPathsPerInvoke;
    callback attribute configurationVersion;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster OtaSoftwareUpdateRequestor {
    emits event StateTransition;
    emits event VersionApplied;
    emits event DownloadError;
    callback attribute defaultOTAProviders;
    ram      attribute updatePossible default = 1;
    ram      attribute updateState default = 0;
    ram      attribute updateStateProgress default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AnnounceOTAProvider;
  }

  server cluster LocalizationConfiguration {
    persist  attribute activeLocale default = "en-US";
    callback attribute supportedLocales;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TimeFormatLocalization {
    persist  attribute hourFormat default = 0;
    persist  attribute activeCalendarType default = 0;
    callback attribute supportedCalendarTypes;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UnitLocalization {
    callback attribute temperatureUnit;
    callback attribute supportedTemperatureUnits;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster PowerSourceConfiguration {
    callback attribute sources;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster PowerSource {
    ram      attribute status default = 0;
    ram      attribute order default = 3;
    ram      attribute description default = "B1";
    ram      attribute batChargeLevel default = 0;
    ram      attribute batReplacementNeeded;
    ram      attribute batReplaceability;
    callback attribute endpointList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 2;
    ram      attribute clusterRevision default = 2;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig;
    callback attribute locationCapability;
    callback attribute supportsConcurrentConnection;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;

    handle command ArmFailSafe;
    handle command ArmFailSafeResponse;
    handle command SetRegulatoryConfig;
    handle command SetRegulatoryConfigResponse;
    handle command CommissioningComplete;
    handle command CommissioningCompleteResponse;
  }

  server cluster NetworkCommissioning {
    callback attribute maxNetworks;
    callback attribute networks;
    callback attribute scanMaxTimeSeconds;
    callback attribute connectMaxTimeSeconds;
    callback attribute interfaceEnabled;
    callback attribute lastNetworkingStatus;
    callback attribute lastNetworkID;
    callback attribute lastConnectErrorValue;
    callback attribute supportedWiFiBands;
    callback attribute supportedThreadFeatures;
    callback attribute threadVersion;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }

  server cluster DiagnosticLogs {
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command RetrieveLogsRequest;
    handle command RetrieveLogsResponse;
  }

  server cluster GeneralDiagnostics {
    emits event HardwareFaultChange;
    emits event RadioFaultChange;
    emits event NetworkFaultChange;
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount;
    callback attribute upTime;
    callback attribute totalOperationalHours;
    callback attribute bootReason;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    callback attribute testEventTriggersEnabled;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command TestEventTrigger;
    handle command TimeSnapshot;
    handle command TimeSnapshotResponse;
    handle command PayloadTestRequest;
    handle command PayloadTestResponse;
  }

  server cluster SoftwareDiagnostics {
    emits event SoftwareFault;
    callback attribute threadMetrics;
    callback attribute currentHeapFree;
    callback attribute currentHeapUsed;
    callback attribute currentHeapHighWatermark;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command ResetWatermarks;
  }

  server cluster ThreadNetworkDiagnostics {
    callback attribute channel;
    callback attribute routingRole;
    callback attribute networkName;
    callback attribute panId;
    callback attribute extendedPanId;
    callback attribute meshLocalPrefix;
    callback attribute overrunCount;
    callback attribute neighborTable;
    callback attribute routeTable;
    callback attribute partitionId;
    callback attribute weighting;
    callback attribute dataVersion;
    callback attribute stableDataVersion;
    callback attribute leaderRouterId;
    callback attribute detachedRoleCount;
    callback attribute childRoleCount;
    callback attribute routerRoleCount;
    callback attribute leaderRoleCount;
    callback attribute attachAttemptCount;
    callback attribute partitionIdChangeCount;
    callback attribute betterPartitionAttachAttemptCount;
    callback attribute parentChangeCount;
    callback attribute txTotalCount;
    callback attribute txUnicastCount;
    callback attribute txBroadcastCount;
    callback attribute txAckRequestedCount;
    callback attribute txAckedCount;
    callback attribute txNoAckRequestedCount;
    callback attribute txDataCount;
    callback attribute txDataPollCount;
    callback attribute txBeaconCount;
    callback attribute txBeaconRequestCount;
    callback attribute txOtherCount;
    callback attribute txRetryCount;
    callback attribute txDirectMaxRetryExpiryCount;
    callback attribute txIndirectMaxRetryExpiryCount;
    callback attribute txErrCcaCount;
    callback attribute txErrAbortCount;
    callback attribute txErrBusyChannelCount;
    callback attribute rxTotalCount;
    callback attribute rxUnicastCount;
    callback attribute rxBroadcastCount;
    callback attribute rxDataCount;
    callback attribute rxDataPollCount;
    callback attribute rxBeaconCount;
    callback attribute rxBeaconRequestCount;
    callback attribute rxOtherCount;
    callback attribute rxAddressFilteredCount;
    callback attribute rxDestAddrFilteredCount;
    callback attribute rxDuplicatedCount;
    callback attribute rxErrNoFrameCount;
    callback attribute rxErrUnknownNeighborCount;
    callback attribute rxErrInvalidSrcAddrCount;
    callback attribute rxErrSecCount;
    callback attribute rxErrFcsCount;
    callback attribute rxErrOtherCount;
    callback attribute activeTimestamp;
    callback attribute pendingTimestamp;
    callback attribute delay;
    callback attribute securityPolicy;
    callback attribute channelPage0Mask;
    callback attribute operationalDatasetComponents;
    callback attribute activeNetworkFaultsList;
    ram      attribute featureMap default = 0x000F;
    ram      attribute clusterRevision default = 2;

    handle command ResetCounts;
  }

  server cluster WiFiNetworkDiagnostics {
    emits event Disconnection;
    emits event AssociationFailure;
    emits event ConnectionStatus;
    callback attribute bssid;
    callback attribute securityType;
    callback attribute wiFiVersion;
    callback attribute channelNumber;
    callback attribute rssi;
    callback attribute beaconLostCount;
    callback attribute beaconRxCount;
    callback attribute packetMulticastRxCount;
    callback attribute packetMulticastTxCount;
    callback attribute packetUnicastRxCount;
    callback attribute packetUnicastTxCount;
    callback attribute currentMaxRate;
    callback attribute overrunCount;
    ram      attribute featureMap default = 3;
    callback attribute clusterRevision default = 1;

    handle command ResetCounts;
  }

  server cluster EthernetNetworkDiagnostics {
    callback attribute PHYRate;
    callback attribute fullDuplex;
    callback attribute packetRxCount;
    callback attribute packetTxCount;
    callback attribute txErrCount;
    callback attribute collisionCount;
    callback attribute overrunCount;
    callback attribute carrierDetect;
    callback attribute timeSinceReset;
    ram      attribute featureMap default = 3;
    callback attribute clusterRevision;

    handle command ResetCounts;
  }

  server cluster TimeSynchronization {
    emits event DSTTableEmpty;
    emits event DSTStatus;
    emits event TimeZoneStatus;
    emits event TimeFailure;
    emits event MissingTrustedTimeSource;
    callback attribute UTCTime;
    callback attribute granularity;
    ram      attribute timeSource default = 0x00;
    callback attribute trustedTimeSource;
    callback attribute defaultNTP;
    callback attribute timeZone;
    callback attribute DSTOffset;
    callback attribute localTime;
    ram      attribute timeZoneDatabase default = 0;
    callback attribute timeZoneListMaxSize;
    callback attribute DSTOffsetListMaxSize;
    ram      attribute supportsDNSResolve default = true;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x0B;
    ram      attribute clusterRevision default = 2;

    handle command SetUTCTime;
    handle command SetTrustedTimeSource;
    handle command SetTimeZone;
    handle command SetTimeZoneResponse;
    handle command SetDSTOffset;
    handle command SetDefaultNTP;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus;
    callback attribute adminFabricIndex;
    callback attribute adminVendorId;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    callback attribute clusterRevision;

    handle command OpenCommissioningWindow;
    handle command OpenBasicCommissioningWindow;
    handle command RevokeCommissioning;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AttestationRequest;
    handle command AttestationResponse;
    handle command CertificateChainRequest;
    handle command CertificateChainResponse;
    handle command CSRRequest;
    handle command CSRResponse;
    handle command AddNOC;
    handle command UpdateNOC;
    handle command NOCResponse;
    handle command UpdateFabricLabel;
    handle command RemoveFabric;
    handle command AddTrustedRootCertificate;
    handle command SetVIDVerificationStatement;
    handle command SignVIDVerificationRequest;
    handle command SignVIDVerificationResponse;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command KeySetWrite;
    handle command KeySetRead;
    handle command KeySetReadResponse;
    handle command KeySetRemove;
    handle command KeySetReadAllIndices;
    handle command KeySetReadAllIndicesResponse;
  }

  server cluster FixedLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UserLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster RelativeHumidityMeasurement {
    ram      attribute measuredValue;
    ram      attribute minMeasuredValue default = 0;
    ram      attribute maxMeasuredValue default = 0x2710;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster FaultInjection {
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command FailAtFault;
    handle command FailRandomlyAtFault;
  }
}
endpoint 1 {
  device type ma_powersource = 17, version 1;
  device type ma_onofflight = 256, version 1;

  binding cluster OnOff;

  server cluster Identify {
    ram      attribute identifyTime default = 0x0000;
    ram      attribute identifyType default = 0x0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 0x0005;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Groups {
    ram      attribute nameSupport;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command AddGroup;
    handle command AddGroupResponse;
    handle command ViewGroup;
    handle command ViewGroupResponse;
    handle command GetGroupMembership;
    handle command GetGroupMembershipResponse;
    handle command RemoveGroup;
    handle command RemoveGroupResponse;
    handle command RemoveAllGroups;
    handle command AddGroupIfIdentifying;
  }

  server cluster OnOff {
    persist  attribute onOff default = 0x00;
    ram      attribute globalSceneControl default = 0x01;
    ram      attribute onTime default = 0x0000;
    ram      attribute offWaitTime default = 0x0000;
    persist  attribute startUpOnOff default = 0xFF;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x0001;
    ram      attribute clusterRevision default = 6;

    handle command Off;
    handle command On;
    handle command Toggle;
    handle command OffWithEffect;
    handle command OnWithRecallGlobalScene;
    handle command OnWithTimedOff;
  }

  server cluster LevelControl {
    persist  attribute currentLevel default = 0xFE;
    ram      attribute remainingTime default = 0x0000;
    ram      attribute minLevel default = 0x01;
    ram      attribute maxLevel default = 0xFE;
    ram      attribute currentFrequency default = 0x0000;
    ram      attribute minFrequency default = 0x0000;
    ram      attribute maxFrequency default = 0x0000;
    ram      attribute options default = 0x00;
    ram      attribute onOffTransitionTime default = 0x0000;
    ram      attribute onLevel default = 0xFF;
    ram      attribute onTransitionTime;
    ram      attribute offTransitionTime;
    ram      attribute defaultMoveRate default = 50;
    persist  attribute startUpCurrentLevel default = 255;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 6;

    handle command MoveToLevel;
    handle command Move;
    handle command Step;
    handle command Stop;
    handle command MoveToLevelWithOnOff;
    handle command MoveWithOnOff;
    handle command StepWithOnOff;
    handle command StopWithOnOff;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute tagList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster Binding {
    callback attribute binding;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster Actions {
    callback attribute actionList;
    callback attribute endpointLists;
    ram      attribute setupURL default = "https://example.com";
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command InstantAction;
    handle command InstantActionWithTransition;
    handle command StartAction;
    handle command StartActionWithDuration;
    handle command StopAction;
    handle command PauseAction;
    handle command PauseActionWithDuration;
    handle command ResumeAction;
    handle command EnableAction;
    handle command EnableActionWithDuration;
    handle command DisableAction;
    handle command DisableActionWithDuration;
  }

  server cluster PowerSource {
    emits event BatFaultChange;
    ram      attribute status default = 0;
    ram      attribute order default = 2;
    ram      attribute description default = "B2";
    ram      attribute batChargeLevel default = 0;
    ram      attribute batReplacementNeeded;
    ram      attribute batReplaceability;
    callback attribute endpointList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 2;
    ram      attribute clusterRevision default = 2;
  }

  server cluster Switch {
    emits event SwitchLatched;
    ram      attribute numberOfPositions default = 2;
    ram      attribute currentPosition;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 2;
  }

  server cluster FixedLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UserLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster BooleanState {
    ram      attribute stateValue default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OvenCavityOperationalState {
    emits event OperationalError;
    emits event OperationCompletion;
    callback attribute phaseList;
    callback attribute currentPhase;
    callback attribute countdownTime;
    callback attribute operationalStateList;
    callback attribute operationalState;
    callback attribute operationalError;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command Stop;
    handle command Start;
    handle command OperationalCommandResponse;
  }

  server cluster OvenMode {
    callback attribute supportedModes;
    ram      attribute currentMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command ChangeToMode;
    handle command ChangeToModeResponse;
  }

  server cluster LaundryDryerControls {
    callback attribute supportedDrynessLevels;
    ram      attribute selectedDrynessLevel;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ModeSelect {
    ram      attribute description default = "Coffee";
    ram      attribute standardNamespace default = 0;
    callback attribute supportedModes;
    persist  attribute currentMode default = 0;
    persist  attribute startUpMode default = 0;
    persist  attribute onMode default = 255;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 2;
    ram      attribute manufacturerExtension default = 255;

    handle command ChangeToMode;
  }

  server cluster LaundryWasherMode {
    callback attribute supportedModes;
    callback attribute currentMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 2;

    handle command ChangeToMode;
    handle command ChangeToModeResponse;
  }

  server cluster RefrigeratorAndTemperatureControlledCabinetMode {
    callback attribute supportedModes;
    callback attribute currentMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 2;

    handle command ChangeToMode;
    handle command ChangeToModeResponse;
  }

  server cluster LaundryWasherControls {
    callback attribute spinSpeeds;
    ram      attribute spinSpeedCurrent;
    ram      attribute numberOfRinses;
    callback attribute supportedRinses;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;
  }

  server cluster RvcRunMode {
    callback attribute supportedModes;
    callback attribute currentMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;

    handle command ChangeToMode;
    handle command ChangeToModeResponse;
  }

  server cluster RvcCleanMode {
    callback attribute supportedModes;
    callback attribute currentMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;

    handle command ChangeToMode;
    handle command ChangeToModeResponse;
  }

  server cluster TemperatureControl {
    ram      attribute selectedTemperatureLevel default = 0;
    callback attribute supportedTemperatureLevels;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 2;
    ram      attribute clusterRevision default = 1;

    handle command SetTemperature;
  }

  server cluster RefrigeratorAlarm {
    emits event Notify;
    ram      attribute mask default = 1;
    ram      attribute state default = 0;
    ram      attribute supported default = 1;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster DishwasherMode {
    callback attribute supportedModes;
    callback attribute currentMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 2;

    handle command ChangeToMode;
    handle command ChangeToModeResponse;
  }

  server cluster AirQuality {
    callback attribute airQuality;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster SmokeCoAlarm {
    emits event SmokeAlarm;
    emits event COAlarm;
    emits event LowBattery;
    emits event HardwareFault;
    emits event EndOfService;
    emits event SelfTestComplete;
    emits event AlarmMuted;
    emits event MuteEnded;
    emits event InterconnectSmokeAlarm;
    emits event InterconnectCOAlarm;
    emits event AllClear;
    persist  attribute expressedState default = 0;
    persist  attribute smokeState default = 0;
    persist  attribute COState default = 0;
    persist  attribute batteryAlert default = 0;
    persist  attribute deviceMuted default = 0;
    ram      attribute testInProgress default = 0;
    persist  attribute hardwareFaultAlert default = 0;
    persist  attribute endOfServiceAlert default = 0;
    ram      attribute interconnectSmokeAlarm default = 0;
    ram      attribute interconnectCOAlarm default = 0;
    ram      attribute contaminationState default = 0;
    ram      attribute smokeSensitivityLevel default = 1;
    ram      attribute expiryDate default = 0;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;

    handle command SelfTestRequest;
  }

  server cluster DishwasherAlarm {
    emits event Notify;
    ram      attribute mask default = 1;
    ram      attribute latch default = 1;
    ram      attribute state default = 0;
    ram      attribute supported default = 15;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;

    handle command Reset;
    handle command ModifyEnabledAlarms;
  }

  server cluster MicrowaveOvenMode {
    callback attribute supportedModes;
    callback attribute currentMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OperationalState {
    emits event OperationalError;
    emits event OperationCompletion;
    callback attribute phaseList;
    callback attribute currentPhase;
    callback attribute countdownTime;
    callback attribute operationalStateList;
    callback attribute operationalState;
    callback attribute operationalError;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;

    handle command Pause;
    handle command Stop;
    handle command Start;
    handle command Resume;
    handle command OperationalCommandResponse;
  }

  server cluster RvcOperationalState {
    emits event OperationalError;
    emits event OperationCompletion;
    callback attribute phaseList;
    callback attribute currentPhase;
    callback attribute countdownTime;
    callback attribute operationalStateList;
    callback attribute operationalState;
    callback attribute operationalError;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command Pause;
    handle command Resume;
    handle command OperationalCommandResponse;
    handle command GoHome;
  }

  server cluster ScenesManagement {
    ram      attribute sceneTableSize default = 16;
    callback attribute fabricSceneInfo;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;

    handle command AddScene;
    handle command AddSceneResponse;
    handle command ViewScene;
    handle command ViewSceneResponse;
    handle command RemoveScene;
    handle command RemoveSceneResponse;
    handle command RemoveAllScenes;
    handle command RemoveAllScenesResponse;
    handle command StoreScene;
    handle command StoreSceneResponse;
    handle command RecallScene;
    handle command GetSceneMembership;
    handle command GetSceneMembershipResponse;
    handle command CopyScene;
    handle command CopySceneResponse;
  }

  server cluster HepaFilterMonitoring {
    callback attribute condition;
    callback attribute degradationDirection;
    callback attribute changeIndication;
    callback attribute inPlaceIndicator;
    callback attribute lastChangedTime;
    callback attribute replacementProductList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;

    handle command ResetCondition;
  }

  server cluster ActivatedCarbonFilterMonitoring {
    callback attribute condition;
    callback attribute degradationDirection;
    callback attribute changeIndication;
    callback attribute inPlaceIndicator;
    callback attribute lastChangedTime;
    callback attribute replacementProductList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;

    handle command ResetCondition;
  }

  server cluster BooleanStateConfiguration {
    emits event AlarmsStateChanged;
    emits event SensorFault;
    callback attribute currentSensitivityLevel;
    ram      attribute supportedSensitivityLevels default = 3;
    ram      attribute defaultSensitivityLevel default = 2;
    ram      attribute alarmsActive;
    ram      attribute alarmsSuppressed;
    persist  attribute alarmsEnabled;
    ram      attribute alarmsSupported default = 0x03;
    ram      attribute sensorFault default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x0F;
    ram      attribute clusterRevision default = 1;

    handle command SuppressAlarm;
    handle command EnableDisableAlarm;
  }

  server cluster ValveConfigurationAndControl {
    emits event ValveStateChanged;
    emits event ValveFault;
    ram      attribute openDuration;
    persist  attribute defaultOpenDuration;
    ram      attribute autoCloseTime;
    callback attribute remainingDuration;
    ram      attribute currentState;
    ram      attribute targetState;
    ram      attribute currentLevel;
    ram      attribute targetLevel;
    persist  attribute defaultOpenLevel default = 100;
    ram      attribute valveFault default = 0;
    ram      attribute levelStep default = 1;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;

    handle command Open;
    handle command Close;
  }

  server cluster EnergyPreference {
    callback attribute energyBalances;
    ram      attribute currentEnergyBalance;
    callback attribute energyPriorities;
    callback attribute lowPowerModeSensitivities;
    ram      attribute currentLowPowerModeSensitivity;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;
  }

  server cluster WindowCovering {
    ram      attribute type default = 0x08;
    ram      attribute physicalClosedLimitLift default = 0xFFFF;
    ram      attribute physicalClosedLimitTilt default = 0xFFFF;
    persist  attribute currentPositionLift default = 0x7FFF;
    persist  attribute currentPositionTilt default = 0x7FFF;
    persist  attribute numberOfActuationsLift default = 0x0000;
    persist  attribute numberOfActuationsTilt default = 0x0000;
    persist  attribute configStatus default = 0x03;
    persist  attribute currentPositionLiftPercentage default = 50;
    persist  attribute currentPositionTiltPercentage default = 50;
    ram      attribute operationalStatus default = 0x00;
    ram      attribute targetPositionLiftPercent100ths default = 5000;
    ram      attribute targetPositionTiltPercent100ths default = 5000;
    ram      attribute endProductType default = 0x00;
    persist  attribute currentPositionLiftPercent100ths default = 5000;
    persist  attribute currentPositionTiltPercent100ths default = 5000;
    persist  attribute installedOpenLimitLift default = 0x0000;
    persist  attribute installedClosedLimitLift default = 0xFFFF;
    persist  attribute installedOpenLimitTilt default = 0x0000;
    persist  attribute installedClosedLimitTilt default = 0xFFFF;
    persist  attribute mode default = 0x00;
    ram      attribute safetyStatus default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x17;
    ram      attribute clusterRevision default = 5;

    handle command UpOrOpen;
    handle command DownOrClose;
    handle command StopMotion;
    handle command GoToLiftValue;
    handle command GoToLiftPercentage;
    handle command GoToTiltValue;
    handle command GoToTiltPercentage;
  }

  server cluster PumpConfigurationAndControl {
    ram      attribute maxPressure;
    ram      attribute maxSpeed;
    ram      attribute maxFlow;
    ram      attribute minConstPressure;
    ram      attribute maxConstPressure;
    ram      attribute minCompPressure;
    ram      attribute maxCompPressure;
    ram      attribute minConstSpeed;
    ram      attribute maxConstSpeed;
    ram      attribute minConstFlow;
    ram      attribute maxConstFlow;
    ram      attribute minConstTemp;
    ram      attribute maxConstTemp;
    ram      attribute pumpStatus;
    ram      attribute effectiveOperationMode;
    ram      attribute effectiveControlMode;
    ram      attribute capacity;
    ram      attribute speed;
    ram      attribute lifetimeRunningHours default = 0x000000;
    ram      attribute power;
    ram      attribute lifetimeEnergyConsumed default = 0x00000000;
    ram      attribute operationMode default = 0x00;
    ram      attribute controlMode default = 0x00;
    ram      attribute featureMap default = 0x1F;
    ram      attribute clusterRevision default = 4;
  }

  server cluster Thermostat {
    ram      attribute localTemperature;
    ram      attribute absMinHeatSetpointLimit default = 0x02BC;
    ram      attribute absMaxHeatSetpointLimit default = 0x0BB8;
    ram      attribute absMinCoolSetpointLimit default = 0x0640;
    ram      attribute absMaxCoolSetpointLimit default = 0x0C80;
    ram      attribute localTemperatureCalibration default = 0x00;
    ram      attribute occupiedCoolingSetpoint default = 0x0A28;
    ram      attribute occupiedHeatingSetpoint default = 0x07D0;
    ram      attribute minHeatSetpointLimit default = 0x02BC;
    ram      attribute maxHeatSetpointLimit default = 0x0BB8;
    ram      attribute minCoolSetpointLimit default = 0x0640;
    ram      attribute maxCoolSetpointLimit default = 0x0C80;
    ram      attribute minSetpointDeadBand default = 0x19;
    ram      attribute controlSequenceOfOperation default = 0x04;
    ram      attribute systemMode default = 0x01;
    callback attribute presetTypes;
    callback attribute scheduleTypes;
    ram      attribute numberOfPresets default = 0;
    ram      attribute numberOfSchedules default = 0;
    ram      attribute numberOfScheduleTransitionPerDay default = 0xFF;
    ram      attribute activePresetHandle;
    ram      attribute activeScheduleHandle;
    callback attribute presets;
    callback attribute schedules;
    ram      attribute setpointHoldExpiryTimestamp;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x0123;
    ram      attribute clusterRevision default = 7;

    handle command SetpointRaiseLower;
    handle command SetActiveScheduleRequest;
    handle command SetActivePresetRequest;
    handle command AtomicResponse;
    handle command AtomicRequest;
  }

  server cluster FanControl {
    ram      attribute fanMode default = 0x00;
    ram      attribute fanModeSequence default = 0x02;
    ram      attribute percentSetting default = 0x00;
    ram      attribute percentCurrent default = 0x00;
    ram      attribute speedMax default = 100;
    ram      attribute speedSetting default = 0x00;
    ram      attribute speedCurrent default = 0x00;
    ram      attribute rockSupport default = 0x03;
    ram      attribute rockSetting default = 0x00;
    ram      attribute windSupport default = 0x03;
    ram      attribute windSetting default = 0x00;
    ram      attribute airflowDirection default = 0;
    ram      attribute featureMap default = 0x3F;
    ram      attribute clusterRevision default = 4;

    handle command Step;
  }

  server cluster ThermostatUserInterfaceConfiguration {
    ram      attribute temperatureDisplayMode default = 0x00;
    ram      attribute keypadLockout default = 0x00;
    ram      attribute scheduleProgrammingVisibility;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster ColorControl {
    persist  attribute currentHue default = 0x00;
    persist  attribute currentSaturation default = 0x00;
    ram      attribute remainingTime default = 0x0000;
    persist  attribute currentX default = 0x616B;
    persist  attribute currentY default = 0x607D;
    ram      attribute driftCompensation;
    ram      attribute compensationText;
    persist  attribute colorTemperatureMireds default = 0x00FA;
    ram      attribute colorMode default = 0x01;
    ram      attribute options default = 0x00;
    ram      attribute numberOfPrimaries;
    ram      attribute primary1X;
    ram      attribute primary1Y;
    ram      attribute primary1Intensity;
    ram      attribute primary2X;
    ram      attribute primary2Y;
    ram      attribute primary2Intensity;
    ram      attribute primary3X;
    ram      attribute primary3Y;
    ram      attribute primary3Intensity;
    ram      attribute primary4X;
    ram      attribute primary4Y;
    ram      attribute primary4Intensity;
    ram      attribute primary5X;
    ram      attribute primary5Y;
    ram      attribute primary5Intensity;
    ram      attribute primary6X;
    ram      attribute primary6Y;
    ram      attribute primary6Intensity;
    ram      attribute whitePointX;
    ram      attribute whitePointY;
    ram      attribute colorPointRX;
    ram      attribute colorPointRY;
    ram      attribute colorPointRIntensity;
    ram      attribute colorPointGX;
    ram      attribute colorPointGY;
    ram      attribute colorPointGIntensity;
    ram      attribute colorPointBX;
    ram      attribute colorPointBY;
    ram      attribute colorPointBIntensity;
    persist  attribute enhancedCurrentHue default = 0x0000;
    persist  attribute enhancedColorMode default = 0x01;
    persist  attribute colorLoopActive default = 0x00;
    persist  attribute colorLoopDirection default = 0x00;
    persist  attribute colorLoopTime default = 0x0019;
    ram      attribute colorLoopStartEnhancedHue default = 0x2300;
    ram      attribute colorLoopStoredEnhancedHue default = 0x0000;
    ram      attribute colorCapabilities default = 0x1F;
    ram      attribute colorTempPhysicalMinMireds default = 0x009A;
    ram      attribute colorTempPhysicalMaxMireds default = 0x01C6;
    ram      attribute coupleColorTempToLevelMinMireds default = 0x009A;
    persist  attribute startUpColorTemperatureMireds default = 0x00FA;
    ram      attribute featureMap default = 0x1F;
    ram      attribute clusterRevision default = 7;

    handle command MoveToHue;
    handle command MoveHue;
    handle command StepHue;
    handle command MoveToSaturation;
    handle command MoveSaturation;
    handle command StepSaturation;
    handle command MoveToHueAndSaturation;
    handle command MoveToColor;
    handle command MoveColor;
    handle command StepColor;
    handle command MoveToColorTemperature;
    handle command EnhancedMoveToHue;
    handle command EnhancedMoveHue;
    handle command EnhancedStepHue;
    handle command EnhancedMoveToHueAndSaturation;
    handle command ColorLoopSet;
    handle command StopMoveStep;
    handle command MoveColorTemperature;
    handle command StepColorTemperature;
  }

  server cluster BallastConfiguration {
    ram      attribute physicalMinLevel default = 0x01;
    ram      attribute physicalMaxLevel default = 0xFE;
    ram      attribute ballastStatus default = 0x00;
    ram      attribute minLevel default = 0x01;
    ram      attribute maxLevel default = 0xFE;
    ram      attribute intrinsicBallastFactor;
    ram      attribute ballastFactorAdjustment default = 0xFF;
    ram      attribute lampQuantity;
    ram      attribute lampType;
    ram      attribute lampManufacturer;
    ram      attribute lampRatedHours default = 0xFFFFFF;
    ram      attribute lampBurnHours default = 0x000000;
    ram      attribute lampAlarmMode default = 0x00;
    ram      attribute lampBurnHoursTripPoint default = 0xFFFFFF;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;
  }

  server cluster IlluminanceMeasurement {
    ram      attribute measuredValue default = 0x0000;
    ram      attribute minMeasuredValue default = 0x01;
    ram      attribute maxMeasuredValue default = 0xFFFE;
    ram      attribute tolerance;
    ram      attribute lightSensorType default = 0xFF;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster TemperatureMeasurement {
    ram      attribute measuredValue default = 0x8000;
    ram      attribute minMeasuredValue default = 0x8000;
    ram      attribute maxMeasuredValue default = 0x8000;
    ram      attribute tolerance;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;
  }

  server cluster PressureMeasurement {
    ram      attribute measuredValue default = 0x0000;
    ram      attribute minMeasuredValue;
    ram      attribute maxMeasuredValue;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster FlowMeasurement {
    ram      attribute measuredValue default = 5;
    ram      attribute minMeasuredValue default = 0;
    ram      attribute maxMeasuredValue default = 100;
    ram      attribute tolerance default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster RelativeHumidityMeasurement {
    ram      attribute measuredValue;
    ram      attribute minMeasuredValue default = 0;
    ram      attribute maxMeasuredValue default = 0x2710;
    ram      attribute tolerance;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster OccupancySensing {
    ram      attribute occupancy;
    ram      attribute occupancySensorType;
    ram      attribute occupancySensorTypeBitmap default = 1;
    callback attribute holdTime;
    callback attribute holdTimeLimits;
    callback attribute PIROccupiedToUnoccupiedDelay;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 5;
  }

  server cluster CarbonMonoxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster CarbonDioxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster NitrogenDioxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster OzoneConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Pm25ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster FormaldehydeConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Pm1ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Pm10ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster TotalVolatileOrganicCompoundsConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster RadonConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster SoilMeasurement {
    callback attribute soilMoistureMeasurementLimits;
    callback attribute soilMoistureMeasuredValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster WakeOnLan {
    ram      attribute MACAddress;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster LowPower {
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command Sleep;
  }

  server cluster CameraAvStreamManagement {
    callback attribute maxConcurrentEncoders;
    callback attribute maxEncodedPixelRate;
    callback attribute videoSensorParams;
    callback attribute nightVisionUsesInfrared;
    callback attribute minViewportResolution;
    callback attribute rateDistortionTradeOffPoints;
    callback attribute maxContentBufferSize;
    callback attribute microphoneCapabilities;
    callback attribute speakerCapabilities;
    callback attribute twoWayTalkSupport;
    callback attribute snapshotCapabilities;
    callback attribute maxNetworkBandwidth;
    callback attribute currentFrameRate;
    callback attribute HDRModeEnabled;
    callback attribute supportedStreamUsages;
    callback attribute allocatedVideoStreams;
    callback attribute allocatedAudioStreams;
    callback attribute allocatedSnapshotStreams;
    callback attribute streamUsagePriorities;
    callback attribute softRecordingPrivacyModeEnabled;
    callback attribute softLivestreamPrivacyModeEnabled;
    callback attribute hardPrivacyModeOn;
    callback attribute nightVision;
    callback attribute nightVisionIllum;
    callback attribute viewport;
    callback attribute speakerMuted;
    callback attribute speakerVolumeLevel;
    callback attribute speakerMaxLevel;
    callback attribute speakerMinLevel;
    callback attribute microphoneMuted;
    callback attribute microphoneVolumeLevel;
    callback attribute microphoneMaxLevel;
    callback attribute microphoneMinLevel;
    callback attribute microphoneAGCEnabled;
    callback attribute imageRotation;
    callback attribute imageFlipHorizontal;
    callback attribute imageFlipVertical;
    callback attribute localVideoRecordingEnabled;
    callback attribute localSnapshotRecordingEnabled;
    callback attribute statusLightEnabled;
    callback attribute statusLightBrightness;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;

    handle command SnapshotStreamAllocate;
    handle command SnapshotStreamAllocateResponse;
    handle command SnapshotStreamDeallocate;
    handle command SetStreamPriorities;
    handle command CaptureSnapshot;
    handle command CaptureSnapshotResponse;
  }

  server cluster CameraAvSettingsUserLevelManagement {
    callback attribute MPTZPosition;
    ram      attribute maxPresets default = 5;
    callback attribute MPTZPresets;
    callback attribute DPTZStreams;
    ram      attribute zoomMax default = 100;
    ram      attribute tiltMin default = -90;
    ram      attribute tiltMax default = 90;
    ram      attribute panMin default = -180;
    ram      attribute panMax default = 180;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command MPTZSetPosition;
    handle command MPTZRelativeMove;
    handle command MPTZMoveToPreset;
    handle command MPTZSavePreset;
    handle command MPTZRemovePreset;
    handle command DPTZSetViewport;
    handle command DPTZRelativeMove;
  }

  server cluster PushAvStreamTransport {
    emits event PushTransportBegin;
    emits event PushTransportEnd;
    callback attribute supportedFormats;
    callback attribute currentConnections;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AllocatePushTransport;
    handle command AllocatePushTransportResponse;
    handle command DeallocatePushTransport;
    handle command ModifyPushTransport;
    handle command SetTransportStatus;
    handle command ManuallyTriggerTransport;
    handle command FindTransport;
    handle command FindTransportResponse;
  }

  server cluster Chime {
    callback attribute installedChimeSounds;
    callback attribute selectedChime;
    callback attribute enabled;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command PlayChimeSound;
  }

  server cluster TlsCertificateManagement {
    callback attribute maxRootCertificates;
    callback attribute provisionedRootCertificates;
    callback attribute maxClientCertificates;
    callback attribute provisionedClientCertificates;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision;

    handle command ProvisionRootCertificate;
    handle command ProvisionRootCertificateResponse;
    handle command FindRootCertificate;
    handle command FindRootCertificateResponse;
    handle command LookupRootCertificate;
    handle command LookupRootCertificateResponse;
    handle command RemoveRootCertificate;
    handle command TLSClientCSR;
    handle command TLSClientCSRResponse;
    handle command ProvisionClientCertificate;
    handle command FindClientCertificate;
    handle command FindClientCertificateResponse;
    handle command LookupClientCertificate;
    handle command LookupClientCertificateResponse;
    handle command RemoveClientCertificate;
  }

  server cluster TlsClientManagement {
    callback attribute maxProvisioned;
    callback attribute provisionedEndpoints;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision;

    handle command ProvisionEndpoint;
    handle command ProvisionEndpointResponse;
    handle command FindEndpoint;
    handle command FindEndpointResponse;
    handle command RemoveEndpoint;
  }

  server cluster UnitTesting {
    emits event TestEvent;
    emits event TestFabricScopedEvent;
    emits event TestDifferentVendorMeiEvent;
    ram      attribute boolean default = false;
    ram      attribute bitmap8 default = 0;
    ram      attribute bitmap16 default = 0;
    ram      attribute bitmap32 default = 0;
    ram      attribute bitmap64 default = 0;
    ram      attribute int8u default = 0;
    ram      attribute int16u default = 0;
    ram      attribute int24u default = 0;
    ram      attribute int32u default = 0;
    ram      attribute int40u default = 0;
    ram      attribute int48u default = 0;
    ram      attribute int56u default = 0;
    ram      attribute int64u default = 0;
    ram      attribute int8s default = 0;
    ram      attribute int16s default = 0;
    ram      attribute int24s default = 0;
    ram      attribute int32s default = 0;
    ram      attribute int40s default = 0;
    ram      attribute int48s default = 0;
    ram      attribute int56s default = 0;
    ram      attribute int64s default = 0;
    ram      attribute enum8 default = 0;
    ram      attribute enum16 default = 0;
    ram      attribute floatSingle default = 0;
    ram      attribute floatDouble default = 0;
    ram      attribute octetString;
    callback attribute listInt8u;
    callback attribute listOctetString;
    callback attribute listStructOctetString;
    ram      attribute longOctetString;
    ram      attribute charString;
    ram      attribute longCharString;
    ram      attribute epochUs;
    ram      attribute epochS;
    ram      attribute vendorId;
    callback attribute listNullablesAndOptionalsStruct;
    ram      attribute enumAttr;
    callback attribute structAttr;
    ram      attribute rangeRestrictedInt8u default = 70;
    ram      attribute rangeRestrictedInt8s default = -20;
    ram      attribute rangeRestrictedInt16u default = 200;
    ram      attribute rangeRestrictedInt16s default = -100;
    callback attribute listLongOctetString;
    callback attribute listFabricScoped;
    ram      attribute timedWriteBoolean;
    callback attribute generalErrorBoolean;
    callback attribute clusterErrorBoolean;
    ram      attribute globalEnum;
    callback attribute globalStruct;
    ram      attribute readFailureCode default = 1;
    callback attribute failureInt32U default = 0;
    ram      attribute nullableBoolean default = false;
    ram      attribute nullableBitmap8 default = 0;
    ram      attribute nullableBitmap16 default = 0;
    ram      attribute nullableBitmap32 default = 0;
    ram      attribute nullableBitmap64 default = 0;
    ram      attribute nullableInt8u default = 0;
    ram      attribute nullableInt16u default = 0;
    ram      attribute nullableInt24u default = 0;
    ram      attribute nullableInt32u default = 0;
    ram      attribute nullableInt40u default = 0;
    ram      attribute nullableInt48u default = 0;
    ram      attribute nullableInt56u default = 0;
    ram      attribute nullableInt64u default = 0;
    ram      attribute nullableInt8s default = 0;
    ram      attribute nullableInt16s default = 0;
    ram      attribute nullableInt24s default = 0;
    ram      attribute nullableInt32s default = 0;
    ram      attribute nullableInt40s default = 0;
    ram      attribute nullableInt48s default = 0;
    ram      attribute nullableInt56s default = 0;
    ram      attribute nullableInt64s default = 0;
    ram      attribute nullableEnum8 default = 0;
    ram      attribute nullableEnum16 default = 0;
    ram      attribute nullableFloatSingle default = 0;
    ram      attribute nullableFloatDouble default = 0;
    ram      attribute nullableOctetString;
    ram      attribute nullableCharString;
    ram      attribute nullableEnumAttr;
    callback attribute nullableStruct;
    ram      attribute nullableRangeRestrictedInt8u default = 70;
    ram      attribute nullableRangeRestrictedInt8s default = -20;
    ram      attribute nullableRangeRestrictedInt16u default = 200;
    ram      attribute nullableRangeRestrictedInt16s default = -100;
    callback attribute writeOnlyInt8u default = 0;
    ram      attribute nullableGlobalEnum;
    callback attribute nullableGlobalStruct;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
    ram      attribute meiInt8u default = 0;

    handle command Test;
    handle command TestSpecificResponse;
    handle command TestNotHandled;
    handle command TestAddArgumentsResponse;
    handle command TestSpecific;
    handle command TestAddArguments;
    handle command TestListInt8UReverseResponse;
    handle command TestEnumsResponse;
    handle command TestNullableOptionalResponse;
    handle command TestStructArgumentRequest;
    handle command TestNestedStructArgumentRequest;
    handle command TestListStructArgumentRequest;
    handle command SimpleStructResponse;
    handle command TestListInt8UArgumentRequest;
    handle command TestEmitTestEventResponse;
    handle command TestNestedStructListArgumentRequest;
    handle command TestEmitTestFabricScopedEventResponse;
    handle command TestListNestedStructListArgumentRequest;
    handle command TestListInt8UReverseRequest;
    handle command StringEchoResponse;
    handle command TestEnumsRequest;
    handle command GlobalEchoResponse;
    handle command TestNullableOptionalRequest;
    handle command SimpleStructEchoRequest;
    handle command TimedInvokeRequest;
    handle command TestSimpleOptionalArgumentRequest;
    handle command TestEmitTestEventRequest;
    handle command TestEmitTestFabricScopedEventRequest;
    handle command TestBatchHelperRequest;
    handle command TestSecondBatchHelperRequest;
    handle command StringEchoRequest;
    handle command GlobalEchoRequest;
    handle command TestCheckCommandFlags;
    handle command TestDifferentVendorMeiRequest;
    handle command TestDifferentVendorMeiResponse;
  }
}
endpoint 2 {
  device type ma_powersource = 17, version 1;
  device type ma_onofflight = 256, version 1;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0000;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 0x0005;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Groups {
    ram      attribute nameSupport;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command AddGroup;
    handle command AddGroupResponse;
    handle command ViewGroup;
    handle command ViewGroupResponse;
    handle command GetGroupMembership;
    handle command GetGroupMembershipResponse;
    handle command RemoveGroup;
    handle command RemoveGroupResponse;
    handle command RemoveAllGroups;
    handle command AddGroupIfIdentifying;
  }

  server cluster OnOff {
    ram      attribute onOff default = 0x00;
    ram      attribute globalSceneControl default = 1;
    ram      attribute onTime default = 0;
    ram      attribute offWaitTime default = 0;
    ram      attribute startUpOnOff;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x0001;
    ram      attribute clusterRevision default = 6;

    handle command Off;
    handle command On;
    handle command Toggle;
    handle command OffWithEffect;
    handle command OnWithRecallGlobalScene;
    handle command OnWithTimedOff;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute tagList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster PowerSource {
    ram      attribute status default = 0;
    ram      attribute order default = 1;
    ram      attribute description default = "B3";
    ram      attribute batChargeLevel default = 0;
    ram      attribute batReplacementNeeded;
    ram      attribute batReplaceability;
    callback attribute endpointList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 2;
    ram      attribute clusterRevision default = 2;
  }

  server cluster ScenesManagement {
    ram      attribute sceneTableSize default = 16;
    callback attribute fabricSceneInfo;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;

    handle command AddScene;
    handle command AddSceneResponse;
    handle command ViewScene;
    handle command ViewSceneResponse;
    handle command RemoveScene;
    handle command RemoveSceneResponse;
    handle command RemoveAllScenes;
    handle command RemoveAllScenesResponse;
    handle command StoreScene;
    handle command StoreSceneResponse;
    handle command RecallScene;
    handle command GetSceneMembership;
    handle command GetSceneMembershipResponse;
    handle command CopyScene;
    handle command CopySceneResponse;
  }

  server cluster OccupancySensing {
    ram      attribute occupancy;
    ram      attribute occupancySensorType;
    ram      attribute occupancySensorTypeBitmap default = 1;
    callback attribute holdTime;
    callback attribute holdTimeLimits;
    callback attribute PIROccupiedToUnoccupiedDelay;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 5;
  }
}
endpoint 3 {
  device type ma_genericswitch = 15, version 3;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0000;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 0x0005;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute tagList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster Switch {
    emits event InitialPress;
    emits event LongPress;
    emits event LongRelease;
    emits event MultiPressComplete;
    ram      attribute numberOfPositions default = 2;
    ram      attribute currentPosition default = 0;
    ram      attribute multiPressMax default = 3;
    ram      attribute featureMap default = 58;
    ram      attribute clusterRevision default = 2;
  }
}
endpoint 4 {
  device type ma_genericswitch = 15, version 3;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0000;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 0x0005;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute tagList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster Switch {
    ram      attribute numberOfPositions default = 2;
    ram      attribute currentPosition default = 0;
    ram      attribute multiPressMax default = 3;
    ram      attribute featureMap default = 30;
    ram      attribute clusterRevision default = 2;
  }
}
endpoint 65534 {
  device type ma_secondary_network_interface = 25, version 1;


  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster NetworkCommissioning {
    callback attribute maxNetworks;
    callback attribute networks;
    callback attribute scanMaxTimeSeconds;
    callback attribute connectMaxTimeSeconds;
    callback attribute interfaceEnabled;
    callback attribute lastNetworkingStatus;
    callback attribute lastNetworkID;
    callback attribute lastConnectErrorValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }
}


