// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

enum AreaTypeTag : enum8 {
  kAisle = 0;
  kAttic = 1;
  kBackDoor = 2;
  kBackYard = 3;
  kBalcony = 4;
  kBallroom = 5;
  kBathroom = 6;
  kBedroom = 7;
  kBorder = 8;
  kBoxroom = 9;
  kBreakfastRoom = 10;
  kCarport = 11;
  kCellar = 12;
  kCloakroom = 13;
  kCloset = 14;
  kConservatory = 15;
  kCorridor = 16;
  kCraftRoom = 17;
  kCupboard = 18;
  kDeck = 19;
  kDen = 20;
  kDining = 21;
  kDrawingRoom = 22;
  kDressingRoom = 23;
  kDriveway = 24;
  kElevator = 25;
  kEnsuite = 26;
  kEntrance = 27;
  kEntryway = 28;
  kFamilyRoom = 29;
  kFoyer = 30;
  kFrontDoor = 31;
  kFrontYard = 32;
  kGameRoom = 33;
  kGarage = 34;
  kGarageDoor = 35;
  kGarden = 36;
  kGardenDoor = 37;
  kGuestBathroom = 38;
  kGuestBedroom = 39;
  kGuestRestroom = 40;
  kGuestRoom = 41;
  kGym = 42;
  kHallway = 43;
  kHearthRoom = 44;
  kKidsRoom = 45;
  kKidsBedroom = 46;
  kKitchen = 47;
  kLarder = 48;
  kLaundryRoom = 49;
  kLawn = 50;
  kLibrary = 51;
  kLivingRoom = 52;
  kLounge = 53;
  kMediaTVRoom = 54;
  kMudRoom = 55;
  kMusicRoom = 56;
  kNursery = 57;
  kOffice = 58;
  kOutdoorKitchen = 59;
  kOutside = 60;
  kPantry = 61;
  kParkingLot = 62;
  kParlor = 63;
  kPatio = 64;
  kPlayRoom = 65;
  kPoolRoom = 66;
  kPorch = 67;
  kPrimaryBathroom = 68;
  kPrimaryBedroom = 69;
  kRamp = 70;
  kReceptionRoom = 71;
  kRecreationRoom = 72;
  kRestroom = 73;
  kRoof = 74;
  kSauna = 75;
  kScullery = 76;
  kSewingRoom = 77;
  kShed = 78;
  kSideDoor = 79;
  kSideYard = 80;
  kSittingRoom = 81;
  kSnug = 82;
  kSpa = 83;
  kStaircase = 84;
  kSteamRoom = 85;
  kStorageRoom = 86;
  kStudio = 87;
  kStudy = 88;
  kSunRoom = 89;
  kSwimmingPool = 90;
  kTerrace = 91;
  kUtilityRoom = 92;
  kWard = 93;
  kWorkshop = 94;
}

enum AtomicRequestTypeEnum : enum8 {
  kBeginWrite = 0;
  kCommitWrite = 1;
  kRollbackWrite = 2;
}

enum FloorSurfaceTag : enum8 {
  kCarpet = 0;
  kCeramic = 1;
  kConcrete = 2;
  kCork = 3;
  kDeepCarpet = 4;
  kDirt = 5;
  kEngineeredWood = 6;
  kGlass = 7;
  kGrass = 8;
  kHardwood = 9;
  kLaminate = 10;
  kLinoleum = 11;
  kMat = 12;
  kMetal = 13;
  kPlastic = 14;
  kPolishedConcrete = 15;
  kRubber = 16;
  kRug = 17;
  kSand = 18;
  kStone = 19;
  kTatami = 20;
  kTerrazzo = 21;
  kTile = 22;
  kVinyl = 23;
}

enum LandmarkTag : enum8 {
  kAirConditioner = 0;
  kAirPurifier = 1;
  kBackDoor = 2;
  kBarStool = 3;
  kBathMat = 4;
  kBathtub = 5;
  kBed = 6;
  kBookshelf = 7;
  kChair = 8;
  kChristmasTree = 9;
  kCoatRack = 10;
  kCoffeeTable = 11;
  kCookingRange = 12;
  kCouch = 13;
  kCountertop = 14;
  kCradle = 15;
  kCrib = 16;
  kDesk = 17;
  kDiningTable = 18;
  kDishwasher = 19;
  kDoor = 20;
  kDresser = 21;
  kLaundryDryer = 22;
  kFan = 23;
  kFireplace = 24;
  kFreezer = 25;
  kFrontDoor = 26;
  kHighChair = 27;
  kKitchenIsland = 28;
  kLamp = 29;
  kLitterBox = 30;
  kMirror = 31;
  kNightstand = 32;
  kOven = 33;
  kPetBed = 34;
  kPetBowl = 35;
  kPetCrate = 36;
  kRefrigerator = 37;
  kScratchingPost = 38;
  kShoeRack = 39;
  kShower = 40;
  kSideDoor = 41;
  kSink = 42;
  kSofa = 43;
  kStove = 44;
  kTable = 45;
  kToilet = 46;
  kTrashCan = 47;
  kLaundryWasher = 48;
  kWindow = 49;
  kWineCooler = 50;
}

enum PositionTag : enum8 {
  kLeft = 0;
  kRight = 1;
  kTop = 2;
  kBottom = 3;
  kMiddle = 4;
  kRow = 5;
  kColumn = 6;
}

enum RelativePositionTag : enum8 {
  kUnder = 0;
  kNextTo = 1;
  kAround = 2;
  kOn = 3;
  kAbove = 4;
  kFrontOf = 5;
  kBehind = 6;
}

enum TestGlobalEnum : enum8 {
  kSomeValue = 0;
  kSomeOtherValue = 1;
  kFinalValue = 2;
}

enum ThreeLevelAutoEnum : enum8 {
  kLow = 0;
  kMedium = 1;
  kHigh = 2;
  kAutomatic = 3;
}

bitmap TestGlobalBitmap : bitmap32 {
  kFirstBit = 0x1;
  kSecondBit = 0x2;
}

struct TestGlobalStruct {
  char_string<128> name = 0;
  nullable TestGlobalBitmap myBitmap = 1;
  optional nullable TestGlobalEnum myEnum = 2;
}

struct LocationDescriptorStruct {
  char_string<128> locationName = 0;
  nullable int16s floorNumber = 1;
  nullable AreaTypeTag areaType = 2;
}

struct AtomicAttributeStatusStruct {
  attrib_id attributeID = 0;
  status statusCode = 1;
}

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
cluster Identify = 3 {
  revision 4;

  enum EffectIdentifierEnum : enum8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum EffectVariantEnum : enum8 {
    kDefault = 0;
  }

  enum IdentifyTypeEnum : enum8 {
    kNone = 0;
    kLightOutput = 1;
    kVisibleIndicator = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute IdentifyTypeEnum identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    int16u identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    EffectVariantEnum effectVariant = 1;
  }

  /** Command description for Identify */
  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  /** Command description for TriggerEffect */
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
cluster Identify = 3 {
  revision 4;

  enum EffectIdentifierEnum : enum8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum EffectVariantEnum : enum8 {
    kDefault = 0;
  }

  enum IdentifyTypeEnum : enum8 {
    kNone = 0;
    kLightOutput = 1;
    kVisibleIndicator = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute IdentifyTypeEnum identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    int16u identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    EffectVariantEnum effectVariant = 1;
  }

  /** Command description for Identify */
  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  /** Command description for TriggerEffect */
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** Attributes and commands for group configuration and manipulation. */
cluster Groups = 4 {
  revision 4;

  bitmap Feature : bitmap32 {
    kGroupNames = 0x1;
  }

  bitmap NameSupportBitmap : bitmap8 {
    kGroupNames = 0x80;
  }

  readonly attribute NameSupportBitmap nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  response struct ViewGroupResponse = 1 {
    enum8 status = 0;
    group_id groupID = 1;
    char_string<16> groupName = 2;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable int8u capacity = 0;
    group_id groupList[] = 1;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  response struct RemoveGroupResponse = 3 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  /** Command description for AddGroup */
  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  /** Command description for ViewGroup */
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  /** Command description for GetGroupMembership */
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  /** Command description for RemoveGroup */
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  /** Command description for RemoveAllGroups */
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  /** Command description for AddGroupIfIdentifying */
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

/** Attributes and commands for switching devices between 'On' and 'Off' states. */
cluster OnOff = 6 {
  revision 6;

  enum DelayedAllOffEffectVariantEnum : enum8 {
    kDelayedOffFastFade = 0;
    kNoFade = 1;
    kDelayedOffSlowFade = 2;
  }

  enum DyingLightEffectVariantEnum : enum8 {
    kDyingLightFadeOff = 0;
  }

  enum EffectIdentifierEnum : enum8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum StartUpOnOffEnum : enum8 {
    kOff = 0;
    kOn = 1;
    kToggle = 2;
  }

  bitmap Feature : bitmap32 {
    kLighting = 0x1;
    kDeadFrontBehavior = 0x2;
    kOffOnly = 0x4;
  }

  bitmap OnOffControlBitmap : bitmap8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute optional boolean globalSceneControl = 16384;
  attribute optional int16u onTime = 16385;
  attribute optional int16u offWaitTime = 16386;
  attribute access(write: manage) optional nullable StartUpOnOffEnum startUpOnOff = 16387;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OffWithEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    enum8 effectVariant = 1;
  }

  request struct OnWithTimedOffRequest {
    OnOffControlBitmap onOffControl = 0;
    int16u onTime = 1;
    int16u offWaitTime = 2;
  }

  /** On receipt of this command, a device SHALL enter its ‘Off’ state. This state is device dependent, but it is recommended that it is used for power off or similar functions. On receipt of the Off command, the OnTime attribute SHALL be set to 0. */
  command Off(): DefaultSuccess = 0;
  /** On receipt of this command, a device SHALL enter its ‘On’ state. This state is device dependent, but it is recommended that it is used for power on or similar functions. On receipt of the On command, if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. */
  command On(): DefaultSuccess = 1;
  /** On receipt of this command, if a device is in its ‘Off’ state it SHALL enter its ‘On’ state. Otherwise, if it is in its ‘On’ state it SHALL enter its ‘Off’ state. On receipt of the Toggle command, if the value of the OnOff attribute is equal to FALSE and if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. If the value of the OnOff attribute is equal to TRUE, the OnTime attribute SHALL be set to 0. */
  command Toggle(): DefaultSuccess = 2;
  /** The OffWithEffect command allows devices to be turned off using enhanced ways of fading. */
  command OffWithEffect(OffWithEffectRequest): DefaultSuccess = 64;
  /** The OnWithRecallGlobalScene command allows the recall of the settings when the device was turned off. */
  command OnWithRecallGlobalScene(): DefaultSuccess = 65;
  /** The OnWithTimedOff command allows devices to be turned on for a specific duration with a guarded off duration so that SHOULD the device be subsequently switched off, further OnWithTimedOff commands, received during this time, are prevented from turning the devices back on. */
  command OnWithTimedOff(OnWithTimedOffRequest): DefaultSuccess = 66;
}

/** Attributes and commands for switching devices between 'On' and 'Off' states. */
cluster OnOff = 6 {
  revision 6;

  enum DelayedAllOffEffectVariantEnum : enum8 {
    kDelayedOffFastFade = 0;
    kNoFade = 1;
    kDelayedOffSlowFade = 2;
  }

  enum DyingLightEffectVariantEnum : enum8 {
    kDyingLightFadeOff = 0;
  }

  enum EffectIdentifierEnum : enum8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum StartUpOnOffEnum : enum8 {
    kOff = 0;
    kOn = 1;
    kToggle = 2;
  }

  bitmap Feature : bitmap32 {
    kLighting = 0x1;
    kDeadFrontBehavior = 0x2;
    kOffOnly = 0x4;
  }

  bitmap OnOffControlBitmap : bitmap8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute optional boolean globalSceneControl = 16384;
  attribute optional int16u onTime = 16385;
  attribute optional int16u offWaitTime = 16386;
  attribute access(write: manage) optional nullable StartUpOnOffEnum startUpOnOff = 16387;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OffWithEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    enum8 effectVariant = 1;
  }

  request struct OnWithTimedOffRequest {
    OnOffControlBitmap onOffControl = 0;
    int16u onTime = 1;
    int16u offWaitTime = 2;
  }

  /** On receipt of this command, a device SHALL enter its ‘Off’ state. This state is device dependent, but it is recommended that it is used for power off or similar functions. On receipt of the Off command, the OnTime attribute SHALL be set to 0. */
  command Off(): DefaultSuccess = 0;
  /** On receipt of this command, a device SHALL enter its ‘On’ state. This state is device dependent, but it is recommended that it is used for power on or similar functions. On receipt of the On command, if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. */
  command On(): DefaultSuccess = 1;
  /** On receipt of this command, if a device is in its ‘Off’ state it SHALL enter its ‘On’ state. Otherwise, if it is in its ‘On’ state it SHALL enter its ‘Off’ state. On receipt of the Toggle command, if the value of the OnOff attribute is equal to FALSE and if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. If the value of the OnOff attribute is equal to TRUE, the OnTime attribute SHALL be set to 0. */
  command Toggle(): DefaultSuccess = 2;
  /** The OffWithEffect command allows devices to be turned off using enhanced ways of fading. */
  command OffWithEffect(OffWithEffectRequest): DefaultSuccess = 64;
  /** The OnWithRecallGlobalScene command allows the recall of the settings when the device was turned off. */
  command OnWithRecallGlobalScene(): DefaultSuccess = 65;
  /** The OnWithTimedOff command allows devices to be turned on for a specific duration with a guarded off duration so that SHOULD the device be subsequently switched off, further OnWithTimedOff commands, received during this time, are prevented from turning the devices back on. */
  command OnWithTimedOff(OnWithTimedOffRequest): DefaultSuccess = 66;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
cluster LevelControl = 8 {
  revision 6;

  enum MoveModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute optional int16u remainingTime = 1;
  readonly attribute optional int8u minLevel = 2;
  readonly attribute optional int8u maxLevel = 3;
  readonly attribute optional int16u currentFrequency = 4;
  readonly attribute optional int16u minFrequency = 5;
  readonly attribute optional int16u maxFrequency = 6;
  attribute OptionsBitmap options = 15;
  attribute optional int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute optional nullable int16u onTransitionTime = 18;
  attribute optional nullable int16u offTransitionTime = 19;
  attribute optional nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) optional nullable int8u startUpCurrentLevel = 16384;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToClosestFrequencyRequest {
    int16u frequency = 0;
  }

  /** Command description for MoveToLevel */
  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  /** Command description for Move */
  command Move(MoveRequest): DefaultSuccess = 1;
  /** Command description for Step */
  command Step(StepRequest): DefaultSuccess = 2;
  /** Command description for Stop */
  command Stop(StopRequest): DefaultSuccess = 3;
  /** Command description for MoveToLevelWithOnOff */
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  /** Command description for MoveWithOnOff */
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  /** Command description for StepWithOnOff */
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  /** Command description for StopWithOnOff */
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
  /** Change the currrent frequency to the provided one, or a close
        approximation if the exact provided one is not possible. */
  command MoveToClosestFrequency(MoveToClosestFrequencyRequest): DefaultSuccess = 8;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
cluster LevelControl = 8 {
  revision 6;

  enum MoveModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute optional int16u remainingTime = 1;
  readonly attribute optional int8u minLevel = 2;
  readonly attribute optional int8u maxLevel = 3;
  readonly attribute optional int16u currentFrequency = 4;
  readonly attribute optional int16u minFrequency = 5;
  readonly attribute optional int16u maxFrequency = 6;
  attribute OptionsBitmap options = 15;
  attribute optional int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute optional nullable int16u onTransitionTime = 18;
  attribute optional nullable int16u offTransitionTime = 19;
  attribute optional nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) optional nullable int8u startUpCurrentLevel = 16384;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToClosestFrequencyRequest {
    int16u frequency = 0;
  }

  /** Command description for MoveToLevel */
  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  /** Command description for Move */
  command Move(MoveRequest): DefaultSuccess = 1;
  /** Command description for Step */
  command Step(StepRequest): DefaultSuccess = 2;
  /** Command description for Stop */
  command Stop(StopRequest): DefaultSuccess = 3;
  /** Command description for MoveToLevelWithOnOff */
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  /** Command description for MoveWithOnOff */
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  /** Command description for StepWithOnOff */
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  /** Command description for StopWithOnOff */
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
  /** Change the currrent frequency to the provided one, or a close
        approximation if the exact provided one is not possible. */
  command MoveToClosestFrequency(MoveToClosestFrequencyRequest): DefaultSuccess = 8;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
cluster Descriptor = 29 {
  revision 2;

  bitmap Feature : bitmap32 {
    kTagList = 0x1;
  }

  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  struct SemanticTagStruct {
    nullable vendor_id mfgCode = 0;
    enum8 namespaceID = 1;
    enum8 tag = 2;
    optional nullable char_string label = 3;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute cluster_id serverList[] = 1;
  readonly attribute cluster_id clientList[] = 2;
  readonly attribute endpoint_no partsList[] = 3;
  readonly attribute optional SemanticTagStruct tagList[] = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
cluster AccessControl = 31 {
  revision 2;

  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1;
    kCASE = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum AccessRestrictionTypeEnum : enum8 {
    kAttributeAccessForbidden = 0;
    kAttributeWriteForbidden = 1;
    kCommandForbidden = 2;
    kEventForbidden = 3;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  bitmap Feature : bitmap32 {
    kExtension = 0x1;
    kManagedDevice = 0x2;
  }

  struct AccessRestrictionStruct {
    AccessRestrictionTypeEnum type = 0;
    nullable int32u id = 1;
  }

  struct CommissioningAccessRestrictionEntryStruct {
    endpoint_no endpoint = 0;
    cluster_id cluster = 1;
    AccessRestrictionStruct restrictions[] = 2;
  }

  fabric_scoped struct AccessRestrictionEntryStruct {
    fabric_sensitive endpoint_no endpoint = 0;
    fabric_sensitive cluster_id cluster = 1;
    fabric_sensitive AccessRestrictionStruct restrictions[] = 2;
    fabric_idx fabricIndex = 254;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) FabricRestrictionReviewUpdate = 2 {
    int64u token = 0;
    optional long_char_string instruction = 1;
    optional long_char_string ARLRequestFlowUrl = 2;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute optional CommissioningAccessRestrictionEntryStruct commissioningARL[] = 5;
  readonly attribute optional AccessRestrictionEntryStruct arl[] = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ReviewFabricRestrictionsRequest {
    CommissioningAccessRestrictionEntryStruct arl[] = 0;
  }

  response struct ReviewFabricRestrictionsResponse = 1 {
    int64u token = 0;
  }

  /** This command signals to the service associated with the device vendor that the fabric administrator would like a review of the current restrictions on the accessing fabric. */
  fabric command access(invoke: administer) ReviewFabricRestrictions(ReviewFabricRestrictionsRequest): ReviewFabricRestrictionsResponse = 0;
}

/** This cluster provides a standardized way for a Node (typically a Bridge, but could be any Node) to expose action information. */
cluster Actions = 37 {
  revision 1; // NOTE: Default/not specifically set

  enum ActionErrorEnum : enum8 {
    kUnknown = 0;
    kInterrupted = 1;
  }

  enum ActionStateEnum : enum8 {
    kInactive = 0;
    kActive = 1;
    kPaused = 2;
    kDisabled = 3;
  }

  enum ActionTypeEnum : enum8 {
    kOther = 0;
    kScene = 1;
    kSequence = 2;
    kAutomation = 3;
    kException = 4;
    kNotification = 5;
    kAlarm = 6;
  }

  enum EndpointListTypeEnum : enum8 {
    kOther = 0;
    kRoom = 1;
    kZone = 2;
  }

  bitmap CommandBits : bitmap16 {
    kInstantAction = 0x1;
    kInstantActionWithTransition = 0x2;
    kStartAction = 0x4;
    kStartActionWithDuration = 0x8;
    kStopAction = 0x10;
    kPauseAction = 0x20;
    kPauseActionWithDuration = 0x40;
    kResumeAction = 0x80;
    kEnableAction = 0x100;
    kEnableActionWithDuration = 0x200;
    kDisableAction = 0x400;
    kDisableActionWithDuration = 0x800;
  }

  struct ActionStruct {
    int16u actionID = 0;
    char_string<32> name = 1;
    ActionTypeEnum type = 2;
    int16u endpointListID = 3;
    CommandBits supportedCommands = 4;
    ActionStateEnum state = 5;
  }

  struct EndpointListStruct {
    int16u endpointListID = 0;
    char_string<32> name = 1;
    EndpointListTypeEnum type = 2;
    endpoint_no endpoints[] = 3;
  }

  info event StateChanged = 0 {
    int16u actionID = 0;
    int32u invokeID = 1;
    ActionStateEnum newState = 2;
  }

  info event ActionFailed = 1 {
    int16u actionID = 0;
    int32u invokeID = 1;
    ActionStateEnum newState = 2;
    ActionErrorEnum error = 3;
  }

  readonly attribute ActionStruct actionList[] = 0;
  readonly attribute EndpointListStruct endpointLists[] = 1;
  readonly attribute optional long_char_string<512> setupURL = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct InstantActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct InstantActionWithTransitionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int16u transitionTime = 2;
  }

  request struct StartActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct StartActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct StopActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct PauseActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct PauseActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct ResumeActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct EnableActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct EnableActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct DisableActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct DisableActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  /** This command triggers an action (state change) on the involved endpoints. */
  command InstantAction(InstantActionRequest): DefaultSuccess = 0;
  /** This command triggers an action (state change) on the involved endpoints, with a specified time to transition from the current state to the new state. */
  command InstantActionWithTransition(InstantActionWithTransitionRequest): DefaultSuccess = 1;
  /** This command triggers the commencement of an action on the involved endpoints. */
  command StartAction(StartActionRequest): DefaultSuccess = 2;
  /** This command triggers the commencement of an action (with a duration) on the involved endpoints. */
  command StartActionWithDuration(StartActionWithDurationRequest): DefaultSuccess = 3;
  /** This command stops the ongoing action on the involved endpoints. */
  command StopAction(StopActionRequest): DefaultSuccess = 4;
  /** This command pauses an ongoing action. */
  command PauseAction(PauseActionRequest): DefaultSuccess = 5;
  /** This command pauses an ongoing action with a duration. */
  command PauseActionWithDuration(PauseActionWithDurationRequest): DefaultSuccess = 6;
  /** This command resumes a previously paused action. */
  command ResumeAction(ResumeActionRequest): DefaultSuccess = 7;
  /** This command enables a certain action or automation. */
  command EnableAction(EnableActionRequest): DefaultSuccess = 8;
  /** This command enables a certain action or automation with a duration. */
  command EnableActionWithDuration(EnableActionWithDurationRequest): DefaultSuccess = 9;
  /** This command disables a certain action or automation. */
  command DisableAction(DisableActionRequest): DefaultSuccess = 10;
  /** This command disables a certain action or automation with a duration. */
  command DisableActionWithDuration(DisableActionWithDurationRequest): DefaultSuccess = 11;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
cluster BasicInformation = 40 {
  revision 3;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  attribute access(write: manage) optional boolean localConfigDisabled = 16;
  readonly attribute optional boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute int32u specificationVersion = 21;
  readonly attribute int16u maxPathsPerInvoke = 22;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command MfgSpecificPing(): DefaultSuccess = 0;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
cluster LocalizationConfiguration = 43 {
  revision 1; // NOTE: Default/not specifically set

  attribute access(write: manage) char_string<35> activeLocale = 0;
  readonly attribute char_string supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
cluster LocalizationConfiguration = 43 {
  revision 1; // NOTE: Default/not specifically set

  attribute access(write: manage) char_string<35> activeLocale = 0;
  readonly attribute char_string supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for how dates and times are conveyed. As such, Nodes that visually
      or audibly convey time information need a mechanism by which they can be configured to use a
      user’s preferred format. */
cluster TimeFormatLocalization = 44 {
  revision 1; // NOTE: Default/not specifically set

  enum CalendarTypeEnum : enum8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
    kUseActiveLocale = 255;
  }

  enum HourFormatEnum : enum8 {
    k12hr = 0;
    k24hr = 1;
    kUseActiveLocale = 255;
  }

  bitmap Feature : bitmap32 {
    kCalendarFormat = 0x1;
  }

  attribute access(write: manage) HourFormatEnum hourFormat = 0;
  attribute access(write: manage) optional CalendarTypeEnum activeCalendarType = 1;
  readonly attribute optional CalendarTypeEnum supportedCalendarTypes[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for the units in which values are conveyed in communication to a
      user. As such, Nodes that visually or audibly convey measurable values to the user need a
      mechanism by which they can be configured to use a user’s preferred unit. */
cluster UnitLocalization = 45 {
  revision 1;

  enum TempUnitEnum : enum8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap Feature : bitmap32 {
    kTemperatureUnit = 0x1;
  }

  attribute access(write: manage) optional TempUnitEnum temperatureUnit = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for the units in which values are conveyed in communication to a
      user. As such, Nodes that visually or audibly convey measurable values to the user need a
      mechanism by which they can be configured to use a user’s preferred unit. */
cluster UnitLocalization = 45 {
  revision 1;

  enum TempUnitEnum : enum8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap Feature : bitmap32 {
    kTemperatureUnit = 0x1;
  }

  attribute access(write: manage) optional TempUnitEnum temperatureUnit = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to describe the configuration and capabilities of a physical power source that provides power to the Node. */
cluster PowerSource = 47 {
  revision 1; // NOTE: Default/not specifically set

  enum BatApprovedChemistryEnum : enum16 {
    kUnspecified = 0;
    kAlkaline = 1;
    kLithiumCarbonFluoride = 2;
    kLithiumChromiumOxide = 3;
    kLithiumCopperOxide = 4;
    kLithiumIronDisulfide = 5;
    kLithiumManganeseDioxide = 6;
    kLithiumThionylChloride = 7;
    kMagnesium = 8;
    kMercuryOxide = 9;
    kNickelOxyhydride = 10;
    kSilverOxide = 11;
    kZincAir = 12;
    kZincCarbon = 13;
    kZincChloride = 14;
    kZincManganeseDioxide = 15;
    kLeadAcid = 16;
    kLithiumCobaltOxide = 17;
    kLithiumIon = 18;
    kLithiumIonPolymer = 19;
    kLithiumIronPhosphate = 20;
    kLithiumSulfur = 21;
    kLithiumTitanate = 22;
    kNickelCadmium = 23;
    kNickelHydrogen = 24;
    kNickelIron = 25;
    kNickelMetalHydride = 26;
    kNickelZinc = 27;
    kSilverZinc = 28;
    kSodiumIon = 29;
    kSodiumSulfur = 30;
    kZincBromide = 31;
    kZincCerium = 32;
  }

  enum BatChargeFaultEnum : enum8 {
    kUnspecified = 0;
    kAmbientTooHot = 1;
    kAmbientTooCold = 2;
    kBatteryTooHot = 3;
    kBatteryTooCold = 4;
    kBatteryAbsent = 5;
    kBatteryOverVoltage = 6;
    kBatteryUnderVoltage = 7;
    kChargerOverVoltage = 8;
    kChargerUnderVoltage = 9;
    kSafetyTimeout = 10;
  }

  enum BatChargeLevelEnum : enum8 {
    kOK = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum BatChargeStateEnum : enum8 {
    kUnknown = 0;
    kIsCharging = 1;
    kIsAtFullCharge = 2;
    kIsNotCharging = 3;
  }

  enum BatCommonDesignationEnum : enum16 {
    kUnspecified = 0;
    kAAA = 1;
    kAA = 2;
    kC = 3;
    kD = 4;
    k4v5 = 5;
    k6v0 = 6;
    k9v0 = 7;
    k12AA = 8;
    kAAAA = 9;
    kA = 10;
    kB = 11;
    kF = 12;
    kN = 13;
    kNo6 = 14;
    kSubC = 15;
    kA23 = 16;
    kA27 = 17;
    kBA5800 = 18;
    kDuplex = 19;
    k4SR44 = 20;
    k523 = 21;
    k531 = 22;
    k15v0 = 23;
    k22v5 = 24;
    k30v0 = 25;
    k45v0 = 26;
    k67v5 = 27;
    kJ = 28;
    kCR123A = 29;
    kCR2 = 30;
    k2CR5 = 31;
    kCRP2 = 32;
    kCRV3 = 33;
    kSR41 = 34;
    kSR43 = 35;
    kSR44 = 36;
    kSR45 = 37;
    kSR48 = 38;
    kSR54 = 39;
    kSR55 = 40;
    kSR57 = 41;
    kSR58 = 42;
    kSR59 = 43;
    kSR60 = 44;
    kSR63 = 45;
    kSR64 = 46;
    kSR65 = 47;
    kSR66 = 48;
    kSR67 = 49;
    kSR68 = 50;
    kSR69 = 51;
    kSR516 = 52;
    kSR731 = 53;
    kSR712 = 54;
    kLR932 = 55;
    kA5 = 56;
    kA10 = 57;
    kA13 = 58;
    kA312 = 59;
    kA675 = 60;
    kAC41E = 61;
    k10180 = 62;
    k10280 = 63;
    k10440 = 64;
    k14250 = 65;
    k14430 = 66;
    k14500 = 67;
    k14650 = 68;
    k15270 = 69;
    k16340 = 70;
    kRCR123A = 71;
    k17500 = 72;
    k17670 = 73;
    k18350 = 74;
    k18500 = 75;
    k18650 = 76;
    k19670 = 77;
    k25500 = 78;
    k26650 = 79;
    k32600 = 80;
  }

  enum BatFaultEnum : enum8 {
    kUnspecified = 0;
    kOverTemp = 1;
    kUnderTemp = 2;
  }

  enum BatReplaceabilityEnum : enum8 {
    kUnspecified = 0;
    kNotReplaceable = 1;
    kUserReplaceable = 2;
    kFactoryReplaceable = 3;
  }

  enum PowerSourceStatusEnum : enum8 {
    kUnspecified = 0;
    kActive = 1;
    kStandby = 2;
    kUnavailable = 3;
  }

  enum WiredCurrentTypeEnum : enum8 {
    kAC = 0;
    kDC = 1;
  }

  enum WiredFaultEnum : enum8 {
    kUnspecified = 0;
    kOverVoltage = 1;
    kUnderVoltage = 2;
  }

  bitmap Feature : bitmap32 {
    kWired = 0x1;
    kBattery = 0x2;
    kRechargeable = 0x4;
    kReplaceable = 0x8;
  }

  struct BatChargeFaultChangeType {
    BatChargeFaultEnum current[] = 0;
    BatChargeFaultEnum previous[] = 1;
  }

  struct BatFaultChangeType {
    BatFaultEnum current[] = 0;
    BatFaultEnum previous[] = 1;
  }

  struct WiredFaultChangeType {
    WiredFaultEnum current[] = 0;
    WiredFaultEnum previous[] = 1;
  }

  info event WiredFaultChange = 0 {
    WiredFaultEnum current[] = 0;
    WiredFaultEnum previous[] = 1;
  }

  info event BatFaultChange = 1 {
    BatFaultEnum current[] = 0;
    BatFaultEnum previous[] = 1;
  }

  info event BatChargeFaultChange = 2 {
    BatChargeFaultEnum current[] = 0;
    BatChargeFaultEnum previous[] = 1;
  }

  readonly attribute PowerSourceStatusEnum status = 0;
  readonly attribute int8u order = 1;
  readonly attribute char_string<60> description = 2;
  readonly attribute optional nullable int32u wiredAssessedInputVoltage = 3;
  readonly attribute optional nullable int16u wiredAssessedInputFrequency = 4;
  readonly attribute optional WiredCurrentTypeEnum wiredCurrentType = 5;
  readonly attribute optional nullable int32u wiredAssessedCurrent = 6;
  readonly attribute optional int32u wiredNominalVoltage = 7;
  readonly attribute optional int32u wiredMaximumCurrent = 8;
  readonly attribute optional boolean wiredPresent = 9;
  readonly attribute optional WiredFaultEnum activeWiredFaults[] = 10;
  readonly attribute optional nullable int32u batVoltage = 11;
  readonly attribute optional nullable int8u batPercentRemaining = 12;
  readonly attribute optional nullable int32u batTimeRemaining = 13;
  readonly attribute optional BatChargeLevelEnum batChargeLevel = 14;
  readonly attribute optional boolean batReplacementNeeded = 15;
  readonly attribute optional BatReplaceabilityEnum batReplaceability = 16;
  readonly attribute optional boolean batPresent = 17;
  readonly attribute optional BatFaultEnum activeBatFaults[] = 18;
  readonly attribute optional char_string<60> batReplacementDescription = 19;
  readonly attribute optional BatCommonDesignationEnum batCommonDesignation = 20;
  readonly attribute optional char_string<20> batANSIDesignation = 21;
  readonly attribute optional char_string<20> batIECDesignation = 22;
  readonly attribute optional BatApprovedChemistryEnum batApprovedChemistry = 23;
  readonly attribute optional int32u batCapacity = 24;
  readonly attribute optional int8u batQuantity = 25;
  readonly attribute optional BatChargeStateEnum batChargeState = 26;
  readonly attribute optional nullable int32u batTimeToFullCharge = 27;
  readonly attribute optional boolean batFunctionalWhileCharging = 28;
  readonly attribute optional nullable int32u batChargingCurrent = 29;
  readonly attribute optional BatChargeFaultEnum activeBatChargeFaults[] = 30;
  readonly attribute endpoint_no endpointList[] = 31;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
cluster GeneralCommissioning = 48 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningErrorEnum : enum8 {
    kOK = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
    kRequiredTCNotAccepted = 5;
    kTCAcknowledgementsNotReceived = 6;
    kTCMinVersionNotMet = 7;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  bitmap Feature : bitmap32 {
    kTermsAndConditions = 0x1;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  provisional readonly attribute access(read: administer) optional int16u TCAcceptedVersion = 5;
  provisional readonly attribute access(read: administer) optional int16u TCMinRequiredVersion = 6;
  provisional readonly attribute access(read: administer) optional bitmap16 TCAcknowledgements = 7;
  provisional readonly attribute access(read: administer) optional boolean TCAcknowledgementsRequired = 8;
  provisional readonly attribute access(read: administer) optional nullable int32u TCUpdateDeadline = 9;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string<128> debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string<2> countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  request struct SetTCAcknowledgementsRequest {
    int16u TCVersion = 0;
    bitmap16 TCUserResponse = 1;
  }

  response struct SetTCAcknowledgementsResponse = 7 {
    CommissioningErrorEnum errorCode = 0;
  }

  /** Arm the persistent fail-safe timer with an expiry time of now + ExpiryLengthSeconds using device clock */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** Set the regulatory configuration to be used during commissioning */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** Signals the Server that the Client has successfully completed all steps of Commissioning/Recofiguration needed during fail-safe period. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
  /** This command sets the user acknowledgements received in the Enhanced Setup Flow Terms and Conditions into the node. */
  command access(invoke: administer) SetTCAcknowledgements(SetTCAcknowledgementsRequest): SetTCAcknowledgementsResponse = 6;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
cluster GeneralCommissioning = 48 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningErrorEnum : enum8 {
    kOK = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
    kRequiredTCNotAccepted = 5;
    kTCAcknowledgementsNotReceived = 6;
    kTCMinVersionNotMet = 7;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  bitmap Feature : bitmap32 {
    kTermsAndConditions = 0x1;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  provisional readonly attribute access(read: administer) optional int16u TCAcceptedVersion = 5;
  provisional readonly attribute access(read: administer) optional int16u TCMinRequiredVersion = 6;
  provisional readonly attribute access(read: administer) optional bitmap16 TCAcknowledgements = 7;
  provisional readonly attribute access(read: administer) optional boolean TCAcknowledgementsRequired = 8;
  provisional readonly attribute access(read: administer) optional nullable int32u TCUpdateDeadline = 9;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string<128> debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string<2> countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  request struct SetTCAcknowledgementsRequest {
    int16u TCVersion = 0;
    bitmap16 TCUserResponse = 1;
  }

  response struct SetTCAcknowledgementsResponse = 7 {
    CommissioningErrorEnum errorCode = 0;
  }

  /** Arm the persistent fail-safe timer with an expiry time of now + ExpiryLengthSeconds using device clock */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** Set the regulatory configuration to be used during commissioning */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** Signals the Server that the Client has successfully completed all steps of Commissioning/Recofiguration needed during fail-safe period. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
  /** This command sets the user acknowledgements received in the Enhanced Setup Flow Terms and Conditions into the node. */
  command access(invoke: administer) SetTCAcknowledgements(SetTCAcknowledgementsRequest): SetTCAcknowledgementsResponse = 6;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
cluster NetworkCommissioning = 49 {
  revision 1; // NOTE: Default/not specifically set

  enum NetworkCommissioningStatusEnum : enum8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBandEnum : enum8 {
    k2G4 = 0;
    k3G65 = 1;
    k5G = 2;
    k6G = 3;
    k60G = 4;
    k1G = 5;
  }

  bitmap Feature : bitmap32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
    kPerDeviceCredentials = 0x8;
  }

  bitmap ThreadCapabilitiesBitmap : bitmap16 {
    kIsBorderRouterCapable = 0x1;
    kIsRouterCapable = 0x2;
    kIsSleepyEndDeviceCapable = 0x4;
    kIsFullThreadDevice = 0x8;
    kIsSynchronizedSleepyEndDeviceCapable = 0x10;
  }

  bitmap WiFiSecurityBitmap : bitmap8 {
    kUnencrypted = 0x1;
    kWEP = 0x2;
    kWPAPersonal = 0x4;
    kWPA2Personal = 0x8;
    kWPA3Personal = 0x10;
    kWPA3MatterPDC = 0x20;
  }

  struct NetworkInfoStruct {
    octet_string<32> networkID = 0;
    boolean connected = 1;
    optional nullable octet_string<20> networkIdentifier = 2;
    optional nullable octet_string<20> clientIdentifier = 3;
  }

  struct ThreadInterfaceScanResultStruct {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResultStruct {
    WiFiSecurityBitmap security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBandEnum wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfoStruct networks[] = 1;
  readonly attribute optional int8u scanMaxTimeSeconds = 2;
  readonly attribute optional int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatusEnum lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  provisional readonly attribute optional WiFiBandEnum supportedWiFiBands[] = 8;
  provisional readonly attribute optional ThreadCapabilitiesBitmap supportedThreadFeatures = 9;
  provisional readonly attribute optional int16u threadVersion = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable octet_string<32> ssid = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    optional WiFiInterfaceScanResultStruct wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResultStruct threadScanResults[] = 3;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    octet_string<32> ssid = 0;
    octet_string<64> credentials = 1;
    optional int64u breadcrumb = 2;
    optional octet_string<140> networkIdentity = 3;
    optional octet_string<20> clientIdentifier = 4;
    optional octet_string<32> possessionNonce = 5;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    octet_string<254> operationalDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string<512> debugText = 1;
    optional int8u networkIndex = 2;
    optional octet_string<140> clientIdentity = 3;
    optional octet_string<64> possessionSignature = 4;
  }

  request struct ConnectNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    nullable int32s errorValue = 2;
  }

  request struct ReorderNetworkRequest {
    octet_string<32> networkID = 0;
    int8u networkIndex = 1;
    optional int64u breadcrumb = 2;
  }

  request struct QueryIdentityRequest {
    octet_string<20> keyIdentifier = 0;
    optional octet_string<32> possessionNonce = 1;
  }

  response struct QueryIdentityResponse = 10 {
    octet_string<140> identity = 0;
    optional octet_string<64> possessionSignature = 1;
  }

  /** Detemine the set of networks the device sees as available. */
  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  /** Add or update the credentials for a given Wi-Fi network. */
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  /** Add or update the credentials for a given Thread network. */
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  /** Remove the definition of a given network (including its credentials). */
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  /** Connect to the specified network, using previously-defined credentials. */
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  /** Modify the order in which networks will be presented in the Networks attribute. */
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
  /** Retrieve details about and optionally proof of possession of a network client identity. */
  command access(invoke: administer) QueryIdentity(QueryIdentityRequest): QueryIdentityResponse = 9;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster GeneralDiagnostics = 51 {
  revision 2;

  enum BootReasonEnum : enum8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : enum8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : enum8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : enum8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  bitmap Feature : bitmap32 {
    kDataModelTest = 0x1;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute optional int64u upTime = 2;
  readonly attribute optional int32u totalOperationalHours = 3;
  readonly attribute optional BootReasonEnum bootReason = 4;
  readonly attribute optional HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute optional RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute optional NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    octet_string<16> enableKey = 0;
    int64u eventTrigger = 1;
  }

  response struct TimeSnapshotResponse = 2 {
    systime_ms systemTimeMs = 0;
    nullable posix_ms posixTimeMs = 1;
  }

  request struct PayloadTestRequestRequest {
    octet_string<16> enableKey = 0;
    int8u value = 1;
    int16u count = 2;
  }

  response struct PayloadTestResponse = 4 {
    octet_string payload = 0;
  }

  /** Provide a means for certification tests to trigger some test-plan-specific events */
  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
  /** Take a snapshot of system time and epoch time. */
  command TimeSnapshot(): TimeSnapshotResponse = 1;
  /** Request a variable length payload response. */
  command access(invoke: manage) PayloadTestRequest(PayloadTestRequestRequest): PayloadTestResponse = 3;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster SoftwareDiagnostics = 52 {
  revision 1; // NOTE: Default/not specifically set

  bitmap Feature : bitmap32 {
    kWatermarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    int64u id = 0;
    optional char_string name = 1;
    optional octet_string faultRecording = 2;
  }

  readonly attribute optional ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute optional int64u currentHeapFree = 1;
  readonly attribute optional int64u currentHeapUsed = 2;
  readonly attribute optional int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the values: The StackFreeMinimum field of the ThreadMetrics attribute, CurrentHeapHighWaterMark attribute. */
  command access(invoke: manage) ResetWatermarks(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
cluster ThreadNetworkDiagnostics = 53 {
  revision 2;

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRoleEnum : enum8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kREED = 4;
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTableStruct {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTableStruct {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRoleEnum routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute NeighborTableStruct neighborTable[] = 7;
  readonly attribute RouteTableStruct routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int16u weighting = 10;
  readonly attribute nullable int16u dataVersion = 11;
  readonly attribute nullable int16u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute optional int16u detachedRoleCount = 14;
  readonly attribute optional int16u childRoleCount = 15;
  readonly attribute optional int16u routerRoleCount = 16;
  readonly attribute optional int16u leaderRoleCount = 17;
  readonly attribute optional int16u attachAttemptCount = 18;
  readonly attribute optional int16u partitionIdChangeCount = 19;
  readonly attribute optional int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute optional int16u parentChangeCount = 21;
  readonly attribute optional int32u txTotalCount = 22;
  readonly attribute optional int32u txUnicastCount = 23;
  readonly attribute optional int32u txBroadcastCount = 24;
  readonly attribute optional int32u txAckRequestedCount = 25;
  readonly attribute optional int32u txAckedCount = 26;
  readonly attribute optional int32u txNoAckRequestedCount = 27;
  readonly attribute optional int32u txDataCount = 28;
  readonly attribute optional int32u txDataPollCount = 29;
  readonly attribute optional int32u txBeaconCount = 30;
  readonly attribute optional int32u txBeaconRequestCount = 31;
  readonly attribute optional int32u txOtherCount = 32;
  readonly attribute optional int32u txRetryCount = 33;
  readonly attribute optional int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute optional int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute optional int32u txErrCcaCount = 36;
  readonly attribute optional int32u txErrAbortCount = 37;
  readonly attribute optional int32u txErrBusyChannelCount = 38;
  readonly attribute optional int32u rxTotalCount = 39;
  readonly attribute optional int32u rxUnicastCount = 40;
  readonly attribute optional int32u rxBroadcastCount = 41;
  readonly attribute optional int32u rxDataCount = 42;
  readonly attribute optional int32u rxDataPollCount = 43;
  readonly attribute optional int32u rxBeaconCount = 44;
  readonly attribute optional int32u rxBeaconRequestCount = 45;
  readonly attribute optional int32u rxOtherCount = 46;
  readonly attribute optional int32u rxAddressFilteredCount = 47;
  readonly attribute optional int32u rxDestAddrFilteredCount = 48;
  readonly attribute optional int32u rxDuplicatedCount = 49;
  readonly attribute optional int32u rxErrNoFrameCount = 50;
  readonly attribute optional int32u rxErrUnknownNeighborCount = 51;
  readonly attribute optional int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute optional int32u rxErrSecCount = 53;
  readonly attribute optional int32u rxErrFcsCount = 54;
  readonly attribute optional int32u rxErrOtherCount = 55;
  readonly attribute optional nullable int64u activeTimestamp = 56;
  readonly attribute optional nullable int64u pendingTimestamp = 57;
  readonly attribute optional nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFaultEnum activeNetworkFaultsList[] = 62;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the OverrunCount attributes to 0 */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
cluster ThreadNetworkDiagnostics = 53 {
  revision 2;

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRoleEnum : enum8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kREED = 4;
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTableStruct {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTableStruct {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRoleEnum routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute NeighborTableStruct neighborTable[] = 7;
  readonly attribute RouteTableStruct routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int16u weighting = 10;
  readonly attribute nullable int16u dataVersion = 11;
  readonly attribute nullable int16u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute optional int16u detachedRoleCount = 14;
  readonly attribute optional int16u childRoleCount = 15;
  readonly attribute optional int16u routerRoleCount = 16;
  readonly attribute optional int16u leaderRoleCount = 17;
  readonly attribute optional int16u attachAttemptCount = 18;
  readonly attribute optional int16u partitionIdChangeCount = 19;
  readonly attribute optional int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute optional int16u parentChangeCount = 21;
  readonly attribute optional int32u txTotalCount = 22;
  readonly attribute optional int32u txUnicastCount = 23;
  readonly attribute optional int32u txBroadcastCount = 24;
  readonly attribute optional int32u txAckRequestedCount = 25;
  readonly attribute optional int32u txAckedCount = 26;
  readonly attribute optional int32u txNoAckRequestedCount = 27;
  readonly attribute optional int32u txDataCount = 28;
  readonly attribute optional int32u txDataPollCount = 29;
  readonly attribute optional int32u txBeaconCount = 30;
  readonly attribute optional int32u txBeaconRequestCount = 31;
  readonly attribute optional int32u txOtherCount = 32;
  readonly attribute optional int32u txRetryCount = 33;
  readonly attribute optional int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute optional int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute optional int32u txErrCcaCount = 36;
  readonly attribute optional int32u txErrAbortCount = 37;
  readonly attribute optional int32u txErrBusyChannelCount = 38;
  readonly attribute optional int32u rxTotalCount = 39;
  readonly attribute optional int32u rxUnicastCount = 40;
  readonly attribute optional int32u rxBroadcastCount = 41;
  readonly attribute optional int32u rxDataCount = 42;
  readonly attribute optional int32u rxDataPollCount = 43;
  readonly attribute optional int32u rxBeaconCount = 44;
  readonly attribute optional int32u rxBeaconRequestCount = 45;
  readonly attribute optional int32u rxOtherCount = 46;
  readonly attribute optional int32u rxAddressFilteredCount = 47;
  readonly attribute optional int32u rxDestAddrFilteredCount = 48;
  readonly attribute optional int32u rxDuplicatedCount = 49;
  readonly attribute optional int32u rxErrNoFrameCount = 50;
  readonly attribute optional int32u rxErrUnknownNeighborCount = 51;
  readonly attribute optional int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute optional int32u rxErrSecCount = 53;
  readonly attribute optional int32u rxErrFcsCount = 54;
  readonly attribute optional int32u rxErrOtherCount = 55;
  readonly attribute optional nullable int64u activeTimestamp = 56;
  readonly attribute optional nullable int64u pendingTimestamp = 57;
  readonly attribute optional nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFaultEnum activeNetworkFaultsList[] = 62;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the OverrunCount attributes to 0 */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** The Wi-Fi Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster WiFiNetworkDiagnostics = 54 {
  revision 1; // NOTE: Default/not specifically set

  enum AssociationFailureCauseEnum : enum8 {
    kUnknown = 0;
    kAssociationFailed = 1;
    kAuthenticationFailed = 2;
    kSsidNotFound = 3;
  }

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum SecurityTypeEnum : enum8 {
    kUnspecified = 0;
    kNone = 1;
    kWEP = 2;
    kWPA = 3;
    kWPA2 = 4;
    kWPA3 = 5;
  }

  enum WiFiVersionEnum : enum8 {
    kA = 0;
    kB = 1;
    kG = 2;
    kN = 3;
    kAc = 4;
    kAx = 5;
    kAh = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  info event Disconnection = 0 {
    int16u reasonCode = 0;
  }

  info event AssociationFailure = 1 {
    AssociationFailureCauseEnum associationFailureCause = 0;
    int16u status = 1;
  }

  info event ConnectionStatus = 2 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  readonly attribute nullable octet_string<6> bssid = 0;
  readonly attribute nullable SecurityTypeEnum securityType = 1;
  readonly attribute nullable WiFiVersionEnum wiFiVersion = 2;
  readonly attribute nullable int16u channelNumber = 3;
  readonly attribute nullable int8s rssi = 4;
  readonly attribute optional nullable int32u beaconLostCount = 5;
  readonly attribute optional nullable int32u beaconRxCount = 6;
  readonly attribute optional nullable int32u packetMulticastRxCount = 7;
  readonly attribute optional nullable int32u packetMulticastTxCount = 8;
  readonly attribute optional nullable int32u packetUnicastRxCount = 9;
  readonly attribute optional nullable int32u packetUnicastTxCount = 10;
  readonly attribute optional nullable int64u currentMaxRate = 11;
  readonly attribute optional nullable int64u overrunCount = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the Breacon and Packet related count attributes to 0 */
  command ResetCounts(): DefaultSuccess = 0;
}

/** The Ethernet Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster EthernetNetworkDiagnostics = 55 {
  revision 1; // NOTE: Default/not specifically set

  enum PHYRateEnum : enum8 {
    kRate10M = 0;
    kRate100M = 1;
    kRate1G = 2;
    kRate25G = 3;
    kRate5G = 4;
    kRate10G = 5;
    kRate40G = 6;
    kRate100G = 7;
    kRate200G = 8;
    kRate400G = 9;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  readonly attribute optional nullable PHYRateEnum PHYRate = 0;
  readonly attribute optional nullable boolean fullDuplex = 1;
  readonly attribute optional int64u packetRxCount = 2;
  readonly attribute optional int64u packetTxCount = 3;
  readonly attribute optional int64u txErrCount = 4;
  readonly attribute optional int64u collisionCount = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute optional nullable boolean carrierDetect = 7;
  readonly attribute optional int64u timeSinceReset = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the attributes: PacketRxCount, PacketTxCount, TxErrCount, CollisionCount, OverrunCount to 0 */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** This Cluster serves two purposes towards a Node communicating with a Bridge: indicate that the functionality on
          the Endpoint where it is placed (and its Parts) is bridged from a non-CHIP technology; and provide a centralized
          collection of attributes that the Node MAY collect to aid in conveying information regarding the Bridged Device to a user,
          such as the vendor name, the model name, or user-assigned name. */
cluster BridgedDeviceBasicInformation = 57 {
  revision 3;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  bitmap Feature : bitmap32 {
    kBridgedICDSupport = 0x100000;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  info event ActiveChanged = 128 {
    int32u promisedActiveDuration = 0;
  }

  readonly attribute optional char_string<32> vendorName = 1;
  readonly attribute optional vendor_id vendorID = 2;
  readonly attribute optional char_string<32> productName = 3;
  readonly attribute optional int16u productID = 4;
  attribute optional char_string<32> nodeLabel = 5;
  readonly attribute optional int16u hardwareVersion = 7;
  readonly attribute optional char_string<64> hardwareVersionString = 8;
  readonly attribute optional int32u softwareVersion = 9;
  readonly attribute optional char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  readonly attribute boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeepActiveRequest {
    int32u stayActiveDuration = 0;
    int32u timeoutMs = 1;
  }

  /** The server SHALL attempt to keep the devices specified active for StayActiveDuration milliseconds when they are next active. */
  command KeepActive(KeepActiveRequest): DefaultSuccess = 128;
}

/** This cluster exposes interactions with a switch device, for the purpose of using those interactions by other devices.
Two types of switch devices are supported: latching switch (e.g. rocker switch) and momentary switch (e.g. push button), distinguished with their feature flags.
Interactions with the switch device are exposed as attributes (for the latching switch) and as events (for both types of switches). An interested party MAY subscribe to these attributes/events and thus be informed of the interactions, and can perform actions based on this, for example by sending commands to perform an action such as controlling a light or a window shade. */
cluster Switch = 59 {
  revision 2;

  bitmap Feature : bitmap32 {
    kLatchingSwitch = 0x1;
    kMomentarySwitch = 0x2;
    kMomentarySwitchRelease = 0x4;
    kMomentarySwitchLongPress = 0x8;
    kMomentarySwitchMultiPress = 0x10;
    kActionSwitch = 0x20;
  }

  info event SwitchLatched = 0 {
    int8u newPosition = 0;
  }

  info event InitialPress = 1 {
    int8u newPosition = 0;
  }

  info event LongPress = 2 {
    int8u newPosition = 0;
  }

  info event ShortRelease = 3 {
    int8u previousPosition = 0;
  }

  info event LongRelease = 4 {
    int8u previousPosition = 0;
  }

  info event MultiPressOngoing = 5 {
    int8u newPosition = 0;
    int8u currentNumberOfPressesCounted = 1;
  }

  info event MultiPressComplete = 6 {
    int8u previousPosition = 0;
    int8u totalNumberOfPressesCounted = 1;
  }

  readonly attribute int8u numberOfPositions = 0;
  readonly attribute int8u currentPosition = 1;
  readonly attribute optional int8u multiPressMax = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster exposes interactions with a switch device, for the purpose of using those interactions by other devices.
Two types of switch devices are supported: latching switch (e.g. rocker switch) and momentary switch (e.g. push button), distinguished with their feature flags.
Interactions with the switch device are exposed as attributes (for the latching switch) and as events (for both types of switches). An interested party MAY subscribe to these attributes/events and thus be informed of the interactions, and can perform actions based on this, for example by sending commands to perform an action such as controlling a light or a window shade. */
cluster Switch = 59 {
  revision 2;

  bitmap Feature : bitmap32 {
    kLatchingSwitch = 0x1;
    kMomentarySwitch = 0x2;
    kMomentarySwitchRelease = 0x4;
    kMomentarySwitchLongPress = 0x8;
    kMomentarySwitchMultiPress = 0x10;
    kActionSwitch = 0x20;
  }

  info event SwitchLatched = 0 {
    int8u newPosition = 0;
  }

  info event InitialPress = 1 {
    int8u newPosition = 0;
  }

  info event LongPress = 2 {
    int8u newPosition = 0;
  }

  info event ShortRelease = 3 {
    int8u previousPosition = 0;
  }

  info event LongRelease = 4 {
    int8u previousPosition = 0;
  }

  info event MultiPressOngoing = 5 {
    int8u newPosition = 0;
    int8u currentNumberOfPressesCounted = 1;
  }

  info event MultiPressComplete = 6 {
    int8u previousPosition = 0;
    int8u totalNumberOfPressesCounted = 1;
  }

  readonly attribute int8u numberOfPositions = 0;
  readonly attribute int8u currentPosition = 1;
  readonly attribute optional int8u multiPressMax = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
cluster AdministratorCommissioning = 60 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningWindowStatusEnum : enum8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : enum8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  bitmap Feature : bitmap32 {
    kBasic = 0x1;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable vendor_id adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
    octet_string PAKEPasscodeVerifier = 1;
    int16u discriminator = 2;
    int32u iterations = 3;
    octet_string<32> salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
  }

  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using enhanced commissioning method. */
  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using basic commissioning method, if the node supports it. */
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  /** This command is used by a current Administrator to instruct a Node to revoke any active Open Commissioning Window or Open Basic Commissioning Window command. */
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
cluster OperationalCredentials = 62 {
  revision 1; // NOTE: Default/not specifically set

  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string<900> attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string attestationSignature = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string NOCValue = 0;
    optional octet_string ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string rootCACertificate = 0;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** Sender is requesting to update the node operational certificates. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
cluster OperationalCredentials = 62 {
  revision 1; // NOTE: Default/not specifically set

  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string<900> attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string attestationSignature = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string NOCValue = 0;
    optional octet_string ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string rootCACertificate = 0;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** Sender is requesting to update the node operational certificates. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
cluster GroupKeyManagement = 63 {
  revision 1; // NOTE: Default/not specifically set

  enum GroupKeySecurityPolicyEnum : enum8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  bitmap Feature : bitmap32 {
    kCacheAndSync = 0x1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetRemoveRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    int16u groupKeySetIDs[] = 0;
  }

  /** Write a new set of keys for the given key set id. */
  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  /** Read the keys for a given key set id. */
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  /** Revoke a Root Key from a Group */
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  /** Return the list of Group Key Sets associated with the accessing fabric */
  fabric command access(invoke: administer) KeySetReadAllIndices(): KeySetReadAllIndicesResponse = 4;
}

/** The Fixed Label Cluster provides a feature for the device to tag an endpoint with zero or more read only
labels. */
cluster FixedLabel = 64 {
  revision 1; // NOTE: Default/not specifically set

  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Fixed Label Cluster provides a feature for the device to tag an endpoint with zero or more read only
labels. */
cluster FixedLabel = 64 {
  revision 1; // NOTE: Default/not specifically set

  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The User Label Cluster provides a feature to tag an endpoint with zero or more labels. */
cluster UserLabel = 65 {
  revision 1; // NOTE: Default/not specifically set

  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  attribute access(write: manage) LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface to a boolean state called StateValue. */
cluster BooleanState = 69 {
  revision 1;

  info event StateChange = 0 {
    boolean stateValue = 0;
  }

  readonly attribute boolean stateValue = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster ModeSelect = 80 {
  revision 2;

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct SemanticTagStruct {
    vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    SemanticTagStruct semanticTags[] = 2;
  }

  readonly attribute char_string<64> description = 0;
  readonly attribute nullable enum16 standardNamespace = 1;
  readonly attribute ModeOptionStruct supportedModes[] = 2;
  readonly attribute int8u currentMode = 3;
  attribute optional nullable int8u startUpMode = 4;
  attribute optional nullable int8u onMode = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  /** On receipt of this command, if the NewMode field matches the Mode field in an entry of the SupportedModes list, the server SHALL set the CurrentMode attribute to the NewMode value, otherwise, the server SHALL respond with an INVALID_COMMAND status response. */
  command ChangeToMode(ChangeToModeRequest): DefaultSuccess = 0;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster ModeSelect = 80 {
  revision 2;

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct SemanticTagStruct {
    vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    SemanticTagStruct semanticTags[] = 2;
  }

  readonly attribute char_string<64> description = 0;
  readonly attribute nullable enum16 standardNamespace = 1;
  readonly attribute ModeOptionStruct supportedModes[] = 2;
  readonly attribute int8u currentMode = 3;
  attribute optional nullable int8u startUpMode = 4;
  attribute optional nullable int8u onMode = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  /** On receipt of this command, if the NewMode field matches the Mode field in an entry of the SupportedModes list, the server SHALL set the CurrentMode attribute to the NewMode value, otherwise, the server SHALL respond with an INVALID_COMMAND status response. */
  command ChangeToMode(ChangeToModeRequest): DefaultSuccess = 0;
}

/** Attributes and commands for scene configuration and manipulation. */
provisional cluster ScenesManagement = 98 {
  revision 1;

  bitmap CopyModeBitmap : bitmap8 {
    kCopyAllScenes = 0x1;
  }

  bitmap Feature : bitmap32 {
    kSceneNames = 0x1;
  }

  struct AttributeValuePairStruct {
    attrib_id attributeID = 0;
    optional int8u valueUnsigned8 = 1;
    optional int8s valueSigned8 = 2;
    optional int16u valueUnsigned16 = 3;
    optional int16s valueSigned16 = 4;
    optional int32u valueUnsigned32 = 5;
    optional int32s valueSigned32 = 6;
    optional int64u valueUnsigned64 = 7;
    optional int64s valueSigned64 = 8;
  }

  struct ExtensionFieldSet {
    cluster_id clusterID = 0;
    AttributeValuePairStruct attributeValueList[] = 1;
  }

  fabric_scoped struct SceneInfoStruct {
    int8u sceneCount = 0;
    fabric_sensitive int8u currentScene = 1;
    fabric_sensitive group_id currentGroup = 2;
    fabric_sensitive boolean sceneValid = 3;
    int8u remainingCapacity = 4;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute optional nullable node_id lastConfiguredBy = 0;
  readonly attribute int16u sceneTableSize = 1;
  readonly attribute SceneInfoStruct fabricSceneInfo[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
    int32u transitionTime = 2;
    char_string sceneName = 3;
    ExtensionFieldSet extensionFieldSets[] = 4;
  }

  response struct AddSceneResponse = 0 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct ViewSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct ViewSceneResponse = 1 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
    optional int32u transitionTime = 3;
    optional char_string sceneName = 4;
    optional ExtensionFieldSet extensionFieldSets[] = 5;
  }

  request struct RemoveSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct RemoveSceneResponse = 2 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct RemoveAllScenesRequest {
    group_id groupID = 0;
  }

  response struct RemoveAllScenesResponse = 3 {
    status status = 0;
    group_id groupID = 1;
  }

  request struct StoreSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct StoreSceneResponse = 4 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct RecallSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
    optional nullable int32u transitionTime = 2;
  }

  request struct GetSceneMembershipRequest {
    group_id groupID = 0;
  }

  response struct GetSceneMembershipResponse = 6 {
    status status = 0;
    nullable int8u capacity = 1;
    group_id groupID = 2;
    optional int8u sceneList[] = 3;
  }

  request struct CopySceneRequest {
    CopyModeBitmap mode = 0;
    group_id groupIdentifierFrom = 1;
    int8u sceneIdentifierFrom = 2;
    group_id groupIdentifierTo = 3;
    int8u sceneIdentifierTo = 4;
  }

  response struct CopySceneResponse = 64 {
    status status = 0;
    group_id groupIdentifierFrom = 1;
    int8u sceneIdentifierFrom = 2;
  }

  /** Add a scene to the scene table. Extension field sets are supported, and are inputed as '{"ClusterID": VALUE, "AttributeValueList":[{"AttributeID": VALUE, "Value*": VALUE}]}' */
  fabric command access(invoke: manage) AddScene(AddSceneRequest): AddSceneResponse = 0;
  /** Retrieves the requested scene entry from its Scene table. */
  fabric command ViewScene(ViewSceneRequest): ViewSceneResponse = 1;
  /** Removes the requested scene entry, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveScene(RemoveSceneRequest): RemoveSceneResponse = 2;
  /** Remove all scenes, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveAllScenes(RemoveAllScenesRequest): RemoveAllScenesResponse = 3;
  /** Adds the scene entry into its Scene Table along with all extension field sets corresponding to the current state of other clusters on the same endpoint */
  fabric command access(invoke: manage) StoreScene(StoreSceneRequest): StoreSceneResponse = 4;
  /** Set the attributes and corresponding state for each other cluster implemented on the endpoint accordingly to the resquested scene entry in the Scene Table */
  fabric command RecallScene(RecallSceneRequest): DefaultSuccess = 5;
  /** Get an unused scene identifier when no commissioning tool is in the network, or for a commissioning tool to get the used scene identifiers within a certain group */
  fabric command GetSceneMembership(GetSceneMembershipRequest): GetSceneMembershipResponse = 6;
  /** Allows a client to efficiently copy scenes from one group/scene identifier pair to another group/scene identifier pair. */
  fabric command access(invoke: manage) CopyScene(CopySceneRequest): CopySceneResponse = 64;
}

/** An interface to a generic way to secure a door */
cluster DoorLock = 257 {
  revision 7;

  enum AlarmCodeEnum : enum8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : enum8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : enum8 {
    kProgrammingPIN = 0;
    kPIN = 1;
    kRFID = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
    kAliroCredentialIssuerKey = 6;
    kAliroEvictableEndpointKey = 7;
    kAliroNonEvictableEndpointKey = 8;
  }

  enum DataOperationTypeEnum : enum8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : enum8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : enum8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : enum8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : enum8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : enum8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : enum8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : enum8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPIN = 6;
    kRFID = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
    kAliroCredentialIssuerKey = 11;
    kAliroEvictableEndpointKey = 12;
    kAliroNonEvictableEndpointKey = 13;
  }

  enum LockOperationTypeEnum : enum8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : enum8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : enum8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : enum8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRFID = 8;
    kBiometric = 9;
    kAliro = 10;
  }

  enum UserStatusEnum : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : enum8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : bitmap16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : bitmap8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : bitmap16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : bitmap32 {
    kPINCredential = 0x1;
    kRFIDCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
    kAliroProvisioning = 0x2000;
    kAliroBLEUWB = 0x4000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable int16u userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable node_id sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    nullable int16u dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute optional nullable DoorStateEnum doorState = 3;
  attribute access(write: manage) optional int32u doorOpenEvents = 4;
  attribute access(write: manage) optional int32u doorClosedEvents = 5;
  attribute access(write: manage) optional int16u openPeriod = 6;
  readonly attribute optional int16u numberOfTotalUsersSupported = 17;
  readonly attribute optional int16u numberOfPINUsersSupported = 18;
  readonly attribute optional int16u numberOfRFIDUsersSupported = 19;
  readonly attribute optional int8u numberOfWeekDaySchedulesSupportedPerUser = 20;
  readonly attribute optional int8u numberOfYearDaySchedulesSupportedPerUser = 21;
  readonly attribute optional int8u numberOfHolidaySchedulesSupported = 22;
  readonly attribute optional int8u maxPINCodeLength = 23;
  readonly attribute optional int8u minPINCodeLength = 24;
  readonly attribute optional int8u maxRFIDCodeLength = 25;
  readonly attribute optional int8u minRFIDCodeLength = 26;
  readonly attribute optional DlCredentialRuleMask credentialRulesSupport = 27;
  readonly attribute optional int8u numberOfCredentialsSupportedPerUser = 28;
  attribute access(write: manage) optional char_string<3> language = 33;
  attribute access(write: manage) optional int8u LEDSettings = 34;
  attribute access(write: manage) optional int32u autoRelockTime = 35;
  attribute access(write: manage) optional int8u soundVolume = 36;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  readonly attribute optional DlDefaultConfigurationRegister defaultConfigurationRegister = 39;
  attribute access(write: administer) optional boolean enableLocalProgramming = 40;
  attribute access(write: manage) optional boolean enableOneTouchLocking = 41;
  attribute access(write: manage) optional boolean enableInsideStatusLED = 42;
  attribute access(write: manage) optional boolean enablePrivacyModeButton = 43;
  attribute access(write: administer) optional DlLocalProgrammingFeatures localProgrammingFeatures = 44;
  attribute access(write: administer) optional int8u wrongCodeEntryLimit = 48;
  attribute access(write: administer) optional int8u userCodeTemporaryDisableTime = 49;
  attribute access(write: administer) optional boolean sendPINOverTheAir = 50;
  attribute access(write: administer) optional boolean requirePINforRemoteOperation = 51;
  attribute access(write: administer) optional int16u expiringUserTimeout = 53;
  provisional readonly attribute access(read: administer) optional nullable octet_string<65> aliroReaderVerificationKey = 128;
  provisional readonly attribute access(read: administer) optional nullable octet_string<16> aliroReaderGroupIdentifier = 129;
  provisional readonly attribute access(read: administer) optional octet_string<16> aliroReaderGroupSubIdentifier = 130;
  provisional readonly attribute access(read: administer) optional octet_string aliroExpeditedTransactionSupportedProtocolVersions[] = 131;
  provisional readonly attribute access(read: administer) optional nullable octet_string<16> aliroGroupResolvingKey = 132;
  provisional readonly attribute access(read: administer) optional octet_string aliroSupportedBLEUWBProtocolVersions[] = 133;
  provisional readonly attribute access(read: administer) optional int8u aliroBLEAdvertisingVersion = 134;
  provisional readonly attribute optional int16u numberOfAliroCredentialIssuerKeysSupported = 135;
  provisional readonly attribute optional int16u numberOfAliroEndpointKeysSupported = 136;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockWithTimeoutRequest {
    int16u timeout = 0;
    optional octet_string PINCode = 1;
  }

  request struct SetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DaysMaskMap daysMask = 2;
    int8u startHour = 3;
    int8u startMinute = 4;
    int8u endHour = 5;
    int8u endMinute = 6;
  }

  request struct GetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetWeekDayScheduleResponse = 12 {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional DaysMaskMap daysMask = 3;
    optional int8u startHour = 4;
    optional int8u startMinute = 5;
    optional int8u endHour = 6;
    optional int8u endMinute = 7;
  }

  request struct ClearWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    epoch_s localStartTime = 2;
    epoch_s localEndTime = 3;
  }

  request struct GetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetYearDayScheduleResponse = 15 {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional epoch_s localStartTime = 3;
    optional epoch_s localEndTime = 4;
  }

  request struct ClearYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetHolidayScheduleRequest {
    int8u holidayIndex = 0;
    epoch_s localStartTime = 1;
    epoch_s localEndTime = 2;
    OperatingModeEnum operatingMode = 3;
  }

  request struct GetHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  response struct GetHolidayScheduleResponse = 18 {
    int8u holidayIndex = 0;
    DlStatus status = 1;
    optional epoch_s localStartTime = 2;
    optional epoch_s localEndTime = 3;
    optional OperatingModeEnum operatingMode = 4;
  }

  request struct ClearHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    int16u userIndex = 1;
    nullable char_string userName = 2;
    nullable int32u userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    int16u userIndex = 0;
  }

  response struct GetUserResponse = 28 {
    int16u userIndex = 0;
    nullable char_string userName = 1;
    nullable int32u userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable int16u nextUserIndex = 9;
  }

  request struct ClearUserRequest {
    int16u userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    long_octet_string credentialData = 2;
    nullable int16u userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable int16u userIndex = 1;
    nullable int16u nextCredentialIndex = 2;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable int16u userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable int16u nextCredentialIndex = 4;
    optional nullable octet_string credentialData = 5;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  request struct UnboltDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct SetAliroReaderConfigRequest {
    octet_string<32> signingKey = 0;
    octet_string<65> verificationKey = 1;
    octet_string<16> groupIdentifier = 2;
    optional octet_string<16> groupResolvingKey = 3;
  }

  /** This command causes the lock device to lock the door. */
  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  /** This command causes the lock device to unlock the door. */
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  /** This command causes the lock device to unlock the door with a timeout parameter. */
  timed command UnlockWithTimeout(UnlockWithTimeoutRequest): DefaultSuccess = 3;
  /** Set a weekly repeating schedule for a specified user. */
  command access(invoke: administer) SetWeekDaySchedule(SetWeekDayScheduleRequest): DefaultSuccess = 11;
  /** Retrieve the specific weekly schedule for the specific user. */
  command access(invoke: administer) GetWeekDaySchedule(GetWeekDayScheduleRequest): GetWeekDayScheduleResponse = 12;
  /** Clear the specific weekly schedule or all weekly schedules for the specific user. */
  command access(invoke: administer) ClearWeekDaySchedule(ClearWeekDayScheduleRequest): DefaultSuccess = 13;
  /** Set a time-specific schedule ID for a specified user. */
  command access(invoke: administer) SetYearDaySchedule(SetYearDayScheduleRequest): DefaultSuccess = 14;
  /** Returns the year day schedule data for the specified schedule and user indexes. */
  command access(invoke: administer) GetYearDaySchedule(GetYearDayScheduleRequest): GetYearDayScheduleResponse = 15;
  /** Clears the specific year day schedule or all year day schedules for the specific user. */
  command access(invoke: administer) ClearYearDaySchedule(ClearYearDayScheduleRequest): DefaultSuccess = 16;
  /** Set the holiday Schedule by specifying local start time and local end time with respect to any Lock Operating Mode. */
  command access(invoke: administer) SetHolidaySchedule(SetHolidayScheduleRequest): DefaultSuccess = 17;
  /** Get the holiday schedule for the specified index. */
  command access(invoke: administer) GetHolidaySchedule(GetHolidayScheduleRequest): GetHolidayScheduleResponse = 18;
  /** Clears the holiday schedule or all holiday schedules. */
  command access(invoke: administer) ClearHolidaySchedule(ClearHolidayScheduleRequest): DefaultSuccess = 19;
  /** Set User into the lock. */
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  /** Retrieve User. */
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  /** Clears a User or all Users. */
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  /** Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or ProgrammingUser. */
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  /** Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index. */
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
  /** Clear one, one type, or all credentials except ProgrammingPIN credential. */
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
  /** This command causes the lock device to unlock the door without pulling the latch. */
  timed command UnboltDoor(UnboltDoorRequest): DefaultSuccess = 39;
  /** This command communicates an Aliro Reader configuration to the lock. */
  timed command access(invoke: administer) SetAliroReaderConfig(SetAliroReaderConfigRequest): DefaultSuccess = 40;
  /** This command clears an existing Aliro Reader configuration for the lock. */
  timed command access(invoke: administer) ClearAliroReaderConfig(): DefaultSuccess = 41;
}

/** An interface to a generic way to secure a door */
cluster DoorLock = 257 {
  revision 7;

  enum AlarmCodeEnum : enum8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : enum8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : enum8 {
    kProgrammingPIN = 0;
    kPIN = 1;
    kRFID = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
    kAliroCredentialIssuerKey = 6;
    kAliroEvictableEndpointKey = 7;
    kAliroNonEvictableEndpointKey = 8;
  }

  enum DataOperationTypeEnum : enum8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : enum8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : enum8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : enum8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : enum8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : enum8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : enum8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : enum8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPIN = 6;
    kRFID = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
    kAliroCredentialIssuerKey = 11;
    kAliroEvictableEndpointKey = 12;
    kAliroNonEvictableEndpointKey = 13;
  }

  enum LockOperationTypeEnum : enum8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : enum8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : enum8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : enum8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRFID = 8;
    kBiometric = 9;
    kAliro = 10;
  }

  enum UserStatusEnum : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : enum8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : bitmap16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : bitmap8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : bitmap16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : bitmap32 {
    kPINCredential = 0x1;
    kRFIDCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
    kAliroProvisioning = 0x2000;
    kAliroBLEUWB = 0x4000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable int16u userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable node_id sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    nullable int16u dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute optional nullable DoorStateEnum doorState = 3;
  attribute access(write: manage) optional int32u doorOpenEvents = 4;
  attribute access(write: manage) optional int32u doorClosedEvents = 5;
  attribute access(write: manage) optional int16u openPeriod = 6;
  readonly attribute optional int16u numberOfTotalUsersSupported = 17;
  readonly attribute optional int16u numberOfPINUsersSupported = 18;
  readonly attribute optional int16u numberOfRFIDUsersSupported = 19;
  readonly attribute optional int8u numberOfWeekDaySchedulesSupportedPerUser = 20;
  readonly attribute optional int8u numberOfYearDaySchedulesSupportedPerUser = 21;
  readonly attribute optional int8u numberOfHolidaySchedulesSupported = 22;
  readonly attribute optional int8u maxPINCodeLength = 23;
  readonly attribute optional int8u minPINCodeLength = 24;
  readonly attribute optional int8u maxRFIDCodeLength = 25;
  readonly attribute optional int8u minRFIDCodeLength = 26;
  readonly attribute optional DlCredentialRuleMask credentialRulesSupport = 27;
  readonly attribute optional int8u numberOfCredentialsSupportedPerUser = 28;
  attribute access(write: manage) optional char_string<3> language = 33;
  attribute access(write: manage) optional int8u LEDSettings = 34;
  attribute access(write: manage) optional int32u autoRelockTime = 35;
  attribute access(write: manage) optional int8u soundVolume = 36;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  readonly attribute optional DlDefaultConfigurationRegister defaultConfigurationRegister = 39;
  attribute access(write: administer) optional boolean enableLocalProgramming = 40;
  attribute access(write: manage) optional boolean enableOneTouchLocking = 41;
  attribute access(write: manage) optional boolean enableInsideStatusLED = 42;
  attribute access(write: manage) optional boolean enablePrivacyModeButton = 43;
  attribute access(write: administer) optional DlLocalProgrammingFeatures localProgrammingFeatures = 44;
  attribute access(write: administer) optional int8u wrongCodeEntryLimit = 48;
  attribute access(write: administer) optional int8u userCodeTemporaryDisableTime = 49;
  attribute access(write: administer) optional boolean sendPINOverTheAir = 50;
  attribute access(write: administer) optional boolean requirePINforRemoteOperation = 51;
  attribute access(write: administer) optional int16u expiringUserTimeout = 53;
  provisional readonly attribute access(read: administer) optional nullable octet_string<65> aliroReaderVerificationKey = 128;
  provisional readonly attribute access(read: administer) optional nullable octet_string<16> aliroReaderGroupIdentifier = 129;
  provisional readonly attribute access(read: administer) optional octet_string<16> aliroReaderGroupSubIdentifier = 130;
  provisional readonly attribute access(read: administer) optional octet_string aliroExpeditedTransactionSupportedProtocolVersions[] = 131;
  provisional readonly attribute access(read: administer) optional nullable octet_string<16> aliroGroupResolvingKey = 132;
  provisional readonly attribute access(read: administer) optional octet_string aliroSupportedBLEUWBProtocolVersions[] = 133;
  provisional readonly attribute access(read: administer) optional int8u aliroBLEAdvertisingVersion = 134;
  provisional readonly attribute optional int16u numberOfAliroCredentialIssuerKeysSupported = 135;
  provisional readonly attribute optional int16u numberOfAliroEndpointKeysSupported = 136;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockWithTimeoutRequest {
    int16u timeout = 0;
    optional octet_string PINCode = 1;
  }

  request struct SetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DaysMaskMap daysMask = 2;
    int8u startHour = 3;
    int8u startMinute = 4;
    int8u endHour = 5;
    int8u endMinute = 6;
  }

  request struct GetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetWeekDayScheduleResponse = 12 {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional DaysMaskMap daysMask = 3;
    optional int8u startHour = 4;
    optional int8u startMinute = 5;
    optional int8u endHour = 6;
    optional int8u endMinute = 7;
  }

  request struct ClearWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    epoch_s localStartTime = 2;
    epoch_s localEndTime = 3;
  }

  request struct GetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetYearDayScheduleResponse = 15 {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional epoch_s localStartTime = 3;
    optional epoch_s localEndTime = 4;
  }

  request struct ClearYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetHolidayScheduleRequest {
    int8u holidayIndex = 0;
    epoch_s localStartTime = 1;
    epoch_s localEndTime = 2;
    OperatingModeEnum operatingMode = 3;
  }

  request struct GetHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  response struct GetHolidayScheduleResponse = 18 {
    int8u holidayIndex = 0;
    DlStatus status = 1;
    optional epoch_s localStartTime = 2;
    optional epoch_s localEndTime = 3;
    optional OperatingModeEnum operatingMode = 4;
  }

  request struct ClearHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    int16u userIndex = 1;
    nullable char_string userName = 2;
    nullable int32u userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    int16u userIndex = 0;
  }

  response struct GetUserResponse = 28 {
    int16u userIndex = 0;
    nullable char_string userName = 1;
    nullable int32u userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable int16u nextUserIndex = 9;
  }

  request struct ClearUserRequest {
    int16u userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    long_octet_string credentialData = 2;
    nullable int16u userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable int16u userIndex = 1;
    nullable int16u nextCredentialIndex = 2;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable int16u userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable int16u nextCredentialIndex = 4;
    optional nullable octet_string credentialData = 5;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  request struct UnboltDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct SetAliroReaderConfigRequest {
    octet_string<32> signingKey = 0;
    octet_string<65> verificationKey = 1;
    octet_string<16> groupIdentifier = 2;
    optional octet_string<16> groupResolvingKey = 3;
  }

  /** This command causes the lock device to lock the door. */
  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  /** This command causes the lock device to unlock the door. */
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  /** This command causes the lock device to unlock the door with a timeout parameter. */
  timed command UnlockWithTimeout(UnlockWithTimeoutRequest): DefaultSuccess = 3;
  /** Set a weekly repeating schedule for a specified user. */
  command access(invoke: administer) SetWeekDaySchedule(SetWeekDayScheduleRequest): DefaultSuccess = 11;
  /** Retrieve the specific weekly schedule for the specific user. */
  command access(invoke: administer) GetWeekDaySchedule(GetWeekDayScheduleRequest): GetWeekDayScheduleResponse = 12;
  /** Clear the specific weekly schedule or all weekly schedules for the specific user. */
  command access(invoke: administer) ClearWeekDaySchedule(ClearWeekDayScheduleRequest): DefaultSuccess = 13;
  /** Set a time-specific schedule ID for a specified user. */
  command access(invoke: administer) SetYearDaySchedule(SetYearDayScheduleRequest): DefaultSuccess = 14;
  /** Returns the year day schedule data for the specified schedule and user indexes. */
  command access(invoke: administer) GetYearDaySchedule(GetYearDayScheduleRequest): GetYearDayScheduleResponse = 15;
  /** Clears the specific year day schedule or all year day schedules for the specific user. */
  command access(invoke: administer) ClearYearDaySchedule(ClearYearDayScheduleRequest): DefaultSuccess = 16;
  /** Set the holiday Schedule by specifying local start time and local end time with respect to any Lock Operating Mode. */
  command access(invoke: administer) SetHolidaySchedule(SetHolidayScheduleRequest): DefaultSuccess = 17;
  /** Get the holiday schedule for the specified index. */
  command access(invoke: administer) GetHolidaySchedule(GetHolidayScheduleRequest): GetHolidayScheduleResponse = 18;
  /** Clears the holiday schedule or all holiday schedules. */
  command access(invoke: administer) ClearHolidaySchedule(ClearHolidayScheduleRequest): DefaultSuccess = 19;
  /** Set User into the lock. */
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  /** Retrieve User. */
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  /** Clears a User or all Users. */
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  /** Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or ProgrammingUser. */
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  /** Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index. */
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
  /** Clear one, one type, or all credentials except ProgrammingPIN credential. */
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
  /** This command causes the lock device to unlock the door without pulling the latch. */
  timed command UnboltDoor(UnboltDoorRequest): DefaultSuccess = 39;
  /** This command communicates an Aliro Reader configuration to the lock. */
  timed command access(invoke: administer) SetAliroReaderConfig(SetAliroReaderConfigRequest): DefaultSuccess = 40;
  /** This command clears an existing Aliro Reader configuration for the lock. */
  timed command access(invoke: administer) ClearAliroReaderConfig(): DefaultSuccess = 41;
}

/** Provides an interface for controlling and adjusting automatic window coverings. */
cluster WindowCovering = 258 {
  revision 5;

  enum EndProductType : enum8 {
    kRollerShade = 0;
    kRomanShade = 1;
    kBalloonShade = 2;
    kWovenWood = 3;
    kPleatedShade = 4;
    kCellularShade = 5;
    kLayeredShade = 6;
    kLayeredShade2D = 7;
    kSheerShade = 8;
    kTiltOnlyInteriorBlind = 9;
    kInteriorBlind = 10;
    kVerticalBlindStripCurtain = 11;
    kInteriorVenetianBlind = 12;
    kExteriorVenetianBlind = 13;
    kLateralLeftCurtain = 14;
    kLateralRightCurtain = 15;
    kCentralCurtain = 16;
    kRollerShutter = 17;
    kExteriorVerticalScreen = 18;
    kAwningTerracePatio = 19;
    kAwningVerticalScreen = 20;
    kTiltOnlyPergola = 21;
    kSwingingShutter = 22;
    kSlidingShutter = 23;
    kUnknown = 255;
  }

  enum Type : enum8 {
    kRollerShade = 0;
    kRollerShade2Motor = 1;
    kRollerShadeExterior = 2;
    kRollerShadeExterior2Motor = 3;
    kDrapery = 4;
    kAwning = 5;
    kShutter = 6;
    kTiltBlindTiltOnly = 7;
    kTiltBlindLiftAndTilt = 8;
    kProjectorScreen = 9;
    kUnknown = 255;
  }

  bitmap ConfigStatus : bitmap8 {
    kOperational = 0x1;
    kOnlineReserved = 0x2;
    kLiftMovementReversed = 0x4;
    kLiftPositionAware = 0x8;
    kTiltPositionAware = 0x10;
    kLiftEncoderControlled = 0x20;
    kTiltEncoderControlled = 0x40;
  }

  bitmap Feature : bitmap32 {
    kLift = 0x1;
    kTilt = 0x2;
    kPositionAwareLift = 0x4;
    kAbsolutePosition = 0x8;
    kPositionAwareTilt = 0x10;
  }

  bitmap Mode : bitmap8 {
    kMotorDirectionReversed = 0x1;
    kCalibrationMode = 0x2;
    kMaintenanceMode = 0x4;
    kLedFeedback = 0x8;
  }

  bitmap OperationalStatus : bitmap8 {
    kGlobal = 0x3;
    kLift = 0xC;
    kTilt = 0x30;
  }

  bitmap SafetyStatus : bitmap16 {
    kRemoteLockout = 0x1;
    kTamperDetection = 0x2;
    kFailedCommunication = 0x4;
    kPositionFailure = 0x8;
    kThermalProtection = 0x10;
    kObstacleDetected = 0x20;
    kPower = 0x40;
    kStopInput = 0x80;
    kMotorJammed = 0x100;
    kHardwareFailure = 0x200;
    kManualOperation = 0x400;
    kProtection = 0x800;
  }

  readonly attribute Type type = 0;
  readonly attribute optional int16u physicalClosedLimitLift = 1;
  readonly attribute optional int16u physicalClosedLimitTilt = 2;
  readonly attribute optional nullable int16u currentPositionLift = 3;
  readonly attribute optional nullable int16u currentPositionTilt = 4;
  readonly attribute optional int16u numberOfActuationsLift = 5;
  readonly attribute optional int16u numberOfActuationsTilt = 6;
  readonly attribute ConfigStatus configStatus = 7;
  readonly attribute optional nullable percent currentPositionLiftPercentage = 8;
  readonly attribute optional nullable percent currentPositionTiltPercentage = 9;
  readonly attribute OperationalStatus operationalStatus = 10;
  readonly attribute optional nullable percent100ths targetPositionLiftPercent100ths = 11;
  readonly attribute optional nullable percent100ths targetPositionTiltPercent100ths = 12;
  readonly attribute EndProductType endProductType = 13;
  readonly attribute optional nullable percent100ths currentPositionLiftPercent100ths = 14;
  readonly attribute optional nullable percent100ths currentPositionTiltPercent100ths = 15;
  readonly attribute optional int16u installedOpenLimitLift = 16;
  readonly attribute optional int16u installedClosedLimitLift = 17;
  readonly attribute optional int16u installedOpenLimitTilt = 18;
  readonly attribute optional int16u installedClosedLimitTilt = 19;
  attribute access(write: manage) Mode mode = 23;
  readonly attribute optional SafetyStatus safetyStatus = 26;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GoToLiftValueRequest {
    int16u liftValue = 0;
  }

  request struct GoToLiftPercentageRequest {
    percent100ths liftPercent100thsValue = 0;
  }

  request struct GoToTiltValueRequest {
    int16u tiltValue = 0;
  }

  request struct GoToTiltPercentageRequest {
    percent100ths tiltPercent100thsValue = 0;
  }

  /** Moves window covering to InstalledOpenLimitLift and InstalledOpenLimitTilt */
  command UpOrOpen(): DefaultSuccess = 0;
  /** Moves window covering to InstalledClosedLimitLift and InstalledCloseLimitTilt */
  command DownOrClose(): DefaultSuccess = 1;
  /** Stop any adjusting of window covering */
  command StopMotion(): DefaultSuccess = 2;
  /** Go to lift value specified */
  command GoToLiftValue(GoToLiftValueRequest): DefaultSuccess = 4;
  /** Go to lift percentage specified */
  command GoToLiftPercentage(GoToLiftPercentageRequest): DefaultSuccess = 5;
  /** Go to tilt value specified */
  command GoToTiltValue(GoToTiltValueRequest): DefaultSuccess = 7;
  /** Go to tilt percentage specified */
  command GoToTiltPercentage(GoToTiltPercentageRequest): DefaultSuccess = 8;
}

/** An interface for configuring and controlling pumps. */
cluster PumpConfigurationAndControl = 512 {
  revision 3;

  enum ControlModeEnum : enum8 {
    kConstantSpeed = 0;
    kConstantPressure = 1;
    kProportionalPressure = 2;
    kConstantFlow = 3;
    kConstantTemperature = 5;
    kAutomatic = 7;
  }

  enum OperationModeEnum : enum8 {
    kNormal = 0;
    kMinimum = 1;
    kMaximum = 2;
    kLocal = 3;
  }

  bitmap Feature : bitmap32 {
    kConstantPressure = 0x1;
    kCompensatedPressure = 0x2;
    kConstantFlow = 0x4;
    kConstantSpeed = 0x8;
    kConstantTemperature = 0x10;
    kAutomatic = 0x20;
    kLocalOperation = 0x40;
  }

  bitmap PumpStatusBitmap : bitmap16 {
    kDeviceFault = 0x1;
    kSupplyFault = 0x2;
    kSpeedLow = 0x4;
    kSpeedHigh = 0x8;
    kLocalOverride = 0x10;
    kRunning = 0x20;
    kRemotePressure = 0x40;
    kRemoteFlow = 0x80;
    kRemoteTemperature = 0x100;
  }

  info event SupplyVoltageLow = 0 {
  }

  info event SupplyVoltageHigh = 1 {
  }

  info event PowerMissingPhase = 2 {
  }

  info event SystemPressureLow = 3 {
  }

  info event SystemPressureHigh = 4 {
  }

  critical event DryRunning = 5 {
  }

  info event MotorTemperatureHigh = 6 {
  }

  critical event PumpMotorFatalFailure = 7 {
  }

  info event ElectronicTemperatureHigh = 8 {
  }

  critical event PumpBlocked = 9 {
  }

  info event SensorFailure = 10 {
  }

  info event ElectronicNonFatalFailure = 11 {
  }

  critical event ElectronicFatalFailure = 12 {
  }

  info event GeneralFault = 13 {
  }

  info event Leakage = 14 {
  }

  info event AirDetection = 15 {
  }

  info event TurbineOperation = 16 {
  }

  readonly attribute nullable int16s maxPressure = 0;
  readonly attribute nullable int16u maxSpeed = 1;
  readonly attribute nullable int16u maxFlow = 2;
  readonly attribute optional nullable int16s minConstPressure = 3;
  readonly attribute optional nullable int16s maxConstPressure = 4;
  readonly attribute optional nullable int16s minCompPressure = 5;
  readonly attribute optional nullable int16s maxCompPressure = 6;
  readonly attribute optional nullable int16u minConstSpeed = 7;
  readonly attribute optional nullable int16u maxConstSpeed = 8;
  readonly attribute optional nullable int16u minConstFlow = 9;
  readonly attribute optional nullable int16u maxConstFlow = 10;
  readonly attribute optional nullable int16s minConstTemp = 11;
  readonly attribute optional nullable int16s maxConstTemp = 12;
  readonly attribute optional PumpStatusBitmap pumpStatus = 16;
  readonly attribute OperationModeEnum effectiveOperationMode = 17;
  readonly attribute ControlModeEnum effectiveControlMode = 18;
  readonly attribute nullable int16s capacity = 19;
  readonly attribute optional nullable int16u speed = 20;
  attribute access(write: manage) optional nullable int24u lifetimeRunningHours = 21;
  readonly attribute optional nullable int24u power = 22;
  attribute access(write: manage) optional nullable int32u lifetimeEnergyConsumed = 23;
  attribute access(write: manage) OperationModeEnum operationMode = 32;
  attribute access(write: manage) optional ControlModeEnum controlMode = 33;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** An interface for configuring and controlling the functionality of a thermostat. */
cluster Thermostat = 513 {
  revision 7;

  enum ACCapacityFormatEnum : enum8 {
    kBTUh = 0;
  }

  enum ACCompressorTypeEnum : enum8 {
    kUnknown = 0;
    kT1 = 1;
    kT2 = 2;
    kT3 = 3;
  }

  enum ACLouverPositionEnum : enum8 {
    kClosed = 1;
    kOpen = 2;
    kQuarter = 3;
    kHalf = 4;
    kThreeQuarters = 5;
  }

  enum ACRefrigerantTypeEnum : enum8 {
    kUnknown = 0;
    kR22 = 1;
    kR410a = 2;
    kR407c = 3;
  }

  enum ACTypeEnum : enum8 {
    kUnknown = 0;
    kCoolingFixed = 1;
    kHeatPumpFixed = 2;
    kCoolingInverter = 3;
    kHeatPumpInverter = 4;
  }

  enum ControlSequenceOfOperationEnum : enum8 {
    kCoolingOnly = 0;
    kCoolingWithReheat = 1;
    kHeatingOnly = 2;
    kHeatingWithReheat = 3;
    kCoolingAndHeating = 4;
    kCoolingAndHeatingWithReheat = 5;
  }

  enum PresetScenarioEnum : enum8 {
    kOccupied = 1;
    kUnoccupied = 2;
    kSleep = 3;
    kWake = 4;
    kVacation = 5;
    kGoingToSleep = 6;
    kUserDefined = 254;
  }

  enum SetpointChangeSourceEnum : enum8 {
    kManual = 0;
    kSchedule = 1;
    kExternal = 2;
  }

  enum SetpointRaiseLowerModeEnum : enum8 {
    kHeat = 0;
    kCool = 1;
    kBoth = 2;
  }

  enum StartOfWeekEnum : enum8 {
    kSunday = 0;
    kMonday = 1;
    kTuesday = 2;
    kWednesday = 3;
    kThursday = 4;
    kFriday = 5;
    kSaturday = 6;
  }

  enum SystemModeEnum : enum8 {
    kOff = 0;
    kAuto = 1;
    kCool = 3;
    kHeat = 4;
    kEmergencyHeat = 5;
    kPrecooling = 6;
    kFanOnly = 7;
    kDry = 8;
    kSleep = 9;
  }

  enum TemperatureSetpointHoldEnum : enum8 {
    kSetpointHoldOff = 0;
    kSetpointHoldOn = 1;
  }

  enum ThermostatRunningModeEnum : enum8 {
    kOff = 0;
    kCool = 3;
    kHeat = 4;
  }

  bitmap ACErrorCodeBitmap : bitmap32 {
    kCompressorFail = 0x1;
    kRoomSensorFail = 0x2;
    kOutdoorSensorFail = 0x4;
    kCoilSensorFail = 0x8;
    kFanFail = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHeating = 0x1;
    kCooling = 0x2;
    kOccupancy = 0x4;
    kScheduleConfiguration = 0x8;
    kSetback = 0x10;
    kAutoMode = 0x20;
    kLocalTemperatureNotExposed = 0x40;
    kMatterScheduleConfiguration = 0x80;
    kPresets = 0x100;
  }

  bitmap HVACSystemTypeBitmap : bitmap8 {
    kCoolingStage = 0x3;
    kHeatingStage = 0xC;
    kHeatingIsHeatPump = 0x10;
    kHeatingUsesFuel = 0x20;
  }

  bitmap OccupancyBitmap : bitmap8 {
    kOccupied = 0x1;
  }

  bitmap PresetTypeFeaturesBitmap : bitmap16 {
    kAutomatic = 0x1;
    kSupportsNames = 0x2;
  }

  bitmap ProgrammingOperationModeBitmap : bitmap8 {
    kScheduleActive = 0x1;
    kAutoRecovery = 0x2;
    kEconomy = 0x4;
  }

  bitmap RelayStateBitmap : bitmap16 {
    kHeat = 0x1;
    kCool = 0x2;
    kFan = 0x4;
    kHeatStage2 = 0x8;
    kCoolStage2 = 0x10;
    kFanStage2 = 0x20;
    kFanStage3 = 0x40;
  }

  bitmap RemoteSensingBitmap : bitmap8 {
    kLocalTemperature = 0x1;
    kOutdoorTemperature = 0x2;
    kOccupancy = 0x4;
  }

  bitmap ScheduleDayOfWeekBitmap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
    kAway = 0x80;
  }

  bitmap ScheduleModeBitmap : bitmap8 {
    kHeatSetpointPresent = 0x1;
    kCoolSetpointPresent = 0x2;
  }

  bitmap ScheduleTypeFeaturesBitmap : bitmap16 {
    kSupportsPresets = 0x1;
    kSupportsSetpoints = 0x2;
    kSupportsNames = 0x4;
    kSupportsOff = 0x8;
  }

  struct ScheduleTransitionStruct {
    ScheduleDayOfWeekBitmap dayOfWeek = 0;
    int16u transitionTime = 1;
    optional octet_string<16> presetHandle = 2;
    optional SystemModeEnum systemMode = 3;
    optional temperature coolingSetpoint = 4;
    optional temperature heatingSetpoint = 5;
  }

  struct ScheduleStruct {
    nullable octet_string<16> scheduleHandle = 0;
    SystemModeEnum systemMode = 1;
    optional char_string<64> name = 2;
    optional octet_string<16> presetHandle = 3;
    ScheduleTransitionStruct transitions[] = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetStruct {
    nullable octet_string<16> presetHandle = 0;
    PresetScenarioEnum presetScenario = 1;
    optional nullable char_string<64> name = 2;
    optional temperature coolingSetpoint = 3;
    optional temperature heatingSetpoint = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetTypeStruct {
    PresetScenarioEnum presetScenario = 0;
    int8u numberOfPresets = 1;
    PresetTypeFeaturesBitmap presetTypeFeatures = 2;
  }

  struct ScheduleTypeStruct {
    SystemModeEnum systemMode = 0;
    int8u numberOfSchedules = 1;
    ScheduleTypeFeaturesBitmap scheduleTypeFeatures = 2;
  }

  struct WeeklyScheduleTransitionStruct {
    int16u transitionTime = 0;
    nullable temperature heatSetpoint = 1;
    nullable temperature coolSetpoint = 2;
  }

  readonly attribute nullable temperature localTemperature = 0;
  readonly attribute optional nullable temperature outdoorTemperature = 1;
  readonly attribute optional OccupancyBitmap occupancy = 2;
  readonly attribute optional temperature absMinHeatSetpointLimit = 3;
  readonly attribute optional temperature absMaxHeatSetpointLimit = 4;
  readonly attribute optional temperature absMinCoolSetpointLimit = 5;
  readonly attribute optional temperature absMaxCoolSetpointLimit = 6;
  readonly attribute optional int8u PICoolingDemand = 7;
  readonly attribute optional int8u PIHeatingDemand = 8;
  attribute access(write: manage) optional HVACSystemTypeBitmap HVACSystemTypeConfiguration = 9;
  attribute access(write: manage) optional int8s localTemperatureCalibration = 16;
  attribute optional temperature occupiedCoolingSetpoint = 17;
  attribute optional temperature occupiedHeatingSetpoint = 18;
  attribute optional temperature unoccupiedCoolingSetpoint = 19;
  attribute optional temperature unoccupiedHeatingSetpoint = 20;
  attribute access(write: manage) optional temperature minHeatSetpointLimit = 21;
  attribute access(write: manage) optional temperature maxHeatSetpointLimit = 22;
  attribute access(write: manage) optional temperature minCoolSetpointLimit = 23;
  attribute access(write: manage) optional temperature maxCoolSetpointLimit = 24;
  attribute access(write: manage) optional int8s minSetpointDeadBand = 25;
  attribute access(write: manage) optional RemoteSensingBitmap remoteSensing = 26;
  attribute access(write: manage) ControlSequenceOfOperationEnum controlSequenceOfOperation = 27;
  attribute access(write: manage) SystemModeEnum systemMode = 28;
  readonly attribute optional ThermostatRunningModeEnum thermostatRunningMode = 30;
  readonly attribute optional StartOfWeekEnum startOfWeek = 32;
  readonly attribute optional int8u numberOfWeeklyTransitions = 33;
  readonly attribute optional int8u numberOfDailyTransitions = 34;
  attribute access(write: manage) optional TemperatureSetpointHoldEnum temperatureSetpointHold = 35;
  attribute access(write: manage) optional nullable int16u temperatureSetpointHoldDuration = 36;
  attribute access(write: manage) optional ProgrammingOperationModeBitmap thermostatProgrammingOperationMode = 37;
  readonly attribute optional RelayStateBitmap thermostatRunningState = 41;
  readonly attribute optional SetpointChangeSourceEnum setpointChangeSource = 48;
  readonly attribute optional nullable int16s setpointChangeAmount = 49;
  readonly attribute optional epoch_s setpointChangeSourceTimestamp = 50;
  attribute access(write: manage) optional nullable int8u occupiedSetback = 52;
  readonly attribute optional nullable int8u occupiedSetbackMin = 53;
  readonly attribute optional nullable int8u occupiedSetbackMax = 54;
  attribute access(write: manage) optional nullable int8u unoccupiedSetback = 55;
  readonly attribute optional nullable int8u unoccupiedSetbackMin = 56;
  readonly attribute optional nullable int8u unoccupiedSetbackMax = 57;
  attribute access(write: manage) optional int8u emergencyHeatDelta = 58;
  attribute access(write: manage) optional ACTypeEnum ACType = 64;
  attribute access(write: manage) optional int16u ACCapacity = 65;
  attribute access(write: manage) optional ACRefrigerantTypeEnum ACRefrigerantType = 66;
  attribute access(write: manage) optional ACCompressorTypeEnum ACCompressorType = 67;
  attribute access(write: manage) optional ACErrorCodeBitmap ACErrorCode = 68;
  attribute access(write: manage) optional ACLouverPositionEnum ACLouverPosition = 69;
  readonly attribute optional nullable temperature ACCoilTemperature = 70;
  attribute access(write: manage) optional ACCapacityFormatEnum ACCapacityformat = 71;
  readonly attribute optional PresetTypeStruct presetTypes[] = 72;
  readonly attribute optional ScheduleTypeStruct scheduleTypes[] = 73;
  readonly attribute optional int8u numberOfPresets = 74;
  readonly attribute optional int8u numberOfSchedules = 75;
  readonly attribute optional int8u numberOfScheduleTransitions = 76;
  readonly attribute optional nullable int8u numberOfScheduleTransitionPerDay = 77;
  readonly attribute optional nullable octet_string<16> activePresetHandle = 78;
  readonly attribute optional nullable octet_string<16> activeScheduleHandle = 79;
  attribute access(write: manage) optional PresetStruct presets[] = 80;
  attribute access(write: manage) optional ScheduleStruct schedules[] = 81;
  readonly attribute optional nullable epoch_s setpointHoldExpiryTimestamp = 82;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetpointRaiseLowerRequest {
    SetpointRaiseLowerModeEnum mode = 0;
    int8s amount = 1;
  }

  response struct GetWeeklyScheduleResponse = 0 {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct SetWeeklyScheduleRequest {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct GetWeeklyScheduleRequest {
    ScheduleDayOfWeekBitmap daysToReturn = 0;
    ScheduleModeBitmap modeToReturn = 1;
  }

  request struct SetActiveScheduleRequestRequest {
    octet_string<16> scheduleHandle = 0;
  }

  request struct SetActivePresetRequestRequest {
    nullable octet_string<16> presetHandle = 0;
  }

  response struct AtomicResponse = 253 {
    status statusCode = 0;
    AtomicAttributeStatusStruct attributeStatus[] = 1;
    optional int16u timeout = 2;
  }

  request struct AtomicRequestRequest {
    AtomicRequestTypeEnum requestType = 0;
    attrib_id attributeRequests[] = 1;
    optional int16u timeout = 2;
  }

  /** Upon receipt, the attributes for the indicated setpoint(s) SHALL have the amount specified in the Amount field added to them. */
  command SetpointRaiseLower(SetpointRaiseLowerRequest): DefaultSuccess = 0;
  /** This command is used to update the thermostat weekly setpoint schedule from a management system. */
  command access(invoke: manage) SetWeeklySchedule(SetWeeklyScheduleRequest): DefaultSuccess = 1;
  /** The Current Weekly Schedule Command is sent from the server in response to the Get Weekly Schedule Command. */
  command GetWeeklySchedule(GetWeeklyScheduleRequest): GetWeeklyScheduleResponse = 2;
  /** This command is used to clear the weekly schedule. */
  command access(invoke: manage) ClearWeeklySchedule(): DefaultSuccess = 3;
  /** Upon receipt, if the Schedules attribute contains a ScheduleStruct whose ScheduleHandle field matches the value of the ScheduleHandle field, the server SHALL set the thermostat's ActiveScheduleHandle attribute to the value of the ScheduleHandle field. */
  command SetActiveScheduleRequest(SetActiveScheduleRequestRequest): DefaultSuccess = 5;
  /** ID */
  command SetActivePresetRequest(SetActivePresetRequestRequest): DefaultSuccess = 6;
  /** Begins, Commits or Cancels an atomic write */
  command access(invoke: manage) AtomicRequest(AtomicRequestRequest): AtomicResponse = 254;
}

/** An interface for configuring and controlling the functionality of a thermostat. */
cluster Thermostat = 513 {
  revision 7;

  enum ACCapacityFormatEnum : enum8 {
    kBTUh = 0;
  }

  enum ACCompressorTypeEnum : enum8 {
    kUnknown = 0;
    kT1 = 1;
    kT2 = 2;
    kT3 = 3;
  }

  enum ACLouverPositionEnum : enum8 {
    kClosed = 1;
    kOpen = 2;
    kQuarter = 3;
    kHalf = 4;
    kThreeQuarters = 5;
  }

  enum ACRefrigerantTypeEnum : enum8 {
    kUnknown = 0;
    kR22 = 1;
    kR410a = 2;
    kR407c = 3;
  }

  enum ACTypeEnum : enum8 {
    kUnknown = 0;
    kCoolingFixed = 1;
    kHeatPumpFixed = 2;
    kCoolingInverter = 3;
    kHeatPumpInverter = 4;
  }

  enum ControlSequenceOfOperationEnum : enum8 {
    kCoolingOnly = 0;
    kCoolingWithReheat = 1;
    kHeatingOnly = 2;
    kHeatingWithReheat = 3;
    kCoolingAndHeating = 4;
    kCoolingAndHeatingWithReheat = 5;
  }

  enum PresetScenarioEnum : enum8 {
    kOccupied = 1;
    kUnoccupied = 2;
    kSleep = 3;
    kWake = 4;
    kVacation = 5;
    kGoingToSleep = 6;
    kUserDefined = 254;
  }

  enum SetpointChangeSourceEnum : enum8 {
    kManual = 0;
    kSchedule = 1;
    kExternal = 2;
  }

  enum SetpointRaiseLowerModeEnum : enum8 {
    kHeat = 0;
    kCool = 1;
    kBoth = 2;
  }

  enum StartOfWeekEnum : enum8 {
    kSunday = 0;
    kMonday = 1;
    kTuesday = 2;
    kWednesday = 3;
    kThursday = 4;
    kFriday = 5;
    kSaturday = 6;
  }

  enum SystemModeEnum : enum8 {
    kOff = 0;
    kAuto = 1;
    kCool = 3;
    kHeat = 4;
    kEmergencyHeat = 5;
    kPrecooling = 6;
    kFanOnly = 7;
    kDry = 8;
    kSleep = 9;
  }

  enum TemperatureSetpointHoldEnum : enum8 {
    kSetpointHoldOff = 0;
    kSetpointHoldOn = 1;
  }

  enum ThermostatRunningModeEnum : enum8 {
    kOff = 0;
    kCool = 3;
    kHeat = 4;
  }

  bitmap ACErrorCodeBitmap : bitmap32 {
    kCompressorFail = 0x1;
    kRoomSensorFail = 0x2;
    kOutdoorSensorFail = 0x4;
    kCoilSensorFail = 0x8;
    kFanFail = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHeating = 0x1;
    kCooling = 0x2;
    kOccupancy = 0x4;
    kScheduleConfiguration = 0x8;
    kSetback = 0x10;
    kAutoMode = 0x20;
    kLocalTemperatureNotExposed = 0x40;
    kMatterScheduleConfiguration = 0x80;
    kPresets = 0x100;
  }

  bitmap HVACSystemTypeBitmap : bitmap8 {
    kCoolingStage = 0x3;
    kHeatingStage = 0xC;
    kHeatingIsHeatPump = 0x10;
    kHeatingUsesFuel = 0x20;
  }

  bitmap OccupancyBitmap : bitmap8 {
    kOccupied = 0x1;
  }

  bitmap PresetTypeFeaturesBitmap : bitmap16 {
    kAutomatic = 0x1;
    kSupportsNames = 0x2;
  }

  bitmap ProgrammingOperationModeBitmap : bitmap8 {
    kScheduleActive = 0x1;
    kAutoRecovery = 0x2;
    kEconomy = 0x4;
  }

  bitmap RelayStateBitmap : bitmap16 {
    kHeat = 0x1;
    kCool = 0x2;
    kFan = 0x4;
    kHeatStage2 = 0x8;
    kCoolStage2 = 0x10;
    kFanStage2 = 0x20;
    kFanStage3 = 0x40;
  }

  bitmap RemoteSensingBitmap : bitmap8 {
    kLocalTemperature = 0x1;
    kOutdoorTemperature = 0x2;
    kOccupancy = 0x4;
  }

  bitmap ScheduleDayOfWeekBitmap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
    kAway = 0x80;
  }

  bitmap ScheduleModeBitmap : bitmap8 {
    kHeatSetpointPresent = 0x1;
    kCoolSetpointPresent = 0x2;
  }

  bitmap ScheduleTypeFeaturesBitmap : bitmap16 {
    kSupportsPresets = 0x1;
    kSupportsSetpoints = 0x2;
    kSupportsNames = 0x4;
    kSupportsOff = 0x8;
  }

  struct ScheduleTransitionStruct {
    ScheduleDayOfWeekBitmap dayOfWeek = 0;
    int16u transitionTime = 1;
    optional octet_string<16> presetHandle = 2;
    optional SystemModeEnum systemMode = 3;
    optional temperature coolingSetpoint = 4;
    optional temperature heatingSetpoint = 5;
  }

  struct ScheduleStruct {
    nullable octet_string<16> scheduleHandle = 0;
    SystemModeEnum systemMode = 1;
    optional char_string<64> name = 2;
    optional octet_string<16> presetHandle = 3;
    ScheduleTransitionStruct transitions[] = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetStruct {
    nullable octet_string<16> presetHandle = 0;
    PresetScenarioEnum presetScenario = 1;
    optional nullable char_string<64> name = 2;
    optional temperature coolingSetpoint = 3;
    optional temperature heatingSetpoint = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetTypeStruct {
    PresetScenarioEnum presetScenario = 0;
    int8u numberOfPresets = 1;
    PresetTypeFeaturesBitmap presetTypeFeatures = 2;
  }

  struct ScheduleTypeStruct {
    SystemModeEnum systemMode = 0;
    int8u numberOfSchedules = 1;
    ScheduleTypeFeaturesBitmap scheduleTypeFeatures = 2;
  }

  struct WeeklyScheduleTransitionStruct {
    int16u transitionTime = 0;
    nullable temperature heatSetpoint = 1;
    nullable temperature coolSetpoint = 2;
  }

  readonly attribute nullable temperature localTemperature = 0;
  readonly attribute optional nullable temperature outdoorTemperature = 1;
  readonly attribute optional OccupancyBitmap occupancy = 2;
  readonly attribute optional temperature absMinHeatSetpointLimit = 3;
  readonly attribute optional temperature absMaxHeatSetpointLimit = 4;
  readonly attribute optional temperature absMinCoolSetpointLimit = 5;
  readonly attribute optional temperature absMaxCoolSetpointLimit = 6;
  readonly attribute optional int8u PICoolingDemand = 7;
  readonly attribute optional int8u PIHeatingDemand = 8;
  attribute access(write: manage) optional HVACSystemTypeBitmap HVACSystemTypeConfiguration = 9;
  attribute access(write: manage) optional int8s localTemperatureCalibration = 16;
  attribute optional temperature occupiedCoolingSetpoint = 17;
  attribute optional temperature occupiedHeatingSetpoint = 18;
  attribute optional temperature unoccupiedCoolingSetpoint = 19;
  attribute optional temperature unoccupiedHeatingSetpoint = 20;
  attribute access(write: manage) optional temperature minHeatSetpointLimit = 21;
  attribute access(write: manage) optional temperature maxHeatSetpointLimit = 22;
  attribute access(write: manage) optional temperature minCoolSetpointLimit = 23;
  attribute access(write: manage) optional temperature maxCoolSetpointLimit = 24;
  attribute access(write: manage) optional int8s minSetpointDeadBand = 25;
  attribute access(write: manage) optional RemoteSensingBitmap remoteSensing = 26;
  attribute access(write: manage) ControlSequenceOfOperationEnum controlSequenceOfOperation = 27;
  attribute access(write: manage) SystemModeEnum systemMode = 28;
  readonly attribute optional ThermostatRunningModeEnum thermostatRunningMode = 30;
  readonly attribute optional StartOfWeekEnum startOfWeek = 32;
  readonly attribute optional int8u numberOfWeeklyTransitions = 33;
  readonly attribute optional int8u numberOfDailyTransitions = 34;
  attribute access(write: manage) optional TemperatureSetpointHoldEnum temperatureSetpointHold = 35;
  attribute access(write: manage) optional nullable int16u temperatureSetpointHoldDuration = 36;
  attribute access(write: manage) optional ProgrammingOperationModeBitmap thermostatProgrammingOperationMode = 37;
  readonly attribute optional RelayStateBitmap thermostatRunningState = 41;
  readonly attribute optional SetpointChangeSourceEnum setpointChangeSource = 48;
  readonly attribute optional nullable int16s setpointChangeAmount = 49;
  readonly attribute optional epoch_s setpointChangeSourceTimestamp = 50;
  attribute access(write: manage) optional nullable int8u occupiedSetback = 52;
  readonly attribute optional nullable int8u occupiedSetbackMin = 53;
  readonly attribute optional nullable int8u occupiedSetbackMax = 54;
  attribute access(write: manage) optional nullable int8u unoccupiedSetback = 55;
  readonly attribute optional nullable int8u unoccupiedSetbackMin = 56;
  readonly attribute optional nullable int8u unoccupiedSetbackMax = 57;
  attribute access(write: manage) optional int8u emergencyHeatDelta = 58;
  attribute access(write: manage) optional ACTypeEnum ACType = 64;
  attribute access(write: manage) optional int16u ACCapacity = 65;
  attribute access(write: manage) optional ACRefrigerantTypeEnum ACRefrigerantType = 66;
  attribute access(write: manage) optional ACCompressorTypeEnum ACCompressorType = 67;
  attribute access(write: manage) optional ACErrorCodeBitmap ACErrorCode = 68;
  attribute access(write: manage) optional ACLouverPositionEnum ACLouverPosition = 69;
  readonly attribute optional nullable temperature ACCoilTemperature = 70;
  attribute access(write: manage) optional ACCapacityFormatEnum ACCapacityformat = 71;
  readonly attribute optional PresetTypeStruct presetTypes[] = 72;
  readonly attribute optional ScheduleTypeStruct scheduleTypes[] = 73;
  readonly attribute optional int8u numberOfPresets = 74;
  readonly attribute optional int8u numberOfSchedules = 75;
  readonly attribute optional int8u numberOfScheduleTransitions = 76;
  readonly attribute optional nullable int8u numberOfScheduleTransitionPerDay = 77;
  readonly attribute optional nullable octet_string<16> activePresetHandle = 78;
  readonly attribute optional nullable octet_string<16> activeScheduleHandle = 79;
  attribute access(write: manage) optional PresetStruct presets[] = 80;
  attribute access(write: manage) optional ScheduleStruct schedules[] = 81;
  readonly attribute optional nullable epoch_s setpointHoldExpiryTimestamp = 82;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetpointRaiseLowerRequest {
    SetpointRaiseLowerModeEnum mode = 0;
    int8s amount = 1;
  }

  response struct GetWeeklyScheduleResponse = 0 {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct SetWeeklyScheduleRequest {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct GetWeeklyScheduleRequest {
    ScheduleDayOfWeekBitmap daysToReturn = 0;
    ScheduleModeBitmap modeToReturn = 1;
  }

  request struct SetActiveScheduleRequestRequest {
    octet_string<16> scheduleHandle = 0;
  }

  request struct SetActivePresetRequestRequest {
    nullable octet_string<16> presetHandle = 0;
  }

  response struct AtomicResponse = 253 {
    status statusCode = 0;
    AtomicAttributeStatusStruct attributeStatus[] = 1;
    optional int16u timeout = 2;
  }

  request struct AtomicRequestRequest {
    AtomicRequestTypeEnum requestType = 0;
    attrib_id attributeRequests[] = 1;
    optional int16u timeout = 2;
  }

  /** Upon receipt, the attributes for the indicated setpoint(s) SHALL have the amount specified in the Amount field added to them. */
  command SetpointRaiseLower(SetpointRaiseLowerRequest): DefaultSuccess = 0;
  /** This command is used to update the thermostat weekly setpoint schedule from a management system. */
  command access(invoke: manage) SetWeeklySchedule(SetWeeklyScheduleRequest): DefaultSuccess = 1;
  /** The Current Weekly Schedule Command is sent from the server in response to the Get Weekly Schedule Command. */
  command GetWeeklySchedule(GetWeeklyScheduleRequest): GetWeeklyScheduleResponse = 2;
  /** This command is used to clear the weekly schedule. */
  command access(invoke: manage) ClearWeeklySchedule(): DefaultSuccess = 3;
  /** Upon receipt, if the Schedules attribute contains a ScheduleStruct whose ScheduleHandle field matches the value of the ScheduleHandle field, the server SHALL set the thermostat's ActiveScheduleHandle attribute to the value of the ScheduleHandle field. */
  command SetActiveScheduleRequest(SetActiveScheduleRequestRequest): DefaultSuccess = 5;
  /** ID */
  command SetActivePresetRequest(SetActivePresetRequestRequest): DefaultSuccess = 6;
  /** Begins, Commits or Cancels an atomic write */
  command access(invoke: manage) AtomicRequest(AtomicRequestRequest): AtomicResponse = 254;
}

/** An interface for configuring the user interface of a thermostat (which may be remote from the thermostat). */
cluster ThermostatUserInterfaceConfiguration = 516 {
  revision 2;

  enum KeypadLockoutEnum : enum8 {
    kNoLockout = 0;
    kLockout1 = 1;
    kLockout2 = 2;
    kLockout3 = 3;
    kLockout4 = 4;
    kLockout5 = 5;
  }

  enum ScheduleProgrammingVisibilityEnum : enum8 {
    kScheduleProgrammingPermitted = 0;
    kScheduleProgrammingDenied = 1;
  }

  enum TemperatureDisplayModeEnum : enum8 {
    kCelsius = 0;
    kFahrenheit = 1;
  }

  attribute TemperatureDisplayModeEnum temperatureDisplayMode = 0;
  attribute access(write: manage) KeypadLockoutEnum keypadLockout = 1;
  attribute access(write: manage) optional ScheduleProgrammingVisibilityEnum scheduleProgrammingVisibility = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** An interface for configuring the user interface of a thermostat (which may be remote from the thermostat). */
cluster ThermostatUserInterfaceConfiguration = 516 {
  revision 2;

  enum KeypadLockoutEnum : enum8 {
    kNoLockout = 0;
    kLockout1 = 1;
    kLockout2 = 2;
    kLockout3 = 3;
    kLockout4 = 4;
    kLockout5 = 5;
  }

  enum ScheduleProgrammingVisibilityEnum : enum8 {
    kScheduleProgrammingPermitted = 0;
    kScheduleProgrammingDenied = 1;
  }

  enum TemperatureDisplayModeEnum : enum8 {
    kCelsius = 0;
    kFahrenheit = 1;
  }

  attribute TemperatureDisplayModeEnum temperatureDisplayMode = 0;
  attribute access(write: manage) KeypadLockoutEnum keypadLockout = 1;
  attribute access(write: manage) optional ScheduleProgrammingVisibilityEnum scheduleProgrammingVisibility = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for controlling the color properties of a color-capable light. */
cluster ColorControl = 768 {
  revision 7;

  enum ColorLoopActionEnum : enum8 {
    kDeactivate = 0;
    kActivateFromColorLoopStartEnhancedHue = 1;
    kActivateFromEnhancedCurrentHue = 2;
  }

  enum ColorLoopDirectionEnum : enum8 {
    kDecrement = 0;
    kIncrement = 1;
  }

  enum ColorModeEnum : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperatureMireds = 2;
  }

  enum DirectionEnum : enum8 {
    kShortest = 0;
    kLongest = 1;
    kUp = 2;
    kDown = 3;
  }

  enum DriftCompensationEnum : enum8 {
    kNone = 0;
    kOtherOrUnknown = 1;
    kTemperatureMonitoring = 2;
    kOpticalLuminanceMonitoringAndFeedback = 3;
    kOpticalColorMonitoringAndFeedback = 4;
  }

  enum EnhancedColorModeEnum : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperatureMireds = 2;
    kEnhancedCurrentHueAndCurrentSaturation = 3;
  }

  enum MoveModeEnum : enum8 {
    kStop = 0;
    kUp = 1;
    kDown = 3;
  }

  enum StepModeEnum : enum8 {
    kUp = 1;
    kDown = 3;
  }

  bitmap ColorCapabilitiesBitmap : bitmap16 {
    kHueSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8;
    kColorTemperature = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHueAndSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8;
    kColorTemperature = 0x10;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
  }

  bitmap UpdateFlagsBitmap : bitmap8 {
    kUpdateAction = 0x1;
    kUpdateDirection = 0x2;
    kUpdateTime = 0x4;
    kUpdateStartHue = 0x8;
  }

  readonly attribute optional int8u currentHue = 0;
  readonly attribute optional int8u currentSaturation = 1;
  readonly attribute optional int16u remainingTime = 2;
  readonly attribute optional int16u currentX = 3;
  readonly attribute optional int16u currentY = 4;
  readonly attribute optional DriftCompensationEnum driftCompensation = 5;
  readonly attribute optional char_string<254> compensationText = 6;
  readonly attribute optional int16u colorTemperatureMireds = 7;
  readonly attribute ColorModeEnum colorMode = 8;
  attribute OptionsBitmap options = 15;
  readonly attribute nullable int8u numberOfPrimaries = 16;
  readonly attribute optional int16u primary1X = 17;
  readonly attribute optional int16u primary1Y = 18;
  readonly attribute optional nullable int8u primary1Intensity = 19;
  readonly attribute optional int16u primary2X = 21;
  readonly attribute optional int16u primary2Y = 22;
  readonly attribute optional nullable int8u primary2Intensity = 23;
  readonly attribute optional int16u primary3X = 25;
  readonly attribute optional int16u primary3Y = 26;
  readonly attribute optional nullable int8u primary3Intensity = 27;
  readonly attribute optional int16u primary4X = 32;
  readonly attribute optional int16u primary4Y = 33;
  readonly attribute optional nullable int8u primary4Intensity = 34;
  readonly attribute optional int16u primary5X = 36;
  readonly attribute optional int16u primary5Y = 37;
  readonly attribute optional nullable int8u primary5Intensity = 38;
  readonly attribute optional int16u primary6X = 40;
  readonly attribute optional int16u primary6Y = 41;
  readonly attribute optional nullable int8u primary6Intensity = 42;
  attribute access(write: manage) optional int16u whitePointX = 48;
  attribute access(write: manage) optional int16u whitePointY = 49;
  attribute access(write: manage) optional int16u colorPointRX = 50;
  attribute access(write: manage) optional int16u colorPointRY = 51;
  attribute access(write: manage) optional nullable int8u colorPointRIntensity = 52;
  attribute access(write: manage) optional int16u colorPointGX = 54;
  attribute access(write: manage) optional int16u colorPointGY = 55;
  attribute access(write: manage) optional nullable int8u colorPointGIntensity = 56;
  attribute access(write: manage) optional int16u colorPointBX = 58;
  attribute access(write: manage) optional int16u colorPointBY = 59;
  attribute access(write: manage) optional nullable int8u colorPointBIntensity = 60;
  readonly attribute optional int16u enhancedCurrentHue = 16384;
  readonly attribute EnhancedColorModeEnum enhancedColorMode = 16385;
  readonly attribute optional int8u colorLoopActive = 16386;
  readonly attribute optional int8u colorLoopDirection = 16387;
  readonly attribute optional int16u colorLoopTime = 16388;
  readonly attribute optional int16u colorLoopStartEnhancedHue = 16389;
  readonly attribute optional int16u colorLoopStoredEnhancedHue = 16390;
  readonly attribute ColorCapabilitiesBitmap colorCapabilities = 16394;
  readonly attribute optional int16u colorTempPhysicalMinMireds = 16395;
  readonly attribute optional int16u colorTempPhysicalMaxMireds = 16396;
  readonly attribute optional int16u coupleColorTempToLevelMinMireds = 16397;
  attribute access(write: manage) optional nullable int16u startUpColorTemperatureMireds = 16400;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToHueRequest {
    int8u hue = 0;
    DirectionEnum direction = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveHueRequest {
    MoveModeEnum moveMode = 0;
    int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepHueRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToSaturationRequest {
    int8u saturation = 0;
    int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveSaturationRequest {
    MoveModeEnum moveMode = 0;
    int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepSaturationRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToHueAndSaturationRequest {
    int8u hue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToColorRequest {
    int16u colorX = 0;
    int16u colorY = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveColorRequest {
    int16s rateX = 0;
    int16s rateY = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepColorRequest {
    int16s stepX = 0;
    int16s stepY = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToColorTemperatureRequest {
    int16u colorTemperatureMireds = 0;
    int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct EnhancedMoveToHueRequest {
    int16u enhancedHue = 0;
    DirectionEnum direction = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct EnhancedMoveHueRequest {
    MoveModeEnum moveMode = 0;
    int16u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct EnhancedStepHueRequest {
    StepModeEnum stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct EnhancedMoveToHueAndSaturationRequest {
    int16u enhancedHue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct ColorLoopSetRequest {
    UpdateFlagsBitmap updateFlags = 0;
    ColorLoopActionEnum action = 1;
    ColorLoopDirectionEnum direction = 2;
    int16u time = 3;
    int16u startHue = 4;
    OptionsBitmap optionsMask = 5;
    OptionsBitmap optionsOverride = 6;
  }

  request struct StopMoveStepRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveColorTemperatureRequest {
    MoveModeEnum moveMode = 0;
    int16u rate = 1;
    int16u colorTemperatureMinimumMireds = 2;
    int16u colorTemperatureMaximumMireds = 3;
    OptionsBitmap optionsMask = 4;
    OptionsBitmap optionsOverride = 5;
  }

  request struct StepColorTemperatureRequest {
    StepModeEnum stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    int16u colorTemperatureMinimumMireds = 3;
    int16u colorTemperatureMaximumMireds = 4;
    OptionsBitmap optionsMask = 5;
    OptionsBitmap optionsOverride = 6;
  }

  /** Move to specified hue. */
  command MoveToHue(MoveToHueRequest): DefaultSuccess = 0;
  /** Move hue up or down at specified rate. */
  command MoveHue(MoveHueRequest): DefaultSuccess = 1;
  /** Step hue up or down by specified size at specified rate. */
  command StepHue(StepHueRequest): DefaultSuccess = 2;
  /** Move to specified saturation. */
  command MoveToSaturation(MoveToSaturationRequest): DefaultSuccess = 3;
  /** Move saturation up or down at specified rate. */
  command MoveSaturation(MoveSaturationRequest): DefaultSuccess = 4;
  /** Step saturation up or down by specified size at specified rate. */
  command StepSaturation(StepSaturationRequest): DefaultSuccess = 5;
  /** Move to hue and saturation. */
  command MoveToHueAndSaturation(MoveToHueAndSaturationRequest): DefaultSuccess = 6;
  /** Move to specified color. */
  command MoveToColor(MoveToColorRequest): DefaultSuccess = 7;
  /** Moves the color. */
  command MoveColor(MoveColorRequest): DefaultSuccess = 8;
  /** Steps the lighting to a specific color. */
  command StepColor(StepColorRequest): DefaultSuccess = 9;
  /** Move to a specific color temperature. */
  command MoveToColorTemperature(MoveToColorTemperatureRequest): DefaultSuccess = 10;
  /** Command description for EnhancedMoveToHue */
  command EnhancedMoveToHue(EnhancedMoveToHueRequest): DefaultSuccess = 64;
  /** Command description for EnhancedMoveHue */
  command EnhancedMoveHue(EnhancedMoveHueRequest): DefaultSuccess = 65;
  /** Command description for EnhancedStepHue */
  command EnhancedStepHue(EnhancedStepHueRequest): DefaultSuccess = 66;
  /** Command description for EnhancedMoveToHueAndSaturation */
  command EnhancedMoveToHueAndSaturation(EnhancedMoveToHueAndSaturationRequest): DefaultSuccess = 67;
  /** Command description for ColorLoopSet */
  command ColorLoopSet(ColorLoopSetRequest): DefaultSuccess = 68;
  /** Command description for StopMoveStep */
  command StopMoveStep(StopMoveStepRequest): DefaultSuccess = 71;
  /** Command description for MoveColorTemperature */
  command MoveColorTemperature(MoveColorTemperatureRequest): DefaultSuccess = 75;
  /** Command description for StepColorTemperature */
  command StepColorTemperature(StepColorTemperatureRequest): DefaultSuccess = 76;
}

/** Attributes and commands for controlling the color properties of a color-capable light. */
cluster ColorControl = 768 {
  revision 7;

  enum ColorLoopActionEnum : enum8 {
    kDeactivate = 0;
    kActivateFromColorLoopStartEnhancedHue = 1;
    kActivateFromEnhancedCurrentHue = 2;
  }

  enum ColorLoopDirectionEnum : enum8 {
    kDecrement = 0;
    kIncrement = 1;
  }

  enum ColorModeEnum : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperatureMireds = 2;
  }

  enum DirectionEnum : enum8 {
    kShortest = 0;
    kLongest = 1;
    kUp = 2;
    kDown = 3;
  }

  enum DriftCompensationEnum : enum8 {
    kNone = 0;
    kOtherOrUnknown = 1;
    kTemperatureMonitoring = 2;
    kOpticalLuminanceMonitoringAndFeedback = 3;
    kOpticalColorMonitoringAndFeedback = 4;
  }

  enum EnhancedColorModeEnum : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperatureMireds = 2;
    kEnhancedCurrentHueAndCurrentSaturation = 3;
  }

  enum MoveModeEnum : enum8 {
    kStop = 0;
    kUp = 1;
    kDown = 3;
  }

  enum StepModeEnum : enum8 {
    kUp = 1;
    kDown = 3;
  }

  bitmap ColorCapabilitiesBitmap : bitmap16 {
    kHueSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8;
    kColorTemperature = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHueAndSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8;
    kColorTemperature = 0x10;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
  }

  bitmap UpdateFlagsBitmap : bitmap8 {
    kUpdateAction = 0x1;
    kUpdateDirection = 0x2;
    kUpdateTime = 0x4;
    kUpdateStartHue = 0x8;
  }

  readonly attribute optional int8u currentHue = 0;
  readonly attribute optional int8u currentSaturation = 1;
  readonly attribute optional int16u remainingTime = 2;
  readonly attribute optional int16u currentX = 3;
  readonly attribute optional int16u currentY = 4;
  readonly attribute optional DriftCompensationEnum driftCompensation = 5;
  readonly attribute optional char_string<254> compensationText = 6;
  readonly attribute optional int16u colorTemperatureMireds = 7;
  readonly attribute ColorModeEnum colorMode = 8;
  attribute OptionsBitmap options = 15;
  readonly attribute nullable int8u numberOfPrimaries = 16;
  readonly attribute optional int16u primary1X = 17;
  readonly attribute optional int16u primary1Y = 18;
  readonly attribute optional nullable int8u primary1Intensity = 19;
  readonly attribute optional int16u primary2X = 21;
  readonly attribute optional int16u primary2Y = 22;
  readonly attribute optional nullable int8u primary2Intensity = 23;
  readonly attribute optional int16u primary3X = 25;
  readonly attribute optional int16u primary3Y = 26;
  readonly attribute optional nullable int8u primary3Intensity = 27;
  readonly attribute optional int16u primary4X = 32;
  readonly attribute optional int16u primary4Y = 33;
  readonly attribute optional nullable int8u primary4Intensity = 34;
  readonly attribute optional int16u primary5X = 36;
  readonly attribute optional int16u primary5Y = 37;
  readonly attribute optional nullable int8u primary5Intensity = 38;
  readonly attribute optional int16u primary6X = 40;
  readonly attribute optional int16u primary6Y = 41;
  readonly attribute optional nullable int8u primary6Intensity = 42;
  attribute access(write: manage) optional int16u whitePointX = 48;
  attribute access(write: manage) optional int16u whitePointY = 49;
  attribute access(write: manage) optional int16u colorPointRX = 50;
  attribute access(write: manage) optional int16u colorPointRY = 51;
  attribute access(write: manage) optional nullable int8u colorPointRIntensity = 52;
  attribute access(write: manage) optional int16u colorPointGX = 54;
  attribute access(write: manage) optional int16u colorPointGY = 55;
  attribute access(write: manage) optional nullable int8u colorPointGIntensity = 56;
  attribute access(write: manage) optional int16u colorPointBX = 58;
  attribute access(write: manage) optional int16u colorPointBY = 59;
  attribute access(write: manage) optional nullable int8u colorPointBIntensity = 60;
  readonly attribute optional int16u enhancedCurrentHue = 16384;
  readonly attribute EnhancedColorModeEnum enhancedColorMode = 16385;
  readonly attribute optional int8u colorLoopActive = 16386;
  readonly attribute optional int8u colorLoopDirection = 16387;
  readonly attribute optional int16u colorLoopTime = 16388;
  readonly attribute optional int16u colorLoopStartEnhancedHue = 16389;
  readonly attribute optional int16u colorLoopStoredEnhancedHue = 16390;
  readonly attribute ColorCapabilitiesBitmap colorCapabilities = 16394;
  readonly attribute optional int16u colorTempPhysicalMinMireds = 16395;
  readonly attribute optional int16u colorTempPhysicalMaxMireds = 16396;
  readonly attribute optional int16u coupleColorTempToLevelMinMireds = 16397;
  attribute access(write: manage) optional nullable int16u startUpColorTemperatureMireds = 16400;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToHueRequest {
    int8u hue = 0;
    DirectionEnum direction = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveHueRequest {
    MoveModeEnum moveMode = 0;
    int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepHueRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToSaturationRequest {
    int8u saturation = 0;
    int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveSaturationRequest {
    MoveModeEnum moveMode = 0;
    int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepSaturationRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToHueAndSaturationRequest {
    int8u hue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToColorRequest {
    int16u colorX = 0;
    int16u colorY = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveColorRequest {
    int16s rateX = 0;
    int16s rateY = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepColorRequest {
    int16s stepX = 0;
    int16s stepY = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToColorTemperatureRequest {
    int16u colorTemperatureMireds = 0;
    int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct EnhancedMoveToHueRequest {
    int16u enhancedHue = 0;
    DirectionEnum direction = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct EnhancedMoveHueRequest {
    MoveModeEnum moveMode = 0;
    int16u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct EnhancedStepHueRequest {
    StepModeEnum stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct EnhancedMoveToHueAndSaturationRequest {
    int16u enhancedHue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct ColorLoopSetRequest {
    UpdateFlagsBitmap updateFlags = 0;
    ColorLoopActionEnum action = 1;
    ColorLoopDirectionEnum direction = 2;
    int16u time = 3;
    int16u startHue = 4;
    OptionsBitmap optionsMask = 5;
    OptionsBitmap optionsOverride = 6;
  }

  request struct StopMoveStepRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveColorTemperatureRequest {
    MoveModeEnum moveMode = 0;
    int16u rate = 1;
    int16u colorTemperatureMinimumMireds = 2;
    int16u colorTemperatureMaximumMireds = 3;
    OptionsBitmap optionsMask = 4;
    OptionsBitmap optionsOverride = 5;
  }

  request struct StepColorTemperatureRequest {
    StepModeEnum stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    int16u colorTemperatureMinimumMireds = 3;
    int16u colorTemperatureMaximumMireds = 4;
    OptionsBitmap optionsMask = 5;
    OptionsBitmap optionsOverride = 6;
  }

  /** Move to specified hue. */
  command MoveToHue(MoveToHueRequest): DefaultSuccess = 0;
  /** Move hue up or down at specified rate. */
  command MoveHue(MoveHueRequest): DefaultSuccess = 1;
  /** Step hue up or down by specified size at specified rate. */
  command StepHue(StepHueRequest): DefaultSuccess = 2;
  /** Move to specified saturation. */
  command MoveToSaturation(MoveToSaturationRequest): DefaultSuccess = 3;
  /** Move saturation up or down at specified rate. */
  command MoveSaturation(MoveSaturationRequest): DefaultSuccess = 4;
  /** Step saturation up or down by specified size at specified rate. */
  command StepSaturation(StepSaturationRequest): DefaultSuccess = 5;
  /** Move to hue and saturation. */
  command MoveToHueAndSaturation(MoveToHueAndSaturationRequest): DefaultSuccess = 6;
  /** Move to specified color. */
  command MoveToColor(MoveToColorRequest): DefaultSuccess = 7;
  /** Moves the color. */
  command MoveColor(MoveColorRequest): DefaultSuccess = 8;
  /** Steps the lighting to a specific color. */
  command StepColor(StepColorRequest): DefaultSuccess = 9;
  /** Move to a specific color temperature. */
  command MoveToColorTemperature(MoveToColorTemperatureRequest): DefaultSuccess = 10;
  /** Command description for EnhancedMoveToHue */
  command EnhancedMoveToHue(EnhancedMoveToHueRequest): DefaultSuccess = 64;
  /** Command description for EnhancedMoveHue */
  command EnhancedMoveHue(EnhancedMoveHueRequest): DefaultSuccess = 65;
  /** Command description for EnhancedStepHue */
  command EnhancedStepHue(EnhancedStepHueRequest): DefaultSuccess = 66;
  /** Command description for EnhancedMoveToHueAndSaturation */
  command EnhancedMoveToHueAndSaturation(EnhancedMoveToHueAndSaturationRequest): DefaultSuccess = 67;
  /** Command description for ColorLoopSet */
  command ColorLoopSet(ColorLoopSetRequest): DefaultSuccess = 68;
  /** Command description for StopMoveStep */
  command StopMoveStep(StopMoveStepRequest): DefaultSuccess = 71;
  /** Command description for MoveColorTemperature */
  command MoveColorTemperature(MoveColorTemperatureRequest): DefaultSuccess = 75;
  /** Command description for StepColorTemperature */
  command StepColorTemperature(StepColorTemperatureRequest): DefaultSuccess = 76;
}

/** Attributes and commands for configuring the measurement of illuminance, and reporting illuminance measurements. */
cluster IlluminanceMeasurement = 1024 {
  revision 3;

  enum LightSensorTypeEnum : enum8 {
    kPhotodiode = 0;
    kCMOS = 1;
  }

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable LightSensorTypeEnum lightSensorType = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of temperature, and reporting temperature measurements. */
cluster TemperatureMeasurement = 1026 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute nullable temperature measuredValue = 0;
  readonly attribute nullable temperature minMeasuredValue = 1;
  readonly attribute nullable temperature maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of temperature, and reporting temperature measurements. */
cluster TemperatureMeasurement = 1026 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute nullable temperature measuredValue = 0;
  readonly attribute nullable temperature minMeasuredValue = 1;
  readonly attribute nullable temperature maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of pressure, and reporting pressure measurements. */
cluster PressureMeasurement = 1027 {
  revision 3;

  bitmap Feature : bitmap32 {
    kExtended = 0x1;
  }

  readonly attribute nullable int16s measuredValue = 0;
  readonly attribute nullable int16s minMeasuredValue = 1;
  readonly attribute nullable int16s maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable int16s scaledValue = 16;
  readonly attribute optional nullable int16s minScaledValue = 17;
  readonly attribute optional nullable int16s maxScaledValue = 18;
  readonly attribute optional int16u scaledTolerance = 19;
  readonly attribute optional int8s scale = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of flow, and reporting flow measurements. */
cluster FlowMeasurement = 1028 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of relative humidity, and reporting relative humidity measurements. */
cluster RelativeHumidityMeasurement = 1029 {
  revision 3;

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of relative humidity, and reporting relative humidity measurements. */
cluster RelativeHumidityMeasurement = 1029 {
  revision 3;

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The server cluster provides an interface to occupancy sensing functionality based on one or more sensing modalities, including configuration and provision of notifications of occupancy status. */
cluster OccupancySensing = 1030 {
  revision 5;

  enum OccupancySensorTypeEnum : enum8 {
    kPIR = 0;
    kUltrasonic = 1;
    kPIRAndUltrasonic = 2;
    kPhysicalContact = 3;
  }

  bitmap Feature : bitmap32 {
    kOther = 0x1;
    kPassiveInfrared = 0x2;
    kUltrasonic = 0x4;
    kPhysicalContact = 0x8;
    kActiveInfrared = 0x10;
    kRadar = 0x20;
    kRFSensing = 0x40;
    kVision = 0x80;
  }

  bitmap OccupancyBitmap : bitmap8 {
    kOccupied = 0x1;
  }

  bitmap OccupancySensorTypeBitmap : bitmap8 {
    kPIR = 0x1;
    kUltrasonic = 0x2;
    kPhysicalContact = 0x4;
  }

  struct HoldTimeLimitsStruct {
    int16u holdTimeMin = 0;
    int16u holdTimeMax = 1;
    int16u holdTimeDefault = 2;
  }

  info event OccupancyChanged = 0 {
    OccupancyBitmap occupancy = 0;
  }

  readonly attribute OccupancyBitmap occupancy = 0;
  readonly attribute OccupancySensorTypeEnum occupancySensorType = 1;
  readonly attribute OccupancySensorTypeBitmap occupancySensorTypeBitmap = 2;
  attribute access(write: manage) optional int16u holdTime = 3;
  readonly attribute optional HoldTimeLimitsStruct holdTimeLimits = 4;
  attribute access(write: manage) optional int16u PIROccupiedToUnoccupiedDelay = 16;
  attribute access(write: manage) optional int16u PIRUnoccupiedToOccupiedDelay = 17;
  attribute access(write: manage) optional int8u PIRUnoccupiedToOccupiedThreshold = 18;
  attribute access(write: manage) optional int16u ultrasonicOccupiedToUnoccupiedDelay = 32;
  attribute access(write: manage) optional int16u ultrasonicUnoccupiedToOccupiedDelay = 33;
  attribute access(write: manage) optional int8u ultrasonicUnoccupiedToOccupiedThreshold = 34;
  attribute access(write: manage) optional int16u physicalContactOccupiedToUnoccupiedDelay = 48;
  attribute access(write: manage) optional int16u physicalContactUnoccupiedToOccupiedDelay = 49;
  attribute access(write: manage) optional int8u physicalContactUnoccupiedToOccupiedThreshold = 50;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Manage the Thread network of Thread Border Router */
provisional cluster ThreadBorderRouterManagement = 1106 {
  revision 1;

  bitmap Feature : bitmap32 {
    kPANChange = 0x1;
  }

  provisional readonly attribute char_string<63> borderRouterName = 0;
  provisional readonly attribute octet_string<254> borderAgentID = 1;
  provisional readonly attribute int16u threadVersion = 2;
  provisional readonly attribute boolean interfaceEnabled = 3;
  provisional readonly attribute nullable int64u activeDatasetTimestamp = 4;
  provisional readonly attribute nullable int64u pendingDatasetTimestamp = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct DatasetResponse = 2 {
    octet_string<254> dataset = 0;
  }

  request struct SetActiveDatasetRequestRequest {
    octet_string<254> activeDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct SetPendingDatasetRequestRequest {
    octet_string<254> pendingDataset = 0;
  }

  /** Command to request the active operational dataset of the Thread network to which the border router is connected. This command must be sent over a valid CASE session */
  command access(invoke: manage) GetActiveDatasetRequest(): DatasetResponse = 0;
  /** Command to request the pending dataset of the Thread network to which the border router is connected. This command must be sent over a valid CASE session */
  command access(invoke: manage) GetPendingDatasetRequest(): DatasetResponse = 1;
  /** Command to set or update the active Dataset of the Thread network to which the Border Router is connected. */
  command access(invoke: manage) SetActiveDatasetRequest(SetActiveDatasetRequestRequest): DefaultSuccess = 3;
  /** Command set or update the pending Dataset of the Thread network to which the Border Router is connected. */
  command access(invoke: manage) SetPendingDatasetRequest(SetPendingDatasetRequestRequest): DefaultSuccess = 4;
}

/** This cluster provides an interface for controlling the current Channel on a device. */
cluster Channel = 1284 {
  revision 2;

  enum ChannelTypeEnum : enum8 {
    kSatellite = 0;
    kCable = 1;
    kTerrestrial = 2;
    kOTT = 3;
  }

  enum LineupInfoTypeEnum : enum8 {
    kMSO = 0;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kMultipleMatches = 1;
    kNoMatches = 2;
  }

  bitmap Feature : bitmap32 {
    kChannelList = 0x1;
    kLineupInfo = 0x2;
    kElectronicGuide = 0x4;
    kRecordProgram = 0x8;
  }

  bitmap RecordingFlagBitmap : bitmap32 {
    kScheduled = 0x1;
    kRecordSeries = 0x2;
    kRecorded = 0x4;
  }

  struct ProgramCastStruct {
    char_string name = 0;
    char_string role = 1;
  }

  struct ProgramCategoryStruct {
    char_string category = 0;
    optional char_string subCategory = 1;
  }

  struct SeriesInfoStruct {
    char_string season = 0;
    char_string episode = 1;
  }

  struct ChannelInfoStruct {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
    optional char_string name = 2;
    optional char_string callSign = 3;
    optional char_string affiliateCallSign = 4;
    optional char_string identifier = 5;
    optional ChannelTypeEnum type = 6;
  }

  struct ProgramStruct {
    char_string identifier = 0;
    ChannelInfoStruct channel = 1;
    epoch_s startTime = 2;
    epoch_s endTime = 3;
    char_string title = 4;
    optional char_string subtitle = 5;
    optional char_string description = 6;
    optional char_string audioLanguages[] = 7;
    optional char_string ratings[] = 8;
    optional char_string thumbnailUrl = 9;
    optional char_string posterArtUrl = 10;
    optional char_string dvbiUrl = 11;
    optional char_string releaseDate = 12;
    optional char_string parentalGuidanceText = 13;
    optional RecordingFlagBitmap recordingFlag = 14;
    optional nullable SeriesInfoStruct seriesInfo = 15;
    optional ProgramCategoryStruct categoryList[] = 16;
    optional ProgramCastStruct castList[] = 17;
    optional ProgramCastStruct externalIDList[] = 18;
  }

  struct PageTokenStruct {
    optional int16u limit = 0;
    optional char_string after = 1;
    optional char_string before = 2;
  }

  struct ChannelPagingStruct {
    optional nullable PageTokenStruct previousToken = 0;
    optional nullable PageTokenStruct nextToken = 1;
  }

  struct AdditionalInfoStruct {
    char_string name = 0;
    char_string value = 1;
  }

  struct LineupInfoStruct {
    char_string operatorName = 0;
    optional char_string lineupName = 1;
    optional char_string postalCode = 2;
    LineupInfoTypeEnum lineupInfoType = 3;
  }

  readonly attribute optional ChannelInfoStruct channelList[] = 0;
  readonly attribute optional nullable LineupInfoStruct lineup = 1;
  readonly attribute optional nullable ChannelInfoStruct currentChannel = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeChannelRequest {
    char_string match = 0;
  }

  response struct ChangeChannelResponse = 1 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  request struct ChangeChannelByNumberRequest {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
  }

  request struct SkipChannelRequest {
    int16s count = 0;
  }

  request struct GetProgramGuideRequest {
    optional epoch_s startTime = 0;
    optional epoch_s endTime = 1;
    optional ChannelInfoStruct channelList[] = 2;
    optional PageTokenStruct pageToken = 3;
    optional RecordingFlagBitmap recordingFlag = 4;
    optional AdditionalInfoStruct externalIDList[] = 5;
    optional octet_string data = 6;
  }

  response struct ProgramGuideResponse = 5 {
    ChannelPagingStruct paging = 0;
    ProgramStruct programList[] = 1;
  }

  request struct RecordProgramRequest {
    char_string programIdentifier = 0;
    boolean shouldRecordSeries = 1;
    AdditionalInfoStruct externalIDList[] = 2;
    octet_string data = 3;
  }

  request struct CancelRecordProgramRequest {
    char_string programIdentifier = 0;
    boolean shouldRecordSeries = 1;
    AdditionalInfoStruct externalIDList[] = 2;
    octet_string data = 3;
  }

  /** Change the channel on the media player to the channel case-insensitive exact matching the value passed as an argument. */
  command ChangeChannel(ChangeChannelRequest): ChangeChannelResponse = 0;
  /** Change the channel on the media plaeyer to the channel with the given Number in the ChannelList attribute. */
  command ChangeChannelByNumber(ChangeChannelByNumberRequest): DefaultSuccess = 2;
  /** This command provides channel up and channel down functionality, but allows channel index jumps of size Count. When the value of the increase or decrease is larger than the number of channels remaining in the given direction, then the behavior SHALL be to return to the beginning (or end) of the channel list and continue. For example, if the current channel is at index 0 and count value of -1 is given, then the current channel should change to the last channel. */
  command SkipChannel(SkipChannelRequest): DefaultSuccess = 3;
  /** This command retrieves the program guide. It accepts several filter parameters to return specific schedule and program information from a content app. The command shall receive in response a ProgramGuideResponse. */
  command GetProgramGuide(GetProgramGuideRequest): ProgramGuideResponse = 4;
  /** Record a specific program or series when it goes live. This functionality enables DVR recording features. */
  command RecordProgram(RecordProgramRequest): DefaultSuccess = 6;
  /** Cancel recording for a specific program or series. */
  command CancelRecordProgram(CancelRecordProgramRequest): DefaultSuccess = 7;
}

/** This cluster provides an interface for controlling the current Channel on a device. */
cluster Channel = 1284 {
  revision 2;

  enum ChannelTypeEnum : enum8 {
    kSatellite = 0;
    kCable = 1;
    kTerrestrial = 2;
    kOTT = 3;
  }

  enum LineupInfoTypeEnum : enum8 {
    kMSO = 0;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kMultipleMatches = 1;
    kNoMatches = 2;
  }

  bitmap Feature : bitmap32 {
    kChannelList = 0x1;
    kLineupInfo = 0x2;
    kElectronicGuide = 0x4;
    kRecordProgram = 0x8;
  }

  bitmap RecordingFlagBitmap : bitmap32 {
    kScheduled = 0x1;
    kRecordSeries = 0x2;
    kRecorded = 0x4;
  }

  struct ProgramCastStruct {
    char_string name = 0;
    char_string role = 1;
  }

  struct ProgramCategoryStruct {
    char_string category = 0;
    optional char_string subCategory = 1;
  }

  struct SeriesInfoStruct {
    char_string season = 0;
    char_string episode = 1;
  }

  struct ChannelInfoStruct {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
    optional char_string name = 2;
    optional char_string callSign = 3;
    optional char_string affiliateCallSign = 4;
    optional char_string identifier = 5;
    optional ChannelTypeEnum type = 6;
  }

  struct ProgramStruct {
    char_string identifier = 0;
    ChannelInfoStruct channel = 1;
    epoch_s startTime = 2;
    epoch_s endTime = 3;
    char_string title = 4;
    optional char_string subtitle = 5;
    optional char_string description = 6;
    optional char_string audioLanguages[] = 7;
    optional char_string ratings[] = 8;
    optional char_string thumbnailUrl = 9;
    optional char_string posterArtUrl = 10;
    optional char_string dvbiUrl = 11;
    optional char_string releaseDate = 12;
    optional char_string parentalGuidanceText = 13;
    optional RecordingFlagBitmap recordingFlag = 14;
    optional nullable SeriesInfoStruct seriesInfo = 15;
    optional ProgramCategoryStruct categoryList[] = 16;
    optional ProgramCastStruct castList[] = 17;
    optional ProgramCastStruct externalIDList[] = 18;
  }

  struct PageTokenStruct {
    optional int16u limit = 0;
    optional char_string after = 1;
    optional char_string before = 2;
  }

  struct ChannelPagingStruct {
    optional nullable PageTokenStruct previousToken = 0;
    optional nullable PageTokenStruct nextToken = 1;
  }

  struct AdditionalInfoStruct {
    char_string name = 0;
    char_string value = 1;
  }

  struct LineupInfoStruct {
    char_string operatorName = 0;
    optional char_string lineupName = 1;
    optional char_string postalCode = 2;
    LineupInfoTypeEnum lineupInfoType = 3;
  }

  readonly attribute optional ChannelInfoStruct channelList[] = 0;
  readonly attribute optional nullable LineupInfoStruct lineup = 1;
  readonly attribute optional nullable ChannelInfoStruct currentChannel = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeChannelRequest {
    char_string match = 0;
  }

  response struct ChangeChannelResponse = 1 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  request struct ChangeChannelByNumberRequest {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
  }

  request struct SkipChannelRequest {
    int16s count = 0;
  }

  request struct GetProgramGuideRequest {
    optional epoch_s startTime = 0;
    optional epoch_s endTime = 1;
    optional ChannelInfoStruct channelList[] = 2;
    optional PageTokenStruct pageToken = 3;
    optional RecordingFlagBitmap recordingFlag = 4;
    optional AdditionalInfoStruct externalIDList[] = 5;
    optional octet_string data = 6;
  }

  response struct ProgramGuideResponse = 5 {
    ChannelPagingStruct paging = 0;
    ProgramStruct programList[] = 1;
  }

  request struct RecordProgramRequest {
    char_string programIdentifier = 0;
    boolean shouldRecordSeries = 1;
    AdditionalInfoStruct externalIDList[] = 2;
    octet_string data = 3;
  }

  request struct CancelRecordProgramRequest {
    char_string programIdentifier = 0;
    boolean shouldRecordSeries = 1;
    AdditionalInfoStruct externalIDList[] = 2;
    octet_string data = 3;
  }

  /** Change the channel on the media player to the channel case-insensitive exact matching the value passed as an argument. */
  command ChangeChannel(ChangeChannelRequest): ChangeChannelResponse = 0;
  /** Change the channel on the media plaeyer to the channel with the given Number in the ChannelList attribute. */
  command ChangeChannelByNumber(ChangeChannelByNumberRequest): DefaultSuccess = 2;
  /** This command provides channel up and channel down functionality, but allows channel index jumps of size Count. When the value of the increase or decrease is larger than the number of channels remaining in the given direction, then the behavior SHALL be to return to the beginning (or end) of the channel list and continue. For example, if the current channel is at index 0 and count value of -1 is given, then the current channel should change to the last channel. */
  command SkipChannel(SkipChannelRequest): DefaultSuccess = 3;
  /** This command retrieves the program guide. It accepts several filter parameters to return specific schedule and program information from a content app. The command shall receive in response a ProgramGuideResponse. */
  command GetProgramGuide(GetProgramGuideRequest): ProgramGuideResponse = 4;
  /** Record a specific program or series when it goes live. This functionality enables DVR recording features. */
  command RecordProgram(RecordProgramRequest): DefaultSuccess = 6;
  /** Cancel recording for a specific program or series. */
  command CancelRecordProgram(CancelRecordProgramRequest): DefaultSuccess = 7;
}

/** This cluster provides an interface for UX navigation within a set of targets on a device or endpoint. */
cluster TargetNavigator = 1285 {
  revision 2;

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kTargetNotFound = 1;
    kNotAllowed = 2;
  }

  struct TargetInfoStruct {
    int8u identifier = 0;
    char_string name = 1;
  }

  info event TargetUpdated = 0 {
    TargetInfoStruct targetList[] = 0;
    int8u currentTarget = 1;
    octet_string data = 2;
  }

  readonly attribute TargetInfoStruct targetList[] = 0;
  readonly attribute optional int8u currentTarget = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct NavigateTargetRequest {
    int8u target = 0;
    optional char_string data = 1;
  }

  response struct NavigateTargetResponse = 1 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  /** Upon receipt, this SHALL navigation the UX to the target identified. */
  command NavigateTarget(NavigateTargetRequest): NavigateTargetResponse = 0;
}

/** This cluster provides an interface for UX navigation within a set of targets on a device or endpoint. */
cluster TargetNavigator = 1285 {
  revision 2;

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kTargetNotFound = 1;
    kNotAllowed = 2;
  }

  struct TargetInfoStruct {
    int8u identifier = 0;
    char_string name = 1;
  }

  info event TargetUpdated = 0 {
    TargetInfoStruct targetList[] = 0;
    int8u currentTarget = 1;
    octet_string data = 2;
  }

  readonly attribute TargetInfoStruct targetList[] = 0;
  readonly attribute optional int8u currentTarget = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct NavigateTargetRequest {
    int8u target = 0;
    optional char_string data = 1;
  }

  response struct NavigateTargetResponse = 1 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  /** Upon receipt, this SHALL navigation the UX to the target identified. */
  command NavigateTarget(NavigateTargetRequest): NavigateTargetResponse = 0;
}

/** This cluster provides an interface for controlling Media Playback (PLAY, PAUSE, etc) on a media device such as a TV or Speaker. */
cluster MediaPlayback = 1286 {
  revision 2;

  enum CharacteristicEnum : enum8 {
    kForcedSubtitles = 0;
    kDescribesVideo = 1;
    kEasyToRead = 2;
    kFrameBased = 3;
    kMainProgram = 4;
    kOriginalContent = 5;
    kVoiceOverTranslation = 6;
    kCaption = 7;
    kSubtitle = 8;
    kAlternate = 9;
    kSupplementary = 10;
    kCommentary = 11;
    kDubbedTranslation = 12;
    kDescription = 13;
    kMetadata = 14;
    kEnhancedAudioIntelligibility = 15;
    kEmergency = 16;
    kKaraoke = 17;
  }

  enum PlaybackStateEnum : enum8 {
    kPlaying = 0;
    kPaused = 1;
    kNotPlaying = 2;
    kBuffering = 3;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kInvalidStateForCommand = 1;
    kNotAllowed = 2;
    kNotActive = 3;
    kSpeedOutOfRange = 4;
    kSeekOutOfRange = 5;
  }

  bitmap Feature : bitmap32 {
    kAdvancedSeek = 0x1;
    kVariableSpeed = 0x2;
    kTextTracks = 0x4;
    kAudioTracks = 0x8;
    kAudioAdvance = 0x10;
  }

  struct TrackAttributesStruct {
    char_string<32> languageCode = 0;
    optional nullable char_string displayName = 1;
  }

  struct TrackStruct {
    char_string<32> id = 0;
    nullable TrackAttributesStruct trackAttributes = 1;
  }

  struct PlaybackPositionStruct {
    epoch_us updatedAt = 0;
    nullable int64u position = 1;
  }

  info event StateChanged = 0 {
    PlaybackStateEnum currentState = 0;
    EPOCH_US startTime = 1;
    INT64U duration = 2;
    PlaybackPositionStruct sampledPosition = 3;
    single playbackSpeed = 4;
    INT64U seekRangeEnd = 5;
    INT64U seekRangeStart = 6;
    optional OCTET_STRING data = 7;
    boolean audioAdvanceUnmuted = 8;
  }

  readonly attribute PlaybackStateEnum currentState = 0;
  readonly attribute optional nullable epoch_us startTime = 1;
  readonly attribute optional nullable int64u duration = 2;
  readonly attribute optional nullable PlaybackPositionStruct sampledPosition = 3;
  readonly attribute optional single playbackSpeed = 4;
  readonly attribute optional nullable int64u seekRangeEnd = 5;
  readonly attribute optional nullable int64u seekRangeStart = 6;
  readonly attribute optional nullable TrackStruct activeAudioTrack = 7;
  readonly attribute optional nullable TrackStruct availableAudioTracks[] = 8;
  readonly attribute optional nullable TrackStruct activeTextTrack = 9;
  readonly attribute optional nullable TrackStruct availableTextTracks[] = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RewindRequest {
    optional boolean audioAdvanceUnmuted = 0;
  }

  request struct FastForwardRequest {
    optional boolean audioAdvanceUnmuted = 0;
  }

  request struct SkipForwardRequest {
    int64u deltaPositionMilliseconds = 0;
  }

  request struct SkipBackwardRequest {
    int64u deltaPositionMilliseconds = 0;
  }

  response struct PlaybackResponse = 10 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  request struct SeekRequest {
    int64u position = 0;
  }

  request struct ActivateAudioTrackRequest {
    CHAR_STRING trackID = 0;
    INT8U audioOutputIndex = 1;
  }

  request struct ActivateTextTrackRequest {
    CHAR_STRING trackID = 0;
  }

  /** Upon receipt, this SHALL play media. */
  command Play(): PlaybackResponse = 0;
  /** Upon receipt, this SHALL pause media. */
  command Pause(): PlaybackResponse = 1;
  /** Upon receipt, this SHALL stop media. User experience is context-specific. This will often navigate the user back to the location where media was originally launched. */
  command Stop(): PlaybackResponse = 2;
  /** Upon receipt, this SHALL Start Over with the current media playback item. */
  command StartOver(): PlaybackResponse = 3;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Previous". User experience is context-specific. This will often Go back to the previous media playback item. */
  command Previous(): PlaybackResponse = 4;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Next". User experience is context-specific. This will often Go forward to the next media playback item. */
  command Next(): PlaybackResponse = 5;
  /** Upon receipt, this SHALL Rewind through media. Different Rewind speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command Rewind(RewindRequest): PlaybackResponse = 6;
  /** Upon receipt, this SHALL Advance through media. Different FF speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command FastForward(FastForwardRequest): PlaybackResponse = 7;
  /** Upon receipt, this SHALL Skip forward in the media by the given number of seconds, using the data as follows: */
  command SkipForward(SkipForwardRequest): PlaybackResponse = 8;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command SkipBackward(SkipBackwardRequest): PlaybackResponse = 9;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command Seek(SeekRequest): PlaybackResponse = 11;
  /** Upon receipt, the server SHALL set the active Audio Track to the one identified by the TrackID in the Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does not correspond to the streaming media OR no media is being streamed at the time of receipt of this command, the server will return an error status of INVALID_ARGUMENT. */
  command ActivateAudioTrack(ActivateAudioTrackRequest): DefaultSuccess = 12;
  /** Upon receipt, the server SHALL set the active Text Track to the one identified by the TrackID in the Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does not correspond to the streaming media OR no media is being streamed at the time of receipt of this command, the server SHALL return an error status of INVALID_ARGUMENT. */
  command ActivateTextTrack(ActivateTextTrackRequest): DefaultSuccess = 13;
  /** If a Text Track is active (i.e. being displayed), upon receipt of this command, the server SHALL stop displaying it. */
  command DeactivateTextTrack(): DefaultSuccess = 14;
}

/** This cluster provides an interface for controlling Media Playback (PLAY, PAUSE, etc) on a media device such as a TV or Speaker. */
cluster MediaPlayback = 1286 {
  revision 2;

  enum CharacteristicEnum : enum8 {
    kForcedSubtitles = 0;
    kDescribesVideo = 1;
    kEasyToRead = 2;
    kFrameBased = 3;
    kMainProgram = 4;
    kOriginalContent = 5;
    kVoiceOverTranslation = 6;
    kCaption = 7;
    kSubtitle = 8;
    kAlternate = 9;
    kSupplementary = 10;
    kCommentary = 11;
    kDubbedTranslation = 12;
    kDescription = 13;
    kMetadata = 14;
    kEnhancedAudioIntelligibility = 15;
    kEmergency = 16;
    kKaraoke = 17;
  }

  enum PlaybackStateEnum : enum8 {
    kPlaying = 0;
    kPaused = 1;
    kNotPlaying = 2;
    kBuffering = 3;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kInvalidStateForCommand = 1;
    kNotAllowed = 2;
    kNotActive = 3;
    kSpeedOutOfRange = 4;
    kSeekOutOfRange = 5;
  }

  bitmap Feature : bitmap32 {
    kAdvancedSeek = 0x1;
    kVariableSpeed = 0x2;
    kTextTracks = 0x4;
    kAudioTracks = 0x8;
    kAudioAdvance = 0x10;
  }

  struct TrackAttributesStruct {
    char_string<32> languageCode = 0;
    optional nullable char_string displayName = 1;
  }

  struct TrackStruct {
    char_string<32> id = 0;
    nullable TrackAttributesStruct trackAttributes = 1;
  }

  struct PlaybackPositionStruct {
    epoch_us updatedAt = 0;
    nullable int64u position = 1;
  }

  info event StateChanged = 0 {
    PlaybackStateEnum currentState = 0;
    EPOCH_US startTime = 1;
    INT64U duration = 2;
    PlaybackPositionStruct sampledPosition = 3;
    single playbackSpeed = 4;
    INT64U seekRangeEnd = 5;
    INT64U seekRangeStart = 6;
    optional OCTET_STRING data = 7;
    boolean audioAdvanceUnmuted = 8;
  }

  readonly attribute PlaybackStateEnum currentState = 0;
  readonly attribute optional nullable epoch_us startTime = 1;
  readonly attribute optional nullable int64u duration = 2;
  readonly attribute optional nullable PlaybackPositionStruct sampledPosition = 3;
  readonly attribute optional single playbackSpeed = 4;
  readonly attribute optional nullable int64u seekRangeEnd = 5;
  readonly attribute optional nullable int64u seekRangeStart = 6;
  readonly attribute optional nullable TrackStruct activeAudioTrack = 7;
  readonly attribute optional nullable TrackStruct availableAudioTracks[] = 8;
  readonly attribute optional nullable TrackStruct activeTextTrack = 9;
  readonly attribute optional nullable TrackStruct availableTextTracks[] = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RewindRequest {
    optional boolean audioAdvanceUnmuted = 0;
  }

  request struct FastForwardRequest {
    optional boolean audioAdvanceUnmuted = 0;
  }

  request struct SkipForwardRequest {
    int64u deltaPositionMilliseconds = 0;
  }

  request struct SkipBackwardRequest {
    int64u deltaPositionMilliseconds = 0;
  }

  response struct PlaybackResponse = 10 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  request struct SeekRequest {
    int64u position = 0;
  }

  request struct ActivateAudioTrackRequest {
    CHAR_STRING trackID = 0;
    INT8U audioOutputIndex = 1;
  }

  request struct ActivateTextTrackRequest {
    CHAR_STRING trackID = 0;
  }

  /** Upon receipt, this SHALL play media. */
  command Play(): PlaybackResponse = 0;
  /** Upon receipt, this SHALL pause media. */
  command Pause(): PlaybackResponse = 1;
  /** Upon receipt, this SHALL stop media. User experience is context-specific. This will often navigate the user back to the location where media was originally launched. */
  command Stop(): PlaybackResponse = 2;
  /** Upon receipt, this SHALL Start Over with the current media playback item. */
  command StartOver(): PlaybackResponse = 3;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Previous". User experience is context-specific. This will often Go back to the previous media playback item. */
  command Previous(): PlaybackResponse = 4;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Next". User experience is context-specific. This will often Go forward to the next media playback item. */
  command Next(): PlaybackResponse = 5;
  /** Upon receipt, this SHALL Rewind through media. Different Rewind speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command Rewind(RewindRequest): PlaybackResponse = 6;
  /** Upon receipt, this SHALL Advance through media. Different FF speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command FastForward(FastForwardRequest): PlaybackResponse = 7;
  /** Upon receipt, this SHALL Skip forward in the media by the given number of seconds, using the data as follows: */
  command SkipForward(SkipForwardRequest): PlaybackResponse = 8;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command SkipBackward(SkipBackwardRequest): PlaybackResponse = 9;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command Seek(SeekRequest): PlaybackResponse = 11;
  /** Upon receipt, the server SHALL set the active Audio Track to the one identified by the TrackID in the Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does not correspond to the streaming media OR no media is being streamed at the time of receipt of this command, the server will return an error status of INVALID_ARGUMENT. */
  command ActivateAudioTrack(ActivateAudioTrackRequest): DefaultSuccess = 12;
  /** Upon receipt, the server SHALL set the active Text Track to the one identified by the TrackID in the Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does not correspond to the streaming media OR no media is being streamed at the time of receipt of this command, the server SHALL return an error status of INVALID_ARGUMENT. */
  command ActivateTextTrack(ActivateTextTrackRequest): DefaultSuccess = 13;
  /** If a Text Track is active (i.e. being displayed), upon receipt of this command, the server SHALL stop displaying it. */
  command DeactivateTextTrack(): DefaultSuccess = 14;
}

/** This cluster provides an interface for controlling the Input Selector on a media device such as a TV. */
cluster MediaInput = 1287 {
  revision 1; // NOTE: Default/not specifically set

  enum InputTypeEnum : enum8 {
    kInternal = 0;
    kAux = 1;
    kCoax = 2;
    kComposite = 3;
    kHDMI = 4;
    kInput = 5;
    kLine = 6;
    kOptical = 7;
    kVideo = 8;
    kSCART = 9;
    kUSB = 10;
    kOther = 11;
  }

  bitmap Feature : bitmap32 {
    kNameUpdates = 0x1;
  }

  struct InputInfoStruct {
    int8u index = 0;
    InputTypeEnum inputType = 1;
    char_string name = 2;
    char_string description = 3;
  }

  readonly attribute InputInfoStruct inputList[] = 0;
  readonly attribute int8u currentInput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectInputRequest {
    int8u index = 0;
  }

  request struct RenameInputRequest {
    int8u index = 0;
    char_string name = 1;
  }

  /** Upon receipt, this SHALL change the input on the media device to the input at a specific index in the Input List. */
  command SelectInput(SelectInputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL display the active status of the input list on screen. */
  command ShowInputStatus(): DefaultSuccess = 1;
  /** Upon receipt, this SHALL hide the input list from the screen. */
  command HideInputStatus(): DefaultSuccess = 2;
  /** Upon receipt, this SHALL rename the input at a specific index in the Input List. Updates to the input name SHALL appear in the TV settings menus. */
  command access(invoke: manage) RenameInput(RenameInputRequest): DefaultSuccess = 3;
}

/** This cluster provides an interface for controlling the Input Selector on a media device such as a TV. */
cluster MediaInput = 1287 {
  revision 1; // NOTE: Default/not specifically set

  enum InputTypeEnum : enum8 {
    kInternal = 0;
    kAux = 1;
    kCoax = 2;
    kComposite = 3;
    kHDMI = 4;
    kInput = 5;
    kLine = 6;
    kOptical = 7;
    kVideo = 8;
    kSCART = 9;
    kUSB = 10;
    kOther = 11;
  }

  bitmap Feature : bitmap32 {
    kNameUpdates = 0x1;
  }

  struct InputInfoStruct {
    int8u index = 0;
    InputTypeEnum inputType = 1;
    char_string name = 2;
    char_string description = 3;
  }

  readonly attribute InputInfoStruct inputList[] = 0;
  readonly attribute int8u currentInput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectInputRequest {
    int8u index = 0;
  }

  request struct RenameInputRequest {
    int8u index = 0;
    char_string name = 1;
  }

  /** Upon receipt, this SHALL change the input on the media device to the input at a specific index in the Input List. */
  command SelectInput(SelectInputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL display the active status of the input list on screen. */
  command ShowInputStatus(): DefaultSuccess = 1;
  /** Upon receipt, this SHALL hide the input list from the screen. */
  command HideInputStatus(): DefaultSuccess = 2;
  /** Upon receipt, this SHALL rename the input at a specific index in the Input List. Updates to the input name SHALL appear in the TV settings menus. */
  command access(invoke: manage) RenameInput(RenameInputRequest): DefaultSuccess = 3;
}

/** This cluster provides an interface for managing low power mode on a device. */
cluster LowPower = 1288 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command shall put the device into low power mode. */
  command Sleep(): DefaultSuccess = 0;
}

/** This cluster provides an interface for controlling a device like a TV using action commands such as UP, DOWN, and SELECT. */
cluster KeypadInput = 1289 {
  revision 1; // NOTE: Default/not specifically set

  enum CECKeyCodeEnum : enum8 {
    kSelect = 0;
    kUp = 1;
    kDown = 2;
    kLeft = 3;
    kRight = 4;
    kRightUp = 5;
    kRightDown = 6;
    kLeftUp = 7;
    kLeftDown = 8;
    kRootMenu = 9;
    kSetupMenu = 10;
    kContentsMenu = 11;
    kFavoriteMenu = 12;
    kExit = 13;
    kMediaTopMenu = 16;
    kMediaContextSensitiveMenu = 17;
    kNumberEntryMode = 29;
    kNumber11 = 30;
    kNumber12 = 31;
    kNumber0OrNumber10 = 32;
    kNumbers1 = 33;
    kNumbers2 = 34;
    kNumbers3 = 35;
    kNumbers4 = 36;
    kNumbers5 = 37;
    kNumbers6 = 38;
    kNumbers7 = 39;
    kNumbers8 = 40;
    kNumbers9 = 41;
    kDot = 42;
    kEnter = 43;
    kClear = 44;
    kNextFavorite = 47;
    kChannelUp = 48;
    kChannelDown = 49;
    kPreviousChannel = 50;
    kSoundSelect = 51;
    kInputSelect = 52;
    kDisplayInformation = 53;
    kHelp = 54;
    kPageUp = 55;
    kPageDown = 56;
    kPower = 64;
    kVolumeUp = 65;
    kVolumeDown = 66;
    kMute = 67;
    kPlay = 68;
    kStop = 69;
    kPause = 70;
    kRecord = 71;
    kRewind = 72;
    kFastForward = 73;
    kEject = 74;
    kForward = 75;
    kBackward = 76;
    kStopRecord = 77;
    kPauseRecord = 78;
    kReserved = 79;
    kAngle = 80;
    kSubPicture = 81;
    kVideoOnDemand = 82;
    kElectronicProgramGuide = 83;
    kTimerProgramming = 84;
    kInitialConfiguration = 85;
    kSelectBroadcastType = 86;
    kSelectSoundPresentation = 87;
    kPlayFunction = 96;
    kPausePlayFunction = 97;
    kRecordFunction = 98;
    kPauseRecordFunction = 99;
    kStopFunction = 100;
    kMuteFunction = 101;
    kRestoreVolumeFunction = 102;
    kTuneFunction = 103;
    kSelectMediaFunction = 104;
    kSelectAvInputFunction = 105;
    kSelectAudioInputFunction = 106;
    kPowerToggleFunction = 107;
    kPowerOffFunction = 108;
    kPowerOnFunction = 109;
    kF1Blue = 113;
    kF2Red = 114;
    kF3Green = 115;
    kF4Yellow = 116;
    kF5 = 117;
    kData = 118;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kUnsupportedKey = 1;
    kInvalidKeyInCurrentState = 2;
  }

  bitmap Feature : bitmap32 {
    kNavigationKeyCodes = 0x1;
    kLocationKeys = 0x2;
    kNumberKeys = 0x4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SendKeyRequest {
    CECKeyCodeEnum keyCode = 0;
  }

  response struct SendKeyResponse = 1 {
    StatusEnum status = 0;
  }

  /** Upon receipt, this SHALL process a keycode as input to the media device. */
  command SendKey(SendKeyRequest): SendKeyResponse = 0;
}

/** This cluster provides an interface for controlling a device like a TV using action commands such as UP, DOWN, and SELECT. */
cluster KeypadInput = 1289 {
  revision 1; // NOTE: Default/not specifically set

  enum CECKeyCodeEnum : enum8 {
    kSelect = 0;
    kUp = 1;
    kDown = 2;
    kLeft = 3;
    kRight = 4;
    kRightUp = 5;
    kRightDown = 6;
    kLeftUp = 7;
    kLeftDown = 8;
    kRootMenu = 9;
    kSetupMenu = 10;
    kContentsMenu = 11;
    kFavoriteMenu = 12;
    kExit = 13;
    kMediaTopMenu = 16;
    kMediaContextSensitiveMenu = 17;
    kNumberEntryMode = 29;
    kNumber11 = 30;
    kNumber12 = 31;
    kNumber0OrNumber10 = 32;
    kNumbers1 = 33;
    kNumbers2 = 34;
    kNumbers3 = 35;
    kNumbers4 = 36;
    kNumbers5 = 37;
    kNumbers6 = 38;
    kNumbers7 = 39;
    kNumbers8 = 40;
    kNumbers9 = 41;
    kDot = 42;
    kEnter = 43;
    kClear = 44;
    kNextFavorite = 47;
    kChannelUp = 48;
    kChannelDown = 49;
    kPreviousChannel = 50;
    kSoundSelect = 51;
    kInputSelect = 52;
    kDisplayInformation = 53;
    kHelp = 54;
    kPageUp = 55;
    kPageDown = 56;
    kPower = 64;
    kVolumeUp = 65;
    kVolumeDown = 66;
    kMute = 67;
    kPlay = 68;
    kStop = 69;
    kPause = 70;
    kRecord = 71;
    kRewind = 72;
    kFastForward = 73;
    kEject = 74;
    kForward = 75;
    kBackward = 76;
    kStopRecord = 77;
    kPauseRecord = 78;
    kReserved = 79;
    kAngle = 80;
    kSubPicture = 81;
    kVideoOnDemand = 82;
    kElectronicProgramGuide = 83;
    kTimerProgramming = 84;
    kInitialConfiguration = 85;
    kSelectBroadcastType = 86;
    kSelectSoundPresentation = 87;
    kPlayFunction = 96;
    kPausePlayFunction = 97;
    kRecordFunction = 98;
    kPauseRecordFunction = 99;
    kStopFunction = 100;
    kMuteFunction = 101;
    kRestoreVolumeFunction = 102;
    kTuneFunction = 103;
    kSelectMediaFunction = 104;
    kSelectAvInputFunction = 105;
    kSelectAudioInputFunction = 106;
    kPowerToggleFunction = 107;
    kPowerOffFunction = 108;
    kPowerOnFunction = 109;
    kF1Blue = 113;
    kF2Red = 114;
    kF3Green = 115;
    kF4Yellow = 116;
    kF5 = 117;
    kData = 118;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kUnsupportedKey = 1;
    kInvalidKeyInCurrentState = 2;
  }

  bitmap Feature : bitmap32 {
    kNavigationKeyCodes = 0x1;
    kLocationKeys = 0x2;
    kNumberKeys = 0x4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SendKeyRequest {
    CECKeyCodeEnum keyCode = 0;
  }

  response struct SendKeyResponse = 1 {
    StatusEnum status = 0;
  }

  /** Upon receipt, this SHALL process a keycode as input to the media device. */
  command SendKey(SendKeyRequest): SendKeyResponse = 0;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
cluster ContentLauncher = 1290 {
  revision 1;

  enum CharacteristicEnum : enum8 {
    kForcedSubtitles = 0;
    kDescribesVideo = 1;
    kEasyToRead = 2;
    kFrameBased = 3;
    kMainProgram = 4;
    kOriginalContent = 5;
    kVoiceOverTranslation = 6;
    kCaption = 7;
    kSubtitle = 8;
    kAlternate = 9;
    kSupplementary = 10;
    kCommentary = 11;
    kDubbedTranslation = 12;
    kDescription = 13;
    kMetadata = 14;
    kEnhancedAudioIntelligibility = 15;
    kEmergency = 16;
    kKaraoke = 17;
  }

  enum MetricTypeEnum : enum8 {
    kPixels = 0;
    kPercentage = 1;
  }

  enum ParameterEnum : enum8 {
    kActor = 0;
    kChannel = 1;
    kCharacter = 2;
    kDirector = 3;
    kEvent = 4;
    kFranchise = 5;
    kGenre = 6;
    kLeague = 7;
    kPopularity = 8;
    kProvider = 9;
    kSport = 10;
    kSportsTeam = 11;
    kType = 12;
    kVideo = 13;
    kSeason = 14;
    kEpisode = 15;
    kAny = 16;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kURLNotAvailable = 1;
    kAuthFailed = 2;
    kTextTrackNotAvailable = 3;
    kAudioTrackNotAvailable = 4;
  }

  bitmap Feature : bitmap32 {
    kContentSearch = 0x1;
    kURLPlayback = 0x2;
    kAdvancedSeek = 0x4;
    kTextTracks = 0x8;
    kAudioTracks = 0x10;
  }

  bitmap SupportedProtocolsBitmap : bitmap32 {
    kDASH = 0x1;
    kHLS = 0x2;
  }

  struct DimensionStruct {
    double width = 0;
    double height = 1;
    MetricTypeEnum metric = 2;
  }

  struct TrackPreferenceStruct {
    char_string<32> languageCode = 0;
    optional CharacteristicEnum characteristics[] = 1;
    int8u audioOutputIndex = 2;
  }

  struct PlaybackPreferencesStruct {
    int64u playbackPosition = 0;
    TrackPreferenceStruct textTrack = 1;
    optional TrackPreferenceStruct audioTracks[] = 2;
  }

  struct AdditionalInfoStruct {
    char_string<256> name = 0;
    char_string<8192> value = 1;
  }

  struct ParameterStruct {
    ParameterEnum type = 0;
    char_string<1024> value = 1;
    optional AdditionalInfoStruct externalIDList[] = 2;
  }

  struct ContentSearchStruct {
    ParameterStruct parameterList[] = 0;
  }

  struct StyleInformationStruct {
    optional char_string<8192> imageURL = 0;
    optional char_string<9> color = 1;
    optional DimensionStruct size = 2;
  }

  struct BrandingInformationStruct {
    char_string<256> providerName = 0;
    optional StyleInformationStruct background = 1;
    optional StyleInformationStruct logo = 2;
    optional StyleInformationStruct progressBar = 3;
    optional StyleInformationStruct splash = 4;
    optional StyleInformationStruct waterMark = 5;
  }

  readonly attribute optional char_string acceptHeader[] = 0;
  readonly attribute optional SupportedProtocolsBitmap supportedStreamingProtocols = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchContentRequest {
    ContentSearchStruct search = 0;
    boolean autoPlay = 1;
    optional char_string data = 2;
    optional PlaybackPreferencesStruct playbackPreferences = 3;
    optional boolean useCurrentContext = 4;
  }

  request struct LaunchURLRequest {
    char_string contentURL = 0;
    optional char_string displayString = 1;
    optional BrandingInformationStruct brandingInformation = 2;
  }

  response struct LauncherResponse = 2 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  /** Upon receipt, this SHALL launch the specified content with optional search criteria. */
  command LaunchContent(LaunchContentRequest): LauncherResponse = 0;
  /** Upon receipt, this SHALL launch content from the specified URL. */
  command LaunchURL(LaunchURLRequest): LauncherResponse = 1;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
cluster ContentLauncher = 1290 {
  revision 1;

  enum CharacteristicEnum : enum8 {
    kForcedSubtitles = 0;
    kDescribesVideo = 1;
    kEasyToRead = 2;
    kFrameBased = 3;
    kMainProgram = 4;
    kOriginalContent = 5;
    kVoiceOverTranslation = 6;
    kCaption = 7;
    kSubtitle = 8;
    kAlternate = 9;
    kSupplementary = 10;
    kCommentary = 11;
    kDubbedTranslation = 12;
    kDescription = 13;
    kMetadata = 14;
    kEnhancedAudioIntelligibility = 15;
    kEmergency = 16;
    kKaraoke = 17;
  }

  enum MetricTypeEnum : enum8 {
    kPixels = 0;
    kPercentage = 1;
  }

  enum ParameterEnum : enum8 {
    kActor = 0;
    kChannel = 1;
    kCharacter = 2;
    kDirector = 3;
    kEvent = 4;
    kFranchise = 5;
    kGenre = 6;
    kLeague = 7;
    kPopularity = 8;
    kProvider = 9;
    kSport = 10;
    kSportsTeam = 11;
    kType = 12;
    kVideo = 13;
    kSeason = 14;
    kEpisode = 15;
    kAny = 16;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kURLNotAvailable = 1;
    kAuthFailed = 2;
    kTextTrackNotAvailable = 3;
    kAudioTrackNotAvailable = 4;
  }

  bitmap Feature : bitmap32 {
    kContentSearch = 0x1;
    kURLPlayback = 0x2;
    kAdvancedSeek = 0x4;
    kTextTracks = 0x8;
    kAudioTracks = 0x10;
  }

  bitmap SupportedProtocolsBitmap : bitmap32 {
    kDASH = 0x1;
    kHLS = 0x2;
  }

  struct DimensionStruct {
    double width = 0;
    double height = 1;
    MetricTypeEnum metric = 2;
  }

  struct TrackPreferenceStruct {
    char_string<32> languageCode = 0;
    optional CharacteristicEnum characteristics[] = 1;
    int8u audioOutputIndex = 2;
  }

  struct PlaybackPreferencesStruct {
    int64u playbackPosition = 0;
    TrackPreferenceStruct textTrack = 1;
    optional TrackPreferenceStruct audioTracks[] = 2;
  }

  struct AdditionalInfoStruct {
    char_string<256> name = 0;
    char_string<8192> value = 1;
  }

  struct ParameterStruct {
    ParameterEnum type = 0;
    char_string<1024> value = 1;
    optional AdditionalInfoStruct externalIDList[] = 2;
  }

  struct ContentSearchStruct {
    ParameterStruct parameterList[] = 0;
  }

  struct StyleInformationStruct {
    optional char_string<8192> imageURL = 0;
    optional char_string<9> color = 1;
    optional DimensionStruct size = 2;
  }

  struct BrandingInformationStruct {
    char_string<256> providerName = 0;
    optional StyleInformationStruct background = 1;
    optional StyleInformationStruct logo = 2;
    optional StyleInformationStruct progressBar = 3;
    optional StyleInformationStruct splash = 4;
    optional StyleInformationStruct waterMark = 5;
  }

  readonly attribute optional char_string acceptHeader[] = 0;
  readonly attribute optional SupportedProtocolsBitmap supportedStreamingProtocols = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchContentRequest {
    ContentSearchStruct search = 0;
    boolean autoPlay = 1;
    optional char_string data = 2;
    optional PlaybackPreferencesStruct playbackPreferences = 3;
    optional boolean useCurrentContext = 4;
  }

  request struct LaunchURLRequest {
    char_string contentURL = 0;
    optional char_string displayString = 1;
    optional BrandingInformationStruct brandingInformation = 2;
  }

  response struct LauncherResponse = 2 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  /** Upon receipt, this SHALL launch the specified content with optional search criteria. */
  command LaunchContent(LaunchContentRequest): LauncherResponse = 0;
  /** Upon receipt, this SHALL launch content from the specified URL. */
  command LaunchURL(LaunchURLRequest): LauncherResponse = 1;
}

/** This cluster provides an interface for controlling the Output on a media device such as a TV. */
cluster AudioOutput = 1291 {
  revision 1; // NOTE: Default/not specifically set

  enum OutputTypeEnum : enum8 {
    kHDMI = 0;
    kBT = 1;
    kOptical = 2;
    kHeadphone = 3;
    kInternal = 4;
    kOther = 5;
  }

  bitmap Feature : bitmap32 {
    kNameUpdates = 0x1;
  }

  struct OutputInfoStruct {
    int8u index = 0;
    OutputTypeEnum outputType = 1;
    char_string name = 2;
  }

  readonly attribute OutputInfoStruct outputList[] = 0;
  readonly attribute int8u currentOutput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectOutputRequest {
    int8u index = 0;
  }

  request struct RenameOutputRequest {
    int8u index = 0;
    char_string name = 1;
  }

  /** Upon receipt, this SHALL change the output on the media device to the output at a specific index in the Output List. */
  command SelectOutput(SelectOutputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL rename the output at a specific index in the Output List. Updates to the output name SHALL appear in the TV settings menus. */
  command access(invoke: manage) RenameOutput(RenameOutputRequest): DefaultSuccess = 1;
}

/** This cluster provides an interface for controlling the Output on a media device such as a TV. */
cluster AudioOutput = 1291 {
  revision 1; // NOTE: Default/not specifically set

  enum OutputTypeEnum : enum8 {
    kHDMI = 0;
    kBT = 1;
    kOptical = 2;
    kHeadphone = 3;
    kInternal = 4;
    kOther = 5;
  }

  bitmap Feature : bitmap32 {
    kNameUpdates = 0x1;
  }

  struct OutputInfoStruct {
    int8u index = 0;
    OutputTypeEnum outputType = 1;
    char_string name = 2;
  }

  readonly attribute OutputInfoStruct outputList[] = 0;
  readonly attribute int8u currentOutput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectOutputRequest {
    int8u index = 0;
  }

  request struct RenameOutputRequest {
    int8u index = 0;
    char_string name = 1;
  }

  /** Upon receipt, this SHALL change the output on the media device to the output at a specific index in the Output List. */
  command SelectOutput(SelectOutputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL rename the output at a specific index in the Output List. Updates to the output name SHALL appear in the TV settings menus. */
  command access(invoke: manage) RenameOutput(RenameOutputRequest): DefaultSuccess = 1;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
cluster ApplicationLauncher = 1292 {
  revision 1; // NOTE: Default/not specifically set

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kAppNotAvailable = 1;
    kSystemBusy = 2;
    kPendingUserApproval = 3;
    kDownloading = 4;
    kInstalling = 5;
  }

  bitmap Feature : bitmap32 {
    kApplicationPlatform = 0x1;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  struct ApplicationEPStruct {
    ApplicationStruct application = 0;
    optional endpoint_no endpoint = 1;
  }

  readonly attribute optional int16u catalogList[] = 0;
  readonly attribute optional nullable ApplicationEPStruct currentApp = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchAppRequest {
    optional ApplicationStruct application = 0;
    optional octet_string data = 1;
  }

  request struct StopAppRequest {
    optional ApplicationStruct application = 0;
  }

  request struct HideAppRequest {
    optional ApplicationStruct application = 0;
  }

  response struct LauncherResponse = 3 {
    StatusEnum status = 0;
    optional octet_string data = 1;
  }

  /** Upon receipt, this SHALL launch the specified app with optional data. The TV Device SHALL launch and bring to foreground the identified application in the command if the application is not already launched and in foreground. The TV Device SHALL update state attribute on the Application Basic cluster of the Endpoint corresponding to the launched application. This command returns a Launch Response. */
  command LaunchApp(LaunchAppRequest): LauncherResponse = 0;
  /** Upon receipt on a Video Player endpoint this SHALL stop the specified application if it is running. */
  command StopApp(StopAppRequest): LauncherResponse = 1;
  /** Upon receipt on a Video Player endpoint this SHALL hide the specified application if it is running and visible. */
  command HideApp(HideAppRequest): LauncherResponse = 2;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
cluster ApplicationLauncher = 1292 {
  revision 1; // NOTE: Default/not specifically set

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kAppNotAvailable = 1;
    kSystemBusy = 2;
    kPendingUserApproval = 3;
    kDownloading = 4;
    kInstalling = 5;
  }

  bitmap Feature : bitmap32 {
    kApplicationPlatform = 0x1;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  struct ApplicationEPStruct {
    ApplicationStruct application = 0;
    optional endpoint_no endpoint = 1;
  }

  readonly attribute optional int16u catalogList[] = 0;
  readonly attribute optional nullable ApplicationEPStruct currentApp = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchAppRequest {
    optional ApplicationStruct application = 0;
    optional octet_string data = 1;
  }

  request struct StopAppRequest {
    optional ApplicationStruct application = 0;
  }

  request struct HideAppRequest {
    optional ApplicationStruct application = 0;
  }

  response struct LauncherResponse = 3 {
    StatusEnum status = 0;
    optional octet_string data = 1;
  }

  /** Upon receipt, this SHALL launch the specified app with optional data. The TV Device SHALL launch and bring to foreground the identified application in the command if the application is not already launched and in foreground. The TV Device SHALL update state attribute on the Application Basic cluster of the Endpoint corresponding to the launched application. This command returns a Launch Response. */
  command LaunchApp(LaunchAppRequest): LauncherResponse = 0;
  /** Upon receipt on a Video Player endpoint this SHALL stop the specified application if it is running. */
  command StopApp(StopAppRequest): LauncherResponse = 1;
  /** Upon receipt on a Video Player endpoint this SHALL hide the specified application if it is running and visible. */
  command HideApp(HideAppRequest): LauncherResponse = 2;
}

/** This cluster provides information about an application running on a TV or media player device which is represented as an endpoint. */
cluster ApplicationBasic = 1293 {
  revision 1; // NOTE: Default/not specifically set

  enum ApplicationStatusEnum : enum8 {
    kStopped = 0;
    kActiveVisibleFocus = 1;
    kActiveHidden = 2;
    kActiveVisibleNotFocus = 3;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  readonly attribute optional char_string<32> vendorName = 0;
  readonly attribute optional vendor_id vendorID = 1;
  readonly attribute long_char_string<256> applicationName = 2;
  readonly attribute optional int16u productID = 3;
  readonly attribute ApplicationStruct application = 4;
  readonly attribute ApplicationStatusEnum status = 5;
  readonly attribute char_string<32> applicationVersion = 6;
  readonly attribute access(read: administer) vendor_id allowedVendorList[] = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides information about an application running on a TV or media player device which is represented as an endpoint. */
cluster ApplicationBasic = 1293 {
  revision 1; // NOTE: Default/not specifically set

  enum ApplicationStatusEnum : enum8 {
    kStopped = 0;
    kActiveVisibleFocus = 1;
    kActiveHidden = 2;
    kActiveVisibleNotFocus = 3;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  readonly attribute optional char_string<32> vendorName = 0;
  readonly attribute optional vendor_id vendorID = 1;
  readonly attribute long_char_string<256> applicationName = 2;
  readonly attribute optional int16u productID = 3;
  readonly attribute ApplicationStruct application = 4;
  readonly attribute ApplicationStatusEnum status = 5;
  readonly attribute char_string<32> applicationVersion = 6;
  readonly attribute access(read: administer) vendor_id allowedVendorList[] = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides commands that facilitate user account login on a Content App or a node. For example, a Content App running on a Video Player device, which is represented as an endpoint (see [TV Architecture]), can use this cluster to help make the user account on the Content App match the user account on the Client. */
cluster AccountLogin = 1294 {
  revision 2;

  critical event LoggedOut = 0 {
    optional node_id node = 0;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GetSetupPINRequest {
    char_string<100> tempAccountIdentifier = 0;
  }

  response struct GetSetupPINResponse = 1 {
    char_string setupPIN = 0;
  }

  request struct LoginRequest {
    char_string<100> tempAccountIdentifier = 0;
    char_string setupPIN = 1;
    optional node_id node = 2;
  }

  request struct LogoutRequest {
    optional node_id node = 0;
  }

  /** Upon receipt, the Content App checks if the account associated with the client Temp Account Identifier Rotating ID is the same acount that is active on the given Content App. If the accounts are the same, then the Content App includes the Setup PIN in the GetSetupPIN Response. */
  fabric timed command access(invoke: administer) GetSetupPIN(GetSetupPINRequest): GetSetupPINResponse = 0;
  /** Upon receipt, the Content App checks if the account associated with the client’s Temp Account Identifier (Rotating ID) has a current active Setup PIN with the given value. If the Setup PIN is valid for the user account associated with the Temp Account Identifier, then the Content App MAY make that user account active. */
  fabric timed command access(invoke: administer) Login(LoginRequest): DefaultSuccess = 2;
  /** The purpose of this command is to instruct the Content App to clear the current user account. This command SHOULD be used by clients of a Content App to indicate the end of a user session. */
  fabric timed command Logout(LogoutRequest): DefaultSuccess = 3;
}

/** This cluster provides commands that facilitate user account login on a Content App or a node. For example, a Content App running on a Video Player device, which is represented as an endpoint (see [TV Architecture]), can use this cluster to help make the user account on the Content App match the user account on the Client. */
cluster AccountLogin = 1294 {
  revision 2;

  critical event LoggedOut = 0 {
    optional node_id node = 0;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GetSetupPINRequest {
    char_string<100> tempAccountIdentifier = 0;
  }

  response struct GetSetupPINResponse = 1 {
    char_string setupPIN = 0;
  }

  request struct LoginRequest {
    char_string<100> tempAccountIdentifier = 0;
    char_string setupPIN = 1;
    optional node_id node = 2;
  }

  request struct LogoutRequest {
    optional node_id node = 0;
  }

  /** Upon receipt, the Content App checks if the account associated with the client Temp Account Identifier Rotating ID is the same acount that is active on the given Content App. If the accounts are the same, then the Content App includes the Setup PIN in the GetSetupPIN Response. */
  fabric timed command access(invoke: administer) GetSetupPIN(GetSetupPINRequest): GetSetupPINResponse = 0;
  /** Upon receipt, the Content App checks if the account associated with the client’s Temp Account Identifier (Rotating ID) has a current active Setup PIN with the given value. If the Setup PIN is valid for the user account associated with the Temp Account Identifier, then the Content App MAY make that user account active. */
  fabric timed command access(invoke: administer) Login(LoginRequest): DefaultSuccess = 2;
  /** The purpose of this command is to instruct the Content App to clear the current user account. This command SHOULD be used by clients of a Content App to indicate the end of a user session. */
  fabric timed command Logout(LogoutRequest): DefaultSuccess = 3;
}

endpoint 0 {
  device type ma_rootdevice = 22, version 1;
  device type ma_powersource = 17, version 1;

  binding cluster GeneralCommissioning;
  binding cluster ThreadNetworkDiagnostics;
  binding cluster Switch;
  binding cluster OperationalCredentials;
  binding cluster ModeSelect;
  binding cluster DoorLock;
  binding cluster Thermostat;
  binding cluster ThermostatUserInterfaceConfiguration;
  binding cluster TemperatureMeasurement;
  binding cluster RelativeHumidityMeasurement;
  binding cluster Channel;
  binding cluster TargetNavigator;
  binding cluster MediaPlayback;
  binding cluster MediaInput;
  binding cluster LowPower;
  binding cluster KeypadInput;
  binding cluster ContentLauncher;
  binding cluster AudioOutput;
  binding cluster ApplicationLauncher;
  binding cluster ApplicationBasic;
  binding cluster AccountLogin;

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry;
    callback attribute targetsPerAccessControlEntry;
    callback attribute accessControlEntriesPerFabric;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision;
  }

  server cluster Actions {
    callback attribute actionList;
    callback attribute endpointLists;
    callback attribute setupURL;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    callback attribute dataModelRevision;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location;
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate;
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    persist  attribute localConfigDisabled default = 0;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster LocalizationConfiguration {
    ram      attribute activeLocale;
    callback attribute supportedLocales;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TimeFormatLocalization {
    callback attribute hourFormat;
    callback attribute activeCalendarType;
    callback attribute supportedCalendarTypes;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UnitLocalization {
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster PowerSource {
    ram      attribute status;
    ram      attribute order;
    ram      attribute description;
    ram      attribute wiredAssessedInputVoltage;
    ram      attribute wiredAssessedInputFrequency;
    ram      attribute wiredCurrentType;
    ram      attribute wiredAssessedCurrent;
    ram      attribute wiredNominalVoltage;
    ram      attribute wiredMaximumCurrent;
    ram      attribute wiredPresent;
    callback attribute activeWiredFaults;
    ram      attribute batVoltage;
    ram      attribute batPercentRemaining;
    ram      attribute batTimeRemaining;
    ram      attribute batChargeLevel;
    ram      attribute batReplacementNeeded;
    ram      attribute batReplaceability;
    ram      attribute batPresent;
    callback attribute activeBatFaults;
    ram      attribute batReplacementDescription;
    ram      attribute batCommonDesignation;
    ram      attribute batANSIDesignation;
    ram      attribute batIECDesignation;
    ram      attribute batApprovedChemistry;
    ram      attribute batCapacity;
    ram      attribute batQuantity;
    ram      attribute batChargeState;
    ram      attribute batTimeToFullCharge;
    ram      attribute batFunctionalWhileCharging;
    ram      attribute batChargingCurrent;
    callback attribute activeBatChargeFaults;
    callback attribute endpointList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig;
    callback attribute locationCapability;
    callback attribute supportsConcurrentConnection;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command ArmFailSafe;
    handle command ArmFailSafeResponse;
    handle command SetRegulatoryConfig;
    handle command SetRegulatoryConfigResponse;
    handle command CommissioningComplete;
    handle command CommissioningCompleteResponse;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 2;
    ram      attribute clusterRevision default = 1;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }

  server cluster GeneralDiagnostics {
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount;
    callback attribute upTime;
    callback attribute totalOperationalHours;
    callback attribute bootReason;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    callback attribute testEventTriggersEnabled default = false;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command TestEventTrigger;
    handle command TimeSnapshot;
    handle command TimeSnapshotResponse;
  }

  server cluster SoftwareDiagnostics {
    callback attribute threadMetrics;
    callback attribute currentHeapFree;
    callback attribute currentHeapUsed;
    callback attribute currentHeapHighWatermark;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;

    handle command ResetWatermarks;
  }

  server cluster ThreadNetworkDiagnostics {
    callback attribute channel;
    callback attribute routingRole;
    callback attribute networkName;
    callback attribute panId;
    callback attribute extendedPanId;
    callback attribute meshLocalPrefix;
    callback attribute overrunCount;
    callback attribute neighborTable;
    callback attribute routeTable;
    callback attribute partitionId;
    callback attribute weighting;
    callback attribute dataVersion;
    callback attribute stableDataVersion;
    callback attribute leaderRouterId;
    callback attribute detachedRoleCount;
    callback attribute childRoleCount;
    callback attribute routerRoleCount;
    callback attribute leaderRoleCount;
    callback attribute attachAttemptCount;
    callback attribute partitionIdChangeCount;
    callback attribute betterPartitionAttachAttemptCount;
    callback attribute parentChangeCount;
    callback attribute txTotalCount;
    callback attribute txUnicastCount;
    callback attribute txBroadcastCount;
    callback attribute txAckRequestedCount;
    callback attribute txAckedCount;
    callback attribute txNoAckRequestedCount;
    callback attribute txDataCount;
    callback attribute txDataPollCount;
    callback attribute txBeaconCount;
    callback attribute txBeaconRequestCount;
    callback attribute txOtherCount;
    callback attribute txRetryCount;
    callback attribute txDirectMaxRetryExpiryCount;
    callback attribute txIndirectMaxRetryExpiryCount;
    callback attribute txErrCcaCount;
    callback attribute txErrAbortCount;
    callback attribute txErrBusyChannelCount;
    callback attribute rxTotalCount;
    callback attribute rxUnicastCount;
    callback attribute rxBroadcastCount;
    callback attribute rxDataCount;
    callback attribute rxDataPollCount;
    callback attribute rxBeaconCount;
    callback attribute rxBeaconRequestCount;
    callback attribute rxOtherCount;
    callback attribute rxAddressFilteredCount;
    callback attribute rxDestAddrFilteredCount;
    callback attribute rxDuplicatedCount;
    callback attribute rxErrNoFrameCount;
    callback attribute rxErrUnknownNeighborCount;
    callback attribute rxErrInvalidSrcAddrCount;
    callback attribute rxErrSecCount;
    callback attribute rxErrFcsCount;
    callback attribute rxErrOtherCount;
    callback attribute activeTimestamp;
    callback attribute pendingTimestamp;
    callback attribute delay;
    callback attribute securityPolicy;
    callback attribute channelPage0Mask;
    callback attribute operationalDatasetComponents;
    callback attribute activeNetworkFaultsList;
    ram      attribute clusterRevision default = 2;

    handle command ResetCounts;
  }

  server cluster WiFiNetworkDiagnostics {
    emits event Disconnection;
    emits event AssociationFailure;
    emits event ConnectionStatus;
    callback attribute bssid;
    callback attribute securityType;
    callback attribute wiFiVersion;
    callback attribute channelNumber;
    callback attribute rssi;
    callback attribute beaconLostCount;
    callback attribute beaconRxCount;
    callback attribute packetMulticastRxCount;
    callback attribute packetMulticastTxCount;
    callback attribute packetUnicastRxCount;
    callback attribute packetUnicastTxCount;
    callback attribute currentMaxRate;
    callback attribute overrunCount;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;

    handle command ResetCounts;
  }

  server cluster EthernetNetworkDiagnostics {
    callback attribute PHYRate;
    callback attribute fullDuplex;
    callback attribute packetRxCount;
    callback attribute packetTxCount;
    callback attribute txErrCount;
    callback attribute collisionCount;
    callback attribute overrunCount;
    callback attribute carrierDetect;
    callback attribute timeSinceReset;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;

    handle command ResetCounts;
  }

  server cluster BridgedDeviceBasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    ram      attribute vendorName;
    ram      attribute vendorID;
    ram      attribute productName;
    persist  attribute nodeLabel;
    ram      attribute hardwareVersion default = 0;
    ram      attribute hardwareVersionString;
    ram      attribute softwareVersion default = 0;
    ram      attribute softwareVersionString;
    ram      attribute manufacturingDate default = "20210614123456ZZ";
    ram      attribute partNumber;
    ram      attribute productURL;
    ram      attribute productLabel;
    ram      attribute serialNumber;
    ram      attribute reachable default = 1;
    ram      attribute uniqueID;
    callback attribute productAppearance;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster Switch {
    ram      attribute numberOfPositions default = 2;
    ram      attribute currentPosition;
    ram      attribute multiPressMax default = 2;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus;
    callback attribute adminFabricIndex;
    callback attribute adminVendorId;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command OpenCommissioningWindow;
    handle command OpenBasicCommissioningWindow;
    handle command RevokeCommissioning;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AttestationRequest;
    handle command AttestationResponse;
    handle command CertificateChainRequest;
    handle command CertificateChainResponse;
    handle command CSRRequest;
    handle command CSRResponse;
    handle command AddNOC;
    handle command UpdateNOC;
    handle command NOCResponse;
    handle command UpdateFabricLabel;
    handle command RemoveFabric;
    handle command AddTrustedRootCertificate;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command KeySetWrite;
    handle command KeySetRead;
    handle command KeySetReadResponse;
    handle command KeySetRemove;
    handle command KeySetReadAllIndices;
    handle command KeySetReadAllIndicesResponse;
  }

  server cluster BooleanState {
    ram      attribute stateValue default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ModeSelect {
    ram      attribute description;
    callback attribute standardNamespace;
    callback attribute supportedModes;
    ram      attribute currentMode;
    ram      attribute startUpMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;

    handle command ChangeToMode;
  }

  server cluster DoorLock {
    ram      attribute lockState;
    ram      attribute lockType;
    ram      attribute actuatorEnabled;
    ram      attribute doorState;
    ram      attribute doorOpenEvents;
    ram      attribute doorClosedEvents;
    ram      attribute openPeriod;
    ram      attribute numberOfTotalUsersSupported default = 0;
    ram      attribute numberOfPINUsersSupported default = 0;
    ram      attribute numberOfRFIDUsersSupported default = 0;
    ram      attribute numberOfWeekDaySchedulesSupportedPerUser default = 0;
    ram      attribute numberOfYearDaySchedulesSupportedPerUser default = 0;
    ram      attribute numberOfHolidaySchedulesSupported default = 0;
    ram      attribute maxPINCodeLength;
    ram      attribute minPINCodeLength;
    ram      attribute maxRFIDCodeLength;
    ram      attribute minRFIDCodeLength;
    ram      attribute credentialRulesSupport default = 1;
    ram      attribute numberOfCredentialsSupportedPerUser default = 0;
    ram      attribute language;
    ram      attribute LEDSettings default = 0;
    ram      attribute autoRelockTime;
    ram      attribute soundVolume default = 0;
    ram      attribute operatingMode default = 0;
    ram      attribute supportedOperatingModes default = 65526;
    ram      attribute defaultConfigurationRegister default = 0;
    ram      attribute enableLocalProgramming default = 1;
    ram      attribute enableOneTouchLocking default = 0;
    ram      attribute enableInsideStatusLED default = 0;
    ram      attribute enablePrivacyModeButton default = 0;
    ram      attribute localProgrammingFeatures default = 0;
    ram      attribute wrongCodeEntryLimit;
    ram      attribute userCodeTemporaryDisableTime;
    ram      attribute sendPINOverTheAir default = 0;
    ram      attribute requirePINforRemoteOperation default = 0;
    ram      attribute expiringUserTimeout;
    ram      attribute clusterRevision default = 6;

    handle command LockDoor;
    handle command UnlockDoor;
    handle command UnlockWithTimeout;
    handle command SetWeekDaySchedule;
    handle command ClearWeekDaySchedule;
    handle command SetYearDaySchedule;
    handle command ClearYearDaySchedule;
    handle command SetHolidaySchedule;
    handle command ClearHolidaySchedule;
    handle command SetUser;
    handle command ClearCredential;
  }

  server cluster WindowCovering {
    ram      attribute type default = 0x00;
    persist  attribute currentPositionLift default = 0x7FFF;
    persist  attribute currentPositionTilt default = 0x7FFF;
    persist  attribute configStatus default = 0x03;
    persist  attribute currentPositionLiftPercentage default = 50;
    persist  attribute currentPositionTiltPercentage default = 50;
    ram      attribute operationalStatus default = 0x00;
    ram      attribute targetPositionLiftPercent100ths default = 500;
    ram      attribute targetPositionTiltPercent100ths default = 500;
    ram      attribute endProductType default = 0x00;
    persist  attribute currentPositionLiftPercent100ths default = 500;
    persist  attribute currentPositionTiltPercent100ths default = 500;
    persist  attribute installedOpenLimitLift default = 0x0000;
    persist  attribute installedClosedLimitLift default = 0xFFFF;
    persist  attribute installedOpenLimitTilt default = 0x0000;
    persist  attribute installedClosedLimitTilt default = 0xFFFF;
    persist  attribute mode default = 0x00;
    ram      attribute safetyStatus default = 0x00;
    ram      attribute featureMap default = 0x17;
    ram      attribute clusterRevision default = 5;

    handle command UpOrOpen;
    handle command DownOrClose;
    handle command StopMotion;
    handle command GoToLiftValue;
    handle command GoToLiftPercentage;
    handle command GoToTiltValue;
    handle command GoToTiltPercentage;
  }

  server cluster PumpConfigurationAndControl {
    ram      attribute maxPressure;
    ram      attribute maxSpeed;
    ram      attribute maxFlow;
    ram      attribute minConstPressure;
    ram      attribute maxConstPressure;
    ram      attribute minCompPressure;
    ram      attribute maxCompPressure;
    ram      attribute minConstSpeed;
    ram      attribute maxConstSpeed;
    ram      attribute minConstFlow;
    ram      attribute maxConstFlow;
    ram      attribute minConstTemp;
    ram      attribute maxConstTemp;
    ram      attribute pumpStatus;
    ram      attribute effectiveOperationMode;
    ram      attribute effectiveControlMode;
    ram      attribute capacity;
    ram      attribute speed;
    ram      attribute lifetimeRunningHours default = 0x000000;
    ram      attribute power;
    ram      attribute lifetimeEnergyConsumed default = 0x00000000;
    ram      attribute operationMode default = 0x00;
    ram      attribute controlMode default = 0x00;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Thermostat {
    ram      attribute localTemperature;
    callback attribute outdoorTemperature;
    callback attribute occupancy default = 1;
    ram      attribute absMinHeatSetpointLimit default = 0x02BC;
    callback attribute absMaxHeatSetpointLimit default = 0x0BB8;
    ram      attribute absMinCoolSetpointLimit default = 0x0640;
    ram      attribute absMaxCoolSetpointLimit default = 0x0C80;
    ram      attribute PICoolingDemand;
    ram      attribute PIHeatingDemand;
    callback attribute HVACSystemTypeConfiguration default = 0;
    callback attribute localTemperatureCalibration default = 0;
    ram      attribute occupiedCoolingSetpoint default = 0x0A28;
    ram      attribute occupiedHeatingSetpoint default = 0x07D0;
    callback attribute unoccupiedCoolingSetpoint default = 0x0A28;
    callback attribute unoccupiedHeatingSetpoint default = 0x07D0;
    ram      attribute minHeatSetpointLimit default = 0x02BC;
    ram      attribute maxHeatSetpointLimit default = 0x0BB8;
    ram      attribute minCoolSetpointLimit default = 0x0640;
    ram      attribute maxCoolSetpointLimit default = 0x0C80;
    ram      attribute minSetpointDeadBand default = 0x19;
    callback attribute remoteSensing default = 0x0;
    ram      attribute controlSequenceOfOperation default = 0x04;
    ram      attribute systemMode default = 0x01;
    callback attribute thermostatRunningMode default = 0x00;
    ram      attribute startOfWeek default = 0;
    ram      attribute numberOfWeeklyTransitions default = 7;
    ram      attribute numberOfDailyTransitions default = 4;
    ram      attribute temperatureSetpointHold default = 0x00;
    callback attribute temperatureSetpointHoldDuration;
    callback attribute thermostatProgrammingOperationMode default = 0x00;
    callback attribute thermostatRunningState;
    callback attribute setpointChangeSource default = 0x00;
    callback attribute setpointChangeAmount;
    callback attribute setpointChangeSourceTimestamp default = 0x00;
    callback attribute occupiedSetback;
    callback attribute occupiedSetbackMin;
    callback attribute occupiedSetbackMax;
    callback attribute unoccupiedSetback;
    callback attribute unoccupiedSetbackMin;
    callback attribute unoccupiedSetbackMax;
    callback attribute emergencyHeatDelta default = 0x009F6;
    callback attribute ACType default = 0x00;
    callback attribute ACCapacity default = 0x00;
    callback attribute ACRefrigerantType;
    callback attribute ACCompressorType default = 0x00;
    callback attribute ACLouverPosition default = 0x00;
    callback attribute ACCoilTemperature;
    callback attribute ACCapacityformat default = 0x00;
    ram      attribute featureMap default = 0x000b;
    ram      attribute clusterRevision default = 6;
  }

  server cluster ThermostatUserInterfaceConfiguration {
    ram      attribute temperatureDisplayMode default = 0x00;
    ram      attribute keypadLockout default = 0x00;
    ram      attribute scheduleProgrammingVisibility;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster IlluminanceMeasurement {
    ram      attribute measuredValue default = 0x0000;
    ram      attribute minMeasuredValue default = 0x01;
    ram      attribute maxMeasuredValue default = 0xFFFE;
    ram      attribute tolerance;
    ram      attribute lightSensorType default = 0xFF;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster TemperatureMeasurement {
    ram      attribute measuredValue default = 0x8000;
    ram      attribute minMeasuredValue default = 0x8000;
    ram      attribute maxMeasuredValue default = 0x8000;
    ram      attribute tolerance;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;
  }

  server cluster PressureMeasurement {
    ram      attribute measuredValue default = 0x0000;
    ram      attribute minMeasuredValue;
    ram      attribute maxMeasuredValue;
    ram      attribute tolerance;
    ram      attribute scaledValue default = 0x0000;
    ram      attribute minScaledValue default = 0x0000;
    ram      attribute maxScaledValue default = 0x0000;
    ram      attribute scaledTolerance;
    ram      attribute scale default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster FlowMeasurement {
    ram      attribute measuredValue;
    ram      attribute minMeasuredValue;
    ram      attribute maxMeasuredValue;
    ram      attribute tolerance default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster RelativeHumidityMeasurement {
    ram      attribute measuredValue;
    ram      attribute minMeasuredValue default = 0;
    ram      attribute maxMeasuredValue default = 0x2710;
    ram      attribute tolerance;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Channel {
    callback attribute channelList;
    callback attribute lineup;
    callback attribute currentChannel;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;

    handle command ChangeChannel;
    handle command ChangeChannelByNumber;
    handle command SkipChannel;
  }

  server cluster TargetNavigator {
    callback attribute targetList;
    ram      attribute currentTarget default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster MediaPlayback {
    ram      attribute currentState;
    ram      attribute startTime;
    ram      attribute duration;
    callback attribute sampledPosition;
    ram      attribute playbackSpeed default = 1;
    ram      attribute seekRangeEnd;
    ram      attribute seekRangeStart default = 1;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command Play;
    handle command Pause;
    handle command Stop;
    handle command StartOver;
    handle command Previous;
    handle command Next;
    handle command Rewind;
    handle command FastForward;
    handle command SkipForward;
    handle command SkipBackward;
    handle command PlaybackResponse;
    handle command Seek;
  }

  server cluster MediaInput {
    callback attribute inputList;
    callback attribute currentInput;
    ram      attribute clusterRevision default = 1;

    handle command SelectInput;
    handle command ShowInputStatus;
    handle command HideInputStatus;
    handle command RenameInput;
  }

  server cluster KeypadInput {
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ContentLauncher {
    callback attribute acceptHeader;
    ram      attribute supportedStreamingProtocols default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command LaunchContent;
    handle command LaunchURL;
    handle command LauncherResponse;
  }

  server cluster AudioOutput {
    callback attribute outputList;
    ram      attribute currentOutput;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command SelectOutput;
    handle command RenameOutput;
  }

  server cluster ApplicationLauncher {
    callback attribute catalogList;
    callback attribute currentApp;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ApplicationBasic {
    ram      attribute vendorName;
    ram      attribute vendorID default = 0x0;
    ram      attribute applicationName;
    ram      attribute productID default = 0x0;
    callback attribute application;
    ram      attribute status default = 0x01;
    ram      attribute applicationVersion;
    callback attribute allowedVendorList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AccountLogin {
    ram      attribute clusterRevision default = 1;

    handle command GetSetupPIN;
    handle command GetSetupPINResponse;
    handle command Login;
    handle command Logout;
  }
}
endpoint 1 {
  device type ma_dimmablelight = 257, version 1;

  binding cluster Identify;
  binding cluster OnOff;
  binding cluster LevelControl;
  binding cluster LocalizationConfiguration;
  binding cluster UnitLocalization;
  binding cluster FixedLabel;
  binding cluster ColorControl;

  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Groups {
    ram      attribute nameSupport;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command AddGroup;
    handle command AddGroupResponse;
    handle command ViewGroup;
    handle command ViewGroupResponse;
    handle command GetGroupMembership;
    handle command GetGroupMembershipResponse;
    handle command RemoveGroup;
    handle command RemoveGroupResponse;
    handle command RemoveAllGroups;
    handle command AddGroupIfIdentifying;
  }

  server cluster OnOff {
    ram      attribute onOff default = 0x00;
    ram      attribute globalSceneControl default = 0x01;
    ram      attribute onTime default = 0x0000;
    ram      attribute offWaitTime default = 0x0000;
    ram      attribute startUpOnOff default = 0xFF;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x0001;
    ram      attribute clusterRevision default = 5;

    handle command Off;
    handle command On;
    handle command Toggle;
    handle command OffWithEffect;
    handle command OnWithRecallGlobalScene;
    handle command OnWithTimedOff;
  }

  server cluster LevelControl {
    ram      attribute currentLevel default = 0x00;
    ram      attribute remainingTime default = 0x0000;
    ram      attribute minLevel default = 0x00;
    ram      attribute maxLevel default = 0xFE;
    ram      attribute currentFrequency default = 0x0000;
    ram      attribute minFrequency default = 0x0000;
    ram      attribute maxFrequency default = 0x0000;
    ram      attribute options default = 0x00;
    ram      attribute onOffTransitionTime default = 0x0000;
    ram      attribute onLevel;
    ram      attribute onTransitionTime;
    ram      attribute offTransitionTime;
    ram      attribute defaultMoveRate;
    ram      attribute startUpCurrentLevel;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 6;

    handle command MoveToLevel;
    handle command Move;
    handle command Step;
    handle command Stop;
    handle command MoveToLevelWithOnOff;
    handle command MoveWithOnOff;
    handle command StepWithOnOff;
    handle command StopWithOnOff;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster BasicInformation {
    callback attribute dataModelRevision;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location;
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate;
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    persist  attribute localConfigDisabled default = 0;
    ram      attribute reachable default = 1;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster LocalizationConfiguration {
    ram      attribute activeLocale;
    callback attribute supportedLocales;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UnitLocalization {
    ram      attribute temperatureUnit;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster FixedLabel {
    callback attribute labelList;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UserLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster ScenesManagement {
    ram      attribute sceneTableSize default = 16;
    callback attribute fabricSceneInfo;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;

    handle command AddScene;
    handle command AddSceneResponse;
    handle command ViewScene;
    handle command ViewSceneResponse;
    handle command RemoveScene;
    handle command RemoveSceneResponse;
    handle command RemoveAllScenes;
    handle command RemoveAllScenesResponse;
    handle command StoreScene;
    handle command StoreSceneResponse;
    handle command RecallScene;
    handle command GetSceneMembership;
    handle command GetSceneMembershipResponse;
  }

  server cluster ColorControl {
    ram      attribute currentHue default = 0x00;
    ram      attribute currentSaturation default = 0x00;
    ram      attribute remainingTime default = 0x00;
    ram      attribute currentX default = 0x616B;
    ram      attribute currentY default = 0x607D;
    ram      attribute driftCompensation;
    ram      attribute compensationText;
    ram      attribute colorTemperatureMireds default = 0x00FA;
    ram      attribute colorMode default = 1;
    ram      attribute options default = 0x00;
    ram      attribute numberOfPrimaries;
    ram      attribute primary1X;
    ram      attribute primary1Y;
    ram      attribute primary1Intensity;
    ram      attribute primary2X;
    ram      attribute primary2Y;
    ram      attribute primary2Intensity;
    ram      attribute primary3X;
    ram      attribute primary3Y;
    ram      attribute primary3Intensity;
    ram      attribute primary4X;
    ram      attribute primary4Y;
    ram      attribute primary4Intensity;
    ram      attribute primary5X;
    ram      attribute primary5Y;
    ram      attribute primary5Intensity;
    ram      attribute primary6X;
    ram      attribute primary6Y;
    ram      attribute primary6Intensity;
    ram      attribute whitePointX;
    ram      attribute whitePointY;
    ram      attribute colorPointRX;
    ram      attribute colorPointRY;
    ram      attribute colorPointRIntensity;
    ram      attribute colorPointGX;
    ram      attribute colorPointGY;
    ram      attribute colorPointGIntensity;
    ram      attribute colorPointBX;
    ram      attribute colorPointBY;
    ram      attribute colorPointBIntensity;
    ram      attribute enhancedCurrentHue default = 0x00;
    ram      attribute enhancedColorMode default = 0x01;
    ram      attribute colorLoopActive default = 0x00;
    ram      attribute colorLoopDirection default = 0x00;
    ram      attribute colorLoopTime default = 0x0019;
    ram      attribute colorLoopStartEnhancedHue default = 0x2300;
    ram      attribute colorLoopStoredEnhancedHue default = 0x00;
    ram      attribute colorCapabilities default = 0x00;
    ram      attribute colorTempPhysicalMinMireds default = 0x009A;
    ram      attribute colorTempPhysicalMaxMireds default = 0x01C6;
    ram      attribute coupleColorTempToLevelMinMireds;
    ram      attribute startUpColorTemperatureMireds default = 0x00FA;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 7;

    handle command MoveToHue;
    handle command MoveHue;
    handle command StepHue;
    handle command MoveToSaturation;
    handle command MoveSaturation;
    handle command StepSaturation;
    handle command MoveToHueAndSaturation;
    handle command MoveToColor;
    handle command MoveColor;
    handle command StepColor;
    handle command MoveToColorTemperature;
    handle command EnhancedMoveToHue;
    handle command EnhancedMoveHue;
    handle command EnhancedStepHue;
    handle command EnhancedMoveToHueAndSaturation;
    handle command ColorLoopSet;
    handle command StopMoveStep;
    handle command MoveColorTemperature;
    handle command StepColorTemperature;
  }

  server cluster OccupancySensing {
    ram      attribute occupancy;
    ram      attribute occupancySensorType;
    ram      attribute occupancySensorTypeBitmap;
    callback attribute PIROccupiedToUnoccupiedDelay;
    ram      attribute PIRUnoccupiedToOccupiedDelay default = 0x00;
    ram      attribute PIRUnoccupiedToOccupiedThreshold default = 1;
    callback attribute ultrasonicOccupiedToUnoccupiedDelay;
    ram      attribute ultrasonicUnoccupiedToOccupiedDelay default = 0x00;
    ram      attribute ultrasonicUnoccupiedToOccupiedThreshold default = 1;
    callback attribute physicalContactOccupiedToUnoccupiedDelay;
    ram      attribute physicalContactUnoccupiedToOccupiedDelay default = 0x00;
    ram      attribute physicalContactUnoccupiedToOccupiedThreshold default = 1;
    callback attribute featureMap;
    callback attribute clusterRevision default = 5;
  }

  server cluster ThreadBorderRouterManagement {
    callback attribute borderRouterName;
    callback attribute borderAgentID;
    callback attribute threadVersion;
    callback attribute interfaceEnabled;
    callback attribute activeDatasetTimestamp;
    callback attribute pendingDatasetTimestamp;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;

    handle command GetActiveDatasetRequest;
    handle command GetPendingDatasetRequest;
    handle command DatasetResponse;
    handle command SetActiveDatasetRequest;
    handle command SetPendingDatasetRequest;
  }
}


