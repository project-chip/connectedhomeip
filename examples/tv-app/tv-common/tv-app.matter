// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
}

server cluster OnOff = 6 {
  enum OnOffDelayedAllOffEffectVariant : ENUM8 {
    kFadeToOffIn0p8Seconds = 0;
    kNoFade = 1;
    k50PercentDimDownIn0p8SecondsThenFadeToOffIn12Seconds = 2;
  }

  enum OnOffDyingLightEffectVariant : ENUM8 {
    k20PercenterDimUpIn0p5SecondsThenFadeToOffIn1Second = 0;
  }

  enum OnOffEffectIdentifier : ENUM8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum OnOffStartUpOnOff : ENUM8 {
    kOff = 0;
    kOn = 1;
    kTogglePreviousOnOff = 2;
  }

  bitmap OnOffControl : BITMAP8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  bitmap OnOffFeature : BITMAP32 {
    kLighting = 0x1;
  }

  bitmap SceneFeatures : BITMAP32 {
    kSceneNames = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command Off(): DefaultSuccess = 0;
  command On(): DefaultSuccess = 1;
  command Toggle(): DefaultSuccess = 2;
}

server cluster LevelControl = 8 {
  enum MoveMode : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepMode : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap LevelControlFeature : BITMAP32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute int16u remainingTime = 1;
  readonly attribute int8u minLevel = 2;
  readonly attribute int8u maxLevel = 3;
  readonly attribute int16u currentFrequency = 4;
  readonly attribute int16u minFrequency = 5;
  readonly attribute int16u maxFrequency = 6;
  attribute bitmap8 options = 15;
  attribute int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute nullable int16u onTransitionTime = 18;
  attribute nullable int16u offTransitionTime = 19;
  attribute nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) nullable int8u startUpCurrentLevel = 16384;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    INT8U level = 0;
    nullable INT16U transitionTime = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveMode moveMode = 0;
    nullable INT8U rate = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct StepRequest {
    StepMode stepMode = 0;
    INT8U stepSize = 1;
    nullable INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct StopRequest {
    BITMAP8 optionsMask = 0;
    BITMAP8 optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    INT8U level = 0;
    nullable INT16U transitionTime = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveMode moveMode = 0;
    nullable INT8U rate = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepMode stepMode = 0;
    INT8U stepSize = 1;
    nullable INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    BITMAP8 optionsMask = 0;
    BITMAP8 optionsOverride = 1;
  }

  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  command Move(MoveRequest): DefaultSuccess = 1;
  command Step(StepRequest): DefaultSuccess = 2;
  command Stop(StopRequest): DefaultSuccess = 3;
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
}

server cluster Descriptor = 29 {
  struct DeviceTypeStruct {
    devtype_id type = 0;
    int16u revision = 1;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute CLUSTER_ID serverList[] = 1;
  readonly attribute CLUSTER_ID clientList[] = 2;
  readonly attribute ENDPOINT_NO partsList[] = 3;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

client cluster Binding = 30 {
  struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute TargetStruct binding[] = 0;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster Binding = 30 {
  struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute TargetStruct binding[] = 0;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster AccessControl = 31 {
  enum AuthMode : ENUM8 {
    kPase = 1;
    kCase = 2;
    kGroup = 3;
  }

  enum ChangeTypeEnum : ENUM8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  enum Privilege : ENUM8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  struct AccessControlEntry {
    Privilege privilege = 1;
    AuthMode authMode = 2;
    nullable int64u subjects[] = 3;
    nullable Target targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  struct Target {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  struct ExtensionEntry {
    octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntry latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable ExtensionEntry latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntry acl[] = 0;
  attribute access(read: administer, write: administer) ExtensionEntry extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster Basic = 40 {
  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  critical event StartUp = 0 {
    INT32U softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute char_string<16> manufacturingDate = 11;
  readonly attribute char_string<32> partNumber = 12;
  readonly attribute long_char_string<256> productURL = 13;
  readonly attribute char_string<64> productLabel = 14;
  readonly attribute char_string<32> serialNumber = 15;
  attribute access(write: manage) boolean localConfigDisabled = 16;
  readonly attribute boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster OtaSoftwareUpdateProvider = 41 {
  enum OTAApplyUpdateAction : ENUM8 {
    kProceed = 0;
    kAwaitNextAction = 1;
    kDiscontinue = 2;
  }

  enum OTADownloadProtocol : ENUM8 {
    kBDXSynchronous = 0;
    kBDXAsynchronous = 1;
    kHttps = 2;
    kVendorSpecific = 3;
  }

  enum OTAQueryStatus : ENUM8 {
    kUpdateAvailable = 0;
    kBusy = 1;
    kNotAvailable = 2;
    kDownloadProtocolNotSupported = 3;
  }

  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct QueryImageRequest {
    vendor_id vendorId = 0;
    INT16U productId = 1;
    INT32U softwareVersion = 2;
    OTADownloadProtocol protocolsSupported[] = 3;
    optional INT16U hardwareVersion = 4;
    optional CHAR_STRING<2> location = 5;
    optional BOOLEAN requestorCanConsent = 6;
    optional OCTET_STRING<512> metadataForProvider = 7;
  }

  request struct ApplyUpdateRequestRequest {
    OCTET_STRING<32> updateToken = 0;
    INT32U newVersion = 1;
  }

  request struct NotifyUpdateAppliedRequest {
    OCTET_STRING<32> updateToken = 0;
    INT32U softwareVersion = 1;
  }

  response struct QueryImageResponse = 1 {
    OTAQueryStatus status = 0;
    optional INT32U delayedActionTime = 1;
    optional CHAR_STRING<256> imageURI = 2;
    optional INT32U softwareVersion = 3;
    optional CHAR_STRING<64> softwareVersionString = 4;
    optional OCTET_STRING<32> updateToken = 5;
    optional BOOLEAN userConsentNeeded = 6;
    optional OCTET_STRING<512> metadataForRequestor = 7;
  }

  response struct ApplyUpdateResponse = 3 {
    OTAApplyUpdateAction action = 0;
    INT32U delayedActionTime = 1;
  }

  command QueryImage(QueryImageRequest): QueryImageResponse = 0;
  command ApplyUpdateRequest(ApplyUpdateRequestRequest): ApplyUpdateResponse = 2;
  command NotifyUpdateApplied(NotifyUpdateAppliedRequest): DefaultSuccess = 4;
}

server cluster LocalizationConfiguration = 43 {
  attribute char_string<35> activeLocale = 0;
  readonly attribute CHAR_STRING supportedLocales[] = 1;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster TimeFormatLocalization = 44 {
  enum CalendarType : ENUM8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
  }

  enum HourFormat : ENUM8 {
    k12hr = 0;
    k24hr = 1;
  }

  attribute HourFormat hourFormat = 0;
  attribute CalendarType activeCalendarType = 1;
  readonly attribute CalendarType supportedCalendarTypes[] = 2;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster UnitLocalization = 45 {
  enum TempUnit : ENUM8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap UnitLocalizationFeature : BITMAP32 {
    kTemperatureUnit = 0x1;
  }

  attribute TempUnit temperatureUnit = 0;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

client cluster GeneralCommissioning = 48 {
  enum CommissioningError : ENUM8 {
    kOk = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationType : ENUM8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationType regulatoryConfig = 2;
  readonly attribute RegulatoryLocationType locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    INT16U expiryLengthSeconds = 0;
    INT64U breadcrumb = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationType newRegulatoryConfig = 0;
    CHAR_STRING countryCode = 1;
    INT64U breadcrumb = 2;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

server cluster GeneralCommissioning = 48 {
  enum CommissioningError : ENUM8 {
    kOk = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationType : ENUM8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationType regulatoryConfig = 2;
  readonly attribute RegulatoryLocationType locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    INT16U expiryLengthSeconds = 0;
    INT64U breadcrumb = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationType newRegulatoryConfig = 0;
    CHAR_STRING countryCode = 1;
    INT64U breadcrumb = 2;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

client cluster NetworkCommissioning = 49 {
  enum NetworkCommissioningStatus : ENUM8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBand : ENUM8 {
    k2g4 = 0;
    k3g65 = 1;
    k5g = 2;
    k6g = 3;
    k60g = 4;
  }

  bitmap NetworkCommissioningFeature : BITMAP32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
  }

  bitmap WiFiSecurity : BITMAP8 {
    kUnencrypted = 0x1;
    kWepPersonal = 0x2;
    kWpaPersonal = 0x4;
    kWpa2Personal = 0x8;
    kWpa3Personal = 0x10;
  }

  struct NetworkInfo {
    octet_string<32> networkID = 0;
    boolean connected = 1;
  }

  struct WiFiInterfaceScanResult {
    WiFiSecurity security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBand wiFiBand = 4;
    int8s rssi = 5;
  }

  struct ThreadInterfaceScanResult {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfo networks[] = 1;
  readonly attribute int8u scanMaxTimeSeconds = 2;
  readonly attribute int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatus lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable OCTET_STRING<32> ssid = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    OCTET_STRING<32> ssid = 0;
    OCTET_STRING<64> credentials = 1;
    optional INT64U breadcrumb = 2;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    OCTET_STRING<254> operationalDataset = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ConnectNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ReorderNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    INT8U networkIndex = 1;
    optional INT64U breadcrumb = 2;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    optional WiFiInterfaceScanResult wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResult threadScanResults[] = 3;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING<512> debugText = 1;
    optional INT8U networkIndex = 2;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    nullable INT32S errorValue = 2;
  }

  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
}

server cluster NetworkCommissioning = 49 {
  enum NetworkCommissioningStatus : ENUM8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBand : ENUM8 {
    k2g4 = 0;
    k3g65 = 1;
    k5g = 2;
    k6g = 3;
    k60g = 4;
  }

  bitmap NetworkCommissioningFeature : BITMAP32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
  }

  bitmap WiFiSecurity : BITMAP8 {
    kUnencrypted = 0x1;
    kWepPersonal = 0x2;
    kWpaPersonal = 0x4;
    kWpa2Personal = 0x8;
    kWpa3Personal = 0x10;
  }

  struct NetworkInfo {
    octet_string<32> networkID = 0;
    boolean connected = 1;
  }

  struct WiFiInterfaceScanResult {
    WiFiSecurity security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBand wiFiBand = 4;
    int8s rssi = 5;
  }

  struct ThreadInterfaceScanResult {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfo networks[] = 1;
  readonly attribute int8u scanMaxTimeSeconds = 2;
  readonly attribute int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatus lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable OCTET_STRING<32> ssid = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    OCTET_STRING<32> ssid = 0;
    OCTET_STRING<64> credentials = 1;
    optional INT64U breadcrumb = 2;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    OCTET_STRING<254> operationalDataset = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ConnectNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ReorderNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    INT8U networkIndex = 1;
    optional INT64U breadcrumb = 2;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    optional WiFiInterfaceScanResult wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResult threadScanResults[] = 3;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING<512> debugText = 1;
    optional INT8U networkIndex = 2;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    nullable INT32S errorValue = 2;
  }

  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
}

server cluster DiagnosticLogs = 50 {
  enum LogsIntent : ENUM8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum LogsStatus : ENUM8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum LogsTransferProtocol : ENUM8 {
    kResponsePayload = 0;
    kBdx = 1;
  }

  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    LogsIntent intent = 0;
    LogsTransferProtocol requestedProtocol = 1;
    OCTET_STRING<32> transferFileDesignator = 2;
  }

  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

server cluster GeneralDiagnostics = 51 {
  enum BootReasonType : ENUM8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultType : ENUM8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceType : ENUM8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultType : ENUM8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultType : ENUM8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  struct NetworkInterfaceType {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceType type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultType current[] = 0;
    HardwareFaultType previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultType current[] = 0;
    RadioFaultType previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultType current[] = 0;
    NetworkFaultType previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonType bootReason = 0;
  }

  readonly attribute NetworkInterfaceType networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute int64u upTime = 2;
  readonly attribute int32u totalOperationalHours = 3;
  readonly attribute enum8 bootReasons = 4;
  readonly attribute ENUM8 activeHardwareFaults[] = 5;
  readonly attribute ENUM8 activeRadioFaults[] = 6;
  readonly attribute ENUM8 activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    OCTET_STRING<16> enableKey = 0;
    INT64U eventTrigger = 1;
  }

  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
}

server cluster SoftwareDiagnostics = 52 {
  bitmap SoftwareDiagnosticsFeature : BITMAP32 {
    kWaterMarks = 0x1;
  }

  struct ThreadMetrics {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    INT64U id = 0;
    optional CHAR_STRING name = 1;
    optional OCTET_STRING faultRecording = 2;
  }

  readonly attribute ThreadMetrics threadMetrics[] = 0;
  readonly attribute int64u currentHeapFree = 1;
  readonly attribute int64u currentHeapUsed = 2;
  readonly attribute int64u currentHeapHighWatermark = 3;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster ThreadNetworkDiagnostics = 53 {
  enum NetworkFault : ENUM8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRole : ENUM8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kReed = 4;
    kRouter = 5;
    kLeader = 6;
  }

  enum ThreadConnectionStatus : ENUM8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  bitmap ThreadNetworkDiagnosticsFeature : BITMAP32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTable {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct RouteTable {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    bitmap16 flags = 1;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  info event ConnectionStatus = 0 {
    ThreadConnectionStatus connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFault current[] = 0;
    NetworkFault previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRole routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute int64u overrunCount = 6;
  readonly attribute NeighborTable neighborTableList[] = 7;
  readonly attribute RouteTable routeTableList[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int8u weighting = 10;
  readonly attribute nullable int8u dataVersion = 11;
  readonly attribute nullable int8u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute int16u detachedRoleCount = 14;
  readonly attribute int16u childRoleCount = 15;
  readonly attribute int16u routerRoleCount = 16;
  readonly attribute int16u leaderRoleCount = 17;
  readonly attribute int16u attachAttemptCount = 18;
  readonly attribute int16u partitionIdChangeCount = 19;
  readonly attribute int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute int16u parentChangeCount = 21;
  readonly attribute int32u txTotalCount = 22;
  readonly attribute int32u txUnicastCount = 23;
  readonly attribute int32u txBroadcastCount = 24;
  readonly attribute int32u txAckRequestedCount = 25;
  readonly attribute int32u txAckedCount = 26;
  readonly attribute int32u txNoAckRequestedCount = 27;
  readonly attribute int32u txDataCount = 28;
  readonly attribute int32u txDataPollCount = 29;
  readonly attribute int32u txBeaconCount = 30;
  readonly attribute int32u txBeaconRequestCount = 31;
  readonly attribute int32u txOtherCount = 32;
  readonly attribute int32u txRetryCount = 33;
  readonly attribute int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute int32u txErrCcaCount = 36;
  readonly attribute int32u txErrAbortCount = 37;
  readonly attribute int32u txErrBusyChannelCount = 38;
  readonly attribute int32u rxTotalCount = 39;
  readonly attribute int32u rxUnicastCount = 40;
  readonly attribute int32u rxBroadcastCount = 41;
  readonly attribute int32u rxDataCount = 42;
  readonly attribute int32u rxDataPollCount = 43;
  readonly attribute int32u rxBeaconCount = 44;
  readonly attribute int32u rxBeaconRequestCount = 45;
  readonly attribute int32u rxOtherCount = 46;
  readonly attribute int32u rxAddressFilteredCount = 47;
  readonly attribute int32u rxDestAddrFilteredCount = 48;
  readonly attribute int32u rxDuplicatedCount = 49;
  readonly attribute int32u rxErrNoFrameCount = 50;
  readonly attribute int32u rxErrUnknownNeighborCount = 51;
  readonly attribute int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute int32u rxErrSecCount = 53;
  readonly attribute int32u rxErrFcsCount = 54;
  readonly attribute int32u rxErrOtherCount = 55;
  readonly attribute nullable int64u activeTimestamp = 56;
  readonly attribute nullable int64u pendingTimestamp = 57;
  readonly attribute nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFault activeNetworkFaultsList[] = 62;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster WiFiNetworkDiagnostics = 54 {
  enum AssociationFailureCause : ENUM8 {
    kUnknown = 0;
    kAssociationFailed = 1;
    kAuthenticationFailed = 2;
    kSsidNotFound = 3;
  }

  enum SecurityType : ENUM8 {
    kUnspecified = 0;
    kNone = 1;
    kWep = 2;
    kWpa = 3;
    kWpa2 = 4;
    kWpa3 = 5;
  }

  enum WiFiConnectionStatus : ENUM8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum WiFiVersionType : ENUM8 {
    k80211a = 0;
    k80211b = 1;
    k80211g = 2;
    k80211n = 3;
    k80211ac = 4;
    k80211ax = 5;
  }

  info event Disconnection = 0 {
    INT16U reasonCode = 0;
  }

  info event AssociationFailure = 1 {
    AssociationFailureCause associationFailure = 0;
    INT16U status = 1;
  }

  info event ConnectionStatus = 2 {
    WiFiConnectionStatus connectionStatus = 0;
  }

  readonly attribute nullable octet_string<6> bssid = 0;
  readonly attribute nullable SecurityType securityType = 1;
  readonly attribute nullable WiFiVersionType wiFiVersion = 2;
  readonly attribute nullable int16u channelNumber = 3;
  readonly attribute nullable int8s rssi = 4;
  readonly attribute nullable int32u beaconLostCount = 5;
  readonly attribute nullable int32u beaconRxCount = 6;
  readonly attribute nullable int32u packetMulticastRxCount = 7;
  readonly attribute nullable int32u packetMulticastTxCount = 8;
  readonly attribute nullable int32u packetUnicastRxCount = 9;
  readonly attribute nullable int32u packetUnicastTxCount = 10;
  readonly attribute nullable int64u currentMaxRate = 11;
  readonly attribute nullable int64u overrunCount = 12;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster EthernetNetworkDiagnostics = 55 {
  enum PHYRateType : ENUM8 {
    k10m = 0;
    k100m = 1;
    k1000m = 2;
    k25g = 3;
    k5g = 4;
    k10g = 5;
    k40g = 6;
    k100g = 7;
    k200g = 8;
    k400g = 9;
  }

  readonly attribute nullable PHYRateType PHYRate = 0;
  readonly attribute nullable boolean fullDuplex = 1;
  readonly attribute int64u packetRxCount = 2;
  readonly attribute int64u packetTxCount = 3;
  readonly attribute int64u txErrCount = 4;
  readonly attribute int64u collisionCount = 5;
  readonly attribute int64u overrunCount = 6;
  readonly attribute nullable boolean carrierDetect = 7;
  readonly attribute int64u timeSinceReset = 8;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command ResetCounts(): DefaultSuccess = 0;
}

server cluster AdministratorCommissioning = 60 {
  enum CommissioningWindowStatus : ENUM8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : ENUM8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  readonly attribute CommissioningWindowStatus windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable int16u adminVendorId = 2;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
    OCTET_STRING PAKEVerifier = 1;
    INT16U discriminator = 2;
    INT32U iterations = 3;
    OCTET_STRING salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
  }

  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

client cluster OperationalCredentials = 62 {
  enum OperationalCertStatus : ENUM8 {
    kSuccess = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  struct NOCStruct {
    octet_string noc = 1;
    nullable octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  struct FabricDescriptor {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorId = 2;
    fabric_id fabricId = 3;
    node_id nodeId = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptor fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute OCTET_STRING trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    OCTET_STRING attestationNonce = 0;
  }

  request struct CertificateChainRequestRequest {
    INT8U certificateType = 0;
  }

  request struct CSRRequestRequest {
    OCTET_STRING CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  request struct AddNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
    OCTET_STRING IPKValue = 2;
    Int64u caseAdminSubject = 3;
    VENDOR_ID adminVendorId = 4;
  }

  request struct UpdateFabricLabelRequest {
    CHAR_STRING<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    OCTET_STRING rootCertificate = 0;
  }

  response struct AttestationResponse = 1 {
    OCTET_STRING attestationElements = 0;
    OCTET_STRING signature = 1;
  }

  response struct CertificateChainResponse = 3 {
    OCTET_STRING certificate = 0;
  }

  response struct CSRResponse = 5 {
    OCTET_STRING NOCSRElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  response struct NOCResponse = 8 {
    OperationalCertStatus statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional CHAR_STRING debugText = 2;
  }

  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

server cluster OperationalCredentials = 62 {
  enum OperationalCertStatus : ENUM8 {
    kSuccess = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  struct NOCStruct {
    octet_string noc = 1;
    nullable octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  struct FabricDescriptor {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorId = 2;
    fabric_id fabricId = 3;
    node_id nodeId = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptor fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute OCTET_STRING trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    OCTET_STRING attestationNonce = 0;
  }

  request struct CertificateChainRequestRequest {
    INT8U certificateType = 0;
  }

  request struct CSRRequestRequest {
    OCTET_STRING CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  request struct AddNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
    OCTET_STRING IPKValue = 2;
    Int64u caseAdminSubject = 3;
    VENDOR_ID adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
  }

  request struct UpdateFabricLabelRequest {
    CHAR_STRING<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    OCTET_STRING rootCertificate = 0;
  }

  response struct AttestationResponse = 1 {
    OCTET_STRING attestationElements = 0;
    OCTET_STRING signature = 1;
  }

  response struct CertificateChainResponse = 3 {
    OCTET_STRING certificate = 0;
  }

  response struct CSRResponse = 5 {
    OCTET_STRING NOCSRElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  response struct NOCResponse = 8 {
    OperationalCertStatus statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional CHAR_STRING debugText = 2;
  }

  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

server cluster GroupKeyManagement = 63 {
  enum GroupKeySecurityPolicy : ENUM8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicy groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetRemoveRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetReadAllIndicesRequest {
    INT16U groupKeySetIDs[] = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    INT16U groupKeySetIDs[] = 0;
  }

  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  fabric command access(invoke: administer) KeySetReadAllIndices(KeySetReadAllIndicesRequest): KeySetReadAllIndicesResponse = 4;
}

server cluster FixedLabel = 64 {
  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster UserLabel = 65 {
  attribute access(write: manage) LabelStruct labelList[] = 0;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster RelativeHumidityMeasurement = 1029 {
  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster WakeOnLan = 1283 {
  readonly attribute char_string<32> MACAddress = 0;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster Channel = 1284 {
  enum ChannelStatusEnum : ENUM8 {
    kSuccess = 0;
    kMultipleMatches = 1;
    kNoMatches = 2;
  }

  enum LineupInfoTypeEnum : ENUM8 {
    kMso = 0;
  }

  bitmap ChannelFeature : BITMAP32 {
    kChannelList = 0x1;
    kLineupInfo = 0x2;
  }

  struct ChannelInfo {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
    optional char_string<32> name = 2;
    optional char_string<32> callSign = 3;
    optional char_string<32> affiliateCallSign = 4;
  }

  struct LineupInfo {
    char_string operatorName = 0;
    optional char_string lineupName = 1;
    optional char_string postalCode = 2;
    LineupInfoTypeEnum lineupInfoType = 3;
  }

  readonly attribute ChannelInfo channelList[] = 0;
  readonly attribute nullable LineupInfo lineup = 1;
  readonly attribute nullable ChannelInfo currentChannel = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeChannelRequest {
    CHAR_STRING match = 0;
  }

  request struct ChangeChannelByNumberRequest {
    INT16U majorNumber = 0;
    INT16U minorNumber = 1;
  }

  request struct SkipChannelRequest {
    INT16U count = 0;
  }

  response struct ChangeChannelResponse = 1 {
    ChannelStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  command ChangeChannel(ChangeChannelRequest): ChangeChannelResponse = 0;
  command ChangeChannelByNumber(ChangeChannelByNumberRequest): DefaultSuccess = 2;
  command SkipChannel(SkipChannelRequest): DefaultSuccess = 3;
}

server cluster TargetNavigator = 1285 {
  enum TargetNavigatorStatusEnum : ENUM8 {
    kSuccess = 0;
    kTargetNotFound = 1;
    kNotAllowed = 2;
  }

  struct TargetInfo {
    int8u identifier = 0;
    char_string<32> name = 1;
  }

  readonly attribute TargetInfo targetList[] = 0;
  readonly attribute int8u currentTarget = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct NavigateTargetRequest {
    INT8U target = 0;
    optional CHAR_STRING data = 1;
  }

  response struct NavigateTargetResponse = 1 {
    TargetNavigatorStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  command NavigateTarget(NavigateTargetRequest): NavigateTargetResponse = 0;
}

server cluster MediaPlayback = 1286 {
  enum MediaPlaybackStatusEnum : ENUM8 {
    kSuccess = 0;
    kInvalidStateForCommand = 1;
    kNotAllowed = 2;
    kNotActive = 3;
    kSpeedOutOfRange = 4;
    kSeekOutOfRange = 5;
  }

  enum PlaybackStateEnum : ENUM8 {
    kPlaying = 0;
    kPaused = 1;
    kNotPlaying = 2;
    kBuffering = 3;
  }

  struct PlaybackPosition {
    int64u updatedAt = 0;
    nullable int64u position = 1;
  }

  readonly attribute PlaybackStateEnum currentState = 0;
  readonly attribute nullable epoch_us startTime = 1;
  readonly attribute nullable int64u duration = 2;
  readonly attribute nullable PlaybackPosition sampledPosition = 3;
  readonly attribute single playbackSpeed = 4;
  readonly attribute nullable int64u seekRangeEnd = 5;
  readonly attribute nullable int64u seekRangeStart = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SkipForwardRequest {
    INT64U deltaPositionMilliseconds = 0;
  }

  request struct SkipBackwardRequest {
    INT64U deltaPositionMilliseconds = 0;
  }

  request struct SeekRequest {
    INT64U position = 0;
  }

  response struct PlaybackResponse = 10 {
    MediaPlaybackStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  command Play(): PlaybackResponse = 0;
  command Pause(): PlaybackResponse = 1;
  command StopPlayback(): PlaybackResponse = 2;
  command StartOver(): PlaybackResponse = 3;
  command Previous(): PlaybackResponse = 4;
  command Next(): PlaybackResponse = 5;
  command Rewind(): PlaybackResponse = 6;
  command FastForward(): PlaybackResponse = 7;
  command SkipForward(SkipForwardRequest): PlaybackResponse = 8;
  command SkipBackward(SkipBackwardRequest): PlaybackResponse = 9;
  command Seek(SeekRequest): PlaybackResponse = 11;
}

server cluster MediaInput = 1287 {
  enum InputTypeEnum : ENUM8 {
    kInternal = 0;
    kAux = 1;
    kCoax = 2;
    kComposite = 3;
    kHdmi = 4;
    kInput = 5;
    kLine = 6;
    kOptical = 7;
    kVideo = 8;
    kScart = 9;
    kUsb = 10;
    kOther = 11;
  }

  bitmap MediaInputFeature : BITMAP32 {
    kNameUpdates = 0x1;
  }

  struct InputInfo {
    int8u index = 0;
    InputTypeEnum inputType = 1;
    char_string<32> name = 2;
    char_string<32> description = 3;
  }

  readonly attribute InputInfo inputList[] = 0;
  readonly attribute int8u currentInput = 1;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectInputRequest {
    INT8U index = 0;
  }

  request struct RenameInputRequest {
    INT8U index = 0;
    CHAR_STRING name = 1;
  }

  command SelectInput(SelectInputRequest): DefaultSuccess = 0;
  command ShowInputStatus(): DefaultSuccess = 1;
  command HideInputStatus(): DefaultSuccess = 2;
  command RenameInput(RenameInputRequest): DefaultSuccess = 3;
}

server cluster LowPower = 1288 {
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command Sleep(): DefaultSuccess = 0;
}

server cluster KeypadInput = 1289 {
  enum CecKeyCode : ENUM8 {
    kSelect = 0;
    kUp = 1;
    kDown = 2;
    kLeft = 3;
    kRight = 4;
    kRightUp = 5;
    kRightDown = 6;
    kLeftUp = 7;
    kLeftDown = 8;
    kRootMenu = 9;
    kSetupMenu = 10;
    kContentsMenu = 11;
    kFavoriteMenu = 12;
    kExit = 13;
    kMediaTopMenu = 16;
    kMediaContextSensitiveMenu = 17;
    kNumberEntryMode = 29;
    kNumber11 = 30;
    kNumber12 = 31;
    kNumber0OrNumber10 = 32;
    kNumbers1 = 33;
    kNumbers2 = 34;
    kNumbers3 = 35;
    kNumbers4 = 36;
    kNumbers5 = 37;
    kNumbers6 = 38;
    kNumbers7 = 39;
    kNumbers8 = 40;
    kNumbers9 = 41;
    kDot = 42;
    kEnter = 43;
    kClear = 44;
    kNextFavorite = 47;
    kChannelUp = 48;
    kChannelDown = 49;
    kPreviousChannel = 50;
    kSoundSelect = 51;
    kInputSelect = 52;
    kDisplayInformation = 53;
    kHelp = 54;
    kPageUp = 55;
    kPageDown = 56;
    kPower = 64;
    kVolumeUp = 65;
    kVolumeDown = 66;
    kMute = 67;
    kPlay = 68;
    kStop = 69;
    kPause = 70;
    kRecord = 71;
    kRewind = 72;
    kFastForward = 73;
    kEject = 74;
    kForward = 75;
    kBackward = 76;
    kStopRecord = 77;
    kPauseRecord = 78;
    kReserved = 79;
    kAngle = 80;
    kSubPicture = 81;
    kVideoOnDemand = 82;
    kElectronicProgramGuide = 83;
    kTimerProgramming = 84;
    kInitialConfiguration = 85;
    kSelectBroadcastType = 86;
    kSelectSoundPresentation = 87;
    kPlayFunction = 96;
    kPausePlayFunction = 97;
    kRecordFunction = 98;
    kPauseRecordFunction = 99;
    kStopFunction = 100;
    kMuteFunction = 101;
    kRestoreVolumeFunction = 102;
    kTuneFunction = 103;
    kSelectMediaFunction = 104;
    kSelectAvInputFunction = 105;
    kSelectAudioInputFunction = 106;
    kPowerToggleFunction = 107;
    kPowerOffFunction = 108;
    kPowerOnFunction = 109;
    kF1Blue = 113;
    kF2Red = 114;
    kF3Green = 115;
    kF4Yellow = 116;
    kF5 = 117;
    kData = 118;
  }

  enum KeypadInputStatusEnum : ENUM8 {
    kSuccess = 0;
    kUnsupportedKey = 1;
    kInvalidKeyInCurrentState = 2;
  }

  bitmap KeypadInputFeature : BITMAP32 {
    kNavigationKeyCodes = 0x1;
    kLocationKeys = 0x2;
    kNumberKeys = 0x4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SendKeyRequest {
    CecKeyCode keyCode = 0;
  }

  response struct SendKeyResponse = 1 {
    KeypadInputStatusEnum status = 0;
  }

  command SendKey(SendKeyRequest): SendKeyResponse = 0;
}

server cluster ContentLauncher = 1290 {
  enum ContentLaunchStatusEnum : ENUM8 {
    kSuccess = 0;
    kUrlNotAvailable = 1;
    kAuthFailed = 2;
  }

  enum MetricTypeEnum : ENUM8 {
    kPixels = 0;
    kPercentage = 1;
  }

  enum ParameterEnum : ENUM8 {
    kActor = 0;
    kChannel = 1;
    kCharacter = 2;
    kDirector = 3;
    kEvent = 4;
    kFranchise = 5;
    kGenre = 6;
    kLeague = 7;
    kPopularity = 8;
    kProvider = 9;
    kSport = 10;
    kSportsTeam = 11;
    kType = 12;
  }

  bitmap ContentLauncherFeature : BITMAP32 {
    kContentSearch = 0x1;
    kURLPlayback = 0x2;
  }

  bitmap SupportedStreamingProtocol : BITMAP32 {
    kDash = 0x1;
    kHls = 0x2;
  }

  struct ContentSearch {
    Parameter parameterList[] = 0;
  }

  struct Parameter {
    ParameterEnum type = 0;
    char_string value = 1;
    optional AdditionalInfo externalIDList[] = 2;
  }

  struct AdditionalInfo {
    char_string name = 0;
    char_string value = 1;
  }

  struct BrandingInformation {
    char_string providerName = 0;
    optional StyleInformation background = 1;
    optional StyleInformation logo = 2;
    optional StyleInformation progressBar = 3;
    optional StyleInformation splash = 4;
    optional StyleInformation waterMark = 5;
  }

  struct StyleInformation {
    optional char_string imageUrl = 0;
    optional char_string color = 1;
    optional Dimension size = 2;
  }

  struct Dimension {
    double width = 0;
    double height = 1;
    MetricTypeEnum metric = 2;
  }

  readonly attribute CHAR_STRING acceptHeader[] = 0;
  attribute bitmap32 supportedStreamingProtocols = 1;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchContentRequest {
    ContentSearch search = 0;
    BOOLEAN autoPlay = 1;
    optional CHAR_STRING data = 2;
  }

  request struct LaunchURLRequest {
    CHAR_STRING contentURL = 0;
    optional CHAR_STRING displayString = 1;
    optional BrandingInformation brandingInformation = 2;
  }

  response struct LaunchResponse = 2 {
    ContentLaunchStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  command LaunchContent(LaunchContentRequest): LaunchResponse = 0;
  command LaunchURL(LaunchURLRequest): LaunchResponse = 1;
}

server cluster AudioOutput = 1291 {
  enum OutputTypeEnum : ENUM8 {
    kHdmi = 0;
    kBt = 1;
    kOptical = 2;
    kHeadphone = 3;
    kInternal = 4;
    kOther = 5;
  }

  bitmap AudioOutputFeature : BITMAP32 {
    kNameUpdates = 0x1;
  }

  struct OutputInfo {
    int8u index = 0;
    OutputTypeEnum outputType = 1;
    char_string<32> name = 2;
  }

  readonly attribute OutputInfo outputList[] = 0;
  readonly attribute int8u currentOutput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectOutputRequest {
    INT8U index = 0;
  }

  request struct RenameOutputRequest {
    INT8U index = 0;
    CHAR_STRING name = 1;
  }

  command SelectOutput(SelectOutputRequest): DefaultSuccess = 0;
  command RenameOutput(RenameOutputRequest): DefaultSuccess = 1;
}

server cluster ApplicationLauncher = 1292 {
  enum ApplicationLauncherStatusEnum : ENUM8 {
    kSuccess = 0;
    kAppNotAvailable = 1;
    kSystemBusy = 2;
  }

  bitmap ApplicationLauncherFeature : BITMAP32 {
    kApplicationPlatform = 0x1;
  }

  struct ApplicationEP {
    Application application = 0;
    optional endpoint_no endpoint = 1;
  }

  struct Application {
    int16u catalogVendorId = 0;
    char_string applicationId = 1;
  }

  readonly attribute INT16U catalogList[] = 0;
  attribute nullable ApplicationEP currentApp = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchAppRequest {
    Application application = 0;
    optional OCTET_STRING data = 1;
  }

  request struct StopAppRequest {
    Application application = 0;
  }

  request struct HideAppRequest {
    Application application = 0;
  }

  response struct LauncherResponse = 3 {
    ApplicationLauncherStatusEnum status = 0;
    OCTET_STRING data = 1;
  }

  command LaunchApp(LaunchAppRequest): LauncherResponse = 0;
  command StopApp(StopAppRequest): LauncherResponse = 1;
  command HideApp(HideAppRequest): LauncherResponse = 2;
}

server cluster ApplicationBasic = 1293 {
  enum ApplicationStatusEnum : ENUM8 {
    kStopped = 0;
    kActiveVisibleFocus = 1;
    kActiveHidden = 2;
    kActiveVisibleNotFocus = 3;
  }

  struct ApplicationBasicApplication {
    int16u catalogVendorId = 0;
    char_string applicationId = 1;
  }

  readonly attribute char_string<32> vendorName = 0;
  readonly attribute vendor_id vendorID = 1;
  readonly attribute char_string<32> applicationName = 2;
  readonly attribute int16u productID = 3;
  readonly attribute ApplicationBasicApplication application = 4;
  readonly attribute ApplicationStatusEnum status = 5;
  readonly attribute char_string<32> applicationVersion = 6;
  readonly attribute vendor_id allowedVendorList[] = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster AccountLogin = 1294 {
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GetSetupPINRequest {
    CHAR_STRING<100> tempAccountIdentifier = 0;
  }

  request struct LoginRequest {
    CHAR_STRING<100> tempAccountIdentifier = 0;
    CHAR_STRING setupPIN = 1;
  }

  response struct GetSetupPINResponse = 1 {
    CHAR_STRING setupPIN = 0;
  }

  timed command GetSetupPIN(GetSetupPINRequest): GetSetupPINResponse = 0;
  timed command Login(LoginRequest): DefaultSuccess = 2;
  timed command Logout(): DefaultSuccess = 3;
}

endpoint 0 {
  device type rootdevice = 22;
  binding cluster Binding;
  binding cluster GeneralCommissioning;
  binding cluster NetworkCommissioning;
  binding cluster OperationalCredentials;

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    ram      attribute featureMap;
    callback attribute clusterRevision default = 1;
  }

  server cluster Binding {
    callback attribute binding;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AccessControl {
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry default = 4;
    callback attribute targetsPerAccessControlEntry default = 3;
    callback attribute accessControlEntriesPerFabric default = 3;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster Basic {
    callback attribute dataModelRevision default = 10;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location default = "XX";
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate default = "20210614123456ZZ";
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    persist  attribute localConfigDisabled;
    ram      attribute reachable default = 1;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OtaSoftwareUpdateProvider {
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster LocalizationConfiguration {
    persist  attribute activeLocale default = "en-US";
    callback attribute supportedLocales;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TimeFormatLocalization {
    persist  attribute hourFormat;
    persist  attribute activeCalendarType;
    callback attribute supportedCalendarTypes;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UnitLocalization {
    persist  attribute temperatureUnit;
    ram      attribute featureMap default = 0x1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig;
    callback attribute locationCapability;
    callback attribute supportsConcurrentConnection default = 1;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    ram      attribute featureMap default = 4;
    ram      attribute clusterRevision default = 1;
  }

  server cluster DiagnosticLogs {
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralDiagnostics {
    callback attribute networkInterfaces;
    callback attribute rebootCount;
    callback attribute upTime;
    callback attribute totalOperationalHours;
    callback attribute bootReasons;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    callback attribute testEventTriggersEnabled;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster SoftwareDiagnostics {
    callback attribute threadMetrics;
    callback attribute currentHeapFree;
    callback attribute currentHeapUsed;
    callback attribute currentHeapHighWatermark;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ThreadNetworkDiagnostics {
    callback attribute channel;
    callback attribute routingRole;
    callback attribute networkName;
    callback attribute panId;
    callback attribute extendedPanId;
    callback attribute meshLocalPrefix;
    callback attribute overrunCount;
    callback attribute neighborTableList;
    callback attribute routeTableList;
    callback attribute partitionId;
    callback attribute weighting;
    callback attribute dataVersion;
    callback attribute stableDataVersion;
    callback attribute leaderRouterId;
    callback attribute detachedRoleCount;
    callback attribute childRoleCount;
    callback attribute routerRoleCount;
    callback attribute leaderRoleCount;
    callback attribute attachAttemptCount;
    callback attribute partitionIdChangeCount;
    callback attribute betterPartitionAttachAttemptCount;
    callback attribute parentChangeCount;
    callback attribute txTotalCount;
    callback attribute txUnicastCount;
    callback attribute txBroadcastCount;
    callback attribute txAckRequestedCount;
    callback attribute txAckedCount;
    callback attribute txNoAckRequestedCount;
    callback attribute txDataCount;
    callback attribute txDataPollCount;
    callback attribute txBeaconCount;
    callback attribute txBeaconRequestCount;
    callback attribute txOtherCount;
    callback attribute txRetryCount;
    callback attribute txDirectMaxRetryExpiryCount;
    callback attribute txIndirectMaxRetryExpiryCount;
    callback attribute txErrCcaCount;
    callback attribute txErrAbortCount;
    callback attribute txErrBusyChannelCount;
    callback attribute rxTotalCount;
    callback attribute rxUnicastCount;
    callback attribute rxBroadcastCount;
    callback attribute rxDataCount;
    callback attribute rxDataPollCount;
    callback attribute rxBeaconCount;
    callback attribute rxBeaconRequestCount;
    callback attribute rxOtherCount;
    callback attribute rxAddressFilteredCount;
    callback attribute rxDestAddrFilteredCount;
    callback attribute rxDuplicatedCount;
    callback attribute rxErrNoFrameCount;
    callback attribute rxErrUnknownNeighborCount;
    callback attribute rxErrInvalidSrcAddrCount;
    callback attribute rxErrSecCount;
    callback attribute rxErrFcsCount;
    callback attribute rxErrOtherCount;
    callback attribute activeTimestamp;
    callback attribute pendingTimestamp;
    callback attribute delay;
    callback attribute securityPolicy;
    callback attribute channelPage0Mask;
    callback attribute operationalDatasetComponents;
    callback attribute activeNetworkFaultsList;
    ram      attribute featureMap default = 0x000F;
    ram      attribute clusterRevision default = 1;
  }

  server cluster WiFiNetworkDiagnostics {
    callback attribute bssid;
    callback attribute securityType;
    callback attribute wiFiVersion;
    callback attribute channelNumber;
    callback attribute rssi;
    callback attribute beaconLostCount;
    callback attribute beaconRxCount;
    callback attribute packetMulticastRxCount;
    callback attribute packetMulticastTxCount;
    callback attribute packetUnicastRxCount;
    callback attribute packetUnicastTxCount;
    callback attribute currentMaxRate;
    callback attribute overrunCount;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;
  }

  server cluster EthernetNetworkDiagnostics {
    callback attribute PHYRate;
    callback attribute fullDuplex;
    callback attribute packetRxCount;
    callback attribute packetTxCount;
    callback attribute txErrCount;
    callback attribute collisionCount;
    callback attribute overrunCount;
    callback attribute carrierDetect;
    callback attribute timeSinceReset;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus;
    callback attribute adminFabricIndex default = 1;
    callback attribute adminVendorId;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster FixedLabel {
    callback attribute labelList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UserLabel {
    callback attribute labelList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster RelativeHumidityMeasurement {
    ram      attribute measuredValue;
    ram      attribute minMeasuredValue;
    ram      attribute maxMeasuredValue;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }
}
endpoint 1 {
  device type videoplayer = 35;

  server cluster OnOff {
    ram      attribute onOff;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 4;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    ram      attribute featureMap;
    callback attribute clusterRevision default = 1;
  }

  server cluster WakeOnLan {
    ram      attribute MACAddress;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster Channel {
    callback attribute channelList;
    callback attribute lineup;
    callback attribute currentChannel;
    ram      attribute featureMap default = 0x0003;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TargetNavigator {
    callback attribute targetList;
    ram      attribute currentTarget;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster MediaPlayback {
    ram      attribute currentState;
    ram      attribute startTime;
    ram      attribute duration;
    callback attribute sampledPosition;
    ram      attribute playbackSpeed;
    ram      attribute seekRangeEnd;
    ram      attribute seekRangeStart;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x003;
    ram      attribute clusterRevision default = 1;
  }

  server cluster MediaInput {
    callback attribute inputList;
    ram      attribute currentInput;
    ram      attribute featureMap default = 0x0001;
    ram      attribute clusterRevision default = 1;
  }

  server cluster LowPower {
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster KeypadInput {
    ram      attribute featureMap default = 0x0007;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ContentLauncher {
    callback attribute acceptHeader;
    ram      attribute supportedStreamingProtocols;
    ram      attribute featureMap default = 0x0003;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AudioOutput {
    callback attribute outputList;
    ram      attribute currentOutput;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x001;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ApplicationLauncher {
    callback attribute catalogList;
    callback attribute currentApp;
    ram      attribute featureMap default = 0x0001;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 2 {
  device type speaker = 34;

  server cluster OnOff {
    ram      attribute onOff;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 4;
  }

  server cluster LevelControl {
    persist  attribute currentLevel;
    ram      attribute remainingTime;
    ram      attribute minLevel;
    ram      attribute maxLevel default = 0xFF;
    ram      attribute currentFrequency;
    ram      attribute minFrequency;
    ram      attribute maxFrequency;
    ram      attribute options;
    ram      attribute onOffTransitionTime;
    ram      attribute onLevel default = 0xFE;
    ram      attribute onTransitionTime;
    ram      attribute offTransitionTime;
    ram      attribute defaultMoveRate;
    persist  attribute startUpCurrentLevel default = 255;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 5;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    ram      attribute featureMap;
    callback attribute clusterRevision default = 1;
  }
}
endpoint 3 {
  device type contentapplication = 36;

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    ram      attribute featureMap;
    callback attribute clusterRevision default = 1;
  }

  server cluster Channel {
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TargetNavigator {
    callback attribute targetList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster MediaPlayback {
    ram      attribute currentState;
    ram      attribute startTime default = 0xFF;
    ram      attribute duration;
    callback attribute sampledPosition;
    ram      attribute playbackSpeed;
    ram      attribute seekRangeEnd;
    ram      attribute seekRangeStart;
    ram      attribute featureMap default = 0x0003;
    ram      attribute clusterRevision default = 1;
  }

  server cluster KeypadInput {
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ContentLauncher {
    callback attribute acceptHeader;
    ram      attribute supportedStreamingProtocols;
    ram      attribute featureMap default = 0x0003;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ApplicationLauncher {
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ApplicationBasic {
    ram      attribute vendorName;
    ram      attribute vendorID;
    ram      attribute applicationName;
    ram      attribute productID;
    callback attribute application;
    ram      attribute status;
    ram      attribute applicationVersion;
    callback attribute allowedVendorList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AccountLogin {
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }
}


