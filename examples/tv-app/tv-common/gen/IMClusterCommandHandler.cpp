/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include "IMClusterCommandHandler.h"

#include <cinttypes>
#include <cstdint>

#include "af-structs.h"
#include "call-command-handler.h"
#include "callback.h"
#include "cluster-id.h"
#include "command-id.h"
#include "util.h"

#include <app/InteractionModelEngine.h>

namespace chip {
namespace app {

void DispatchSingleClusterCommand(chip::ClusterId aClusterId, chip::CommandId aCommandId, chip::EndpointId aEndPointId,
                                  chip::TLV::TLVReader & aReader, Command * apCommandObj)
{
    ChipLogDetail(DataManagement, "Received Cluster Command: Cluster=%" PRIx16 " Command=%" PRIx8 " Endpoint=%" PRIx8, aClusterId,
                  aCommandId, aEndPointId);
    switch (aClusterId)
    {
    case ZCL_BARRIER_CONTROL_CLUSTER_ID:
        clusters::BarrierControl::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_BASIC_CLUSTER_ID:
        clusters::Basic::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_COLOR_CONTROL_CLUSTER_ID:
        clusters::ColorControl::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_CONTENT_LAUNCH_CLUSTER_ID:
        clusters::ContentLaunch::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_DOOR_LOCK_CLUSTER_ID:
        clusters::DoorLock::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_GROUPS_CLUSTER_ID:
        clusters::Groups::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_IAS_ZONE_CLUSTER_ID:
        clusters::IasZone::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_IDENTIFY_CLUSTER_ID:
        clusters::Identify::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_LEVEL_CONTROL_CLUSTER_ID:
        clusters::LevelControl::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_MEDIA_PLAYBACK_CLUSTER_ID:
        clusters::MediaPlayback::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_ON_OFF_CLUSTER_ID:
        clusters::OnOff::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    case ZCL_SCENES_CLUSTER_ID:
        clusters::Scenes::DispatchServerCommand(apCommandObj, aCommandId, aEndPointId, aReader);
        return;
    default:
        // Unrecognized cluster ID, error status will apply.
        // TODO: Encode response for Cluster not found
        break;
    }
}

// Cluster specific command parsing

namespace clusters {

namespace BarrierControl {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_BARRIER_CONTROL_GO_TO_PERCENT_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t percentOpen;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(percentOpen);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnBarrierControlGoToPercentCommandCallback(command, endpointId, percentOpen);
            break;
        }
        case ZCL_BARRIER_CONTROL_STOP_COMMAND_ID: {
            OnBarrierControlStopCommandCallback(command, endpointId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace BarrierControl

namespace Basic {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_RESET_TO_FACTORY_DEFAULTS_COMMAND_ID: {
            OnResetToFactoryDefaultsCommandCallback(command, endpointId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace Basic

namespace ColorControl {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_MOVE_COLOR_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            int16_t rateX;
            int16_t rateY;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(rateX);
                    break;
                case 1:
                    TLVError = dataTlv.Get(rateY);
                    break;
                case 2:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveColorCommandCallback(command, endpointId, rateX, rateY, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_COLOR_TEMPERATURE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t moveMode;
            uint16_t rate;
            uint16_t colorTemperatureMinimum;
            uint16_t colorTemperatureMaximum;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(moveMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(rate);
                    break;
                case 2:
                    TLVError = dataTlv.Get(colorTemperatureMinimum);
                    break;
                case 3:
                    TLVError = dataTlv.Get(colorTemperatureMaximum);
                    break;
                case 4:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 5:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveColorTemperatureCommandCallback(command, endpointId, moveMode, rate, colorTemperatureMinimum,
                                                  colorTemperatureMaximum, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_HUE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t moveMode;
            uint8_t rate;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(moveMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(rate);
                    break;
                case 2:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveHueCommandCallback(command, endpointId, moveMode, rate, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_SATURATION_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t moveMode;
            uint8_t rate;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(moveMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(rate);
                    break;
                case 2:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveSaturationCommandCallback(command, endpointId, moveMode, rate, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_TO_COLOR_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t colorX;
            uint16_t colorY;
            uint16_t transitionTime;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(colorX);
                    break;
                case 1:
                    TLVError = dataTlv.Get(colorY);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 4:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveToColorCommandCallback(command, endpointId, colorX, colorY, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_TO_COLOR_TEMPERATURE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t colorTemperature;
            uint16_t transitionTime;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(colorTemperature);
                    break;
                case 1:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 2:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveToColorTemperatureCommandCallback(command, endpointId, colorTemperature, transitionTime, optionsMask,
                                                    optionsOverride);
            break;
        }
        case ZCL_MOVE_TO_HUE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t hue;
            uint8_t direction;
            uint16_t transitionTime;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(hue);
                    break;
                case 1:
                    TLVError = dataTlv.Get(direction);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 4:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveToHueCommandCallback(command, endpointId, hue, direction, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_MOVE_TO_HUE_AND_SATURATION_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t hue;
            uint8_t saturation;
            uint16_t transitionTime;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(hue);
                    break;
                case 1:
                    TLVError = dataTlv.Get(saturation);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 4:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveToHueAndSaturationCommandCallback(command, endpointId, hue, saturation, transitionTime, optionsMask,
                                                    optionsOverride);
            break;
        }
        case ZCL_MOVE_TO_SATURATION_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t saturation;
            uint16_t transitionTime;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(saturation);
                    break;
                case 1:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 2:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveToSaturationCommandCallback(command, endpointId, saturation, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_STEP_COLOR_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            int16_t stepX;
            int16_t stepY;
            uint16_t transitionTime;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(stepX);
                    break;
                case 1:
                    TLVError = dataTlv.Get(stepY);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 4:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStepColorCommandCallback(command, endpointId, stepX, stepY, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_STEP_COLOR_TEMPERATURE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t stepMode;
            uint16_t stepSize;
            uint16_t transitionTime;
            uint16_t colorTemperatureMinimum;
            uint16_t colorTemperatureMaximum;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(stepMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(stepSize);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(colorTemperatureMinimum);
                    break;
                case 4:
                    TLVError = dataTlv.Get(colorTemperatureMaximum);
                    break;
                case 5:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 6:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStepColorTemperatureCommandCallback(command, endpointId, stepMode, stepSize, transitionTime, colorTemperatureMinimum,
                                                  colorTemperatureMaximum, optionsMask, optionsOverride);
            break;
        }
        case ZCL_STEP_HUE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t stepMode;
            uint8_t stepSize;
            uint8_t transitionTime;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(stepMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(stepSize);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 4:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStepHueCommandCallback(command, endpointId, stepMode, stepSize, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_STEP_SATURATION_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t stepMode;
            uint8_t stepSize;
            uint8_t transitionTime;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(stepMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(stepSize);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 4:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStepSaturationCommandCallback(command, endpointId, stepMode, stepSize, transitionTime, optionsMask, optionsOverride);
            break;
        }
        case ZCL_STOP_MOVE_STEP_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t optionsMask;
            uint8_t optionsOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(optionsMask);
                    break;
                case 1:
                    TLVError = dataTlv.Get(optionsOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStopMoveStepCommandCallback(command, endpointId, optionsMask, optionsOverride);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace ColorControl

namespace ContentLaunch {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_LAUNCH_CONTENT_COMMAND_ID: {
            OnLaunchContentCommandCallback(command, endpointId);
            break;
        }
        case ZCL_LAUNCH_URL_COMMAND_ID: {
            OnLaunchURLCommandCallback(command, endpointId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace ContentLaunch

namespace DoorLock {

void DispatchClientCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_LOCK_DOOR_RESPONSE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t status;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(status);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnLockDoorResponseCommandCallback(command, endpointId, status);
            break;
        }
        case ZCL_UNLOCK_DOOR_RESPONSE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t status;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(status);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnUnlockDoorResponseCommandCallback(command, endpointId, status);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace DoorLock

namespace DoorLock {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_CLEAR_ALL_PINS_COMMAND_ID: {
            OnClearAllPinsCommandCallback(command, endpointId);
            break;
        }
        case ZCL_CLEAR_ALL_RFIDS_COMMAND_ID: {
            OnClearAllRfidsCommandCallback(command, endpointId);
            break;
        }
        case ZCL_CLEAR_HOLIDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnClearHolidayScheduleCommandCallback(command, endpointId, scheduleId);
            break;
        }
        case ZCL_CLEAR_PIN_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnClearPinCommandCallback(command, endpointId, userId);
            break;
        }
        case ZCL_CLEAR_RFID_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnClearRfidCommandCallback(command, endpointId, userId);
            break;
        }
        case ZCL_CLEAR_WEEKDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnClearWeekdayScheduleCommandCallback(command, endpointId, scheduleId, userId);
            break;
        }
        case ZCL_CLEAR_YEARDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnClearYeardayScheduleCommandCallback(command, endpointId, scheduleId, userId);
            break;
        }
        case ZCL_GET_HOLIDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetHolidayScheduleCommandCallback(command, endpointId, scheduleId);
            break;
        }
        case ZCL_GET_LOG_RECORD_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t logIndex;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(logIndex);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetLogRecordCommandCallback(command, endpointId, logIndex);
            break;
        }
        case ZCL_GET_PIN_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetPinCommandCallback(command, endpointId, userId);
            break;
        }
        case ZCL_GET_RFID_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetRfidCommandCallback(command, endpointId, userId);
            break;
        }
        case ZCL_GET_USER_TYPE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetUserTypeCommandCallback(command, endpointId, userId);
            break;
        }
        case ZCL_GET_WEEKDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetWeekdayScheduleCommandCallback(command, endpointId, scheduleId, userId);
            break;
        }
        case ZCL_GET_YEARDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;
            uint16_t userId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetYeardayScheduleCommandCallback(command, endpointId, scheduleId, userId);
            break;
        }
        case ZCL_LOCK_DOOR_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            const uint8_t * PIN;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.GetDataPtr(PIN);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnLockDoorCommandCallback(command, endpointId, PIN);
            break;
        }
        case ZCL_SET_HOLIDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;
            uint32_t localStartTime;
            uint32_t localEndTime;
            uint8_t operatingModeDuringHoliday;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(localStartTime);
                    break;
                case 2:
                    TLVError = dataTlv.Get(localEndTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(operatingModeDuringHoliday);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnSetHolidayScheduleCommandCallback(command, endpointId, scheduleId, localStartTime, localEndTime,
                                                operatingModeDuringHoliday);
            break;
        }
        case ZCL_SET_PIN_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t userId;
            uint8_t userStatus;
            uint8_t userType;
            const uint8_t * pin;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(userId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userStatus);
                    break;
                case 2:
                    TLVError = dataTlv.Get(userType);
                    break;
                case 3:
                    TLVError = dataTlv.GetDataPtr(pin);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnSetPinCommandCallback(command, endpointId, userId, userStatus, userType, pin);
            break;
        }
        case ZCL_SET_RFID_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t userId;
            uint8_t userStatus;
            uint8_t userType;
            const uint8_t * id;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(userId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userStatus);
                    break;
                case 2:
                    TLVError = dataTlv.Get(userType);
                    break;
                case 3:
                    TLVError = dataTlv.GetDataPtr(id);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnSetRfidCommandCallback(command, endpointId, userId, userStatus, userType, id);
            break;
        }
        case ZCL_SET_USER_TYPE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t userId;
            uint8_t userType;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(userId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userType);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnSetUserTypeCommandCallback(command, endpointId, userId, userType);
            break;
        }
        case ZCL_SET_WEEKDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;
            uint16_t userId;
            uint8_t daysMask;
            uint8_t startHour;
            uint8_t startMinute;
            uint8_t endHour;
            uint8_t endMinute;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userId);
                    break;
                case 2:
                    TLVError = dataTlv.Get(daysMask);
                    break;
                case 3:
                    TLVError = dataTlv.Get(startHour);
                    break;
                case 4:
                    TLVError = dataTlv.Get(startMinute);
                    break;
                case 5:
                    TLVError = dataTlv.Get(endHour);
                    break;
                case 6:
                    TLVError = dataTlv.Get(endMinute);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnSetWeekdayScheduleCommandCallback(command, endpointId, scheduleId, userId, daysMask, startHour, startMinute, endHour,
                                                endMinute);
            break;
        }
        case ZCL_SET_YEARDAY_SCHEDULE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t scheduleId;
            uint16_t userId;
            uint32_t localStartTime;
            uint32_t localEndTime;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(scheduleId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(userId);
                    break;
                case 2:
                    TLVError = dataTlv.Get(localStartTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(localEndTime);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnSetYeardayScheduleCommandCallback(command, endpointId, scheduleId, userId, localStartTime, localEndTime);
            break;
        }
        case ZCL_UNLOCK_DOOR_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            const uint8_t * PIN;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.GetDataPtr(PIN);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnUnlockDoorCommandCallback(command, endpointId, PIN);
            break;
        }
        case ZCL_UNLOCK_WITH_TIMEOUT_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t timeoutInSeconds;
            const uint8_t * pin;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(timeoutInSeconds);
                    break;
                case 1:
                    TLVError = dataTlv.GetDataPtr(pin);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnUnlockWithTimeoutCommandCallback(command, endpointId, timeoutInSeconds, pin);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace DoorLock

namespace Groups {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_ADD_GROUP_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;
            const uint8_t * groupName;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                case 1:
                    TLVError = dataTlv.GetDataPtr(groupName);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnAddGroupCommandCallback(command, endpointId, groupId, groupName);
            break;
        }
        case ZCL_ADD_GROUP_IF_IDENTIFYING_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;
            const uint8_t * groupName;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                case 1:
                    TLVError = dataTlv.GetDataPtr(groupName);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnAddGroupIfIdentifyingCommandCallback(command, endpointId, groupId, groupName);
            break;
        }
        case ZCL_GET_GROUP_MEMBERSHIP_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t groupCount;
            /* TYPE WARNING: array array defaults to */ uint8_t * groupList;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupCount);
                    break;
                case 1:
                    // Just for compatibility, we will add array type support in IM later.
                    TLVError = dataTlv.GetDataPtr(const_cast<const uint8_t *&>(groupList));
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetGroupMembershipCommandCallback(command, endpointId, groupCount, groupList);
            break;
        }
        case ZCL_REMOVE_ALL_GROUPS_COMMAND_ID: {
            OnRemoveAllGroupsCommandCallback(command, endpointId);
            break;
        }
        case ZCL_REMOVE_GROUP_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnRemoveGroupCommandCallback(command, endpointId, groupId);
            break;
        }
        case ZCL_VIEW_GROUP_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnViewGroupCommandCallback(command, endpointId, groupId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace Groups

namespace IasZone {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_ZONE_ENROLL_RESPONSE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t enrollResponseCode;
            uint8_t zoneId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(enrollResponseCode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(zoneId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnZoneEnrollResponseCommandCallback(command, endpointId, enrollResponseCode, zoneId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace IasZone

namespace Identify {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_IDENTIFY_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t identifyTime;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(identifyTime);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnIdentifyCommandCallback(command, endpointId, identifyTime);
            break;
        }
        case ZCL_IDENTIFY_QUERY_COMMAND_ID: {
            OnIdentifyQueryCommandCallback(command, endpointId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace Identify

namespace LevelControl {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_MOVE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t moveMode;
            uint8_t rate;
            uint8_t optionMask;
            uint8_t optionOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(moveMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(rate);
                    break;
                case 2:
                    TLVError = dataTlv.Get(optionMask);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveCommandCallback(command, endpointId, moveMode, rate, optionMask, optionOverride);
            break;
        }
        case ZCL_MOVE_TO_LEVEL_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t level;
            uint16_t transitionTime;
            uint8_t optionMask;
            uint8_t optionOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(level);
                    break;
                case 1:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 2:
                    TLVError = dataTlv.Get(optionMask);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveToLevelCommandCallback(command, endpointId, level, transitionTime, optionMask, optionOverride);
            break;
        }
        case ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t level;
            uint16_t transitionTime;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(level);
                    break;
                case 1:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveToLevelWithOnOffCommandCallback(command, endpointId, level, transitionTime);
            break;
        }
        case ZCL_MOVE_WITH_ON_OFF_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t moveMode;
            uint8_t rate;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(moveMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(rate);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnMoveWithOnOffCommandCallback(command, endpointId, moveMode, rate);
            break;
        }
        case ZCL_STEP_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t stepMode;
            uint8_t stepSize;
            uint16_t transitionTime;
            uint8_t optionMask;
            uint8_t optionOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(stepMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(stepSize);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.Get(optionMask);
                    break;
                case 4:
                    TLVError = dataTlv.Get(optionOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStepCommandCallback(command, endpointId, stepMode, stepSize, transitionTime, optionMask, optionOverride);
            break;
        }
        case ZCL_STEP_WITH_ON_OFF_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t stepMode;
            uint8_t stepSize;
            uint16_t transitionTime;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(stepMode);
                    break;
                case 1:
                    TLVError = dataTlv.Get(stepSize);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStepWithOnOffCommandCallback(command, endpointId, stepMode, stepSize, transitionTime);
            break;
        }
        case ZCL_STOP_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint8_t optionMask;
            uint8_t optionOverride;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(optionMask);
                    break;
                case 1:
                    TLVError = dataTlv.Get(optionOverride);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStopCommandCallback(command, endpointId, optionMask, optionOverride);
            break;
        }
        case ZCL_STOP_WITH_ON_OFF_COMMAND_ID: {
            OnStopWithOnOffCommandCallback(command, endpointId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace LevelControl

namespace MediaPlayback {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_FAST_FORWARD_REQUEST_COMMAND_ID: {
            OnFastForwardRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_NEXT_REQUEST_COMMAND_ID: {
            OnNextRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_PAUSE_REQUEST_COMMAND_ID: {
            OnPauseRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_PLAY_REQUEST_COMMAND_ID: {
            OnPlayRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_PREVIOUS_REQUEST_COMMAND_ID: {
            OnPreviousRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_REWIND_REQUEST_COMMAND_ID: {
            OnRewindRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_SKIP_BACKWARD_REQUEST_COMMAND_ID: {
            OnSkipBackwardRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_SKIP_FORWARD_REQUEST_COMMAND_ID: {
            OnSkipForwardRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_START_OVER_REQUEST_COMMAND_ID: {
            OnStartOverRequestCommandCallback(command, endpointId);
            break;
        }
        case ZCL_STOP_REQUEST_COMMAND_ID: {
            OnStopRequestCommandCallback(command, endpointId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace MediaPlayback

namespace OnOff {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_OFF_COMMAND_ID: {
            OnOffCommandCallback(command, endpointId);
            break;
        }
        case ZCL_ON_COMMAND_ID: {
            OnOnCommandCallback(command, endpointId);
            break;
        }
        case ZCL_TOGGLE_COMMAND_ID: {
            OnToggleCommandCallback(command, endpointId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace OnOff

namespace Scenes {

void DispatchServerCommand(app::Command * command, CommandId commandId, EndpointId endpointId, TLV::TLVReader & dataTlv)
{
    {
        switch (commandId)
        {
        case ZCL_ADD_SCENE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;
            uint8_t sceneId;
            uint16_t transitionTime;
            const uint8_t * sceneName;
            /* TYPE WARNING: array array defaults to */ uint8_t * extensionFieldSets;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(sceneId);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                case 3:
                    TLVError = dataTlv.GetDataPtr(sceneName);
                    break;
                case 4:
                    // Just for compatibility, we will add array type support in IM later.
                    TLVError = dataTlv.GetDataPtr(const_cast<const uint8_t *&>(extensionFieldSets));
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnAddSceneCommandCallback(command, endpointId, groupId, sceneId, transitionTime, sceneName, extensionFieldSets);
            break;
        }
        case ZCL_GET_SCENE_MEMBERSHIP_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnGetSceneMembershipCommandCallback(command, endpointId, groupId);
            break;
        }
        case ZCL_RECALL_SCENE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;
            uint8_t sceneId;
            uint16_t transitionTime;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(sceneId);
                    break;
                case 2:
                    TLVError = dataTlv.Get(transitionTime);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnRecallSceneCommandCallback(command, endpointId, groupId, sceneId, transitionTime);
            break;
        }
        case ZCL_REMOVE_ALL_SCENES_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnRemoveAllScenesCommandCallback(command, endpointId, groupId);
            break;
        }
        case ZCL_REMOVE_SCENE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;
            uint8_t sceneId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(sceneId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnRemoveSceneCommandCallback(command, endpointId, groupId, sceneId);
            break;
        }
        case ZCL_STORE_SCENE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;
            uint8_t sceneId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(sceneId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnStoreSceneCommandCallback(command, endpointId, groupId, sceneId);
            break;
        }
        case ZCL_VIEW_SCENE_COMMAND_ID: {
            CHIP_ERROR TLVError = CHIP_NO_ERROR;
            uint16_t groupId;
            uint8_t sceneId;

            while ((TLVError = dataTlv.Next()) == CHIP_NO_ERROR)
            {
                switch (TLV::TagNumFromTag(dataTlv.GetTag()))
                {
                case 0:
                    TLVError = dataTlv.Get(groupId);
                    break;
                case 1:
                    TLVError = dataTlv.Get(sceneId);
                    break;
                default:
                    // Unsupported tag, ignore it.
                    // TODO: Can be a log for INFO level
                    continue;
                }
                if (TLVError != CHIP_NO_ERROR)
                {
                    // TODO: Report Error Here
                }
            }
            OnViewSceneCommandCallback(command, endpointId, groupId, sceneId);
            break;
        }
        default: {
            // Unrecognized command ID, error status will apply.
            // TODO: Encode response for command not found
            break;
        }
        }
    }
}

} // namespace Scenes

} // namespace clusters
} // namespace app
} // namespace chip
