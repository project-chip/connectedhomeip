/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <app/util/af.h>
#include <app/util/basic-types.h>
#include <support/SafeInt.h>
#include <support/logging/CHIPLogging.h>

#include "gen/af-structs.h"

using namespace chip;

// The first 2 bytes specify the number of entries. A value of 0xFFFF means the list in invalid
// and data is undefined.
constexpr uint16_t kSizeLengthInBytes = 2u;

void copyListMember(uint8_t * dest, uint8_t * src, bool write, uint16_t * offset, uint16_t length)
{
    if (write)
    {
        memmove(dest + *offset, src, length);
    }
    else
    {
        memmove(dest, src + *offset, length);
    }

    *offset = static_cast<uint16_t>(*offset + length);
}

uint16_t emberAfCopyList(ClusterId clusterId, EmberAfAttributeMetadata * am, bool write, uint8_t * dest, uint8_t * src,
                         int32_t index)
{
    if (index == -1)
    {
        memmove(dest, src, am->size);
        return am->size;
    }

    if (index == 0)
    {
        if (write)
        {
            // src is a pointer to native-endian uint16_t, dest is pointer to buffer that should hold little-endian value
            emberAfCopyInt16u(dest, 0, *reinterpret_cast<uint16_t *>(src));
        }
        else
        {
            // src is pointer to buffer holding little-endian value, dest is a pointer to native-endian uint16_t
            *reinterpret_cast<uint16_t *>(dest) = emberAfGetInt16u(src, 0, kSizeLengthInBytes);
        }
        return kSizeLengthInBytes;
    }

    if (!chip::CanCastTo<uint16_t>(index))
    {
        ChipLogError(Zcl, "Index %l is invalid. Should be between 1 and 65534", index);
        return 0;
    }

    uint16_t entryLength = 0;
    switch (clusterId)
    {
    case 0x050C: // Application Launcher Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (am->attributeId)
        {
        case 0x0000: // application launcher list
        {
            entryLength = 2;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %l is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // INT16U
            break;
        }
        }
        break;
    }
    case 0x050B: // Audio Output Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (am->attributeId)
        {
        case 0x0000: // audio output list
        {
            entryLength = 34;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %l is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _AudioOutputInfo
            _AudioOutputInfo * entry = reinterpret_cast<_AudioOutputInfo *>(write ? src : dest);
            copyListMember(write ? dest : (uint8_t *) &entry->index, write ? (uint8_t *) &entry->index : src, write, &entryOffset,
                           sizeof(entry->index)); // INT8U
            copyListMember(write ? dest : (uint8_t *) &entry->outputType, write ? (uint8_t *) &entry->outputType : src, write,
                           &entryOffset, sizeof(entry->outputType)); // AudioOutputType
            copyListMember(write ? dest : (uint8_t *) &entry->name, write ? (uint8_t *) &entry->name : src, write, &entryOffset,
                           32); // OCTET_STRING
            break;
        }
        }
        break;
    }
    case 0x050A: // Content Launch Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (am->attributeId)
        {
        case 0x0000: // accepts header list
        {
            entryLength = 254;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %l is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // OCTET_STRING
            break;
        }
        case 0x0001: // supported streaming types
        {
            entryLength = 1;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %l is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // ContentLaunchStreamingType
            break;
        }
        }
        break;
    }
    case 0x0507: // Media Input Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (am->attributeId)
        {
        case 0x0000: // media input list
        {
            entryLength = 66;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %l is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _MediaInputInfo
            _MediaInputInfo * entry = reinterpret_cast<_MediaInputInfo *>(write ? src : dest);
            copyListMember(write ? dest : (uint8_t *) &entry->index, write ? (uint8_t *) &entry->index : src, write, &entryOffset,
                           sizeof(entry->index)); // INT8U
            copyListMember(write ? dest : (uint8_t *) &entry->inputType, write ? (uint8_t *) &entry->inputType : src, write,
                           &entryOffset, sizeof(entry->inputType)); // MediaInputType
            copyListMember(write ? dest : (uint8_t *) &entry->name, write ? (uint8_t *) &entry->name : src, write, &entryOffset,
                           32); // OCTET_STRING
            copyListMember(write ? dest : (uint8_t *) &entry->description, write ? (uint8_t *) &entry->description : src, write,
                           &entryOffset, 32); // OCTET_STRING
            break;
        }
        }
        break;
    }
    case 0x0504: // TV Channel Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (am->attributeId)
        {
        case 0x0000: // tv channel list
        {
            entryLength = 100;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %l is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _TvChannelInfo
            _TvChannelInfo * entry = reinterpret_cast<_TvChannelInfo *>(write ? src : dest);
            copyListMember(write ? dest : (uint8_t *) &entry->majorNumber, write ? (uint8_t *) &entry->majorNumber : src, write,
                           &entryOffset, sizeof(entry->majorNumber)); // INT16U
            copyListMember(write ? dest : (uint8_t *) &entry->minorNumber, write ? (uint8_t *) &entry->minorNumber : src, write,
                           &entryOffset, sizeof(entry->minorNumber)); // INT16U
            copyListMember(write ? dest : (uint8_t *) &entry->name, write ? (uint8_t *) &entry->name : src, write, &entryOffset,
                           32); // OCTET_STRING
            copyListMember(write ? dest : (uint8_t *) &entry->callSign, write ? (uint8_t *) &entry->callSign : src, write,
                           &entryOffset, 32); // OCTET_STRING
            copyListMember(write ? dest : (uint8_t *) &entry->affiliateCallSign,
                           write ? (uint8_t *) &entry->affiliateCallSign : src, write, &entryOffset, 32); // OCTET_STRING
            break;
        }
        }
        break;
    }
    case 0x0505: // Target Navigator Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (am->attributeId)
        {
        case 0x0000: // target navigator list
        {
            entryLength = 33;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %l is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _NavigateTargetTargetInfo
            _NavigateTargetTargetInfo * entry = reinterpret_cast<_NavigateTargetTargetInfo *>(write ? src : dest);
            copyListMember(write ? dest : (uint8_t *) &entry->identifier, write ? (uint8_t *) &entry->identifier : src, write,
                           &entryOffset, sizeof(entry->identifier)); // INT8U
            copyListMember(write ? dest : (uint8_t *) &entry->name, write ? (uint8_t *) &entry->name : src, write, &entryOffset,
                           32); // OCTET_STRING
            break;
        }
        }
        break;
    }
    }

    return entryLength;
}

// A list is a collection of entries of the same data type. The data type may be any defined data type.
uint16_t emberAfAttributeValueListSize(ClusterId clusterId, AttributeId attributeId, const uint8_t * buffer)
{
    // The first 2 bytes specify the number of entries. A value of 0xFFFF means the list in invalid
    // and data is undefined.
    uint16_t entryCount = emberAfGetInt16u(buffer, 0, kSizeLengthInBytes);
    if (entryCount == 0xFFFF)
    {
        return 0;
    }

    uint16_t entryLength = 0;
    switch (clusterId)
    {
    case 0x050C: // Application Launcher Cluster
        switch (attributeId)
        {
        case 0x0000: // application launcher list
            // uint16_t
            entryLength = 2;
            break;
        }
        break;
    case 0x050B: // Audio Output Cluster
        switch (attributeId)
        {
        case 0x0000: // audio output list
            // Struct _AudioOutputInfo
            entryLength = 34;
            break;
        }
        break;
    case 0x050A: // Content Launch Cluster
        switch (attributeId)
        {
        case 0x0000: // accepts header list
            // chip::ByteSpan
            entryLength = 254;
            break;
        case 0x0001: // supported streaming types
            // uint8_t
            entryLength = 1;
            break;
        }
        break;
    case 0x0507: // Media Input Cluster
        switch (attributeId)
        {
        case 0x0000: // media input list
            // Struct _MediaInputInfo
            entryLength = 66;
            break;
        }
        break;
    case 0x0504: // TV Channel Cluster
        switch (attributeId)
        {
        case 0x0000: // tv channel list
            // Struct _TvChannelInfo
            entryLength = 100;
            break;
        }
        break;
    case 0x0505: // Target Navigator Cluster
        switch (attributeId)
        {
        case 0x0000: // target navigator list
            // Struct _NavigateTargetTargetInfo
            entryLength = 33;
            break;
        }
        break;
    }

    uint32_t totalSize = kSizeLengthInBytes + (entryCount * entryLength);
    if (!chip::CanCastTo<uint16_t>(totalSize))
    {
        ChipLogError(Zcl, "Cluster 0x%04x: Size of attribute 0x%02x is too large.", clusterId, attributeId);
        return 0;
    }

    return static_cast<uint16_t>(totalSize);
}
