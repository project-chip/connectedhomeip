/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <app/common/gen/af-structs.h>
#include <app/util/af.h>
#include <app/util/attribute-list-byte-span.h>
#include <app/util/basic-types.h>
#include <app/util/ember-compatibility-functions.h>
#include <core/CHIPTLV.h>
#include <support/SafeInt.h>
#include <support/logging/CHIPLogging.h>

using namespace chip;
using namespace chip::app;
using namespace chip::app::List;

// The first 2 bytes specify the number of entries. A value of 0xFFFF means the list in invalid
// and data is undefined.
constexpr uint16_t kSizeLengthInBytes = 2u;

void copyListMember(uint8_t * dest, uint8_t * src, bool write, uint16_t * offset, uint16_t length)
{
    if (write)
    {
        memmove(dest + *offset, src, length);
    }
    else
    {
        memmove(dest, src + *offset, length);
    }

    *offset = static_cast<uint16_t>(*offset + length);
}

CHIP_ERROR CopyStructAttributeToCHIPTLV(ClusterId clusterId, AttributeId attributeId, uint8_t * src, uint16_t len,
                                        TLV::TLVWriter & writer, uint64_t tag)
{
    switch (clusterId)
    {
    }
    return CHIP_ERROR_INVALID_ARGUMENT;
}

CHIP_ERROR EmberListToCHIPTLV(ClusterId clusterId, AttributeId attributeId, uint8_t * src, uint16_t len, TLV::TLVWriter & writer,
                              uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    size_t count         = *reinterpret_cast<uint16_t *>(src);
    uint16_t entryLength = 0;
    // Suppress error of unused variable.
    (void) entryLength;
    (void) count;
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Array, tmpType));
    switch (clusterId)
    {
    case 0x050C: // Application Launcher Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // application launcher list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 2;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                uint16_t entry;
                copyListMember(reinterpret_cast<uint8_t *>(&entry), src, false, &entryOffset, entryLength); // INT16U
                writer.Put(TLV::AnonymousTag, entry);
            }
            break;
        }
        }
        break;
    }
    case 0x050B: // Audio Output Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // audio output list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 36;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _AudioOutputInfo
                _AudioOutputInfo entry;
                SuccessOrExit(err = _AudioOutputInfo::FromEmberBuffer(&entry, src + entryOffset, 36));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        }
        break;
    }
    case 0x050A: // Content Launcher Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // accepts header list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryOffset = GetByteSpanOffsetFromIndex(src, len, static_cast<uint16_t>(index));
                if (entryOffset == 0)
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }

                chip::ByteSpan acceptsHeaderListSpan; // OCTET_STRING
                uint16_t acceptsHeaderListRemainingSpace = static_cast<uint16_t>(len - entryOffset);
                if (CHIP_NO_ERROR != ReadByteSpan(src + entryOffset, acceptsHeaderListRemainingSpace, &acceptsHeaderListSpan))
                {
                    ChipLogError(Zcl, "Index %zu is invalid. Not enough remaining space", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                writer.Put(TLV::AnonymousTag, acceptsHeaderListSpan);
            }
            break;
        }
        case 0x0001: // supported streaming types
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 1;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                uint8_t entry;
                copyListMember(reinterpret_cast<uint8_t *>(&entry), src, false, &entryOffset,
                               entryLength); // ContentLaunchStreamingType
                writer.Put(TLV::AnonymousTag, entry);
            }
            break;
        }
        }
        break;
    }
    case 0x001D: // Descriptor Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // device list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 6;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _DeviceType
                _DeviceType entry;
                SuccessOrExit(err = _DeviceType::FromEmberBuffer(&entry, src + entryOffset, 6));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        case 0x0001: // server list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 4;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                chip::ClusterId entry;
                copyListMember(reinterpret_cast<uint8_t *>(&entry), src, false, &entryOffset, entryLength); // CLUSTER_ID
                writer.Put(TLV::AnonymousTag, entry);
            }
            break;
        }
        case 0x0002: // client list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 4;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                chip::ClusterId entry;
                copyListMember(reinterpret_cast<uint8_t *>(&entry), src, false, &entryOffset, entryLength); // CLUSTER_ID
                writer.Put(TLV::AnonymousTag, entry);
            }
            break;
        }
        case 0x0003: // parts list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 2;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                chip::EndpointId entry;
                copyListMember(reinterpret_cast<uint8_t *>(&entry), src, false, &entryOffset, entryLength); // ENDPOINT_NO
                writer.Put(TLV::AnonymousTag, entry);
            }
            break;
        }
        }
        break;
    }
    case 0x0033: // General Diagnostics Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // NetworkInterfaces
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 48;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _NetworkInterfaceType
                _NetworkInterfaceType entry;
                SuccessOrExit(err = _NetworkInterfaceType::FromEmberBuffer(&entry, src + entryOffset, 48));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        }
        break;
    }
    case 0xF004: // Group Key Management Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // groups
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 6;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _GroupState
                _GroupState entry;
                SuccessOrExit(err = _GroupState::FromEmberBuffer(&entry, src + entryOffset, 6));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        case 0x0001: // group keys
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 31;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _GroupKey
                _GroupKey entry;
                SuccessOrExit(err = _GroupKey::FromEmberBuffer(&entry, src + entryOffset, 31));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        }
        break;
    }
    case 0x0507: // Media Input Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // media input list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 70;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _MediaInputInfo
                _MediaInputInfo entry;
                SuccessOrExit(err = _MediaInputInfo::FromEmberBuffer(&entry, src + entryOffset, 70));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        }
        break;
    }
    case 0x003E: // Operational Credentials Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0001: // fabrics list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 52;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _FabricDescriptor
                _FabricDescriptor entry;
                SuccessOrExit(err = _FabricDescriptor::FromEmberBuffer(&entry, src + entryOffset, 52));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        }
        break;
    }
    case 0x0504: // TV Channel Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // tv channel list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 106;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _TvChannelInfo
                _TvChannelInfo entry;
                SuccessOrExit(err = _TvChannelInfo::FromEmberBuffer(&entry, src + entryOffset, 106));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        }
        break;
    }
    case 0x0505: // Target Navigator Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0000: // target navigator list
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 35;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _NavigateTargetTargetInfo
                _NavigateTargetTargetInfo entry;
                SuccessOrExit(err = _NavigateTargetTargetInfo::FromEmberBuffer(&entry, src + entryOffset, 35));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        }
        break;
    }
    case 0x0035: // Thread Network Diagnostics Cluster
    {
        uint16_t entryOffset = kSizeLengthInBytes;
        switch (attributeId)
        {
        case 0x0007: // NeighborTableList
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 31;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _NeighborTable
                _NeighborTable entry;
                SuccessOrExit(err = _NeighborTable::FromEmberBuffer(&entry, src + entryOffset, 31));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        case 0x0008: // RouteTableList
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 18;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _RouteTable
                _RouteTable entry;
                SuccessOrExit(err = _RouteTable::FromEmberBuffer(&entry, src + entryOffset, 18));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        case 0x003B: // SecurityPolicy
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 3;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _SecurityPolicy
                _SecurityPolicy entry;
                SuccessOrExit(err = _SecurityPolicy::FromEmberBuffer(&entry, src + entryOffset, 3));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        case 0x003D: // OperationalDatasetComponents
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 12;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                // Struct _OperationalDatasetComponents
                _OperationalDatasetComponents entry;
                SuccessOrExit(err = _OperationalDatasetComponents::FromEmberBuffer(&entry, src + entryOffset, 12));
                SuccessOrExit(err = writer.Put(TLV::AnonymousTag, entry));
            }
            break;
        }
        case 0x003E: // ActiveNetworkFaultsList
        {
            for (size_t index = 0; index < count; index++)
            {
                entryLength = 1;
                if ((index * entryLength) > static_cast<size_t>(len - entryLength))
                {
                    ChipLogError(Zcl, "Index %zu is invalid.", index);
                    ExitNow(err = CHIP_ERROR_INVALID_ARGUMENT);
                }
                entryOffset = static_cast<uint16_t>(kSizeLengthInBytes + (index * entryLength));
                uint8_t entry;
                copyListMember(reinterpret_cast<uint8_t *>(&entry), src, false, &entryOffset, entryLength); // NetworkFault
                writer.Put(TLV::AnonymousTag, entry);
            }
            break;
        }
        }
        break;
    }
    }
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

uint16_t emberAfCopyList(ClusterId clusterId, EmberAfAttributeMetadata * am, bool write, uint8_t * dest, uint8_t * src,
                         int32_t index)
{
    if (index == -1)
    {
        memmove(dest, src, am->size);
        return am->size;
    }

    if (index == 0)
    {
        if (write)
        {
            // src is a pointer to native-endian uint16_t, dest is pointer to buffer that should hold little-endian value
            emberAfCopyInt16u(dest, 0, *reinterpret_cast<uint16_t *>(src));
        }
        else
        {
            // src is pointer to buffer holding little-endian value, dest is a pointer to native-endian uint16_t
            *reinterpret_cast<uint16_t *>(dest) = emberAfGetInt16u(src, 0, kSizeLengthInBytes);
        }
        return kSizeLengthInBytes;
    }

    if (!chip::CanCastTo<uint16_t>(index))
    {
        ChipLogError(Zcl, "Index %" PRId32 " is invalid. Should be between 1 and 65534", index);
        return 0;
    }

    uint16_t entryLength = 0;
    switch (clusterId)
    {
    case 0x050C: // Application Launcher Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // application launcher list
        {
            entryLength = 2;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // INT16U
            break;
        }
        }
        break;
    }
    case 0x050B: // Audio Output Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // audio output list
        {
            entryLength = 36;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _AudioOutputInfo
            _AudioOutputInfo * entry = reinterpret_cast<_AudioOutputInfo *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _AudioOutputInfo::ToEmberBuffer(entry, dest + entryOffset, 36, unusedLen);
            }
            else
            {
                _AudioOutputInfo::FromEmberBuffer(entry, src + entryOffset, 36);
            }
            break;
        }
        }
        break;
    }
    case 0x050A: // Content Launcher Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // accepts header list
        {
            entryOffset = GetByteSpanOffsetFromIndex(write ? dest : src, am->size, static_cast<uint16_t>(index - 1));
            if (entryOffset == 0)
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }

            chip::ByteSpan * acceptsHeaderListSpan   = reinterpret_cast<chip::ByteSpan *>(write ? src : dest); // OCTET_STRING
            uint16_t acceptsHeaderListRemainingSpace = static_cast<uint16_t>(am->size - entryOffset);
            if (CHIP_NO_ERROR !=
                (write ? WriteByteSpan(dest + entryOffset, acceptsHeaderListRemainingSpace, acceptsHeaderListSpan)
                       : ReadByteSpan(src + entryOffset, acceptsHeaderListRemainingSpace, acceptsHeaderListSpan)))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid. Not enough remaining space", index);
                return 0;
            }

            if (!CanCastTo<uint16_t>(acceptsHeaderListSpan->size()))
            {
                ChipLogError(Zcl, "Span size %zu is too large", acceptsHeaderListSpan->size());
                return 0;
            }
            entryLength = static_cast<uint16_t>(acceptsHeaderListSpan->size());
            break;
        }
        case 0x0001: // supported streaming types
        {
            entryLength = 1;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // ContentLaunchStreamingType
            break;
        }
        }
        break;
    }
    case 0x001D: // Descriptor Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // device list
        {
            entryLength = 6;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _DeviceType
            _DeviceType * entry = reinterpret_cast<_DeviceType *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _DeviceType::ToEmberBuffer(entry, dest + entryOffset, 6, unusedLen);
            }
            else
            {
                _DeviceType::FromEmberBuffer(entry, src + entryOffset, 6);
            }
            break;
        }
        case 0x0001: // server list
        {
            entryLength = 4;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // CLUSTER_ID
            break;
        }
        case 0x0002: // client list
        {
            entryLength = 4;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // CLUSTER_ID
            break;
        }
        case 0x0003: // parts list
        {
            entryLength = 2;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // ENDPOINT_NO
            break;
        }
        }
        break;
    }
    case 0x0033: // General Diagnostics Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // NetworkInterfaces
        {
            entryLength = 48;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _NetworkInterfaceType
            _NetworkInterfaceType * entry = reinterpret_cast<_NetworkInterfaceType *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _NetworkInterfaceType::ToEmberBuffer(entry, dest + entryOffset, 48, unusedLen);
            }
            else
            {
                _NetworkInterfaceType::FromEmberBuffer(entry, src + entryOffset, 48);
            }
            break;
        }
        }
        break;
    }
    case 0xF004: // Group Key Management Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // groups
        {
            entryLength = 6;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _GroupState
            _GroupState * entry = reinterpret_cast<_GroupState *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _GroupState::ToEmberBuffer(entry, dest + entryOffset, 6, unusedLen);
            }
            else
            {
                _GroupState::FromEmberBuffer(entry, src + entryOffset, 6);
            }
            break;
        }
        case 0x0001: // group keys
        {
            entryLength = 31;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _GroupKey
            _GroupKey * entry = reinterpret_cast<_GroupKey *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _GroupKey::ToEmberBuffer(entry, dest + entryOffset, 31, unusedLen);
            }
            else
            {
                _GroupKey::FromEmberBuffer(entry, src + entryOffset, 31);
            }
            break;
        }
        }
        break;
    }
    case 0x0507: // Media Input Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // media input list
        {
            entryLength = 70;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _MediaInputInfo
            _MediaInputInfo * entry = reinterpret_cast<_MediaInputInfo *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _MediaInputInfo::ToEmberBuffer(entry, dest + entryOffset, 70, unusedLen);
            }
            else
            {
                _MediaInputInfo::FromEmberBuffer(entry, src + entryOffset, 70);
            }
            break;
        }
        }
        break;
    }
    case 0x003E: // Operational Credentials Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0001: // fabrics list
        {
            entryLength = 52;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _FabricDescriptor
            _FabricDescriptor * entry = reinterpret_cast<_FabricDescriptor *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _FabricDescriptor::ToEmberBuffer(entry, dest + entryOffset, 52, unusedLen);
            }
            else
            {
                _FabricDescriptor::FromEmberBuffer(entry, src + entryOffset, 52);
            }
            break;
        }
        }
        break;
    }
    case 0x0504: // TV Channel Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // tv channel list
        {
            entryLength = 106;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _TvChannelInfo
            _TvChannelInfo * entry = reinterpret_cast<_TvChannelInfo *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _TvChannelInfo::ToEmberBuffer(entry, dest + entryOffset, 106, unusedLen);
            }
            else
            {
                _TvChannelInfo::FromEmberBuffer(entry, src + entryOffset, 106);
            }
            break;
        }
        }
        break;
    }
    case 0x0505: // Target Navigator Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0000: // target navigator list
        {
            entryLength = 35;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _NavigateTargetTargetInfo
            _NavigateTargetTargetInfo * entry = reinterpret_cast<_NavigateTargetTargetInfo *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _NavigateTargetTargetInfo::ToEmberBuffer(entry, dest + entryOffset, 35, unusedLen);
            }
            else
            {
                _NavigateTargetTargetInfo::FromEmberBuffer(entry, src + entryOffset, 35);
            }
            break;
        }
        }
        break;
    }
    case 0x0035: // Thread Network Diagnostics Cluster
    {
        uint16_t entryOffset    = kSizeLengthInBytes;
        AttributeId attributeId = am->attributeId;
        switch (attributeId)
        {
        case 0x0007: // NeighborTableList
        {
            entryLength = 31;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _NeighborTable
            _NeighborTable * entry = reinterpret_cast<_NeighborTable *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _NeighborTable::ToEmberBuffer(entry, dest + entryOffset, 31, unusedLen);
            }
            else
            {
                _NeighborTable::FromEmberBuffer(entry, src + entryOffset, 31);
            }
            break;
        }
        case 0x0008: // RouteTableList
        {
            entryLength = 18;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _RouteTable
            _RouteTable * entry = reinterpret_cast<_RouteTable *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _RouteTable::ToEmberBuffer(entry, dest + entryOffset, 18, unusedLen);
            }
            else
            {
                _RouteTable::FromEmberBuffer(entry, src + entryOffset, 18);
            }
            break;
        }
        case 0x003B: // SecurityPolicy
        {
            entryLength = 3;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _SecurityPolicy
            _SecurityPolicy * entry = reinterpret_cast<_SecurityPolicy *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _SecurityPolicy::ToEmberBuffer(entry, dest + entryOffset, 3, unusedLen);
            }
            else
            {
                _SecurityPolicy::FromEmberBuffer(entry, src + entryOffset, 3);
            }
            break;
        }
        case 0x003D: // OperationalDatasetComponents
        {
            entryLength = 12;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            // Struct _OperationalDatasetComponents
            _OperationalDatasetComponents * entry = reinterpret_cast<_OperationalDatasetComponents *>(write ? src : dest);
            if (write)
            {
                size_t unusedLen;
                _OperationalDatasetComponents::ToEmberBuffer(entry, dest + entryOffset, 12, unusedLen);
            }
            else
            {
                _OperationalDatasetComponents::FromEmberBuffer(entry, src + entryOffset, 12);
            }
            break;
        }
        case 0x003E: // ActiveNetworkFaultsList
        {
            entryLength = 1;
            if (((index - 1) * entryLength) > (am->size - entryLength))
            {
                ChipLogError(Zcl, "Index %" PRId32 " is invalid.", index);
                return 0;
            }
            entryOffset = static_cast<uint16_t>(entryOffset + ((index - 1) * entryLength));
            copyListMember(dest, src, write, &entryOffset, entryLength); // NetworkFault
            break;
        }
        }
        break;
    }
    }

    return entryLength;
}

// A list is a collection of entries of the same data type. The data type may be any defined data type.
uint16_t emberAfAttributeValueListSize(ClusterId clusterId, AttributeId attributeId, const uint8_t * buffer)
{
    // The first 2 bytes specify the number of entries. A value of 0xFFFF means the list in invalid
    // and data is undefined.
    uint16_t entryCount = emberAfGetInt16u(buffer, 0, kSizeLengthInBytes);
    if (entryCount == 0xFFFF)
    {
        return 0;
    }

    uint16_t entryLength = 0;
    switch (clusterId)
    {
    case 0x050C: // Application Launcher Cluster
        switch (attributeId)
        {
        case 0x0000: // application launcher list
            // uint16_t
            entryLength = 2;
            break;
        }
        break;
    case 0x050B: // Audio Output Cluster
        switch (attributeId)
        {
        case 0x0000: // audio output list
            // Struct _AudioOutputInfo
            entryLength = 36;
            break;
        }
        break;
    case 0x050A: // Content Launcher Cluster
        switch (attributeId)
        {
        case 0x0000: // accepts header list
            // chip::ByteSpan
            return GetByteSpanOffsetFromIndex(buffer, 256, entryCount);
            break;
        case 0x0001: // supported streaming types
            // uint8_t
            entryLength = 1;
            break;
        }
        break;
    case 0x001D: // Descriptor Cluster
        switch (attributeId)
        {
        case 0x0000: // device list
            // Struct _DeviceType
            entryLength = 6;
            break;
        case 0x0001: // server list
            // chip::ClusterId
            entryLength = 4;
            break;
        case 0x0002: // client list
            // chip::ClusterId
            entryLength = 4;
            break;
        case 0x0003: // parts list
            // chip::EndpointId
            entryLength = 2;
            break;
        }
        break;
    case 0x0033: // General Diagnostics Cluster
        switch (attributeId)
        {
        case 0x0000: // NetworkInterfaces
            // Struct _NetworkInterfaceType
            entryLength = 48;
            break;
        }
        break;
    case 0xF004: // Group Key Management Cluster
        switch (attributeId)
        {
        case 0x0000: // groups
            // Struct _GroupState
            entryLength = 6;
            break;
        case 0x0001: // group keys
            // Struct _GroupKey
            entryLength = 31;
            break;
        }
        break;
    case 0x0507: // Media Input Cluster
        switch (attributeId)
        {
        case 0x0000: // media input list
            // Struct _MediaInputInfo
            entryLength = 70;
            break;
        }
        break;
    case 0x003E: // Operational Credentials Cluster
        switch (attributeId)
        {
        case 0x0001: // fabrics list
            // Struct _FabricDescriptor
            entryLength = 52;
            break;
        }
        break;
    case 0x0504: // TV Channel Cluster
        switch (attributeId)
        {
        case 0x0000: // tv channel list
            // Struct _TvChannelInfo
            entryLength = 106;
            break;
        }
        break;
    case 0x0505: // Target Navigator Cluster
        switch (attributeId)
        {
        case 0x0000: // target navigator list
            // Struct _NavigateTargetTargetInfo
            entryLength = 35;
            break;
        }
        break;
    case 0x0035: // Thread Network Diagnostics Cluster
        switch (attributeId)
        {
        case 0x0007: // NeighborTableList
            // Struct _NeighborTable
            entryLength = 31;
            break;
        case 0x0008: // RouteTableList
            // Struct _RouteTable
            entryLength = 18;
            break;
        case 0x003B: // SecurityPolicy
            // Struct _SecurityPolicy
            entryLength = 3;
            break;
        case 0x003D: // OperationalDatasetComponents
            // Struct _OperationalDatasetComponents
            entryLength = 12;
            break;
        case 0x003E: // ActiveNetworkFaultsList
            // uint8_t
            entryLength = 1;
            break;
        }
        break;
    }

    uint32_t totalSize = kSizeLengthInBytes + (entryCount * entryLength);
    if (!chip::CanCastTo<uint16_t>(totalSize))
    {
        ChipLogError(Zcl, "Cluster " ChipLogFormatMEI ": Size of attribute " ChipLogFormatMEI " is too large.",
                     ChipLogValueMEI(clusterId), ChipLogValueMEI(attributeId));
        return 0;
    }

    return static_cast<uint16_t>(totalSize);
}
