/**
 *
 *    Copyright (c) 2020 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
// This file is generated by ZAP.  Please do not edit manually.
//
//

#pragma once

#include "../common/ModelCommand.h"
#include "../common/ModelCommandResponse.h"

#include <limits>

#include <app/util/basic-types.h>
#include <support/SafeInt.h>

#define CHECK_MESSAGE_LENGTH(value)                                                                                                \
    if (!chip::CanCastTo<uint16_t>(value))                                                                                         \
    {                                                                                                                              \
        ChipLogError(chipTool, "CHECK_MESSAGE_LENGTH expects a uint16_t value, got: %d", value);                                   \
        return false;                                                                                                              \
    }                                                                                                                              \
                                                                                                                                   \
    if (messageLen < value)                                                                                                        \
    {                                                                                                                              \
        ChipLogError(chipTool, "Unexpected response length: %d", messageLen);                                                      \
        return false;                                                                                                              \
    }                                                                                                                              \
                                                                                                                                   \
    messageLen = static_cast<uint16_t>(messageLen - static_cast<uint16_t>(value));

typedef enum
{
    EMBER_ZCL_STATUS_SUCCESS                      = 0x00,
    EMBER_ZCL_STATUS_FAILURE                      = 0x01,
    EMBER_ZCL_STATUS_REQUEST_DENIED               = 0x70,
    EMBER_ZCL_STATUS_MULTIPLE_REQUEST_NOT_ALLOWED = 0x71,
    EMBER_ZCL_STATUS_INDICATION_REDIRECTION_TO_AP = 0x72,
    EMBER_ZCL_STATUS_PREFERENCE_DENIED            = 0x73,
    EMBER_ZCL_STATUS_PREFERENCE_IGNORED           = 0x74,
    EMBER_ZCL_STATUS_NOT_AUTHORIZED               = 0x7E,
    EMBER_ZCL_STATUS_RESERVED_FIELD_NOT_ZERO      = 0x7F,
    EMBER_ZCL_STATUS_MALFORMED_COMMAND            = 0x80,
    EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND        = 0x81,
    EMBER_ZCL_STATUS_UNSUP_GENERAL_COMMAND        = 0x82,
    EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND  = 0x83,
    EMBER_ZCL_STATUS_UNSUP_MANUF_GENERAL_COMMAND  = 0x84,
    EMBER_ZCL_STATUS_INVALID_FIELD                = 0x85,
    EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE        = 0x86,
    EMBER_ZCL_STATUS_INVALID_VALUE                = 0x87,
    EMBER_ZCL_STATUS_READ_ONLY                    = 0x88,
    EMBER_ZCL_STATUS_INSUFFICIENT_SPACE           = 0x89,
    EMBER_ZCL_STATUS_DUPLICATE_EXISTS             = 0x8A,
    EMBER_ZCL_STATUS_NOT_FOUND                    = 0x8B,
    EMBER_ZCL_STATUS_UNREPORTABLE_ATTRIBUTE       = 0x8C,
    EMBER_ZCL_STATUS_INVALID_DATA_TYPE            = 0x8D,
    EMBER_ZCL_STATUS_INVALID_SELECTOR             = 0x8E,
    EMBER_ZCL_STATUS_WRITE_ONLY                   = 0x8F,
    EMBER_ZCL_STATUS_INCONSISTENT_STARTUP_STATE   = 0x90,
    EMBER_ZCL_STATUS_DEFINED_OUT_OF_BAND          = 0x91,
    EMBER_ZCL_STATUS_INCONSISTENT                 = 0x92,
    EMBER_ZCL_STATUS_ACTION_DENIED                = 0x93,
    EMBER_ZCL_STATUS_TIMEOUT                      = 0x94,
    EMBER_ZCL_STATUS_ABORT                        = 0x95,
    EMBER_ZCL_STATUS_INVALID_IMAGE                = 0x96,
    EMBER_ZCL_STATUS_WAIT_FOR_DATA                = 0x97,
    EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE           = 0x98,
    EMBER_ZCL_STATUS_REQUIRE_MORE_IMAGE           = 0x99,
    EMBER_ZCL_STATUS_HARDWARE_FAILURE             = 0xC0,
    EMBER_ZCL_STATUS_SOFTWARE_FAILURE             = 0xC1,
    EMBER_ZCL_STATUS_CALIBRATION_ERROR            = 0xC2,
    EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER          = 0xC3,
} EmberAfStatus;

bool CheckStatus(uint8_t status)
{
    bool success = false;

    switch (status)
    {
    case EMBER_ZCL_STATUS_SUCCESS:
        success = true;
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_SUCCESS (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_FAILURE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_FAILURE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_REQUEST_DENIED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_REQUEST_DENIED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_MULTIPLE_REQUEST_NOT_ALLOWED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_REQUEST_NOT_ALLOWED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INDICATION_REDIRECTION_TO_AP:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INDICATION_REDIRECTION_TO_AP (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_PREFERENCE_DENIED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_PREFERENCE_DENIED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_PREFERENCE_IGNORED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_PREFERENCE_IGNORED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_NOT_AUTHORIZED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_NOT_AUTHORIZED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_RESERVED_FIELD_NOT_ZERO:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_RESERVED_FIELD_NOT_ZERO (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_MALFORMED_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_MALFORMED_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUP_GENERAL_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUP_GENERAL_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUP_MANUF_GENERAL_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUP_MANUF_GENERAL_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_FIELD:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_FIELD (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_VALUE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_VALUE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_READ_ONLY:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_READ_ONLY (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INSUFFICIENT_SPACE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INSUFFICIENT_SPACE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_DUPLICATE_EXISTS:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_DUPLICATE_EXISTS (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_NOT_FOUND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_NOT_FOUND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNREPORTABLE_ATTRIBUTE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNREPORTABLE_ATTRIBUTE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_DATA_TYPE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_DATA_TYPE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_SELECTOR:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_SELECTOR (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_WRITE_ONLY:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_WRITE_ONLY (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INCONSISTENT_STARTUP_STATE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INCONSISTENT_STARTUP_STATE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_DEFINED_OUT_OF_BAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_DEFINED_OUT_Of_BAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INCONSISTENT:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INCONSISTENT (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_ACTION_DENIED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_ACTION_DENIED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_TIMEOUT:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_TIMEOUT (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_ABORT:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_ABORT (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_IMAGE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_IMAGE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_WAIT_FOR_DATA:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_WAIT_FOR_DATA (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_REQUIRE_MORE_IMAGE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_REQUIRE_MORE_IMAGE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_HARDWARE_FAILURE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_HARDWARE_FAILURE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_SOFTWARE_FAILURE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_SOFTWARE_FAILURE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_CALIBRATION_ERROR:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_CALIBRATION_ERROR (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER (0x%02x)", status);
        break;
    default:
        ChipLogError(chipTool, "Unknow status: 0x%02x", status);
        break;
    }

    return success;
}

bool ReadAttributeValue(uint8_t *& message, uint16_t & messageLen)
{
    CHECK_MESSAGE_LENGTH(1);
    uint8_t type = chip::Encoding::Read8(message);
    ChipLogProgress(chipTool, "  type: 0x%02x", type);

    // FIXME: Should we have a mapping of type ids to types, based on
    // table 2.6.2.2 in Rev 8 of the ZCL spec?
    switch (type)
    {
    case 0x00: // nodata / No data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x08: // data8 / 8-bit data
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x09: // data16 / 16-bit data
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0x0A: // data24 / 24-bit data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 3;
        break;
    case 0x0B: // data32 / 32-bit data
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0x0C: // data40 / 40-bit data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 5;
        break;
    case 0x0D: // data48 / 48-bit data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 6;
        break;
    case 0x0E: // data56 / 56-bit data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 7;
        break;
    case 0x0F: // data64 / 64-bit data
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: 0x%16x", chip::Encoding::LittleEndian::Read64(message));
        return true;
        break;
    case 0x10: // bool / Boolean
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x18: // map8 / 8-bit bitmap
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x19: // map16 / 16-bit bitmap
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0x1A: // map24 / 24-bit bitmap
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 3;
        break;
    case 0x1B: // map32 / 32-bit bitmap
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0x1C: // map40 / 40-bit bitmap
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 5;
        break;
    case 0x1D: // map48 / 48-bit bitmap
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 6;
        break;
    case 0x1E: // map56 / 56-bit bitmap
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 7;
        break;
    case 0x1F: // map64 / 64-bit bitmap
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: 0x%16x", chip::Encoding::LittleEndian::Read64(message));
        return true;
        break;
    case 0x20: // uint8 / Unsigned  8-bit integer
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x21: // uint16 / Unsigned 16-bit integer
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0x22: // uint24 / Unsigned 24-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 3;
        break;
    case 0x23: // uint32 / Unsigned 32-bit integer
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0x24: // uint40 / Unsigned 40-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 5;
        break;
    case 0x25: // uint48 / Unsigned 48-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 6;
        break;
    case 0x26: // uint56 / Unsigned 56-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 7;
        break;
    case 0x27: // uint64 / Unsigned 64-bit integer
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: 0x%16x", chip::Encoding::LittleEndian::Read64(message));
        return true;
        break;
    case 0x28: // int8 / Signed 8-bit integer
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: %d", chip::CastToSigned(chip::Encoding::Read8(message)));
        return true;
        break;
    case 0x29: // int16 / Signed 16-bit integer
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: %d", chip::CastToSigned(chip::Encoding::LittleEndian::Read16(message)));
        return true;
        break;
    case 0x2A: // int24 / Signed 24-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 3;
        break;
    case 0x2B: // int32 / Signed 32-bit integer
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: %d", chip::CastToSigned(chip::Encoding::LittleEndian::Read32(message)));
        return true;
        break;
    case 0x2C: // int40 / Signed 40-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 5;
        break;
    case 0x2D: // int48 / Signed 48-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 6;
        break;
    case 0x2E: // int56 / Signed 56-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 7;
        break;
    case 0x2F: // int64 / Signed 64-bit integer
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: %d", chip::CastToSigned(chip::Encoding::LittleEndian::Read64(message)));
        return true;
        break;
    case 0x30: // enum8 / 8-bit enumeration
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x31: // enum16 / 16-bit enumeration
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0x38: // semi / Semi-precision
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x39: // single / Single precision
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x3A: // double / Double precision
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x41: // octstr / Octet string
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x42: // string / Character string
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x43: // octstr16 / Long octet string
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 2;
        break;
    case 0x44: // string16 / Long character string
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 2;
        break;
    case 0x48: // array / Array
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x49: // struct / Structure
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x50: // set / Set
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x51: // bag / Bag
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0xE0: // ToD / Time of day
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0xE1: // date / Date
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0xE2: // UTC / UTCTime
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0xE8: // clusterId / Cluster ID
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0xE9: // attribId / Attribute ID
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0xEA: // bacOID / BACnet OID
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0xF0: // EUI64 / IEEE address
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: 0x%16x", chip::Encoding::LittleEndian::Read64(message));
        return true;
        break;
    case 0xF1: // key128 / 128-bit security key
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 16;
        break;
    case 0xFF: // unk / Unknown
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    }

    return false;
}

/*----------------------------------------------------------------------------*\
| Global Command Responses                                              |  ID  |
|------------------------------------------------------------------------------|
| * ReadAttributesResponse                                              | 0x01 |
| * WriteAttributesResponse                                             | 0x04 |
| * WriteAttributesNoResponse                                           | 0x05 |
| * ConfigureReportingResponse                                          | 0x07 |
| * ReadReportingConfigurationResponse                                  | 0x09 |
| * DefaultResponse                                                     | 0x0B |
| * DiscoverAttributesResponse                                          | 0x0D |
| * WriteAttributesStructuredResponse                                   | 0x10 |
| * DiscoverCommandsReceivedResponse                                    | 0x12 |
| * DiscoverCommandsGeneratedResponse                                   | 0x14 |
| * DiscoverAttributesExtendedResponse                                  | 0x16 |
\*----------------------------------------------------------------------------*/

/*
 * Command ReadAttributesResponse
 */
class ReadAttributesResponse : public ModelCommandResponse
{
public:
    ReadAttributesResponse() : ModelCommandResponse(0x01) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ReadAttributesResponse (0x01):");

        // struct readAttributeResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            CHECK_MESSAGE_LENGTH(1);
            uint8_t status = chip::Encoding::Read8(message); // zclStatus
            success        = CheckStatus(status);

            if (status == 0)
            {
                if (!ReadAttributeValue(message, messageLen))
                {
                    return false;
                }
            }
        }
        return success;
    }
};

/*
 * Command WriteAttributesResponse
 */
class WriteAttributesResponse : public ModelCommandResponse
{
public:
    WriteAttributesResponse() : ModelCommandResponse(0x04) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "WriteAttributesResponse (0x04):");

        // struct writeAttributeResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t status = chip::Encoding::Read8(message); // zclStatus
            success        = CheckStatus(status);

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
                ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);
            }
        }
        return success;
    }
};

/*
 * Command WriteAttributesNoResponse
 */
class WriteAttributesNoResponse : public ModelCommandResponse
{
public:
    WriteAttributesNoResponse() : ModelCommandResponse(0x05) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "WriteAttributesNoResponse (0x05):");

        // struct writeAttributeRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            if (!ReadAttributeValue(message, messageLen))
            {
                return false;
            }
        }
        return success;
    }
};

/*
 * Command ConfigureReportingResponse
 */
class ConfigureReportingResponse : public ModelCommandResponse
{
public:
    ConfigureReportingResponse() : ModelCommandResponse(0x07) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ConfigureReportingResponse (0x07):");

        // struct configureReportingResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t status = chip::Encoding::Read8(message); // zclStatus
            success        = CheckStatus(status);

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(1);
                uint8_t direction = chip::Encoding::Read8(message); // reportingRole
                ChipLogProgress(chipTool, "  %s: 0x%02x", "direction", direction);
            }

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
                ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);
            }
        }
        return success;
    }
};

/*
 * Command ReadReportingConfigurationResponse
 */
class ReadReportingConfigurationResponse : public ModelCommandResponse
{
public:
    ReadReportingConfigurationResponse() : ModelCommandResponse(0x09) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ReadReportingConfigurationResponse (0x09):");

        // struct readReportingConfigurationResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t direction = chip::Encoding::Read8(message); // reportingRole
            ChipLogProgress(chipTool, "  %s: 0x%02x", "direction", direction);

            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            if (direction == 0)
            {
                CHECK_MESSAGE_LENGTH(1);
                uint8_t attributeType = chip::Encoding::Read8(message); // zclType
                ChipLogProgress(chipTool, "  %s: 0x%02x", "attributeType", attributeType);
            }

            if (direction == 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t minimumReportingInterval = chip::Encoding::LittleEndian::Read16(message); // uint16
                ChipLogProgress(chipTool, "  %s: 0x%04x", "minimumReportingInterval", minimumReportingInterval);
            }

            if (direction == 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t maximumReportingInterval = chip::Encoding::LittleEndian::Read16(message); // uint16
                ChipLogProgress(chipTool, "  %s: 0x%04x", "maximumReportingInterval", maximumReportingInterval);
            }

            if (direction == 0)
            {
                // FIXME: unk is not supported yet.
            }

            if (direction == 1)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t timeout = chip::Encoding::LittleEndian::Read16(message); // uint16
                ChipLogProgress(chipTool, "  %s: 0x%04x", "timeout", timeout);
            }
        }
        return success;
    }
};

/*
 * Command DefaultResponse
 */
class DefaultResponse : public ModelCommandResponse
{
public:
    DefaultResponse() : ModelCommandResponse(0x0B) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DefaultResponse (0x0B):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t commandId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "commandId", commandId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        return success;
    }
};

/*
 * Command DiscoverAttributesResponse
 */
class DiscoverAttributesResponse : public ModelCommandResponse
{
public:
    DiscoverAttributesResponse() : ModelCommandResponse(0x0D) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DiscoverAttributesResponse (0x0D):");

        CHECK_MESSAGE_LENGTH(1);
        bool discoveryComplete = chip::Encoding::Read8(message); // bool
        ChipLogProgress(chipTool, "  %s: 0x%02x", "discoveryComplete", discoveryComplete);

        // struct discoverAttributesResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            CHECK_MESSAGE_LENGTH(1);
            uint8_t attributeType = chip::Encoding::Read8(message); // zclType
            ChipLogProgress(chipTool, "  %s: 0x%02x", "attributeType", attributeType);
        }
        return success;
    }
};

/*
 * Command WriteAttributesStructuredResponse
 */
class WriteAttributesStructuredResponse : public ModelCommandResponse
{
public:
    WriteAttributesStructuredResponse() : ModelCommandResponse(0x10) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "WriteAttributesStructuredResponse (0x10):");

        // struct writeStructuredResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t status = chip::Encoding::Read8(message); // zclStatus
            success        = CheckStatus(status);

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
                ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);
            }

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t selector = chip::Encoding::LittleEndian::Read16(message); // uint16
                ChipLogProgress(chipTool, "  %s: 0x%04x", "selector", selector);
            }
        }
        return success;
    }
};

/*
 * Command DiscoverCommandsReceivedResponse
 */
class DiscoverCommandsReceivedResponse : public ModelCommandResponse
{
public:
    DiscoverCommandsReceivedResponse() : ModelCommandResponse(0x12) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DiscoverCommandsReceivedResponse (0x12):");

        CHECK_MESSAGE_LENGTH(1);
        bool discoveryComplete = chip::Encoding::Read8(message); // bool
        ChipLogProgress(chipTool, "  %s: 0x%02x", "discoveryComplete", discoveryComplete);

        // uint8_t uint8[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t commandId = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "commandId", commandId);
        }
        return success;
    }
};

/*
 * Command DiscoverCommandsGeneratedResponse
 */
class DiscoverCommandsGeneratedResponse : public ModelCommandResponse
{
public:
    DiscoverCommandsGeneratedResponse() : ModelCommandResponse(0x14) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DiscoverCommandsGeneratedResponse (0x14):");

        CHECK_MESSAGE_LENGTH(1);
        bool discoveryComplete = chip::Encoding::Read8(message); // bool
        ChipLogProgress(chipTool, "  %s: 0x%02x", "discoveryComplete", discoveryComplete);

        // uint8_t uint8[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t commandId = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "commandId", commandId);
        }
        return success;
    }
};

/*
 * Command DiscoverAttributesExtendedResponse
 */
class DiscoverAttributesExtendedResponse : public ModelCommandResponse
{
public:
    DiscoverAttributesExtendedResponse() : ModelCommandResponse(0x16) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DiscoverAttributesExtendedResponse (0x16):");

        CHECK_MESSAGE_LENGTH(1);
        bool discoveryComplete = chip::Encoding::Read8(message); // bool
        ChipLogProgress(chipTool, "  %s: 0x%02x", "discoveryComplete", discoveryComplete);

        // struct discoverAttributesExtendedResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            CHECK_MESSAGE_LENGTH(1);
            uint8_t accessControl = chip::Encoding::Read8(message); // bitmap8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "accessControl", accessControl);
        }
        return success;
    }
};

/*----------------------------------------------------------------------------*\
| Cluster Name                                                        |   ID   |
|---------------------------------------------------------------------+--------|
| BarrierControl                                                      | 0x0103 |
| Basic                                                               | 0x0000 |
| ColorControl                                                        | 0x0300 |
| DoorLock                                                            | 0x0101 |
| Groups                                                              | 0x0004 |
| IASZone                                                             | 0x0500 |
| Identify                                                            | 0x0003 |
| Level                                                               | 0x0008 |
| OnOff                                                               | 0x0006 |
| Scenes                                                              | 0x0005 |
| TemperatureMeasurement                                              | 0x0402 |
\*----------------------------------------------------------------------------*/

constexpr uint16_t kBarrierControlClusterId  = 0x0103;
constexpr uint16_t kBasicClusterId           = 0x0000;
constexpr uint16_t kColorControlClusterId    = 0x0300;
constexpr uint16_t kDoorLockClusterId        = 0x0101;
constexpr uint16_t kGroupsClusterId          = 0x0004;
constexpr uint16_t kIASZoneClusterId         = 0x0500;
constexpr uint16_t kIdentifyClusterId        = 0x0003;
constexpr uint16_t kLevelClusterId           = 0x0008;
constexpr uint16_t kOnOffClusterId           = 0x0006;
constexpr uint16_t kScenesClusterId          = 0x0005;
constexpr uint16_t kTempMeasurementClusterId = 0x0402;

/*----------------------------------------------------------------------------*\
| Cluster BarrierControl                                              | 0x0103 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GoToPercent                                                       |   0x00 |
| * Stop                                                              |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MovingState                                                       | 0x0001 |
| * SafetyStatus                                                      | 0x0002 |
| * Capabilities                                                      | 0x0003 |
| * BarrierPosition                                                   | 0x000A |
\*----------------------------------------------------------------------------*/

/*
 * Command GoToPercent
 */
class BarrierControlGoToPercent : public ModelCommand
{
public:
    BarrierControlGoToPercent() : ModelCommand("go-to-percent", kBarrierControlClusterId, 0x00)
    {
        AddArgument("percentOpen", 0, UINT8_MAX, &mPercentOpen);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterGoToPercentCommand(buffer->Start(), bufferSize, endPointId, mPercentOpen);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mPercentOpen;
};

/*
 * Command Stop
 */
class BarrierControlStop : public ModelCommand
{
public:
    BarrierControlStop() : ModelCommand("stop", kBarrierControlClusterId, 0x01) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterStopCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverBarrierControlAttributes : public ModelCommand
{
public:
    DiscoverBarrierControlAttributes() : ModelCommand("discover", kBarrierControlClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute MovingState
 */
class ReadBarrierControlMovingState : public ModelCommand
{
public:
    ReadBarrierControlMovingState() : ModelCommand("read", kBarrierControlClusterId, 0x00)
    {
        AddArgument("attr-name", "moving-state");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReadMovingStateAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportBarrierControlMovingState : public ModelCommand
{
public:
    ReportBarrierControlMovingState() : ModelCommand("report", kBarrierControlClusterId, 0x06)
    {
        AddArgument("attr-name", "moving-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReportMovingStateAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval,
                                                                     mMaxInterval);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
};

/*
 * Attribute SafetyStatus
 */
class ReadBarrierControlSafetyStatus : public ModelCommand
{
public:
    ReadBarrierControlSafetyStatus() : ModelCommand("read", kBarrierControlClusterId, 0x00)
    {
        AddArgument("attr-name", "safety-status");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReadSafetyStatusAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportBarrierControlSafetyStatus : public ModelCommand
{
public:
    ReportBarrierControlSafetyStatus() : ModelCommand("report", kBarrierControlClusterId, 0x06)
    {
        AddArgument("attr-name", "safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReportSafetyStatusAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval,
                                                                      mMaxInterval);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
};

/*
 * Attribute Capabilities
 */
class ReadBarrierControlCapabilities : public ModelCommand
{
public:
    ReadBarrierControlCapabilities() : ModelCommand("read", kBarrierControlClusterId, 0x00)
    {
        AddArgument("attr-name", "capabilities");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReadCapabilitiesAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute BarrierPosition
 */
class ReadBarrierControlBarrierPosition : public ModelCommand
{
public:
    ReadBarrierControlBarrierPosition() : ModelCommand("read", kBarrierControlClusterId, 0x00)
    {
        AddArgument("attr-name", "barrier-position");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReadBarrierPositionAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportBarrierControlBarrierPosition : public ModelCommand
{
public:
    ReportBarrierControlBarrierPosition() : ModelCommand("report", kBarrierControlClusterId, 0x06)
    {
        AddArgument("attr-name", "barrier-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT8_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReportBarrierPositionAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval,
                                                                         mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint8_t mChange;
};

/*----------------------------------------------------------------------------*\
| Cluster Basic                                                       | 0x0000 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetToFactoryDefaults                                            |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ZCLVersion                                                        | 0x0000 |
| * PowerSource                                                       | 0x0007 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetToFactoryDefaults
 */
class BasicResetToFactoryDefaults : public ModelCommand
{
public:
    BasicResetToFactoryDefaults() : ModelCommand("reset-to-factory-defaults", kBasicClusterId, 0x00)
    {
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBasicClusterResetToFactoryDefaultsCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverBasicAttributes : public ModelCommand
{
public:
    DiscoverBasicAttributes() : ModelCommand("discover", kBasicClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBasicClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ZCLVersion
 */
class ReadBasicZCLVersion : public ModelCommand
{
public:
    ReadBasicZCLVersion() : ModelCommand("read", kBasicClusterId, 0x00)
    {
        AddArgument("attr-name", "zclversion");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBasicClusterReadZCLVersionAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute PowerSource
 */
class ReadBasicPowerSource : public ModelCommand
{
public:
    ReadBasicPowerSource() : ModelCommand("read", kBasicClusterId, 0x00)
    {
        AddArgument("attr-name", "power-source");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeBasicClusterReadPowerSourceAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster ColorControl                                                | 0x0300 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MoveColor                                                         |   0x08 |
| * MoveColorTemperature                                              |   0x4B |
| * MoveHue                                                           |   0x01 |
| * MoveSaturation                                                    |   0x04 |
| * MoveToColor                                                       |   0x07 |
| * MoveToColorTemperature                                            |   0x0A |
| * MoveToHue                                                         |   0x00 |
| * MoveToHueAndSaturation                                            |   0x06 |
| * MoveToSaturation                                                  |   0x03 |
| * StepColor                                                         |   0x09 |
| * StepColorTemperature                                              |   0x4C |
| * StepHue                                                           |   0x02 |
| * StepSaturation                                                    |   0x05 |
| * StopMoveStep                                                      |   0x47 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentHue                                                        | 0x0000 |
| * CurrentSaturation                                                 | 0x0001 |
| * RemainingTime                                                     | 0x0002 |
| * CurrentX                                                          | 0x0003 |
| * CurrentY                                                          | 0x0004 |
| * ColorTemperatureMireds                                            | 0x0007 |
| * ColorMode                                                         | 0x0008 |
| * Options                                                           | 0x000F |
| * NumberOfPrimaries                                                 | 0x0010 |
| * Primary1X                                                         | 0x0011 |
| * Primary1Y                                                         | 0x0012 |
| * Primary1Intensity                                                 | 0x0013 |
| * Primary2X                                                         | 0x0015 |
| * Primary2Y                                                         | 0x0016 |
| * Primary2Intensity                                                 | 0x0017 |
| * Primary3X                                                         | 0x0019 |
| * Primary3Y                                                         | 0x001A |
| * Primary3Intensity                                                 | 0x001B |
| * Primary4X                                                         | 0x0020 |
| * Primary4Y                                                         | 0x0021 |
| * Primary4Intensity                                                 | 0x0022 |
| * Primary5X                                                         | 0x0024 |
| * Primary5Y                                                         | 0x0025 |
| * Primary5Intensity                                                 | 0x0026 |
| * Primary6X                                                         | 0x0028 |
| * Primary6Y                                                         | 0x0029 |
| * Primary6Intensity                                                 | 0x002A |
| * EnhancedCurrentHue                                                | 0x4000 |
| * EnhancedColorMode                                                 | 0x4001 |
| * ColorLoopActive                                                   | 0x4002 |
| * ColorLoopDirection                                                | 0x4003 |
| * ColorLoopTime                                                     | 0x4004 |
| * ColorLoopStartEnhancedHue                                         | 0x4005 |
| * ColorLoopStoredEnhancedHue                                        | 0x4006 |
| * ColorCapabilities                                                 | 0x400A |
| * ColorTempPhysicalMinMireds                                        | 0x400B |
| * ColorTempPhysicalMaxMireds                                        | 0x400C |
| * CoupleColorTempToLevelMinMireds                                   | 0x400D |
| * StartUpColorTemperatureMireds                                     | 0x4010 |
\*----------------------------------------------------------------------------*/

/*
 * Command MoveColor
 */
class ColorControlMoveColor : public ModelCommand
{
public:
    ColorControlMoveColor() : ModelCommand("move-color", kColorControlClusterId, 0x08)
    {
        AddArgument("rateX", INT16_MIN, INT16_MAX, &mRateX);
        AddArgument("rateY", INT16_MIN, INT16_MAX, &mRateY);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveColorCommand(buffer->Start(), bufferSize, endPointId, mRateX, mRateY, mOptionsMask,
                                                         mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    int16_t mRateX;
    int16_t mRateY;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveColorTemperature
 */
class ColorControlMoveColorTemperature : public ModelCommand
{
public:
    ColorControlMoveColorTemperature() : ModelCommand("move-color-temperature", kColorControlClusterId, 0x4B)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT16_MAX, &mRate);
        AddArgument("colorTemperatureMinimumMireds", 0, UINT16_MAX, &mColorTemperatureMinimumMireds);
        AddArgument("colorTemperatureMaximumMireds", 0, UINT16_MAX, &mColorTemperatureMaximumMireds);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveColorTemperatureCommand(buffer->Start(), bufferSize, endPointId, mMoveMode, mRate,
                                                                    mColorTemperatureMinimumMireds, mColorTemperatureMaximumMireds,
                                                                    mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint16_t mRate;
    uint16_t mColorTemperatureMinimumMireds;
    uint16_t mColorTemperatureMaximumMireds;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveHue
 */
class ColorControlMoveHue : public ModelCommand
{
public:
    ColorControlMoveHue() : ModelCommand("move-hue", kColorControlClusterId, 0x01)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT8_MAX, &mRate);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveHueCommand(buffer->Start(), bufferSize, endPointId, mMoveMode, mRate, mOptionsMask,
                                                       mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveSaturation
 */
class ColorControlMoveSaturation : public ModelCommand
{
public:
    ColorControlMoveSaturation() : ModelCommand("move-saturation", kColorControlClusterId, 0x04)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT8_MAX, &mRate);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveSaturationCommand(buffer->Start(), bufferSize, endPointId, mMoveMode, mRate,
                                                              mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColor
 */
class ColorControlMoveToColor : public ModelCommand
{
public:
    ColorControlMoveToColor() : ModelCommand("move-to-color", kColorControlClusterId, 0x07)
    {
        AddArgument("colorX", 0, UINT16_MAX, &mColorX);
        AddArgument("colorY", 0, UINT16_MAX, &mColorY);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToColorCommand(buffer->Start(), bufferSize, endPointId, mColorX, mColorY,
                                                           mTransitionTime, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mColorX;
    uint16_t mColorY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColorTemperature
 */
class ColorControlMoveToColorTemperature : public ModelCommand
{
public:
    ColorControlMoveToColorTemperature() : ModelCommand("move-to-color-temperature", kColorControlClusterId, 0x0A)
    {
        AddArgument("colorTemperatureMireds", 0, UINT16_MAX, &mColorTemperatureMireds);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToColorTemperatureCommand(
            buffer->Start(), bufferSize, endPointId, mColorTemperatureMireds, mTransitionTime, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mColorTemperatureMireds;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHue
 */
class ColorControlMoveToHue : public ModelCommand
{
public:
    ColorControlMoveToHue() : ModelCommand("move-to-hue", kColorControlClusterId, 0x00)
    {
        AddArgument("hue", 0, UINT8_MAX, &mHue);
        AddArgument("direction", 0, UINT8_MAX, &mDirection);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToHueCommand(buffer->Start(), bufferSize, endPointId, mHue, mDirection, mTransitionTime,
                                                         mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHue;
    uint8_t mDirection;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHueAndSaturation
 */
class ColorControlMoveToHueAndSaturation : public ModelCommand
{
public:
    ColorControlMoveToHueAndSaturation() : ModelCommand("move-to-hue-and-saturation", kColorControlClusterId, 0x06)
    {
        AddArgument("hue", 0, UINT8_MAX, &mHue);
        AddArgument("saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToHueAndSaturationCommand(buffer->Start(), bufferSize, endPointId, mHue, mSaturation,
                                                                      mTransitionTime, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHue;
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToSaturation
 */
class ColorControlMoveToSaturation : public ModelCommand
{
public:
    ColorControlMoveToSaturation() : ModelCommand("move-to-saturation", kColorControlClusterId, 0x03)
    {
        AddArgument("saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToSaturationCommand(buffer->Start(), bufferSize, endPointId, mSaturation,
                                                                mTransitionTime, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColor
 */
class ColorControlStepColor : public ModelCommand
{
public:
    ColorControlStepColor() : ModelCommand("step-color", kColorControlClusterId, 0x09)
    {
        AddArgument("stepX", INT16_MIN, INT16_MAX, &mStepX);
        AddArgument("stepY", INT16_MIN, INT16_MAX, &mStepY);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterStepColorCommand(buffer->Start(), bufferSize, endPointId, mStepX, mStepY, mTransitionTime,
                                                         mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    int16_t mStepX;
    int16_t mStepY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColorTemperature
 */
class ColorControlStepColorTemperature : public ModelCommand
{
public:
    ColorControlStepColorTemperature() : ModelCommand("step-color-temperature", kColorControlClusterId, 0x4C)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT16_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("colorTemperatureMinimumMireds", 0, UINT16_MAX, &mColorTemperatureMinimumMireds);
        AddArgument("colorTemperatureMaximumMireds", 0, UINT16_MAX, &mColorTemperatureMaximumMireds);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterStepColorTemperatureCommand(buffer->Start(), bufferSize, endPointId, mStepMode, mStepSize,
                                                                    mTransitionTime, mColorTemperatureMinimumMireds,
                                                                    mColorTemperatureMaximumMireds, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint16_t mStepSize;
    uint16_t mTransitionTime;
    uint16_t mColorTemperatureMinimumMireds;
    uint16_t mColorTemperatureMaximumMireds;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepHue
 */
class ColorControlStepHue : public ModelCommand
{
public:
    ColorControlStepHue() : ModelCommand("step-hue", kColorControlClusterId, 0x02)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterStepHueCommand(buffer->Start(), bufferSize, endPointId, mStepMode, mStepSize,
                                                       mTransitionTime, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepSaturation
 */
class ColorControlStepSaturation : public ModelCommand
{
public:
    ColorControlStepSaturation() : ModelCommand("step-saturation", kColorControlClusterId, 0x05)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterStepSaturationCommand(buffer->Start(), bufferSize, endPointId, mStepMode, mStepSize,
                                                              mTransitionTime, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StopMoveStep
 */
class ColorControlStopMoveStep : public ModelCommand
{
public:
    ColorControlStopMoveStep() : ModelCommand("stop-move-step", kColorControlClusterId, 0x47)
    {
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterStopMoveStepCommand(buffer->Start(), bufferSize, endPointId, mOptionsMask,
                                                            mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Discover attributes
 */
class DiscoverColorControlAttributes : public ModelCommand
{
public:
    DiscoverColorControlAttributes() : ModelCommand("discover", kColorControlClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentHue
 */
class ReadColorControlCurrentHue : public ModelCommand
{
public:
    ReadColorControlCurrentHue() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "current-hue");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCurrentHueAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlCurrentHue : public ModelCommand
{
public:
    ReportColorControlCurrentHue() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT8_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReportCurrentHueAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval,
                                                                  mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint8_t mChange;
};

/*
 * Attribute CurrentSaturation
 */
class ReadColorControlCurrentSaturation : public ModelCommand
{
public:
    ReadColorControlCurrentSaturation() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "current-saturation");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCurrentSaturationAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlCurrentSaturation : public ModelCommand
{
public:
    ReportColorControlCurrentSaturation() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "current-saturation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT8_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReportCurrentSaturationAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval,
                                                                         mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint8_t mChange;
};

/*
 * Attribute RemainingTime
 */
class ReadColorControlRemainingTime : public ModelCommand
{
public:
    ReadColorControlRemainingTime() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadRemainingTimeAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentX
 */
class ReadColorControlCurrentX : public ModelCommand
{
public:
    ReadColorControlCurrentX() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "current-x");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCurrentXAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlCurrentX : public ModelCommand
{
public:
    ReportColorControlCurrentX() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "current-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT16_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReportCurrentXAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval, mMaxInterval,
                                                                mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint16_t mChange;
};

/*
 * Attribute CurrentY
 */
class ReadColorControlCurrentY : public ModelCommand
{
public:
    ReadColorControlCurrentY() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "current-y");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCurrentYAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlCurrentY : public ModelCommand
{
public:
    ReportColorControlCurrentY() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "current-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT16_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReportCurrentYAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval, mMaxInterval,
                                                                mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint16_t mChange;
};

/*
 * Attribute ColorTemperatureMireds
 */
class ReadColorControlColorTemperatureMireds : public ModelCommand
{
public:
    ReadColorControlColorTemperatureMireds() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorTemperatureMiredsAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlColorTemperatureMireds : public ModelCommand
{
public:
    ReportColorControlColorTemperatureMireds() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "color-temperature-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT16_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReportColorTemperatureMiredsAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval,
                                                                              mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint16_t mChange;
};

/*
 * Attribute ColorMode
 */
class ReadColorControlColorMode : public ModelCommand
{
public:
    ReadColorControlColorMode() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-mode");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorModeAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Options
 */
class ReadColorControlOptions : public ModelCommand
{
public:
    ReadColorControlOptions() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "options");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadOptionsAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class WriteColorControlOptions : public ModelCommand
{
public:
    WriteColorControlOptions() : ModelCommand("write", kColorControlClusterId, 0x01)
    {
        AddArgument("attr-name", "options");
        AddArgument("attr-value", 0, UINT8_MAX, &mOptions);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterWriteOptionsAttribute(buffer->Start(), bufferSize, endPointId, mOptions);
    }

    // Global Response: WriteAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        WriteAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mOptions;
};

/*
 * Attribute NumberOfPrimaries
 */
class ReadColorControlNumberOfPrimaries : public ModelCommand
{
public:
    ReadColorControlNumberOfPrimaries() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "number-of-primaries");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadNumberOfPrimariesAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary1X
 */
class ReadColorControlPrimary1X : public ModelCommand
{
public:
    ReadColorControlPrimary1X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary1-x");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary1XAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary1Y
 */
class ReadColorControlPrimary1Y : public ModelCommand
{
public:
    ReadColorControlPrimary1Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary1-y");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary1YAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary1Intensity
 */
class ReadColorControlPrimary1Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary1Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary1-intensity");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary1IntensityAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary2X
 */
class ReadColorControlPrimary2X : public ModelCommand
{
public:
    ReadColorControlPrimary2X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary2-x");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary2XAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary2Y
 */
class ReadColorControlPrimary2Y : public ModelCommand
{
public:
    ReadColorControlPrimary2Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary2-y");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary2YAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary2Intensity
 */
class ReadColorControlPrimary2Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary2Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary2-intensity");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary2IntensityAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary3X
 */
class ReadColorControlPrimary3X : public ModelCommand
{
public:
    ReadColorControlPrimary3X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary3-x");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary3XAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary3Y
 */
class ReadColorControlPrimary3Y : public ModelCommand
{
public:
    ReadColorControlPrimary3Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary3-y");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary3YAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary3Intensity
 */
class ReadColorControlPrimary3Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary3Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary3-intensity");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary3IntensityAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary4X
 */
class ReadColorControlPrimary4X : public ModelCommand
{
public:
    ReadColorControlPrimary4X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary4-x");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary4XAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary4Y
 */
class ReadColorControlPrimary4Y : public ModelCommand
{
public:
    ReadColorControlPrimary4Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary4-y");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary4YAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary4Intensity
 */
class ReadColorControlPrimary4Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary4Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary4-intensity");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary4IntensityAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary5X
 */
class ReadColorControlPrimary5X : public ModelCommand
{
public:
    ReadColorControlPrimary5X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary5-x");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary5XAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary5Y
 */
class ReadColorControlPrimary5Y : public ModelCommand
{
public:
    ReadColorControlPrimary5Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary5-y");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary5YAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary5Intensity
 */
class ReadColorControlPrimary5Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary5Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary5-intensity");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary5IntensityAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary6X
 */
class ReadColorControlPrimary6X : public ModelCommand
{
public:
    ReadColorControlPrimary6X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary6-x");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary6XAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary6Y
 */
class ReadColorControlPrimary6Y : public ModelCommand
{
public:
    ReadColorControlPrimary6Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary6-y");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary6YAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary6Intensity
 */
class ReadColorControlPrimary6Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary6Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary6-intensity");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary6IntensityAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute EnhancedCurrentHue
 */
class ReadColorControlEnhancedCurrentHue : public ModelCommand
{
public:
    ReadColorControlEnhancedCurrentHue() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "enhanced-current-hue");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadEnhancedCurrentHueAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute EnhancedColorMode
 */
class ReadColorControlEnhancedColorMode : public ModelCommand
{
public:
    ReadColorControlEnhancedColorMode() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "enhanced-color-mode");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadEnhancedColorModeAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorLoopActive
 */
class ReadColorControlColorLoopActive : public ModelCommand
{
public:
    ReadColorControlColorLoopActive() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-loop-active");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorLoopActiveAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorLoopDirection
 */
class ReadColorControlColorLoopDirection : public ModelCommand
{
public:
    ReadColorControlColorLoopDirection() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-loop-direction");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorLoopDirectionAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorLoopTime
 */
class ReadColorControlColorLoopTime : public ModelCommand
{
public:
    ReadColorControlColorLoopTime() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-loop-time");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorLoopTimeAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorLoopStartEnhancedHue
 */
class ReadColorControlColorLoopStartEnhancedHue : public ModelCommand
{
public:
    ReadColorControlColorLoopStartEnhancedHue() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorLoopStartEnhancedHueAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorLoopStoredEnhancedHue
 */
class ReadColorControlColorLoopStoredEnhancedHue : public ModelCommand
{
public:
    ReadColorControlColorLoopStoredEnhancedHue() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorLoopStoredEnhancedHueAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorCapabilities
 */
class ReadColorControlColorCapabilities : public ModelCommand
{
public:
    ReadColorControlColorCapabilities() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-capabilities");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorCapabilitiesAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorTempPhysicalMinMireds
 */
class ReadColorControlColorTempPhysicalMinMireds : public ModelCommand
{
public:
    ReadColorControlColorTempPhysicalMinMireds() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-temp-physical-min-mireds");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorTempPhysicalMinMiredsAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorTempPhysicalMaxMireds
 */
class ReadColorControlColorTempPhysicalMaxMireds : public ModelCommand
{
public:
    ReadColorControlColorTempPhysicalMaxMireds() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-temp-physical-max-mireds");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorTempPhysicalMaxMiredsAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CoupleColorTempToLevelMinMireds
 */
class ReadColorControlCoupleColorTempToLevelMinMireds : public ModelCommand
{
public:
    ReadColorControlCoupleColorTempToLevelMinMireds() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCoupleColorTempToLevelMinMiredsAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute StartUpColorTemperatureMireds
 */
class ReadColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    ReadColorControlStartUpColorTemperatureMireds() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterReadStartUpColorTemperatureMiredsAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class WriteColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    WriteColorControlStartUpColorTemperatureMireds() : ModelCommand("write", kColorControlClusterId, 0x01)
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("attr-value", 0, UINT16_MAX, &mStartUpColorTemperatureMireds);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeColorControlClusterWriteStartUpColorTemperatureMiredsAttribute(buffer->Start(), bufferSize, endPointId,
                                                                                    mStartUpColorTemperatureMireds);
    }

    // Global Response: WriteAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        WriteAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mStartUpColorTemperatureMireds;
};

/*----------------------------------------------------------------------------*\
| Cluster DoorLock                                                    | 0x0101 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
| * ClearAllPINCodesResponse                                          |   0x08 |
| * ClearAllRFIDCodesResponse                                         |   0x19 |
| * ClearHolidayScheduleResponse                                      |   0x13 |
| * ClearPINCodeResponse                                              |   0x07 |
| * ClearRFIDCodeResponse                                             |   0x18 |
| * ClearWeekdayScheduleResponse                                      |   0x0D |
| * ClearYearDayScheduleResponse                                      |   0x10 |
| * GetHolidayScheduleResponse                                        |   0x12 |
| * GetPINCodeResponse                                                |   0x06 |
| * GetRFIDCodeResponse                                               |   0x17 |
| * GetUserTypeResponse                                               |   0x15 |
| * GetWeekdayScheduleResponse                                        |   0x0C |
| * GetYearDayScheduleResponse                                        |   0x0F |
| * LockDoorResponse                                                  |   0x00 |
| * SetHolidayScheduleResponse                                        |   0x11 |
| * SetPINCodeResponse                                                |   0x05 |
| * SetRFIDCodeResponse                                               |   0x16 |
| * SetUserTypeResponse                                               |   0x14 |
| * SetWeekdayScheduleResponse                                        |   0x0B |
| * SetYearDayScheduleResponse                                        |   0x0E |
| * UnlockDoorResponse                                                |   0x01 |
| * UnlockWithTimeoutResponse                                         |   0x03 |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ClearAllPINCodes                                                  |   0x08 |
| * ClearAllRFIDCodes                                                 |   0x19 |
| * ClearHolidaySchedule                                              |   0x13 |
| * ClearPINCode                                                      |   0x07 |
| * ClearRFIDCode                                                     |   0x18 |
| * ClearWeekdaySchedule                                              |   0x0D |
| * ClearYearDaySchedule                                              |   0x10 |
| * GetHolidaySchedule                                                |   0x12 |
| * GetPINCode                                                        |   0x06 |
| * GetRFIDCode                                                       |   0x17 |
| * GetUserType                                                       |   0x15 |
| * GetWeekdaySchedule                                                |   0x0C |
| * GetYearDaySchedule                                                |   0x0F |
| * LockDoor                                                          |   0x00 |
| * SetHolidaySchedule                                                |   0x11 |
| * SetPINCode                                                        |   0x05 |
| * SetRFIDCode                                                       |   0x16 |
| * SetUserType                                                       |   0x14 |
| * SetWeekdaySchedule                                                |   0x0B |
| * SetYearDaySchedule                                                |   0x0E |
| * UnlockDoor                                                        |   0x01 |
| * UnlockWithTimeout                                                 |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LockState                                                         | 0x0000 |
| * LockType                                                          | 0x0001 |
| * ActuatorEnabled                                                   | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command Response ClearAllPINCodesResponse
 */
class ClearAllPINCodesResponse : public ModelCommandResponse
{
public:
    ClearAllPINCodesResponse() : ModelCommandResponse(0x08) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearAllPINCodesResponse (0x08):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearAllRFIDCodesResponse
 */
class ClearAllRFIDCodesResponse : public ModelCommandResponse
{
public:
    ClearAllRFIDCodesResponse() : ModelCommandResponse(0x19) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearAllRFIDCodesResponse (0x19):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearHolidayScheduleResponse
 */
class ClearHolidayScheduleResponse : public ModelCommandResponse
{
public:
    ClearHolidayScheduleResponse() : ModelCommandResponse(0x13) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearHolidayScheduleResponse (0x13):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearPINCodeResponse
 */
class ClearPINCodeResponse : public ModelCommandResponse
{
public:
    ClearPINCodeResponse() : ModelCommandResponse(0x07) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearPINCodeResponse (0x07):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearRFIDCodeResponse
 */
class ClearRFIDCodeResponse : public ModelCommandResponse
{
public:
    ClearRFIDCodeResponse() : ModelCommandResponse(0x18) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearRFIDCodeResponse (0x18):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearWeekdayScheduleResponse
 */
class ClearWeekdayScheduleResponse : public ModelCommandResponse
{
public:
    ClearWeekdayScheduleResponse() : ModelCommandResponse(0x0D) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearWeekdayScheduleResponse (0x0D):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearYearDayScheduleResponse
 */
class ClearYearDayScheduleResponse : public ModelCommandResponse
{
public:
    ClearYearDayScheduleResponse() : ModelCommandResponse(0x10) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearYearDayScheduleResponse (0x10):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response GetHolidayScheduleResponse
 */
class GetHolidayScheduleResponse : public ModelCommandResponse
{
public:
    GetHolidayScheduleResponse() : ModelCommandResponse(0x12) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetHolidayScheduleResponse (0x12):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t holidayScheduleId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "holidayScheduleId", holidayScheduleId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(4);
            uint32_t localStartTime = chip::Encoding::LittleEndian::Read32(message); // uint32
            ChipLogProgress(chipTool, "  %s: 0x%08x", "localStartTime", localStartTime);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(4);
            uint32_t localEndTime = chip::Encoding::LittleEndian::Read32(message); // uint32
            ChipLogProgress(chipTool, "  %s: 0x%08x", "localEndTime", localEndTime);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t operatingModeDuringHoliday = chip::Encoding::Read8(message); // DrlkOperMode
            ChipLogProgress(chipTool, "  %s: 0x%02x", "operatingModeDuringHoliday", operatingModeDuringHoliday);
        }

        return success;
    }
};

/*
 * Command Response GetPINCodeResponse
 */
class GetPINCodeResponse : public ModelCommandResponse
{
public:
    GetPINCodeResponse() : ModelCommandResponse(0x06) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetPINCodeResponse (0x06):");

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userStatus = chip::Encoding::Read8(message); // DrlkUserStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userStatus", userStatus);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userType = chip::Encoding::Read8(message); // DrlkUserType
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userType", userType);

        CHECK_MESSAGE_LENGTH(1);
        {
            uint8_t codeLen = chip::Encoding::Read8(message);              // octstr
            ChipLogProgress(chipTool, "  %s: 0x%02x", "codeLen", codeLen); // octstr

            // FIXME Strings are not supported yet. For the moment the code just checks that
            // there is enough bytes in the buffer
            CHECK_MESSAGE_LENGTH(codeLen);
            message += codeLen;
        }

        return success;
    }
};

/*
 * Command Response GetRFIDCodeResponse
 */
class GetRFIDCodeResponse : public ModelCommandResponse
{
public:
    GetRFIDCodeResponse() : ModelCommandResponse(0x17) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetRFIDCodeResponse (0x17):");

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userStatus = chip::Encoding::Read8(message); // DrlkUserStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userStatus", userStatus);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userType = chip::Encoding::Read8(message); // DrlkUserType
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userType", userType);

        CHECK_MESSAGE_LENGTH(1);
        {
            uint8_t rFIdCodeLen = chip::Encoding::Read8(message);                  // octstr
            ChipLogProgress(chipTool, "  %s: 0x%02x", "rFIdCodeLen", rFIdCodeLen); // octstr

            // FIXME Strings are not supported yet. For the moment the code just checks that
            // there is enough bytes in the buffer
            CHECK_MESSAGE_LENGTH(rFIdCodeLen);
            message += rFIdCodeLen;
        }

        return success;
    }
};

/*
 * Command Response GetUserTypeResponse
 */
class GetUserTypeResponse : public ModelCommandResponse
{
public:
    GetUserTypeResponse() : ModelCommandResponse(0x15) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetUserTypeResponse (0x15):");

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userType = chip::Encoding::Read8(message); // DrlkUserType
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userType", userType);

        return success;
    }
};

/*
 * Command Response GetWeekdayScheduleResponse
 */
class GetWeekdayScheduleResponse : public ModelCommandResponse
{
public:
    GetWeekdayScheduleResponse() : ModelCommandResponse(0x0C) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetWeekdayScheduleResponse (0x0C):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t scheduleId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "scheduleId", scheduleId);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t daysMask = chip::Encoding::Read8(message); // DrlkDaysMask
            ChipLogProgress(chipTool, "  %s: 0x%02x", "daysMask", daysMask);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t startHour = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "startHour", startHour);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t startMinute = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "startMinute", startMinute);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t endHour = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "endHour", endHour);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t endMinute = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "endMinute", endMinute);
        }

        return success;
    }
};

/*
 * Command Response GetYearDayScheduleResponse
 */
class GetYearDayScheduleResponse : public ModelCommandResponse
{
public:
    GetYearDayScheduleResponse() : ModelCommandResponse(0x0F) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetYearDayScheduleResponse (0x0F):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t scheduleId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "scheduleId", scheduleId);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(4);
            uint32_t localStartTime = chip::Encoding::LittleEndian::Read32(message); // uint32
            ChipLogProgress(chipTool, "  %s: 0x%08x", "localStartTime", localStartTime);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(4);
            uint32_t localEndTime = chip::Encoding::LittleEndian::Read32(message); // uint32
            ChipLogProgress(chipTool, "  %s: 0x%08x", "localEndTime", localEndTime);
        }

        return success;
    }
};

/*
 * Command Response LockDoorResponse
 */
class LockDoorResponse : public ModelCommandResponse
{
public:
    LockDoorResponse() : ModelCommandResponse(0x00) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "LockDoorResponse (0x00):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        return success;
    }
};

/*
 * Command Response SetHolidayScheduleResponse
 */
class SetHolidayScheduleResponse : public ModelCommandResponse
{
public:
    SetHolidayScheduleResponse() : ModelCommandResponse(0x11) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetHolidayScheduleResponse (0x11):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetPINCodeResponse
 */
class SetPINCodeResponse : public ModelCommandResponse
{
public:
    SetPINCodeResponse() : ModelCommandResponse(0x05) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetPINCodeResponse (0x05):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkSetCodeStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetRFIDCodeResponse
 */
class SetRFIDCodeResponse : public ModelCommandResponse
{
public:
    SetRFIDCodeResponse() : ModelCommandResponse(0x16) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetRFIDCodeResponse (0x16):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkSetCodeStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetUserTypeResponse
 */
class SetUserTypeResponse : public ModelCommandResponse
{
public:
    SetUserTypeResponse() : ModelCommandResponse(0x14) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetUserTypeResponse (0x14):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetWeekdayScheduleResponse
 */
class SetWeekdayScheduleResponse : public ModelCommandResponse
{
public:
    SetWeekdayScheduleResponse() : ModelCommandResponse(0x0B) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetWeekdayScheduleResponse (0x0B):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetYearDayScheduleResponse
 */
class SetYearDayScheduleResponse : public ModelCommandResponse
{
public:
    SetYearDayScheduleResponse() : ModelCommandResponse(0x0E) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetYearDayScheduleResponse (0x0E):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response UnlockDoorResponse
 */
class UnlockDoorResponse : public ModelCommandResponse
{
public:
    UnlockDoorResponse() : ModelCommandResponse(0x01) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "UnlockDoorResponse (0x01):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        return success;
    }
};

/*
 * Command Response UnlockWithTimeoutResponse
 */
class UnlockWithTimeoutResponse : public ModelCommandResponse
{
public:
    UnlockWithTimeoutResponse() : ModelCommandResponse(0x03) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "UnlockWithTimeoutResponse (0x03):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        return success;
    }
};

/*
 * Command ClearAllPINCodes
 */
class DoorLockClearAllPINCodes : public ModelCommand
{
public:
    DoorLockClearAllPINCodes() : ModelCommand("clear-all-pincodes", kDoorLockClusterId, 0x08) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearAllPINCodesCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearAllPINCodesResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearAllPINCodesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command ClearAllRFIDCodes
 */
class DoorLockClearAllRFIDCodes : public ModelCommand
{
public:
    DoorLockClearAllRFIDCodes() : ModelCommand("clear-all-rfidcodes", kDoorLockClusterId, 0x19) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearAllRFIDCodesCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearAllRFIDCodesResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearAllRFIDCodesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command ClearHolidaySchedule
 */
class DoorLockClearHolidaySchedule : public ModelCommand
{
public:
    DoorLockClearHolidaySchedule() : ModelCommand("clear-holiday-schedule", kDoorLockClusterId, 0x13)
    {
        AddArgument("holidayScheduleID", 0, UINT8_MAX, &mHolidayScheduleID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearHolidayScheduleCommand(buffer->Start(), bufferSize, endPointId, mHolidayScheduleID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearHolidayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearHolidayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHolidayScheduleID;
};

/*
 * Command ClearPINCode
 */
class DoorLockClearPINCode : public ModelCommand
{
public:
    DoorLockClearPINCode() : ModelCommand("clear-pincode", kDoorLockClusterId, 0x07)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearPINCodeCommand(buffer->Start(), bufferSize, endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearPINCodeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearPINCodeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command ClearRFIDCode
 */
class DoorLockClearRFIDCode : public ModelCommand
{
public:
    DoorLockClearRFIDCode() : ModelCommand("clear-rfidcode", kDoorLockClusterId, 0x18)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearRFIDCodeCommand(buffer->Start(), bufferSize, endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearRFIDCodeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearRFIDCodeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command ClearWeekdaySchedule
 */
class DoorLockClearWeekdaySchedule : public ModelCommand
{
public:
    DoorLockClearWeekdaySchedule() : ModelCommand("clear-weekday-schedule", kDoorLockClusterId, 0x0D)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearWeekdayScheduleCommand(buffer->Start(), bufferSize, endPointId, mScheduleID, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearWeekdayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearWeekdayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
};

/*
 * Command ClearYearDaySchedule
 */
class DoorLockClearYearDaySchedule : public ModelCommand
{
public:
    DoorLockClearYearDaySchedule() : ModelCommand("clear-year-day-schedule", kDoorLockClusterId, 0x10)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearYearDayScheduleCommand(buffer->Start(), bufferSize, endPointId, mScheduleID, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearYearDayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearYearDayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
};

/*
 * Command GetHolidaySchedule
 */
class DoorLockGetHolidaySchedule : public ModelCommand
{
public:
    DoorLockGetHolidaySchedule() : ModelCommand("get-holiday-schedule", kDoorLockClusterId, 0x12)
    {
        AddArgument("holidayScheduleID", 0, UINT8_MAX, &mHolidayScheduleID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetHolidayScheduleCommand(buffer->Start(), bufferSize, endPointId, mHolidayScheduleID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetHolidayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetHolidayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHolidayScheduleID;
};

/*
 * Command GetPINCode
 */
class DoorLockGetPINCode : public ModelCommand
{
public:
    DoorLockGetPINCode() : ModelCommand("get-pincode", kDoorLockClusterId, 0x06)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetPINCodeCommand(buffer->Start(), bufferSize, endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetPINCodeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetPINCodeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command GetRFIDCode
 */
class DoorLockGetRFIDCode : public ModelCommand
{
public:
    DoorLockGetRFIDCode() : ModelCommand("get-rfidcode", kDoorLockClusterId, 0x17)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetRFIDCodeCommand(buffer->Start(), bufferSize, endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetRFIDCodeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetRFIDCodeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command GetUserType
 */
class DoorLockGetUserType : public ModelCommand
{
public:
    DoorLockGetUserType() : ModelCommand("get-user-type", kDoorLockClusterId, 0x15)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetUserTypeCommand(buffer->Start(), bufferSize, endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetUserTypeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetUserTypeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command GetWeekdaySchedule
 */
class DoorLockGetWeekdaySchedule : public ModelCommand
{
public:
    DoorLockGetWeekdaySchedule() : ModelCommand("get-weekday-schedule", kDoorLockClusterId, 0x0C)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetWeekdayScheduleCommand(buffer->Start(), bufferSize, endPointId, mScheduleID, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetWeekdayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetWeekdayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
};

/*
 * Command GetYearDaySchedule
 */
class DoorLockGetYearDaySchedule : public ModelCommand
{
public:
    DoorLockGetYearDaySchedule() : ModelCommand("get-year-day-schedule", kDoorLockClusterId, 0x0F)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetYearDayScheduleCommand(buffer->Start(), bufferSize, endPointId, mScheduleID, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetYearDayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetYearDayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
};

/*
 * Command LockDoor
 */
class DoorLockLockDoor : public ModelCommand
{
public:
    DoorLockLockDoor() : ModelCommand("lock-door", kDoorLockClusterId, 0x00)
    {
        AddArgument("pINOrRFIDCode", &mPINOrRFIDCode);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterLockDoorCommand(buffer->Start(), bufferSize, endPointId, mPINOrRFIDCode);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: LockDoorResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        LockDoorResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    char * mPINOrRFIDCode;
};

/*
 * Command SetHolidaySchedule
 */
class DoorLockSetHolidaySchedule : public ModelCommand
{
public:
    DoorLockSetHolidaySchedule() : ModelCommand("set-holiday-schedule", kDoorLockClusterId, 0x11)
    {
        AddArgument("holidayScheduleID", 0, UINT8_MAX, &mHolidayScheduleID);
        AddArgument("localStartTime", 0, UINT32_MAX, &mLocalStartTime);
        AddArgument("localEndTime", 0, UINT32_MAX, &mLocalEndTime);
        AddArgument("operatingModeDuringHoliday", 0, UINT8_MAX, &mOperatingModeDuringHoliday);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetHolidayScheduleCommand(buffer->Start(), bufferSize, endPointId, mHolidayScheduleID,
                                                              mLocalStartTime, mLocalEndTime, mOperatingModeDuringHoliday);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetHolidayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetHolidayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHolidayScheduleID;
    uint32_t mLocalStartTime;
    uint32_t mLocalEndTime;
    uint8_t mOperatingModeDuringHoliday;
};

/*
 * Command SetPINCode
 */
class DoorLockSetPINCode : public ModelCommand
{
public:
    DoorLockSetPINCode() : ModelCommand("set-pincode", kDoorLockClusterId, 0x05)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("userStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("userType", 0, UINT8_MAX, &mUserType);
        AddArgument("pIN", &mPIN);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetPINCodeCommand(buffer->Start(), bufferSize, endPointId, mUserID, mUserStatus, mUserType,
                                                      mPIN);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetPINCodeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetPINCodeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
    uint8_t mUserStatus;
    uint8_t mUserType;
    char * mPIN;
};

/*
 * Command SetRFIDCode
 */
class DoorLockSetRFIDCode : public ModelCommand
{
public:
    DoorLockSetRFIDCode() : ModelCommand("set-rfidcode", kDoorLockClusterId, 0x16)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("userStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("userType", 0, UINT8_MAX, &mUserType);
        AddArgument("rFIDCode", &mRFIDCode);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetRFIDCodeCommand(buffer->Start(), bufferSize, endPointId, mUserID, mUserStatus, mUserType,
                                                       mRFIDCode);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetRFIDCodeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetRFIDCodeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
    uint8_t mUserStatus;
    uint8_t mUserType;
    char * mRFIDCode;
};

/*
 * Command SetUserType
 */
class DoorLockSetUserType : public ModelCommand
{
public:
    DoorLockSetUserType() : ModelCommand("set-user-type", kDoorLockClusterId, 0x14)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("userType", 0, UINT8_MAX, &mUserType);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetUserTypeCommand(buffer->Start(), bufferSize, endPointId, mUserID, mUserType);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetUserTypeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetUserTypeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
    uint8_t mUserType;
};

/*
 * Command SetWeekdaySchedule
 */
class DoorLockSetWeekdaySchedule : public ModelCommand
{
public:
    DoorLockSetWeekdaySchedule() : ModelCommand("set-weekday-schedule", kDoorLockClusterId, 0x0B)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("daysMask", 0, UINT8_MAX, &mDaysMask);
        AddArgument("startHour", 0, UINT8_MAX, &mStartHour);
        AddArgument("startMinute", 0, UINT8_MAX, &mStartMinute);
        AddArgument("endHour", 0, UINT8_MAX, &mEndHour);
        AddArgument("endMinute", 0, UINT8_MAX, &mEndMinute);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetWeekdayScheduleCommand(buffer->Start(), bufferSize, endPointId, mScheduleID, mUserID,
                                                              mDaysMask, mStartHour, mStartMinute, mEndHour, mEndMinute);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetWeekdayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetWeekdayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
    uint8_t mDaysMask;
    uint8_t mStartHour;
    uint8_t mStartMinute;
    uint8_t mEndHour;
    uint8_t mEndMinute;
};

/*
 * Command SetYearDaySchedule
 */
class DoorLockSetYearDaySchedule : public ModelCommand
{
public:
    DoorLockSetYearDaySchedule() : ModelCommand("set-year-day-schedule", kDoorLockClusterId, 0x0E)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("localStartTime", 0, UINT32_MAX, &mLocalStartTime);
        AddArgument("localEndTime", 0, UINT32_MAX, &mLocalEndTime);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetYearDayScheduleCommand(buffer->Start(), bufferSize, endPointId, mScheduleID, mUserID,
                                                              mLocalStartTime, mLocalEndTime);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetYearDayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetYearDayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
    uint32_t mLocalStartTime;
    uint32_t mLocalEndTime;
};

/*
 * Command UnlockDoor
 */
class DoorLockUnlockDoor : public ModelCommand
{
public:
    DoorLockUnlockDoor() : ModelCommand("unlock-door", kDoorLockClusterId, 0x01)
    {
        AddArgument("pINOrRFIDCode", &mPINOrRFIDCode);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterUnlockDoorCommand(buffer->Start(), bufferSize, endPointId, mPINOrRFIDCode);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: UnlockDoorResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        UnlockDoorResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    char * mPINOrRFIDCode;
};

/*
 * Command UnlockWithTimeout
 */
class DoorLockUnlockWithTimeout : public ModelCommand
{
public:
    DoorLockUnlockWithTimeout() : ModelCommand("unlock-with-timeout", kDoorLockClusterId, 0x03)
    {
        AddArgument("timeoutInSeconds", 0, UINT16_MAX, &mTimeoutInSeconds);
        AddArgument("pINOrRFIDCode", &mPINOrRFIDCode);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterUnlockWithTimeoutCommand(buffer->Start(), bufferSize, endPointId, mTimeoutInSeconds,
                                                             mPINOrRFIDCode);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: UnlockWithTimeoutResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        UnlockWithTimeoutResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mTimeoutInSeconds;
    char * mPINOrRFIDCode;
};

/*
 * Discover attributes
 */
class DiscoverDoorLockAttributes : public ModelCommand
{
public:
    DiscoverDoorLockAttributes() : ModelCommand("discover", kDoorLockClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute LockState
 */
class ReadDoorLockLockState : public ModelCommand
{
public:
    ReadDoorLockLockState() : ModelCommand("read", kDoorLockClusterId, 0x00)
    {
        AddArgument("attr-name", "lock-state");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterReadLockStateAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportDoorLockLockState : public ModelCommand
{
public:
    ReportDoorLockLockState() : ModelCommand("report", kDoorLockClusterId, 0x06)
    {
        AddArgument("attr-name", "lock-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterReportLockStateAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval, mMaxInterval);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
};

/*
 * Attribute LockType
 */
class ReadDoorLockLockType : public ModelCommand
{
public:
    ReadDoorLockLockType() : ModelCommand("read", kDoorLockClusterId, 0x00)
    {
        AddArgument("attr-name", "lock-type");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterReadLockTypeAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ActuatorEnabled
 */
class ReadDoorLockActuatorEnabled : public ModelCommand
{
public:
    ReadDoorLockActuatorEnabled() : ModelCommand("read", kDoorLockClusterId, 0x00)
    {
        AddArgument("attr-name", "actuator-enabled");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeDoorLockClusterReadActuatorEnabledAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster Groups                                                      | 0x0004 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
| * AddGroupResponse                                                  |   0x00 |
| * GetGroupMembershipResponse                                        |   0x02 |
| * RemoveGroupResponse                                               |   0x03 |
| * ViewGroupResponse                                                 |   0x01 |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddGroup                                                          |   0x00 |
| * AddGroupIfIdentifying                                             |   0x05 |
| * GetGroupMembership                                                |   0x02 |
| * RemoveAllGroups                                                   |   0x04 |
| * RemoveGroup                                                       |   0x03 |
| * ViewGroup                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NameSupport                                                       | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command Response AddGroupResponse
 */
class AddGroupResponse : public ModelCommandResponse
{
public:
    AddGroupResponse() : ModelCommandResponse(0x00) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "AddGroupResponse (0x00):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // enum8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        return success;
    }
};

/*
 * Command Response GetGroupMembershipResponse
 */
class GetGroupMembershipResponse : public ModelCommandResponse
{
public:
    GetGroupMembershipResponse() : ModelCommandResponse(0x02) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetGroupMembershipResponse (0x02):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t capacity = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "capacity", capacity);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t groupCount = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "groupCount", groupCount);

        // uint16_t uint16[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t groupList = chip::Encoding::LittleEndian::Read16(message); // uint16
            ChipLogProgress(chipTool, "  %s: 0x%04x", "groupList", groupList);
        }

        return success;
    }
};

/*
 * Command Response RemoveGroupResponse
 */
class RemoveGroupResponse : public ModelCommandResponse
{
public:
    RemoveGroupResponse() : ModelCommandResponse(0x03) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "RemoveGroupResponse (0x03):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // enum8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        return success;
    }
};

/*
 * Command Response ViewGroupResponse
 */
class ViewGroupResponse : public ModelCommandResponse
{
public:
    ViewGroupResponse() : ModelCommandResponse(0x01) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ViewGroupResponse (0x01):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // enum8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        {
            uint8_t groupNameLen = chip::Encoding::Read8(message);                   // string
            ChipLogProgress(chipTool, "  %s: 0x%02x", "groupNameLen", groupNameLen); // string

            // FIXME Strings are not supported yet. For the moment the code just checks that
            // there is enough bytes in the buffer
            CHECK_MESSAGE_LENGTH(groupNameLen);
            message += groupNameLen;
        }

        return success;
    }
};

/*
 * Command AddGroup
 */
class GroupsAddGroup : public ModelCommand
{
public:
    GroupsAddGroup() : ModelCommand("add-group", kGroupsClusterId, 0x00)
    {
        AddArgument("groupId", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupId);
        AddArgument("groupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeGroupsClusterAddGroupCommand(buffer->Start(), bufferSize, endPointId, mGroupId, mGroupName);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: AddGroupResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        AddGroupResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupId;
    char * mGroupName;
};

/*
 * Command AddGroupIfIdentifying
 */
class GroupsAddGroupIfIdentifying : public ModelCommand
{
public:
    GroupsAddGroupIfIdentifying() : ModelCommand("add-group-if-identifying", kGroupsClusterId, 0x05)
    {
        AddArgument("groupId", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupId);
        AddArgument("groupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeGroupsClusterAddGroupIfIdentifyingCommand(buffer->Start(), bufferSize, endPointId, mGroupId, mGroupName);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupId;
    char * mGroupName;
};

/*
 * Command GetGroupMembership
 */
class GroupsGetGroupMembership : public ModelCommand
{
public:
    GroupsGetGroupMembership() : ModelCommand("get-group-membership", kGroupsClusterId, 0x02)
    {
        AddArgument("groupCount", 0, UINT8_MAX, &mGroupCount);
        // groupList is an array, but since chip-tool does not support variable
        // number of arguments, only a single instance is supported.
        AddArgument("groupList", 0, UINT16_MAX, &mGroupList);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeGroupsClusterGetGroupMembershipCommand(buffer->Start(), bufferSize, endPointId, mGroupCount, mGroupList);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetGroupMembershipResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetGroupMembershipResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mGroupCount;
    uint16_t mGroupList;
};

/*
 * Command RemoveAllGroups
 */
class GroupsRemoveAllGroups : public ModelCommand
{
public:
    GroupsRemoveAllGroups() : ModelCommand("remove-all-groups", kGroupsClusterId, 0x04) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeGroupsClusterRemoveAllGroupsCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command RemoveGroup
 */
class GroupsRemoveGroup : public ModelCommand
{
public:
    GroupsRemoveGroup() : ModelCommand("remove-group", kGroupsClusterId, 0x03)
    {
        AddArgument("groupId", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupId);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeGroupsClusterRemoveGroupCommand(buffer->Start(), bufferSize, endPointId, mGroupId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: RemoveGroupResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        RemoveGroupResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupId;
};

/*
 * Command ViewGroup
 */
class GroupsViewGroup : public ModelCommand
{
public:
    GroupsViewGroup() : ModelCommand("view-group", kGroupsClusterId, 0x01)
    {
        AddArgument("groupId", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupId);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeGroupsClusterViewGroupCommand(buffer->Start(), bufferSize, endPointId, mGroupId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ViewGroupResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ViewGroupResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupId;
};

/*
 * Discover attributes
 */
class DiscoverGroupsAttributes : public ModelCommand
{
public:
    DiscoverGroupsAttributes() : ModelCommand("discover", kGroupsClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeGroupsClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute NameSupport
 */
class ReadGroupsNameSupport : public ModelCommand
{
public:
    ReadGroupsNameSupport() : ModelCommand("read", kGroupsClusterId, 0x00)
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeGroupsClusterReadNameSupportAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster IASZone                                                     | 0x0500 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ZoneState                                                         | 0x0000 |
| * ZoneType                                                          | 0x0001 |
| * ZoneStatus                                                        | 0x0002 |
| * IASCIEAddress                                                     | 0x0010 |
| * ZoneID                                                            | 0x0011 |
\*----------------------------------------------------------------------------*/

/*
 * Discover attributes
 */
class DiscoverIASZoneAttributes : public ModelCommand
{
public:
    DiscoverIASZoneAttributes() : ModelCommand("discover", kIASZoneClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIASZoneClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ZoneState
 */
class ReadIASZoneZoneState : public ModelCommand
{
public:
    ReadIASZoneZoneState() : ModelCommand("read", kIASZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "zone-state");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIASZoneClusterReadZoneStateAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ZoneType
 */
class ReadIASZoneZoneType : public ModelCommand
{
public:
    ReadIASZoneZoneType() : ModelCommand("read", kIASZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "zone-type");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIASZoneClusterReadZoneTypeAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ZoneStatus
 */
class ReadIASZoneZoneStatus : public ModelCommand
{
public:
    ReadIASZoneZoneStatus() : ModelCommand("read", kIASZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "zone-status");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIASZoneClusterReadZoneStatusAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute IASCIEAddress
 */
class ReadIASZoneIASCIEAddress : public ModelCommand
{
public:
    ReadIASZoneIASCIEAddress() : ModelCommand("read", kIASZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "iascieaddress");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIASZoneClusterReadIASCIEAddressAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class WriteIASZoneIASCIEAddress : public ModelCommand
{
public:
    WriteIASZoneIASCIEAddress() : ModelCommand("write", kIASZoneClusterId, 0x01)
    {
        AddArgument("attr-name", "iascieaddress");
        AddArgument("attr-value", 0, UINT64_MAX, &mIASCIEAddress);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIASZoneClusterWriteIASCIEAddressAttribute(buffer->Start(), bufferSize, endPointId, mIASCIEAddress);
    }

    // Global Response: WriteAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        WriteAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint64_t mIASCIEAddress;
};

/*
 * Attribute ZoneID
 */
class ReadIASZoneZoneID : public ModelCommand
{
public:
    ReadIASZoneZoneID() : ModelCommand("read", kIASZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "zone-id");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIASZoneClusterReadZoneIDAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster Identify                                                    | 0x0003 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
| * IdentifyQueryResponse                                             |   0x00 |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Identify                                                          |   0x00 |
| * IdentifyQuery                                                     |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * IdentifyTime                                                      | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command Response IdentifyQueryResponse
 */
class IdentifyQueryResponse : public ModelCommandResponse
{
public:
    IdentifyQueryResponse() : ModelCommandResponse(0x00) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "IdentifyQueryResponse (0x00):");

        CHECK_MESSAGE_LENGTH(2);
        uint16_t timeout = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "timeout", timeout);

        return success;
    }
};

/*
 * Command Identify
 */
class IdentifyIdentify : public ModelCommand
{
public:
    IdentifyIdentify() : ModelCommand("identify", kIdentifyClusterId, 0x00)
    {
        AddArgument("identifyTime", 0, UINT16_MAX, &mIdentifyTime);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIdentifyClusterIdentifyCommand(buffer->Start(), bufferSize, endPointId, mIdentifyTime);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mIdentifyTime;
};

/*
 * Command IdentifyQuery
 */
class IdentifyIdentifyQuery : public ModelCommand
{
public:
    IdentifyIdentifyQuery() : ModelCommand("identify-query", kIdentifyClusterId, 0x01) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIdentifyClusterIdentifyQueryCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: IdentifyQueryResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        IdentifyQueryResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverIdentifyAttributes : public ModelCommand
{
public:
    DiscoverIdentifyAttributes() : ModelCommand("discover", kIdentifyClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIdentifyClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute IdentifyTime
 */
class ReadIdentifyIdentifyTime : public ModelCommand
{
public:
    ReadIdentifyIdentifyTime() : ModelCommand("read", kIdentifyClusterId, 0x00)
    {
        AddArgument("attr-name", "identify-time");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIdentifyClusterReadIdentifyTimeAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class WriteIdentifyIdentifyTime : public ModelCommand
{
public:
    WriteIdentifyIdentifyTime() : ModelCommand("write", kIdentifyClusterId, 0x01)
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mIdentifyTime);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeIdentifyClusterWriteIdentifyTimeAttribute(buffer->Start(), bufferSize, endPointId, mIdentifyTime);
    }

    // Global Response: WriteAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        WriteAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mIdentifyTime;
};

/*----------------------------------------------------------------------------*\
| Cluster Level                                                       | 0x0008 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Move                                                              |   0x01 |
| * MoveToLevel                                                       |   0x00 |
| * MoveToLevelWithOnOff                                              |   0x04 |
| * MoveWithOnOff                                                     |   0x05 |
| * Step                                                              |   0x02 |
| * StepWithOnOff                                                     |   0x06 |
| * Stop                                                              |   0x03 |
| * StopWithOnOff                                                     |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentLevel                                                      | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command Move
 */
class LevelMove : public ModelCommand
{
public:
    LevelMove() : ModelCommand("move", kLevelClusterId, 0x01)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT8_MAX, &mRate);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterMoveCommand(buffer->Start(), bufferSize, endPointId, mMoveMode, mRate, mOptionsMask,
                                             mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToLevel
 */
class LevelMoveToLevel : public ModelCommand
{
public:
    LevelMoveToLevel() : ModelCommand("move-to-level", kLevelClusterId, 0x00)
    {
        AddArgument("level", 0, UINT8_MAX, &mLevel);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterMoveToLevelCommand(buffer->Start(), bufferSize, endPointId, mLevel, mTransitionTime, mOptionsMask,
                                                    mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToLevelWithOnOff
 */
class LevelMoveToLevelWithOnOff : public ModelCommand
{
public:
    LevelMoveToLevelWithOnOff() : ModelCommand("move-to-level-with-on-off", kLevelClusterId, 0x04)
    {
        AddArgument("level", 0, UINT8_MAX, &mLevel);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterMoveToLevelWithOnOffCommand(buffer->Start(), bufferSize, endPointId, mLevel, mTransitionTime,
                                                             mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveWithOnOff
 */
class LevelMoveWithOnOff : public ModelCommand
{
public:
    LevelMoveWithOnOff() : ModelCommand("move-with-on-off", kLevelClusterId, 0x05)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT8_MAX, &mRate);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterMoveWithOnOffCommand(buffer->Start(), bufferSize, endPointId, mMoveMode, mRate, mOptionsMask,
                                                      mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command Step
 */
class LevelStep : public ModelCommand
{
public:
    LevelStep() : ModelCommand("step", kLevelClusterId, 0x02)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterStepCommand(buffer->Start(), bufferSize, endPointId, mStepMode, mStepSize, mTransitionTime,
                                             mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepWithOnOff
 */
class LevelStepWithOnOff : public ModelCommand
{
public:
    LevelStepWithOnOff() : ModelCommand("step-with-on-off", kLevelClusterId, 0x06)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterStepWithOnOffCommand(buffer->Start(), bufferSize, endPointId, mStepMode, mStepSize,
                                                      mTransitionTime, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command Stop
 */
class LevelStop : public ModelCommand
{
public:
    LevelStop() : ModelCommand("stop", kLevelClusterId, 0x03)
    {
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterStopCommand(buffer->Start(), bufferSize, endPointId, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StopWithOnOff
 */
class LevelStopWithOnOff : public ModelCommand
{
public:
    LevelStopWithOnOff() : ModelCommand("stop-with-on-off", kLevelClusterId, 0x07)
    {
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterStopWithOnOffCommand(buffer->Start(), bufferSize, endPointId, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Discover attributes
 */
class DiscoverLevelAttributes : public ModelCommand
{
public:
    DiscoverLevelAttributes() : ModelCommand("discover", kLevelClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentLevel
 */
class ReadLevelCurrentLevel : public ModelCommand
{
public:
    ReadLevelCurrentLevel() : ModelCommand("read", kLevelClusterId, 0x00)
    {
        AddArgument("attr-name", "current-level");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterReadCurrentLevelAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportLevelCurrentLevel : public ModelCommand
{
public:
    ReportLevelCurrentLevel() : ModelCommand("report", kLevelClusterId, 0x06)
    {
        AddArgument("attr-name", "current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT8_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeLevelClusterReportCurrentLevelAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval, mMaxInterval,
                                                             mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint8_t mChange;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOff                                                       | 0x0006 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Off                                                               |   0x00 |
| * On                                                                |   0x01 |
| * Toggle                                                            |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OnOff                                                             | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command Off
 */
class OnOffOff : public ModelCommand
{
public:
    OnOffOff() : ModelCommand("off", kOnOffClusterId, 0x00) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeOnOffClusterOffCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command On
 */
class OnOffOn : public ModelCommand
{
public:
    OnOffOn() : ModelCommand("on", kOnOffClusterId, 0x01) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeOnOffClusterOnCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command Toggle
 */
class OnOffToggle : public ModelCommand
{
public:
    OnOffToggle() : ModelCommand("toggle", kOnOffClusterId, 0x02) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeOnOffClusterToggleCommand(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverOnOffAttributes : public ModelCommand
{
public:
    DiscoverOnOffAttributes() : ModelCommand("discover", kOnOffClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeOnOffClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute OnOff
 */
class ReadOnOffOnOff : public ModelCommand
{
public:
    ReadOnOffOnOff() : ModelCommand("read", kOnOffClusterId, 0x00)
    {
        AddArgument("attr-name", "on-off");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeOnOffClusterReadOnOffAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportOnOffOnOff : public ModelCommand
{
public:
    ReportOnOffOnOff() : ModelCommand("report", kOnOffClusterId, 0x06)
    {
        AddArgument("attr-name", "on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeOnOffClusterReportOnOffAttribute(buffer->Start(), bufferSize, endPointId, mMinInterval, mMaxInterval);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
};

/*----------------------------------------------------------------------------*\
| Cluster Scenes                                                      | 0x0005 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
| * AddSceneResponse                                                  |   0x00 |
| * GetSceneMembershipResponse                                        |   0x06 |
| * RemoveAllScenesResponse                                           |   0x03 |
| * RemoveSceneResponse                                               |   0x02 |
| * StoreSceneResponse                                                |   0x04 |
| * ViewSceneResponse                                                 |   0x01 |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddScene                                                          |   0x00 |
| * GetSceneMembership                                                |   0x06 |
| * RecallScene                                                       |   0x05 |
| * RemoveAllScenes                                                   |   0x03 |
| * RemoveScene                                                       |   0x02 |
| * StoreScene                                                        |   0x04 |
| * ViewScene                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SceneCount                                                        | 0x0000 |
| * CurrentScene                                                      | 0x0001 |
| * CurrentGroup                                                      | 0x0002 |
| * SceneValid                                                        | 0x0003 |
| * NameSupport                                                       | 0x0004 |
\*----------------------------------------------------------------------------*/

/*
 * Command Response AddSceneResponse
 */
class AddSceneResponse : public ModelCommandResponse
{
public:
    AddSceneResponse() : ModelCommandResponse(0x00) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "AddSceneResponse (0x00):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t sceneId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneId", sceneId);

        return success;
    }
};

/*
 * Command Response GetSceneMembershipResponse
 */
class GetSceneMembershipResponse : public ModelCommandResponse
{
public:
    GetSceneMembershipResponse() : ModelCommandResponse(0x06) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetSceneMembershipResponse (0x06):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t capacity = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "capacity", capacity);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        // uint8_t uint8[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t sceneList = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneList", sceneList);
        }

        return success;
    }
};

/*
 * Command Response RemoveAllScenesResponse
 */
class RemoveAllScenesResponse : public ModelCommandResponse
{
public:
    RemoveAllScenesResponse() : ModelCommandResponse(0x03) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "RemoveAllScenesResponse (0x03):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        return success;
    }
};

/*
 * Command Response RemoveSceneResponse
 */
class RemoveSceneResponse : public ModelCommandResponse
{
public:
    RemoveSceneResponse() : ModelCommandResponse(0x02) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "RemoveSceneResponse (0x02):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t sceneId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneId", sceneId);

        return success;
    }
};

/*
 * Command Response StoreSceneResponse
 */
class StoreSceneResponse : public ModelCommandResponse
{
public:
    StoreSceneResponse() : ModelCommandResponse(0x04) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "StoreSceneResponse (0x04):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t sceneId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneId", sceneId);

        return success;
    }
};

/*
 * Command Response ViewSceneResponse
 */
class ViewSceneResponse : public ModelCommandResponse
{
public:
    ViewSceneResponse() : ModelCommandResponse(0x01) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ViewSceneResponse (0x01):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t sceneId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneId", sceneId);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t transitionTime = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "transitionTime", transitionTime);

        CHECK_MESSAGE_LENGTH(1);
        {
            uint8_t sceneNameLen = chip::Encoding::Read8(message);                   // SSceneName
            ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneNameLen", sceneNameLen); // SSceneName

            // FIXME Strings are not supported yet. For the moment the code just checks that
            // there is enough bytes in the buffer
            CHECK_MESSAGE_LENGTH(sceneNameLen);
            message += sceneNameLen;
        }

        // struct SExtensionFieldSetList[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t clusterId = chip::Encoding::LittleEndian::Read16(message); // uint16
            ChipLogProgress(chipTool, "  %s: 0x%04x", "clusterId", clusterId);

            CHECK_MESSAGE_LENGTH(1);
            {
                uint8_t extensionFieldSetLen = chip::Encoding::Read8(message);                           // octstr
                ChipLogProgress(chipTool, "  %s: 0x%02x", "extensionFieldSetLen", extensionFieldSetLen); // octstr

                // FIXME Strings are not supported yet. For the moment the code just checks that
                // there is enough bytes in the buffer
                CHECK_MESSAGE_LENGTH(extensionFieldSetLen);
                message += extensionFieldSetLen;
            }
        }

        return success;
    }
};

/*
 * Command AddScene
 */
class ScenesAddScene : public ModelCommand
{
public:
    ScenesAddScene() : ModelCommand("add-scene", kScenesClusterId, 0x00)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("sceneName", &mSceneName);
        // extensionFieldSets is an array, but since chip-tool does not support variable
        // number of arguments, only a single instance is supported.
        AddArgument("clusterId", 0, UINT16_MAX, &mClusterId);
        AddArgument("extensionFieldSet", &mExtensionFieldSet);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterAddSceneCommand(buffer->Start(), bufferSize, endPointId, mGroupID, mSceneID, mTransitionTime,
                                                  mSceneName, mClusterId, mExtensionFieldSet);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: AddSceneResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        AddSceneResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
    uint16_t mTransitionTime;
    char * mSceneName;
    uint16_t mClusterId;
    char * mExtensionFieldSet;
};

/*
 * Command GetSceneMembership
 */
class ScenesGetSceneMembership : public ModelCommand
{
public:
    ScenesGetSceneMembership() : ModelCommand("get-scene-membership", kScenesClusterId, 0x06)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterGetSceneMembershipCommand(buffer->Start(), bufferSize, endPointId, mGroupID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetSceneMembershipResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetSceneMembershipResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
};

/*
 * Command RecallScene
 */
class ScenesRecallScene : public ModelCommand
{
public:
    ScenesRecallScene() : ModelCommand("recall-scene", kScenesClusterId, 0x05)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterRecallSceneCommand(buffer->Start(), bufferSize, endPointId, mGroupID, mSceneID, mTransitionTime);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
    uint16_t mTransitionTime;
};

/*
 * Command RemoveAllScenes
 */
class ScenesRemoveAllScenes : public ModelCommand
{
public:
    ScenesRemoveAllScenes() : ModelCommand("remove-all-scenes", kScenesClusterId, 0x03)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterRemoveAllScenesCommand(buffer->Start(), bufferSize, endPointId, mGroupID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: RemoveAllScenesResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        RemoveAllScenesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
};

/*
 * Command RemoveScene
 */
class ScenesRemoveScene : public ModelCommand
{
public:
    ScenesRemoveScene() : ModelCommand("remove-scene", kScenesClusterId, 0x02)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterRemoveSceneCommand(buffer->Start(), bufferSize, endPointId, mGroupID, mSceneID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: RemoveSceneResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        RemoveSceneResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
};

/*
 * Command StoreScene
 */
class ScenesStoreScene : public ModelCommand
{
public:
    ScenesStoreScene() : ModelCommand("store-scene", kScenesClusterId, 0x04)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterStoreSceneCommand(buffer->Start(), bufferSize, endPointId, mGroupID, mSceneID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: StoreSceneResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        StoreSceneResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
};

/*
 * Command ViewScene
 */
class ScenesViewScene : public ModelCommand
{
public:
    ScenesViewScene() : ModelCommand("view-scene", kScenesClusterId, 0x01)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterViewSceneCommand(buffer->Start(), bufferSize, endPointId, mGroupID, mSceneID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ViewSceneResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ViewSceneResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
};

/*
 * Discover attributes
 */
class DiscoverScenesAttributes : public ModelCommand
{
public:
    DiscoverScenesAttributes() : ModelCommand("discover", kScenesClusterId, 0x0c) { ModelCommand::AddArguments(); }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute SceneCount
 */
class ReadScenesSceneCount : public ModelCommand
{
public:
    ReadScenesSceneCount() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "scene-count");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterReadSceneCountAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentScene
 */
class ReadScenesCurrentScene : public ModelCommand
{
public:
    ReadScenesCurrentScene() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "current-scene");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterReadCurrentSceneAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentGroup
 */
class ReadScenesCurrentGroup : public ModelCommand
{
public:
    ReadScenesCurrentGroup() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "current-group");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterReadCurrentGroupAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute SceneValid
 */
class ReadScenesSceneValid : public ModelCommand
{
public:
    ReadScenesSceneValid() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "scene-valid");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterReadSceneValidAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute NameSupport
 */
class ReadScenesNameSupport : public ModelCommand
{
public:
    ReadScenesNameSupport() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeScenesClusterReadNameSupportAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster TemperatureMeasurement                                      | 0x0402 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Discover attributes
 */
class DiscoverTemperatureMeasurementAttributes : public ModelCommand
{
public:
    DiscoverTemperatureMeasurementAttributes() : ModelCommand("discover", kTempMeasurementClusterId, 0x0c)
    {
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterDiscoverAttributes(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute MeasuredValue
 */
class ReadTemperatureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMeasuredValue() : ModelCommand("read", kTempMeasurementClusterId, 0x00)
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterReadMeasuredValueAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportTemperatureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportTemperatureMeasurementMeasuredValue() : ModelCommand("report", kTempMeasurementClusterId, 0x06)
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", INT16_MIN, INT16_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterReportMeasuredValueAttribute(buffer->Start(), bufferSize, endPointId,
                                                                               mMinInterval, mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    int16_t mChange;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadTemperatureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMinMeasuredValue() : ModelCommand("read", kTempMeasurementClusterId, 0x00)
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterReadMinMeasuredValueAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadTemperatureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMaxMeasuredValue() : ModelCommand("read", kTempMeasurementClusterId, 0x00)
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    uint16_t EncodeCommand(const PacketBufferHandle & buffer, uint16_t bufferSize, uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterReadMaxMeasuredValueAttribute(buffer->Start(), bufferSize, endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Register all Clusters commands                                               |
\*----------------------------------------------------------------------------*/
void registerClusterBarrierControl(Commands & commands)
{
    const char * clusterName = "BarrierControl";

    commands_list clusterCommands = {
        make_unique<BarrierControlGoToPercent>(),         make_unique<BarrierControlStop>(),
        make_unique<DiscoverBarrierControlAttributes>(),  make_unique<ReadBarrierControlMovingState>(),
        make_unique<ReportBarrierControlMovingState>(),   make_unique<ReadBarrierControlSafetyStatus>(),
        make_unique<ReportBarrierControlSafetyStatus>(),  make_unique<ReadBarrierControlCapabilities>(),
        make_unique<ReadBarrierControlBarrierPosition>(), make_unique<ReportBarrierControlBarrierPosition>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterBasic(Commands & commands)
{
    const char * clusterName = "Basic";

    commands_list clusterCommands = {
        make_unique<BasicResetToFactoryDefaults>(),
        make_unique<DiscoverBasicAttributes>(),
        make_unique<ReadBasicZCLVersion>(),
        make_unique<ReadBasicPowerSource>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterColorControl(Commands & commands)
{
    const char * clusterName = "ColorControl";

    commands_list clusterCommands = {
        make_unique<ColorControlMoveColor>(),
        make_unique<ColorControlMoveColorTemperature>(),
        make_unique<ColorControlMoveHue>(),
        make_unique<ColorControlMoveSaturation>(),
        make_unique<ColorControlMoveToColor>(),
        make_unique<ColorControlMoveToColorTemperature>(),
        make_unique<ColorControlMoveToHue>(),
        make_unique<ColorControlMoveToHueAndSaturation>(),
        make_unique<ColorControlMoveToSaturation>(),
        make_unique<ColorControlStepColor>(),
        make_unique<ColorControlStepColorTemperature>(),
        make_unique<ColorControlStepHue>(),
        make_unique<ColorControlStepSaturation>(),
        make_unique<ColorControlStopMoveStep>(),
        make_unique<DiscoverColorControlAttributes>(),
        make_unique<ReadColorControlCurrentHue>(),
        make_unique<ReportColorControlCurrentHue>(),
        make_unique<ReadColorControlCurrentSaturation>(),
        make_unique<ReportColorControlCurrentSaturation>(),
        make_unique<ReadColorControlRemainingTime>(),
        make_unique<ReadColorControlCurrentX>(),
        make_unique<ReportColorControlCurrentX>(),
        make_unique<ReadColorControlCurrentY>(),
        make_unique<ReportColorControlCurrentY>(),
        make_unique<ReadColorControlColorTemperatureMireds>(),
        make_unique<ReportColorControlColorTemperatureMireds>(),
        make_unique<ReadColorControlColorMode>(),
        make_unique<ReadColorControlOptions>(),
        make_unique<WriteColorControlOptions>(),
        make_unique<ReadColorControlNumberOfPrimaries>(),
        make_unique<ReadColorControlPrimary1X>(),
        make_unique<ReadColorControlPrimary1Y>(),
        make_unique<ReadColorControlPrimary1Intensity>(),
        make_unique<ReadColorControlPrimary2X>(),
        make_unique<ReadColorControlPrimary2Y>(),
        make_unique<ReadColorControlPrimary2Intensity>(),
        make_unique<ReadColorControlPrimary3X>(),
        make_unique<ReadColorControlPrimary3Y>(),
        make_unique<ReadColorControlPrimary3Intensity>(),
        make_unique<ReadColorControlPrimary4X>(),
        make_unique<ReadColorControlPrimary4Y>(),
        make_unique<ReadColorControlPrimary4Intensity>(),
        make_unique<ReadColorControlPrimary5X>(),
        make_unique<ReadColorControlPrimary5Y>(),
        make_unique<ReadColorControlPrimary5Intensity>(),
        make_unique<ReadColorControlPrimary6X>(),
        make_unique<ReadColorControlPrimary6Y>(),
        make_unique<ReadColorControlPrimary6Intensity>(),
        make_unique<ReadColorControlEnhancedCurrentHue>(),
        make_unique<ReadColorControlEnhancedColorMode>(),
        make_unique<ReadColorControlColorLoopActive>(),
        make_unique<ReadColorControlColorLoopDirection>(),
        make_unique<ReadColorControlColorLoopTime>(),
        make_unique<ReadColorControlColorLoopStartEnhancedHue>(),
        make_unique<ReadColorControlColorLoopStoredEnhancedHue>(),
        make_unique<ReadColorControlColorCapabilities>(),
        make_unique<ReadColorControlColorTempPhysicalMinMireds>(),
        make_unique<ReadColorControlColorTempPhysicalMaxMireds>(),
        make_unique<ReadColorControlCoupleColorTempToLevelMinMireds>(),
        make_unique<ReadColorControlStartUpColorTemperatureMireds>(),
        make_unique<WriteColorControlStartUpColorTemperatureMireds>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterDoorLock(Commands & commands)
{
    const char * clusterName = "DoorLock";

    commands_list clusterCommands = {
        make_unique<DoorLockClearAllPINCodes>(),     make_unique<DoorLockClearAllRFIDCodes>(),
        make_unique<DoorLockClearHolidaySchedule>(), make_unique<DoorLockClearPINCode>(),
        make_unique<DoorLockClearRFIDCode>(),        make_unique<DoorLockClearWeekdaySchedule>(),
        make_unique<DoorLockClearYearDaySchedule>(), make_unique<DoorLockGetHolidaySchedule>(),
        make_unique<DoorLockGetPINCode>(),           make_unique<DoorLockGetRFIDCode>(),
        make_unique<DoorLockGetUserType>(),          make_unique<DoorLockGetWeekdaySchedule>(),
        make_unique<DoorLockGetYearDaySchedule>(),   make_unique<DoorLockLockDoor>(),
        make_unique<DoorLockSetHolidaySchedule>(),   make_unique<DoorLockSetPINCode>(),
        make_unique<DoorLockSetRFIDCode>(),          make_unique<DoorLockSetUserType>(),
        make_unique<DoorLockSetWeekdaySchedule>(),   make_unique<DoorLockSetYearDaySchedule>(),
        make_unique<DoorLockUnlockDoor>(),           make_unique<DoorLockUnlockWithTimeout>(),
        make_unique<DiscoverDoorLockAttributes>(),   make_unique<ReadDoorLockLockState>(),
        make_unique<ReportDoorLockLockState>(),      make_unique<ReadDoorLockLockType>(),
        make_unique<ReadDoorLockActuatorEnabled>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterGroups(Commands & commands)
{
    const char * clusterName = "Groups";

    commands_list clusterCommands = {
        make_unique<GroupsAddGroup>(),           make_unique<GroupsAddGroupIfIdentifying>(),
        make_unique<GroupsGetGroupMembership>(), make_unique<GroupsRemoveAllGroups>(),
        make_unique<GroupsRemoveGroup>(),        make_unique<GroupsViewGroup>(),
        make_unique<DiscoverGroupsAttributes>(), make_unique<ReadGroupsNameSupport>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterIASZone(Commands & commands)
{
    const char * clusterName = "IASZone";

    commands_list clusterCommands = {
        make_unique<DiscoverIASZoneAttributes>(), make_unique<ReadIASZoneZoneState>(),     make_unique<ReadIASZoneZoneType>(),
        make_unique<ReadIASZoneZoneStatus>(),     make_unique<ReadIASZoneIASCIEAddress>(), make_unique<WriteIASZoneIASCIEAddress>(),
        make_unique<ReadIASZoneZoneID>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterIdentify(Commands & commands)
{
    const char * clusterName = "Identify";

    commands_list clusterCommands = {
        make_unique<IdentifyIdentify>(),           make_unique<IdentifyIdentifyQuery>(),
        make_unique<DiscoverIdentifyAttributes>(), make_unique<ReadIdentifyIdentifyTime>(),
        make_unique<WriteIdentifyIdentifyTime>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterLevel(Commands & commands)
{
    const char * clusterName = "Level";

    commands_list clusterCommands = {
        make_unique<LevelMove>(),
        make_unique<LevelMoveToLevel>(),
        make_unique<LevelMoveToLevelWithOnOff>(),
        make_unique<LevelMoveWithOnOff>(),
        make_unique<LevelStep>(),
        make_unique<LevelStepWithOnOff>(),
        make_unique<LevelStop>(),
        make_unique<LevelStopWithOnOff>(),
        make_unique<DiscoverLevelAttributes>(),
        make_unique<ReadLevelCurrentLevel>(),
        make_unique<ReportLevelCurrentLevel>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterOnOff(Commands & commands)
{
    const char * clusterName = "OnOff";

    commands_list clusterCommands = {
        make_unique<OnOffOff>(),       make_unique<OnOffOn>(),
        make_unique<OnOffToggle>(),    make_unique<DiscoverOnOffAttributes>(),
        make_unique<ReadOnOffOnOff>(), make_unique<ReportOnOffOnOff>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterScenes(Commands & commands)
{
    const char * clusterName = "Scenes";

    commands_list clusterCommands = {
        make_unique<ScenesAddScene>(),         make_unique<ScenesGetSceneMembership>(), make_unique<ScenesRecallScene>(),
        make_unique<ScenesRemoveAllScenes>(),  make_unique<ScenesRemoveScene>(),        make_unique<ScenesStoreScene>(),
        make_unique<ScenesViewScene>(),        make_unique<DiscoverScenesAttributes>(), make_unique<ReadScenesSceneCount>(),
        make_unique<ReadScenesCurrentScene>(), make_unique<ReadScenesCurrentGroup>(),   make_unique<ReadScenesSceneValid>(),
        make_unique<ReadScenesNameSupport>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterTempMeasurement(Commands & commands)
{
    const char * clusterName = "TemperatureMeasurement";

    commands_list clusterCommands = {
        make_unique<DiscoverTemperatureMeasurementAttributes>(),   make_unique<ReadTemperatureMeasurementMeasuredValue>(),
        make_unique<ReportTemperatureMeasurementMeasuredValue>(),  make_unique<ReadTemperatureMeasurementMinMeasuredValue>(),
        make_unique<ReadTemperatureMeasurementMaxMeasuredValue>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusters(Commands & commands)
{
    registerClusterBarrierControl(commands);
    registerClusterBasic(commands);
    registerClusterColorControl(commands);
    registerClusterDoorLock(commands);
    registerClusterGroups(commands);
    registerClusterIASZone(commands);
    registerClusterIdentify(commands);
    registerClusterLevel(commands);
    registerClusterOnOff(commands);
    registerClusterScenes(commands);
    registerClusterTempMeasurement(commands);
}
