/**
 *
 *    Copyright (c) 2020 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
// This file is generated by ZAP.  Please do not edit manually.
//
//

#pragma once

#include "ModelCommand.h"
#include "ModelCommandResponse.h"

#include <limits>

#include <app/util/basic-types.h>
#include <support/SafeInt.h>

#define CHECK_MESSAGE_LENGTH(value)                                                                                                \
    if (!chip::CanCastTo<uint16_t>(value))                                                                                         \
    {                                                                                                                              \
        ChipLogError(chipTool, "CHECK_MESSAGE_LENGTH expects a uint16_t value, got: %d", value);                                   \
        return false;                                                                                                              \
    }                                                                                                                              \
                                                                                                                                   \
    if (messageLen < value)                                                                                                        \
    {                                                                                                                              \
        ChipLogError(chipTool, "Unexpected response length: %d", messageLen);                                                      \
        return false;                                                                                                              \
    }                                                                                                                              \
                                                                                                                                   \
    messageLen = static_cast<uint16_t>(messageLen - static_cast<uint16_t>(value));

typedef enum
{
    EMBER_ZCL_STATUS_SUCCESS                      = 0x00,
    EMBER_ZCL_STATUS_FAILURE                      = 0x01,
    EMBER_ZCL_STATUS_REQUEST_DENIED               = 0x70,
    EMBER_ZCL_STATUS_MULTIPLE_REQUEST_NOT_ALLOWED = 0x71,
    EMBER_ZCL_STATUS_INDICATION_REDIRECTION_TO_AP = 0x72,
    EMBER_ZCL_STATUS_PREFERENCE_DENIED            = 0x73,
    EMBER_ZCL_STATUS_PREFERENCE_IGNORED           = 0x74,
    EMBER_ZCL_STATUS_NOT_AUTHORIZED               = 0x7E,
    EMBER_ZCL_STATUS_RESERVED_FIELD_NOT_ZERO      = 0x7F,
    EMBER_ZCL_STATUS_MALFORMED_COMMAND            = 0x80,
    EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND        = 0x81,
    EMBER_ZCL_STATUS_UNSUP_GENERAL_COMMAND        = 0x82,
    EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND  = 0x83,
    EMBER_ZCL_STATUS_UNSUP_MANUF_GENERAL_COMMAND  = 0x84,
    EMBER_ZCL_STATUS_INVALID_FIELD                = 0x85,
    EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE        = 0x86,
    EMBER_ZCL_STATUS_INVALID_VALUE                = 0x87,
    EMBER_ZCL_STATUS_READ_ONLY                    = 0x88,
    EMBER_ZCL_STATUS_INSUFFICIENT_SPACE           = 0x89,
    EMBER_ZCL_STATUS_DUPLICATE_EXISTS             = 0x8A,
    EMBER_ZCL_STATUS_NOT_FOUND                    = 0x8B,
    EMBER_ZCL_STATUS_UNREPORTABLE_ATTRIBUTE       = 0x8C,
    EMBER_ZCL_STATUS_INVALID_DATA_TYPE            = 0x8D,
    EMBER_ZCL_STATUS_INVALID_SELECTOR             = 0x8E,
    EMBER_ZCL_STATUS_WRITE_ONLY                   = 0x8F,
    EMBER_ZCL_STATUS_INCONSISTENT_STARTUP_STATE   = 0x90,
    EMBER_ZCL_STATUS_DEFINED_OUT_OF_BAND          = 0x91,
    EMBER_ZCL_STATUS_INCONSISTENT                 = 0x92,
    EMBER_ZCL_STATUS_ACTION_DENIED                = 0x93,
    EMBER_ZCL_STATUS_TIMEOUT                      = 0x94,
    EMBER_ZCL_STATUS_ABORT                        = 0x95,
    EMBER_ZCL_STATUS_INVALID_IMAGE                = 0x96,
    EMBER_ZCL_STATUS_WAIT_FOR_DATA                = 0x97,
    EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE           = 0x98,
    EMBER_ZCL_STATUS_REQUIRE_MORE_IMAGE           = 0x99,
    EMBER_ZCL_STATUS_HARDWARE_FAILURE             = 0xC0,
    EMBER_ZCL_STATUS_SOFTWARE_FAILURE             = 0xC1,
    EMBER_ZCL_STATUS_CALIBRATION_ERROR            = 0xC2,
    EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER          = 0xC3,
} EmberAfStatus;

bool CheckStatus(uint8_t status)
{
    bool success = false;

    switch (status)
    {
    case EMBER_ZCL_STATUS_SUCCESS:
        success = true;
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_SUCCESS (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_FAILURE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_FAILURE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_REQUEST_DENIED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_REQUEST_DENIED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_MULTIPLE_REQUEST_NOT_ALLOWED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_REQUEST_NOT_ALLOWED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INDICATION_REDIRECTION_TO_AP:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INDICATION_REDIRECTION_TO_AP (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_PREFERENCE_DENIED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_PREFERENCE_DENIED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_PREFERENCE_IGNORED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_PREFERENCE_IGNORED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_NOT_AUTHORIZED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_NOT_AUTHORIZED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_RESERVED_FIELD_NOT_ZERO:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_RESERVED_FIELD_NOT_ZERO (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_MALFORMED_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_MALFORMED_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUP_GENERAL_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUP_GENERAL_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUP_MANUF_GENERAL_COMMAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUP_MANUF_GENERAL_COMMAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_FIELD:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_FIELD (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_VALUE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_VALUE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_READ_ONLY:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_READ_ONLY (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INSUFFICIENT_SPACE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INSUFFICIENT_SPACE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_DUPLICATE_EXISTS:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_DUPLICATE_EXISTS (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_NOT_FOUND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_NOT_FOUND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNREPORTABLE_ATTRIBUTE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNREPORTABLE_ATTRIBUTE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_DATA_TYPE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_DATA_TYPE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_SELECTOR:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_SELECTOR (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_WRITE_ONLY:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_WRITE_ONLY (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INCONSISTENT_STARTUP_STATE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INCONSISTENT_STARTUP_STATE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_DEFINED_OUT_OF_BAND:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_DEFINED_OUT_Of_BAND (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INCONSISTENT:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INCONSISTENT (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_ACTION_DENIED:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_ACTION_DENIED (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_TIMEOUT:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_TIMEOUT (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_ABORT:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_ABORT (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_INVALID_IMAGE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_INVALID_IMAGE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_WAIT_FOR_DATA:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_WAIT_FOR_DATA (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_REQUIRE_MORE_IMAGE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_REQUIRE_MORE_IMAGE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_HARDWARE_FAILURE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_HARDWARE_FAILURE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_SOFTWARE_FAILURE:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_SOFTWARE_FAILURE (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_CALIBRATION_ERROR:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_CALIBRATION_ERROR (0x%02x)", status);
        break;
    case EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER:
        ChipLogProgress(chipTool, "  status: EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER (0x%02x)", status);
        break;
    default:
        ChipLogError(chipTool, "Unknow status: 0x%02x", status);
        break;
    }

    return success;
}

bool ReadAttributeValue(uint8_t *& message, uint16_t & messageLen)
{
    CHECK_MESSAGE_LENGTH(1);
    uint8_t type = chip::Encoding::Read8(message);
    ChipLogProgress(chipTool, "  type: 0x%02x", type);

    // FIXME: Should we have a mapping of type ids to types, based on
    // table 2.6.2.2 in Rev 8 of the ZCL spec?
    switch (type)
    {
    case 0x00: // nodata / No data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x08: // data8 / 8-bit data
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x09: // data16 / 16-bit data
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0x0A: // data24 / 24-bit data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 3;
        break;
    case 0x0B: // data32 / 32-bit data
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0x0C: // data40 / 40-bit data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 5;
        break;
    case 0x0D: // data48 / 48-bit data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 6;
        break;
    case 0x0E: // data56 / 56-bit data
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 7;
        break;
    case 0x0F: // data64 / 64-bit data
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: 0x%16x", chip::Encoding::LittleEndian::Read64(message));
        return true;
        break;
    case 0x10: // bool / Boolean
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x18: // map8 / 8-bit bitmap
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x19: // map16 / 16-bit bitmap
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0x1A: // map24 / 24-bit bitmap
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 3;
        break;
    case 0x1B: // map32 / 32-bit bitmap
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0x1C: // map40 / 40-bit bitmap
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 5;
        break;
    case 0x1D: // map48 / 48-bit bitmap
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 6;
        break;
    case 0x1E: // map56 / 56-bit bitmap
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 7;
        break;
    case 0x1F: // map64 / 64-bit bitmap
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: 0x%16x", chip::Encoding::LittleEndian::Read64(message));
        return true;
        break;
    case 0x20: // uint8 / Unsigned  8-bit integer
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x21: // uint16 / Unsigned 16-bit integer
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0x22: // uint24 / Unsigned 24-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 3;
        break;
    case 0x23: // uint32 / Unsigned 32-bit integer
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0x24: // uint40 / Unsigned 40-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 5;
        break;
    case 0x25: // uint48 / Unsigned 48-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 6;
        break;
    case 0x26: // uint56 / Unsigned 56-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 7;
        break;
    case 0x27: // uint64 / Unsigned 64-bit integer
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: 0x%16x", chip::Encoding::LittleEndian::Read64(message));
        return true;
        break;
    case 0x28: // int8 / Signed 8-bit integer
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: %d", chip::CastToSigned(chip::Encoding::Read8(message)));
        return true;
        break;
    case 0x29: // int16 / Signed 16-bit integer
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: %d", chip::CastToSigned(chip::Encoding::LittleEndian::Read16(message)));
        return true;
        break;
    case 0x2A: // int24 / Signed 24-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 3;
        break;
    case 0x2B: // int32 / Signed 32-bit integer
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: %d", chip::CastToSigned(chip::Encoding::LittleEndian::Read32(message)));
        return true;
        break;
    case 0x2C: // int40 / Signed 40-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 5;
        break;
    case 0x2D: // int48 / Signed 48-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 6;
        break;
    case 0x2E: // int56 / Signed 56-bit integer
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 7;
        break;
    case 0x2F: // int64 / Signed 64-bit integer
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: %d", chip::CastToSigned(chip::Encoding::LittleEndian::Read64(message)));
        return true;
        break;
    case 0x30: // enum8 / 8-bit enumeration
        CHECK_MESSAGE_LENGTH(1);
        ChipLogProgress(chipTool, "  value: 0x%02x", chip::Encoding::Read8(message));
        return true;
        break;
    case 0x31: // enum16 / 16-bit enumeration
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0x38: // semi / Semi-precision
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x39: // single / Single precision
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x3A: // double / Double precision
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x41: // octstr / Octet string
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x42: // string / Character string
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x43: // octstr16 / Long octet string
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 2;
        break;
    case 0x44: // string16 / Long character string
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 2;
        break;
    case 0x48: // array / Array
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x49: // struct / Structure
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x50: // set / Set
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0x51: // bag / Bag
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0xE0: // ToD / Time of day
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0xE1: // date / Date
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0xE2: // UTC / UTCTime
        CHECK_MESSAGE_LENGTH(4);
        ChipLogProgress(chipTool, "  value: 0x%08x", chip::Encoding::LittleEndian::Read32(message));
        return true;
        break;
    case 0xE8: // clusterId / Cluster ID
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0xE9: // attribId / Attribute ID
        CHECK_MESSAGE_LENGTH(2);
        ChipLogProgress(chipTool, "  value: 0x%04x", chip::Encoding::LittleEndian::Read16(message));
        return true;
        break;
    case 0xEA: // bacOID / BACnet OID
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    case 0xF0: // EUI64 / IEEE address
        CHECK_MESSAGE_LENGTH(8);
        ChipLogProgress(chipTool, "  value: 0x%16x", chip::Encoding::LittleEndian::Read64(message));
        return true;
        break;
    case 0xF1: // key128 / 128-bit security key
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 16;
        break;
    case 0xFF: // unk / Unknown
        ChipLogError(chipTool, "Type 0x%02x is not supported", type);
        message += 0;
        break;
    }

    return false;
}

/*----------------------------------------------------------------------------*\
| Global Command Responses                                              |  ID  |
|------------------------------------------------------------------------------|
| * ReadAttributesResponse                                              | 0x01 |
| * WriteAttributesResponse                                             | 0x04 |
| * WriteAttributesNoResponse                                           | 0x05 |
| * ConfigureReportingResponse                                          | 0x07 |
| * ReadReportingConfigurationResponse                                  | 0x09 |
| * DefaultResponse                                                     | 0x0B |
| * DiscoverAttributesResponse                                          | 0x0D |
| * WriteAttributesStructuredResponse                                   | 0x10 |
| * DiscoverCommandsReceivedResponse                                    | 0x12 |
| * DiscoverCommandsGeneratedResponse                                   | 0x14 |
| * DiscoverAttributesExtendedResponse                                  | 0x16 |
\*----------------------------------------------------------------------------*/

/*
 * Command ReadAttributesResponse
 */
class ReadAttributesResponse : public ModelCommandResponse
{
public:
    ReadAttributesResponse() : ModelCommandResponse(0x01) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ReadAttributesResponse (0x01):");

        // struct readAttributeResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            CHECK_MESSAGE_LENGTH(1);
            uint8_t status = chip::Encoding::Read8(message); // zclStatus
            success        = CheckStatus(status);

            if (status == 0)
            {
                if (!ReadAttributeValue(message, messageLen))
                {
                    return false;
                }
            }
        }
        return success;
    }
};

/*
 * Command WriteAttributesResponse
 */
class WriteAttributesResponse : public ModelCommandResponse
{
public:
    WriteAttributesResponse() : ModelCommandResponse(0x04) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "WriteAttributesResponse (0x04):");

        // struct writeAttributeResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t status = chip::Encoding::Read8(message); // zclStatus
            success        = CheckStatus(status);

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
                ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);
            }
        }
        return success;
    }
};

/*
 * Command WriteAttributesNoResponse
 */
class WriteAttributesNoResponse : public ModelCommandResponse
{
public:
    WriteAttributesNoResponse() : ModelCommandResponse(0x05) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "WriteAttributesNoResponse (0x05):");

        // struct writeAttributeRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            if (!ReadAttributeValue(message, messageLen))
            {
                return false;
            }
        }
        return success;
    }
};

/*
 * Command ConfigureReportingResponse
 */
class ConfigureReportingResponse : public ModelCommandResponse
{
public:
    ConfigureReportingResponse() : ModelCommandResponse(0x07) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ConfigureReportingResponse (0x07):");

        // struct configureReportingResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t status = chip::Encoding::Read8(message); // zclStatus
            success        = CheckStatus(status);

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(1);
                uint8_t direction = chip::Encoding::Read8(message); // reportingRole
                ChipLogProgress(chipTool, "  %s: 0x%02x", "direction", direction);
            }

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
                ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);
            }
        }
        return success;
    }
};

/*
 * Command ReadReportingConfigurationResponse
 */
class ReadReportingConfigurationResponse : public ModelCommandResponse
{
public:
    ReadReportingConfigurationResponse() : ModelCommandResponse(0x09) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ReadReportingConfigurationResponse (0x09):");

        // struct readReportingConfigurationResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t direction = chip::Encoding::Read8(message); // reportingRole
            ChipLogProgress(chipTool, "  %s: 0x%02x", "direction", direction);

            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            if (direction == 0)
            {
                CHECK_MESSAGE_LENGTH(1);
                uint8_t attributeType = chip::Encoding::Read8(message); // zclType
                ChipLogProgress(chipTool, "  %s: 0x%02x", "attributeType", attributeType);
            }

            if (direction == 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t minimumReportingInterval = chip::Encoding::LittleEndian::Read16(message); // uint16
                ChipLogProgress(chipTool, "  %s: 0x%04x", "minimumReportingInterval", minimumReportingInterval);
            }

            if (direction == 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t maximumReportingInterval = chip::Encoding::LittleEndian::Read16(message); // uint16
                ChipLogProgress(chipTool, "  %s: 0x%04x", "maximumReportingInterval", maximumReportingInterval);
            }

            if (direction == 0)
            {
                // FIXME: unk is not supported yet.
            }

            if (direction == 1)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t timeout = chip::Encoding::LittleEndian::Read16(message); // uint16
                ChipLogProgress(chipTool, "  %s: 0x%04x", "timeout", timeout);
            }
        }
        return success;
    }
};

/*
 * Command DefaultResponse
 */
class DefaultResponse : public ModelCommandResponse
{
public:
    DefaultResponse() : ModelCommandResponse(0x0B) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DefaultResponse (0x0B):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t commandId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "commandId", commandId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        return success;
    }
};

/*
 * Command DiscoverAttributesResponse
 */
class DiscoverAttributesResponse : public ModelCommandResponse
{
public:
    DiscoverAttributesResponse() : ModelCommandResponse(0x0D) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DiscoverAttributesResponse (0x0D):");

        CHECK_MESSAGE_LENGTH(1);
        bool discoveryComplete = chip::Encoding::Read8(message); // bool
        ChipLogProgress(chipTool, "  %s: 0x%02x", "discoveryComplete", discoveryComplete);

        // struct discoverAttributesResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            CHECK_MESSAGE_LENGTH(1);
            uint8_t attributeType = chip::Encoding::Read8(message); // zclType
            ChipLogProgress(chipTool, "  %s: 0x%02x", "attributeType", attributeType);
        }
        return success;
    }
};

/*
 * Command WriteAttributesStructuredResponse
 */
class WriteAttributesStructuredResponse : public ModelCommandResponse
{
public:
    WriteAttributesStructuredResponse() : ModelCommandResponse(0x10) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "WriteAttributesStructuredResponse (0x10):");

        // struct writeStructuredResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t status = chip::Encoding::Read8(message); // zclStatus
            success        = CheckStatus(status);

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
                ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);
            }

            if (status != 0)
            {
                CHECK_MESSAGE_LENGTH(2);
                uint16_t selector = chip::Encoding::LittleEndian::Read16(message); // uint16
                ChipLogProgress(chipTool, "  %s: 0x%04x", "selector", selector);
            }
        }
        return success;
    }
};

/*
 * Command DiscoverCommandsReceivedResponse
 */
class DiscoverCommandsReceivedResponse : public ModelCommandResponse
{
public:
    DiscoverCommandsReceivedResponse() : ModelCommandResponse(0x12) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DiscoverCommandsReceivedResponse (0x12):");

        CHECK_MESSAGE_LENGTH(1);
        bool discoveryComplete = chip::Encoding::Read8(message); // bool
        ChipLogProgress(chipTool, "  %s: 0x%02x", "discoveryComplete", discoveryComplete);

        // uint8_t uint8[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t commandId = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "commandId", commandId);
        }
        return success;
    }
};

/*
 * Command DiscoverCommandsGeneratedResponse
 */
class DiscoverCommandsGeneratedResponse : public ModelCommandResponse
{
public:
    DiscoverCommandsGeneratedResponse() : ModelCommandResponse(0x14) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DiscoverCommandsGeneratedResponse (0x14):");

        CHECK_MESSAGE_LENGTH(1);
        bool discoveryComplete = chip::Encoding::Read8(message); // bool
        ChipLogProgress(chipTool, "  %s: 0x%02x", "discoveryComplete", discoveryComplete);

        // uint8_t uint8[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t commandId = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "commandId", commandId);
        }
        return success;
    }
};

/*
 * Command DiscoverAttributesExtendedResponse
 */
class DiscoverAttributesExtendedResponse : public ModelCommandResponse
{
public:
    DiscoverAttributesExtendedResponse() : ModelCommandResponse(0x16) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "DiscoverAttributesExtendedResponse (0x16):");

        CHECK_MESSAGE_LENGTH(1);
        bool discoveryComplete = chip::Encoding::Read8(message); // bool
        ChipLogProgress(chipTool, "  %s: 0x%02x", "discoveryComplete", discoveryComplete);

        // struct discoverAttributesExtendedResponseRecord[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t attributeId = chip::Encoding::LittleEndian::Read16(message); // attribId
            ChipLogProgress(chipTool, "  %s: 0x%04x", "attributeId", attributeId);

            CHECK_MESSAGE_LENGTH(1);
            uint8_t accessControl = chip::Encoding::Read8(message); // bitmap8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "accessControl", accessControl);
        }
        return success;
    }
};

/*----------------------------------------------------------------------------*\
| Cluster Name                                                        |   ID   |
|---------------------------------------------------------------------+--------|
| BarrierControl                                                      | 0x0103 |
| Basic                                                               | 0x0000 |
| ColorControl                                                        | 0x0300 |
| DoorLock                                                            | 0x0101 |
| Groups                                                              | 0x0004 |
| IasZone                                                             | 0x0500 |
| Identify                                                            | 0x0003 |
| Level                                                               | 0x0008 |
| OnOff                                                               | 0x0006 |
| Scenes                                                              | 0x0005 |
| TemperatureMeasurement                                              | 0x0402 |
\*----------------------------------------------------------------------------*/

constexpr uint16_t kBarrierControlClusterId  = 0x0103;
constexpr uint16_t kBasicClusterId           = 0x0000;
constexpr uint16_t kColorControlClusterId    = 0x0300;
constexpr uint16_t kDoorLockClusterId        = 0x0101;
constexpr uint16_t kGroupsClusterId          = 0x0004;
constexpr uint16_t kIasZoneClusterId         = 0x0500;
constexpr uint16_t kIdentifyClusterId        = 0x0003;
constexpr uint16_t kLevelClusterId           = 0x0008;
constexpr uint16_t kOnOffClusterId           = 0x0006;
constexpr uint16_t kScenesClusterId          = 0x0005;
constexpr uint16_t kTempMeasurementClusterId = 0x0402;

/*----------------------------------------------------------------------------*\
| Cluster BarrierControl                                              | 0x0103 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GoToPercent                                                       |   0x00 |
| * Stop                                                              |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MovingState                                                       | 0x0001 |
| * SafetyStatus                                                      | 0x0002 |
| * Capabilities                                                      | 0x0003 |
| * BarrierPosition                                                   | 0x000A |
\*----------------------------------------------------------------------------*/

/*
 * Command GoToPercent
 */
class BarrierControlGoToPercent : public ModelCommand
{
public:
    BarrierControlGoToPercent() : ModelCommand("barrier-control-go-to-percent", kBarrierControlClusterId, 0x00)
    {
        AddArgument("percentOpen", 0, UINT8_MAX, &mPercentOpen);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeBarrierControlClusterBarrierControlGoToPercentCommand(endPointId, mPercentOpen);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mPercentOpen;
};

/*
 * Command Stop
 */
class BarrierControlStop : public ModelCommand
{
public:
    BarrierControlStop() : ModelCommand("barrier-control-stop", kBarrierControlClusterId, 0x01) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeBarrierControlClusterBarrierControlStopCommand(endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverBarrierControlAttributes : public ModelCommand
{
public:
    DiscoverBarrierControlAttributes() : ModelCommand("discover", kBarrierControlClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeBarrierControlClusterDiscoverAttributes(endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute MovingState
 */
class ReadBarrierControlMovingState : public ModelCommand
{
public:
    ReadBarrierControlMovingState() : ModelCommand("read", kBarrierControlClusterId, 0x00)
    {
        AddArgument("attr-name", "barrier-moving-state");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReadBarrierMovingStateAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute SafetyStatus
 */
class ReadBarrierControlSafetyStatus : public ModelCommand
{
public:
    ReadBarrierControlSafetyStatus() : ModelCommand("read", kBarrierControlClusterId, 0x00)
    {
        AddArgument("attr-name", "barrier-safety-status");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReadBarrierSafetyStatusAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Capabilities
 */
class ReadBarrierControlCapabilities : public ModelCommand
{
public:
    ReadBarrierControlCapabilities() : ModelCommand("read", kBarrierControlClusterId, 0x00)
    {
        AddArgument("attr-name", "barrier-capabilities");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReadBarrierCapabilitiesAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute BarrierPosition
 */
class ReadBarrierControlBarrierPosition : public ModelCommand
{
public:
    ReadBarrierControlBarrierPosition() : ModelCommand("read", kBarrierControlClusterId, 0x00)
    {
        AddArgument("attr-name", "barrier-position");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeBarrierControlClusterReadBarrierPositionAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster Basic                                                       | 0x0000 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetToFactoryDefaults                                            |   0x00 |
| * MfgSpecificPing                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ZclVersion                                                        | 0x0000 |
| * PowerSource                                                       | 0x0007 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetToFactoryDefaults
 */
class BasicResetToFactoryDefaults : public ModelCommand
{
public:
    BasicResetToFactoryDefaults() : ModelCommand("reset-to-factory-defaults", kBasicClusterId, 0x00)
    {
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeBasicClusterResetToFactoryDefaultsCommand(endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command MfgSpecificPing
 */
class BasicMfgSpecificPing : public ModelCommand
{
public:
    BasicMfgSpecificPing() : ModelCommand("ping", kBasicClusterId, 0x00) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeBasicClusterMfgSpecificPingCommand(endPointId); }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverBasicAttributes : public ModelCommand
{
public:
    DiscoverBasicAttributes() : ModelCommand("discover", kBasicClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeBasicClusterDiscoverAttributes(endPointId); }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ZclVersion
 */
class ReadBasicZclVersion : public ModelCommand
{
public:
    ReadBasicZclVersion() : ModelCommand("read", kBasicClusterId, 0x00)
    {
        AddArgument("attr-name", "zcl-version");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeBasicClusterReadZclVersionAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute PowerSource
 */
class ReadBasicPowerSource : public ModelCommand
{
public:
    ReadBasicPowerSource() : ModelCommand("read", kBasicClusterId, 0x00)
    {
        AddArgument("attr-name", "power-source");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeBasicClusterReadPowerSourceAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster ColorControl                                                | 0x0300 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * MoveColor                                                         |   0x08 |
| * MoveColorTemperature                                              |   0x4B |
| * MoveHue                                                           |   0x01 |
| * MoveSaturation                                                    |   0x04 |
| * MoveToColor                                                       |   0x07 |
| * MoveToColorTemperature                                            |   0x0A |
| * MoveToHue                                                         |   0x00 |
| * MoveToHueAndSaturation                                            |   0x06 |
| * MoveToSaturation                                                  |   0x03 |
| * StepColor                                                         |   0x09 |
| * StepColorTemperature                                              |   0x4C |
| * StepHue                                                           |   0x02 |
| * StepSaturation                                                    |   0x05 |
| * StopMoveStep                                                      |   0x47 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentHue                                                        | 0x0000 |
| * CurrentSaturation                                                 | 0x0001 |
| * RemainingTime                                                     | 0x0002 |
| * CurrentX                                                          | 0x0003 |
| * CurrentY                                                          | 0x0004 |
| * ColorTemperature                                                  | 0x0007 |
| * ColorMode                                                         | 0x0008 |
| * NumberOfPrimaries                                                 | 0x0010 |
| * Primary1X                                                         | 0x0011 |
| * Primary1Y                                                         | 0x0012 |
| * Primary1Intensity                                                 | 0x0013 |
| * Primary2X                                                         | 0x0015 |
| * Primary2Y                                                         | 0x0016 |
| * Primary2Intensity                                                 | 0x0017 |
| * Primary3X                                                         | 0x0019 |
| * Primary3Y                                                         | 0x001A |
| * Primary3Intensity                                                 | 0x001B |
| * Primary4X                                                         | 0x0020 |
| * Primary4Y                                                         | 0x0021 |
| * Primary4Intensity                                                 | 0x0022 |
| * Primary5X                                                         | 0x0024 |
| * Primary5Y                                                         | 0x0025 |
| * Primary5Intensity                                                 | 0x0026 |
| * Primary6X                                                         | 0x0028 |
| * Primary6Y                                                         | 0x0029 |
| * Primary6Intensity                                                 | 0x002A |
| * EnhancedCurrentHue                                                | 0x4000 |
| * EnhancedColorMode                                                 | 0x4001 |
| * ColorLoopActive                                                   | 0x4002 |
| * ColorLoopDirection                                                | 0x4003 |
| * ColorLoopTime                                                     | 0x4004 |
| * ColorCapabilities                                                 | 0x400A |
| * ColorTempPhysicalMin                                              | 0x400B |
| * ColorTempPhysicalMax                                              | 0x400C |
| * CoupleColorTempToLevelMinMireds                                   | 0x400D |
| * StartUpColorTemperatureMireds                                     | 0x4010 |
\*----------------------------------------------------------------------------*/

/*
 * Command MoveColor
 */
class ColorControlMoveColor : public ModelCommand
{
public:
    ColorControlMoveColor() : ModelCommand("move-color", kColorControlClusterId, 0x08)
    {
        AddArgument("rateX", INT16_MIN, INT16_MAX, &mRateX);
        AddArgument("rateY", INT16_MIN, INT16_MAX, &mRateY);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveColorCommand(endPointId, mRateX, mRateY, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    int16_t mRateX;
    int16_t mRateY;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveColorTemperature
 */
class ColorControlMoveColorTemperature : public ModelCommand
{
public:
    ColorControlMoveColorTemperature() : ModelCommand("move-color-temperature", kColorControlClusterId, 0x4B)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT16_MAX, &mRate);
        AddArgument("colorTemperatureMinimum", 0, UINT16_MAX, &mColorTemperatureMinimum);
        AddArgument("colorTemperatureMaximum", 0, UINT16_MAX, &mColorTemperatureMaximum);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveColorTemperatureCommand(endPointId, mMoveMode, mRate, mColorTemperatureMinimum,
                                                                    mColorTemperatureMaximum, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint16_t mRate;
    uint16_t mColorTemperatureMinimum;
    uint16_t mColorTemperatureMaximum;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveHue
 */
class ColorControlMoveHue : public ModelCommand
{
public:
    ColorControlMoveHue() : ModelCommand("move-hue", kColorControlClusterId, 0x01)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT8_MAX, &mRate);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveHueCommand(endPointId, mMoveMode, mRate, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveSaturation
 */
class ColorControlMoveSaturation : public ModelCommand
{
public:
    ColorControlMoveSaturation() : ModelCommand("move-saturation", kColorControlClusterId, 0x04)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT8_MAX, &mRate);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveSaturationCommand(endPointId, mMoveMode, mRate, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColor
 */
class ColorControlMoveToColor : public ModelCommand
{
public:
    ColorControlMoveToColor() : ModelCommand("move-to-color", kColorControlClusterId, 0x07)
    {
        AddArgument("colorX", 0, UINT16_MAX, &mColorX);
        AddArgument("colorY", 0, UINT16_MAX, &mColorY);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToColorCommand(endPointId, mColorX, mColorY, mTransitionTime, mOptionsMask,
                                                           mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mColorX;
    uint16_t mColorY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColorTemperature
 */
class ColorControlMoveToColorTemperature : public ModelCommand
{
public:
    ColorControlMoveToColorTemperature() : ModelCommand("move-to-color-temperature", kColorControlClusterId, 0x0A)
    {
        AddArgument("colorTemperature", 0, UINT16_MAX, &mColorTemperature);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToColorTemperatureCommand(endPointId, mColorTemperature, mTransitionTime, mOptionsMask,
                                                                      mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mColorTemperature;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHue
 */
class ColorControlMoveToHue : public ModelCommand
{
public:
    ColorControlMoveToHue() : ModelCommand("move-to-hue", kColorControlClusterId, 0x00)
    {
        AddArgument("hue", 0, UINT8_MAX, &mHue);
        AddArgument("direction", 0, UINT8_MAX, &mDirection);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToHueCommand(endPointId, mHue, mDirection, mTransitionTime, mOptionsMask,
                                                         mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHue;
    uint8_t mDirection;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHueAndSaturation
 */
class ColorControlMoveToHueAndSaturation : public ModelCommand
{
public:
    ColorControlMoveToHueAndSaturation() : ModelCommand("move-to-hue-and-saturation", kColorControlClusterId, 0x06)
    {
        AddArgument("hue", 0, UINT8_MAX, &mHue);
        AddArgument("saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToHueAndSaturationCommand(endPointId, mHue, mSaturation, mTransitionTime, mOptionsMask,
                                                                      mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHue;
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToSaturation
 */
class ColorControlMoveToSaturation : public ModelCommand
{
public:
    ColorControlMoveToSaturation() : ModelCommand("move-to-saturation", kColorControlClusterId, 0x03)
    {
        AddArgument("saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterMoveToSaturationCommand(endPointId, mSaturation, mTransitionTime, mOptionsMask,
                                                                mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColor
 */
class ColorControlStepColor : public ModelCommand
{
public:
    ColorControlStepColor() : ModelCommand("step-color", kColorControlClusterId, 0x09)
    {
        AddArgument("stepX", INT16_MIN, INT16_MAX, &mStepX);
        AddArgument("stepY", INT16_MIN, INT16_MAX, &mStepY);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterStepColorCommand(endPointId, mStepX, mStepY, mTransitionTime, mOptionsMask,
                                                         mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    int16_t mStepX;
    int16_t mStepY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColorTemperature
 */
class ColorControlStepColorTemperature : public ModelCommand
{
public:
    ColorControlStepColorTemperature() : ModelCommand("step-color-temperature", kColorControlClusterId, 0x4C)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT16_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("colorTemperatureMinimum", 0, UINT16_MAX, &mColorTemperatureMinimum);
        AddArgument("colorTemperatureMaximum", 0, UINT16_MAX, &mColorTemperatureMaximum);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterStepColorTemperatureCommand(endPointId, mStepMode, mStepSize, mTransitionTime,
                                                                    mColorTemperatureMinimum, mColorTemperatureMaximum,
                                                                    mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint16_t mStepSize;
    uint16_t mTransitionTime;
    uint16_t mColorTemperatureMinimum;
    uint16_t mColorTemperatureMaximum;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepHue
 */
class ColorControlStepHue : public ModelCommand
{
public:
    ColorControlStepHue() : ModelCommand("step-hue", kColorControlClusterId, 0x02)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterStepHueCommand(endPointId, mStepMode, mStepSize, mTransitionTime, mOptionsMask,
                                                       mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepSaturation
 */
class ColorControlStepSaturation : public ModelCommand
{
public:
    ColorControlStepSaturation() : ModelCommand("step-saturation", kColorControlClusterId, 0x05)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterStepSaturationCommand(endPointId, mStepMode, mStepSize, mTransitionTime, mOptionsMask,
                                                              mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StopMoveStep
 */
class ColorControlStopMoveStep : public ModelCommand
{
public:
    ColorControlStopMoveStep() : ModelCommand("stop-move-step", kColorControlClusterId, 0x47)
    {
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterStopMoveStepCommand(endPointId, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Discover attributes
 */
class DiscoverColorControlAttributes : public ModelCommand
{
public:
    DiscoverColorControlAttributes() : ModelCommand("discover", kColorControlClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterDiscoverAttributes(endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentHue
 */
class ReadColorControlCurrentHue : public ModelCommand
{
public:
    ReadColorControlCurrentHue() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "current-hue");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCurrentHueAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlCurrentHue : public ModelCommand
{
public:
    ReportColorControlCurrentHue() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT8_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReportCurrentHueAttribute(endPointId, mMinInterval, mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint8_t mChange;
};

/*
 * Attribute CurrentSaturation
 */
class ReadColorControlCurrentSaturation : public ModelCommand
{
public:
    ReadColorControlCurrentSaturation() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "current-saturation");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCurrentSaturationAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlCurrentSaturation : public ModelCommand
{
public:
    ReportColorControlCurrentSaturation() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "current-saturation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT8_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReportCurrentSaturationAttribute(endPointId, mMinInterval, mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint8_t mChange;
};

/*
 * Attribute RemainingTime
 */
class ReadColorControlRemainingTime : public ModelCommand
{
public:
    ReadColorControlRemainingTime() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadRemainingTimeAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentX
 */
class ReadColorControlCurrentX : public ModelCommand
{
public:
    ReadColorControlCurrentX() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "currentx");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCurrentXAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlCurrentX : public ModelCommand
{
public:
    ReportColorControlCurrentX() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "currentx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT16_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReportCurrentXAttribute(endPointId, mMinInterval, mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint16_t mChange;
};

/*
 * Attribute CurrentY
 */
class ReadColorControlCurrentY : public ModelCommand
{
public:
    ReadColorControlCurrentY() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "currenty");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCurrentYAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlCurrentY : public ModelCommand
{
public:
    ReportColorControlCurrentY() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "currenty");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT16_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReportCurrentYAttribute(endPointId, mMinInterval, mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint16_t mChange;
};

/*
 * Attribute ColorTemperature
 */
class ReadColorControlColorTemperature : public ModelCommand
{
public:
    ReadColorControlColorTemperature() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorTemperatureAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportColorControlColorTemperature : public ModelCommand
{
public:
    ReportColorControlColorTemperature() : ModelCommand("report", kColorControlClusterId, 0x06)
    {
        AddArgument("attr-name", "color-temperature-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT16_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReportColorTemperatureAttribute(endPointId, mMinInterval, mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint16_t mChange;
};

/*
 * Attribute ColorMode
 */
class ReadColorControlColorMode : public ModelCommand
{
public:
    ReadColorControlColorMode() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-mode");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorModeAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute NumberOfPrimaries
 */
class ReadColorControlNumberOfPrimaries : public ModelCommand
{
public:
    ReadColorControlNumberOfPrimaries() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "number-of-primaries");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadNumberOfPrimariesAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary1X
 */
class ReadColorControlPrimary1X : public ModelCommand
{
public:
    ReadColorControlPrimary1X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary1-x");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary1XAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary1Y
 */
class ReadColorControlPrimary1Y : public ModelCommand
{
public:
    ReadColorControlPrimary1Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary1-y");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary1YAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary1Intensity
 */
class ReadColorControlPrimary1Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary1Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary1-intensity");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary1IntensityAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary2X
 */
class ReadColorControlPrimary2X : public ModelCommand
{
public:
    ReadColorControlPrimary2X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary2-x");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary2XAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary2Y
 */
class ReadColorControlPrimary2Y : public ModelCommand
{
public:
    ReadColorControlPrimary2Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary2-y");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary2YAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary2Intensity
 */
class ReadColorControlPrimary2Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary2Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary2-intensity");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary2IntensityAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary3X
 */
class ReadColorControlPrimary3X : public ModelCommand
{
public:
    ReadColorControlPrimary3X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary3-x");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary3XAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary3Y
 */
class ReadColorControlPrimary3Y : public ModelCommand
{
public:
    ReadColorControlPrimary3Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary3-y");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary3YAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary3Intensity
 */
class ReadColorControlPrimary3Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary3Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary3-intensity");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary3IntensityAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary4X
 */
class ReadColorControlPrimary4X : public ModelCommand
{
public:
    ReadColorControlPrimary4X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary4-x");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary4XAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary4Y
 */
class ReadColorControlPrimary4Y : public ModelCommand
{
public:
    ReadColorControlPrimary4Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary4-y");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary4YAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary4Intensity
 */
class ReadColorControlPrimary4Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary4Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary4-intensity");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary4IntensityAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary5X
 */
class ReadColorControlPrimary5X : public ModelCommand
{
public:
    ReadColorControlPrimary5X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary5-x");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary5XAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary5Y
 */
class ReadColorControlPrimary5Y : public ModelCommand
{
public:
    ReadColorControlPrimary5Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary5-y");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary5YAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary5Intensity
 */
class ReadColorControlPrimary5Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary5Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary5-intensity");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary5IntensityAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary6X
 */
class ReadColorControlPrimary6X : public ModelCommand
{
public:
    ReadColorControlPrimary6X() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary6-x");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary6XAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary6Y
 */
class ReadColorControlPrimary6Y : public ModelCommand
{
public:
    ReadColorControlPrimary6Y() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary6-y");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary6YAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute Primary6Intensity
 */
class ReadColorControlPrimary6Intensity : public ModelCommand
{
public:
    ReadColorControlPrimary6Intensity() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "primary6-intensity");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadPrimary6IntensityAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute EnhancedCurrentHue
 */
class ReadColorControlEnhancedCurrentHue : public ModelCommand
{
public:
    ReadColorControlEnhancedCurrentHue() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "enhanced-current-hue");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadEnhancedCurrentHueAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute EnhancedColorMode
 */
class ReadColorControlEnhancedColorMode : public ModelCommand
{
public:
    ReadColorControlEnhancedColorMode() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "enhanced-color-mode");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadEnhancedColorModeAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorLoopActive
 */
class ReadColorControlColorLoopActive : public ModelCommand
{
public:
    ReadColorControlColorLoopActive() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-loop-active");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorLoopActiveAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorLoopDirection
 */
class ReadColorControlColorLoopDirection : public ModelCommand
{
public:
    ReadColorControlColorLoopDirection() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-loop-direction");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorLoopDirectionAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorLoopTime
 */
class ReadColorControlColorLoopTime : public ModelCommand
{
public:
    ReadColorControlColorLoopTime() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-loop-time");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorLoopTimeAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorCapabilities
 */
class ReadColorControlColorCapabilities : public ModelCommand
{
public:
    ReadColorControlColorCapabilities() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-capabilities");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorCapabilitiesAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorTempPhysicalMin
 */
class ReadColorControlColorTempPhysicalMin : public ModelCommand
{
public:
    ReadColorControlColorTempPhysicalMin() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-temp-physical-min");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorTempPhysicalMinAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ColorTempPhysicalMax
 */
class ReadColorControlColorTempPhysicalMax : public ModelCommand
{
public:
    ReadColorControlColorTempPhysicalMax() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "color-temp-physical-max");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadColorTempPhysicalMaxAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CoupleColorTempToLevelMinMireds
 */
class ReadColorControlCoupleColorTempToLevelMinMireds : public ModelCommand
{
public:
    ReadColorControlCoupleColorTempToLevelMinMireds() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadCoupleColorTempToLevelMinMiredsAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute StartUpColorTemperatureMireds
 */
class ReadColorControlStartUpColorTemperatureMireds : public ModelCommand
{
public:
    ReadColorControlStartUpColorTemperatureMireds() : ModelCommand("read", kColorControlClusterId, 0x00)
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeColorControlClusterReadStartUpColorTemperatureMiredsAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster DoorLock                                                    | 0x0101 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
| * ClearAllPinsResponse                                              |   0x08 |
| * ClearAllRfidsResponse                                             |   0x19 |
| * ClearHolidayScheduleResponse                                      |   0x13 |
| * ClearPinResponse                                                  |   0x07 |
| * ClearRfidResponse                                                 |   0x18 |
| * ClearWeekdayScheduleResponse                                      |   0x0D |
| * ClearYeardayScheduleResponse                                      |   0x10 |
| * GetHolidayScheduleResponse                                        |   0x12 |
| * GetPinResponse                                                    |   0x06 |
| * GetRfidResponse                                                   |   0x17 |
| * GetUserTypeResponse                                               |   0x15 |
| * GetWeekdayScheduleResponse                                        |   0x0C |
| * GetYeardayScheduleResponse                                        |   0x0F |
| * LockDoorResponse                                                  |   0x00 |
| * SetHolidayScheduleResponse                                        |   0x11 |
| * SetPinResponse                                                    |   0x05 |
| * SetRfidResponse                                                   |   0x16 |
| * SetUserTypeResponse                                               |   0x14 |
| * SetWeekdayScheduleResponse                                        |   0x0B |
| * SetYeardayScheduleResponse                                        |   0x0E |
| * UnlockDoorResponse                                                |   0x01 |
| * UnlockWithTimeoutResponse                                         |   0x03 |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ClearAllPins                                                      |   0x08 |
| * ClearAllRfids                                                     |   0x19 |
| * ClearHolidaySchedule                                              |   0x13 |
| * ClearPin                                                          |   0x07 |
| * ClearRfid                                                         |   0x18 |
| * ClearWeekdaySchedule                                              |   0x0D |
| * ClearYeardaySchedule                                              |   0x10 |
| * GetHolidaySchedule                                                |   0x12 |
| * GetPin                                                            |   0x06 |
| * GetRfid                                                           |   0x17 |
| * GetUserType                                                       |   0x15 |
| * GetWeekdaySchedule                                                |   0x0C |
| * GetYeardaySchedule                                                |   0x0F |
| * LockDoor                                                          |   0x00 |
| * SetHolidaySchedule                                                |   0x11 |
| * SetPin                                                            |   0x05 |
| * SetRfid                                                           |   0x16 |
| * SetUserType                                                       |   0x14 |
| * SetWeekdaySchedule                                                |   0x0B |
| * SetYeardaySchedule                                                |   0x0E |
| * UnlockDoor                                                        |   0x01 |
| * UnlockWithTimeout                                                 |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LockState                                                         | 0x0000 |
| * LockType                                                          | 0x0001 |
| * ActuatorEnabled                                                   | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command Response ClearAllPinsResponse
 */
class ClearAllPinsResponse : public ModelCommandResponse
{
public:
    ClearAllPinsResponse() : ModelCommandResponse(0x08) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearAllPinsResponse (0x08):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearAllRfidsResponse
 */
class ClearAllRfidsResponse : public ModelCommandResponse
{
public:
    ClearAllRfidsResponse() : ModelCommandResponse(0x19) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearAllRfidsResponse (0x19):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearHolidayScheduleResponse
 */
class ClearHolidayScheduleResponse : public ModelCommandResponse
{
public:
    ClearHolidayScheduleResponse() : ModelCommandResponse(0x13) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearHolidayScheduleResponse (0x13):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearPinResponse
 */
class ClearPinResponse : public ModelCommandResponse
{
public:
    ClearPinResponse() : ModelCommandResponse(0x07) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearPinResponse (0x07):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearRfidResponse
 */
class ClearRfidResponse : public ModelCommandResponse
{
public:
    ClearRfidResponse() : ModelCommandResponse(0x18) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearRfidResponse (0x18):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearWeekdayScheduleResponse
 */
class ClearWeekdayScheduleResponse : public ModelCommandResponse
{
public:
    ClearWeekdayScheduleResponse() : ModelCommandResponse(0x0D) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearWeekdayScheduleResponse (0x0D):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response ClearYeardayScheduleResponse
 */
class ClearYeardayScheduleResponse : public ModelCommandResponse
{
public:
    ClearYeardayScheduleResponse() : ModelCommandResponse(0x10) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ClearYeardayScheduleResponse (0x10):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response GetHolidayScheduleResponse
 */
class GetHolidayScheduleResponse : public ModelCommandResponse
{
public:
    GetHolidayScheduleResponse() : ModelCommandResponse(0x12) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetHolidayScheduleResponse (0x12):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t holidayScheduleId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "holidayScheduleId", holidayScheduleId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(4);
            uint32_t localStartTime = chip::Encoding::LittleEndian::Read32(message); // uint32
            ChipLogProgress(chipTool, "  %s: 0x%08x", "localStartTime", localStartTime);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(4);
            uint32_t localEndTime = chip::Encoding::LittleEndian::Read32(message); // uint32
            ChipLogProgress(chipTool, "  %s: 0x%08x", "localEndTime", localEndTime);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t operatingModeDuringHoliday = chip::Encoding::Read8(message); // DrlkOperMode
            ChipLogProgress(chipTool, "  %s: 0x%02x", "operatingModeDuringHoliday", operatingModeDuringHoliday);
        }

        return success;
    }
};

/*
 * Command Response GetPinResponse
 */
class GetPinResponse : public ModelCommandResponse
{
public:
    GetPinResponse() : ModelCommandResponse(0x06) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetPinResponse (0x06):");

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userStatus = chip::Encoding::Read8(message); // DrlkUserStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userStatus", userStatus);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userType = chip::Encoding::Read8(message); // DrlkUserType
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userType", userType);

        CHECK_MESSAGE_LENGTH(1);
        {
            uint8_t codeLen = chip::Encoding::Read8(message);              // octstr
            ChipLogProgress(chipTool, "  %s: 0x%02x", "codeLen", codeLen); // octstr

            // FIXME Strings are not supported yet. For the moment the code just checks that
            // there is enough bytes in the buffer
            CHECK_MESSAGE_LENGTH(codeLen);
            message += codeLen;
        }

        return success;
    }
};

/*
 * Command Response GetRfidResponse
 */
class GetRfidResponse : public ModelCommandResponse
{
public:
    GetRfidResponse() : ModelCommandResponse(0x17) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetRfidResponse (0x17):");

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userStatus = chip::Encoding::Read8(message); // DrlkUserStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userStatus", userStatus);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userType = chip::Encoding::Read8(message); // DrlkUserType
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userType", userType);

        CHECK_MESSAGE_LENGTH(1);
        {
            uint8_t rFIdCodeLen = chip::Encoding::Read8(message);                  // octstr
            ChipLogProgress(chipTool, "  %s: 0x%02x", "rFIdCodeLen", rFIdCodeLen); // octstr

            // FIXME Strings are not supported yet. For the moment the code just checks that
            // there is enough bytes in the buffer
            CHECK_MESSAGE_LENGTH(rFIdCodeLen);
            message += rFIdCodeLen;
        }

        return success;
    }
};

/*
 * Command Response GetUserTypeResponse
 */
class GetUserTypeResponse : public ModelCommandResponse
{
public:
    GetUserTypeResponse() : ModelCommandResponse(0x15) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetUserTypeResponse (0x15):");

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t userType = chip::Encoding::Read8(message); // DrlkUserType
        ChipLogProgress(chipTool, "  %s: 0x%02x", "userType", userType);

        return success;
    }
};

/*
 * Command Response GetWeekdayScheduleResponse
 */
class GetWeekdayScheduleResponse : public ModelCommandResponse
{
public:
    GetWeekdayScheduleResponse() : ModelCommandResponse(0x0C) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetWeekdayScheduleResponse (0x0C):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t scheduleId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "scheduleId", scheduleId);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t daysMask = chip::Encoding::Read8(message); // DrlkDaysMask
            ChipLogProgress(chipTool, "  %s: 0x%02x", "daysMask", daysMask);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t startHour = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "startHour", startHour);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t startMinute = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "startMinute", startMinute);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t endHour = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "endHour", endHour);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t endMinute = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "endMinute", endMinute);
        }

        return success;
    }
};

/*
 * Command Response GetYeardayScheduleResponse
 */
class GetYeardayScheduleResponse : public ModelCommandResponse
{
public:
    GetYeardayScheduleResponse() : ModelCommandResponse(0x0F) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetYeardayScheduleResponse (0x0F):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t scheduleId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "scheduleId", scheduleId);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t userId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "userId", userId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(4);
            uint32_t localStartTime = chip::Encoding::LittleEndian::Read32(message); // uint32
            ChipLogProgress(chipTool, "  %s: 0x%08x", "localStartTime", localStartTime);
        }

        if (status == 0)
        {
            CHECK_MESSAGE_LENGTH(4);
            uint32_t localEndTime = chip::Encoding::LittleEndian::Read32(message); // uint32
            ChipLogProgress(chipTool, "  %s: 0x%08x", "localEndTime", localEndTime);
        }

        return success;
    }
};

/*
 * Command Response LockDoorResponse
 */
class LockDoorResponse : public ModelCommandResponse
{
public:
    LockDoorResponse() : ModelCommandResponse(0x00) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "LockDoorResponse (0x00):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        return success;
    }
};

/*
 * Command Response SetHolidayScheduleResponse
 */
class SetHolidayScheduleResponse : public ModelCommandResponse
{
public:
    SetHolidayScheduleResponse() : ModelCommandResponse(0x11) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetHolidayScheduleResponse (0x11):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetPinResponse
 */
class SetPinResponse : public ModelCommandResponse
{
public:
    SetPinResponse() : ModelCommandResponse(0x05) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetPinResponse (0x05):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkSetCodeStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetRfidResponse
 */
class SetRfidResponse : public ModelCommandResponse
{
public:
    SetRfidResponse() : ModelCommandResponse(0x16) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetRfidResponse (0x16):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkSetCodeStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetUserTypeResponse
 */
class SetUserTypeResponse : public ModelCommandResponse
{
public:
    SetUserTypeResponse() : ModelCommandResponse(0x14) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetUserTypeResponse (0x14):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetWeekdayScheduleResponse
 */
class SetWeekdayScheduleResponse : public ModelCommandResponse
{
public:
    SetWeekdayScheduleResponse() : ModelCommandResponse(0x0B) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetWeekdayScheduleResponse (0x0B):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response SetYeardayScheduleResponse
 */
class SetYeardayScheduleResponse : public ModelCommandResponse
{
public:
    SetYeardayScheduleResponse() : ModelCommandResponse(0x0E) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "SetYeardayScheduleResponse (0x0E):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // DrlkPassFailStatus
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        return success;
    }
};

/*
 * Command Response UnlockDoorResponse
 */
class UnlockDoorResponse : public ModelCommandResponse
{
public:
    UnlockDoorResponse() : ModelCommandResponse(0x01) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "UnlockDoorResponse (0x01):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        return success;
    }
};

/*
 * Command Response UnlockWithTimeoutResponse
 */
class UnlockWithTimeoutResponse : public ModelCommandResponse
{
public:
    UnlockWithTimeoutResponse() : ModelCommandResponse(0x03) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "UnlockWithTimeoutResponse (0x03):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        return success;
    }
};

/*
 * Command ClearAllPins
 */
class DoorLockClearAllPins : public ModelCommand
{
public:
    DoorLockClearAllPins() : ModelCommand("clear-all-pins", kDoorLockClusterId, 0x08) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeDoorLockClusterClearAllPinsCommand(endPointId); }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearAllPinsResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearAllPinsResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command ClearAllRfids
 */
class DoorLockClearAllRfids : public ModelCommand
{
public:
    DoorLockClearAllRfids() : ModelCommand("clear-all-rfids", kDoorLockClusterId, 0x19) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeDoorLockClusterClearAllRfidsCommand(endPointId); }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearAllRfidsResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearAllRfidsResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command ClearHolidaySchedule
 */
class DoorLockClearHolidaySchedule : public ModelCommand
{
public:
    DoorLockClearHolidaySchedule() : ModelCommand("clear-holiday-schedule", kDoorLockClusterId, 0x13)
    {
        AddArgument("holidayScheduleID", 0, UINT8_MAX, &mHolidayScheduleID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearHolidayScheduleCommand(endPointId, mHolidayScheduleID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearHolidayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearHolidayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHolidayScheduleID;
};

/*
 * Command ClearPin
 */
class DoorLockClearPin : public ModelCommand
{
public:
    DoorLockClearPin() : ModelCommand("clear-pin", kDoorLockClusterId, 0x07)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearPinCommand(endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearPinResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearPinResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command ClearRfid
 */
class DoorLockClearRfid : public ModelCommand
{
public:
    DoorLockClearRfid() : ModelCommand("clear-rfid", kDoorLockClusterId, 0x18)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearRfidCommand(endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearRfidResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearRfidResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command ClearWeekdaySchedule
 */
class DoorLockClearWeekdaySchedule : public ModelCommand
{
public:
    DoorLockClearWeekdaySchedule() : ModelCommand("clear-weekday-schedule", kDoorLockClusterId, 0x0D)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearWeekdayScheduleCommand(endPointId, mScheduleID, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearWeekdayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearWeekdayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
};

/*
 * Command ClearYeardaySchedule
 */
class DoorLockClearYeardaySchedule : public ModelCommand
{
public:
    DoorLockClearYeardaySchedule() : ModelCommand("clear-yearday-schedule", kDoorLockClusterId, 0x10)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterClearYeardayScheduleCommand(endPointId, mScheduleID, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ClearYeardayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ClearYeardayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
};

/*
 * Command GetHolidaySchedule
 */
class DoorLockGetHolidaySchedule : public ModelCommand
{
public:
    DoorLockGetHolidaySchedule() : ModelCommand("get-holiday-schedule", kDoorLockClusterId, 0x12)
    {
        AddArgument("holidayScheduleID", 0, UINT8_MAX, &mHolidayScheduleID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetHolidayScheduleCommand(endPointId, mHolidayScheduleID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetHolidayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetHolidayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHolidayScheduleID;
};

/*
 * Command GetPin
 */
class DoorLockGetPin : public ModelCommand
{
public:
    DoorLockGetPin() : ModelCommand("get-pin", kDoorLockClusterId, 0x06)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetPinCommand(endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetPinResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetPinResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command GetRfid
 */
class DoorLockGetRfid : public ModelCommand
{
public:
    DoorLockGetRfid() : ModelCommand("get-rfid", kDoorLockClusterId, 0x17)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetRfidCommand(endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetRfidResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetRfidResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command GetUserType
 */
class DoorLockGetUserType : public ModelCommand
{
public:
    DoorLockGetUserType() : ModelCommand("get-user-type", kDoorLockClusterId, 0x15)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetUserTypeCommand(endPointId, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetUserTypeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetUserTypeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
};

/*
 * Command GetWeekdaySchedule
 */
class DoorLockGetWeekdaySchedule : public ModelCommand
{
public:
    DoorLockGetWeekdaySchedule() : ModelCommand("get-weekday-schedule", kDoorLockClusterId, 0x0C)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetWeekdayScheduleCommand(endPointId, mScheduleID, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetWeekdayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetWeekdayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
};

/*
 * Command GetYeardaySchedule
 */
class DoorLockGetYeardaySchedule : public ModelCommand
{
public:
    DoorLockGetYeardaySchedule() : ModelCommand("get-yearday-schedule", kDoorLockClusterId, 0x0F)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterGetYeardayScheduleCommand(endPointId, mScheduleID, mUserID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetYeardayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetYeardayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
};

/*
 * Command LockDoor
 */
class DoorLockLockDoor : public ModelCommand
{
public:
    DoorLockLockDoor() : ModelCommand("lock-door", kDoorLockClusterId, 0x00)
    {
        AddArgument("pINOrRFIDCode", &mPINOrRFIDCode);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterLockDoorCommand(endPointId, mPINOrRFIDCode);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: LockDoorResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        LockDoorResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    char * mPINOrRFIDCode;
};

/*
 * Command SetHolidaySchedule
 */
class DoorLockSetHolidaySchedule : public ModelCommand
{
public:
    DoorLockSetHolidaySchedule() : ModelCommand("set-holiday-schedule", kDoorLockClusterId, 0x11)
    {
        AddArgument("holidayScheduleID", 0, UINT8_MAX, &mHolidayScheduleID);
        AddArgument("localStartTime", 0, UINT32_MAX, &mLocalStartTime);
        AddArgument("localEndTime", 0, UINT32_MAX, &mLocalEndTime);
        AddArgument("operatingModeDuringHoliday", 0, UINT8_MAX, &mOperatingModeDuringHoliday);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetHolidayScheduleCommand(endPointId, mHolidayScheduleID, mLocalStartTime, mLocalEndTime,
                                                              mOperatingModeDuringHoliday);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetHolidayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetHolidayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mHolidayScheduleID;
    uint32_t mLocalStartTime;
    uint32_t mLocalEndTime;
    uint8_t mOperatingModeDuringHoliday;
};

/*
 * Command SetPin
 */
class DoorLockSetPin : public ModelCommand
{
public:
    DoorLockSetPin() : ModelCommand("set-pin", kDoorLockClusterId, 0x05)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("userStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("userType", 0, UINT8_MAX, &mUserType);
        AddArgument("pin", &mPIN);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetPinCommand(endPointId, mUserID, mUserStatus, mUserType, mPIN);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetPinResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetPinResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
    uint8_t mUserStatus;
    uint8_t mUserType;
    char * mPIN;
};

/*
 * Command SetRfid
 */
class DoorLockSetRfid : public ModelCommand
{
public:
    DoorLockSetRfid() : ModelCommand("set-rfid", kDoorLockClusterId, 0x16)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("userStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("userType", 0, UINT8_MAX, &mUserType);
        AddArgument("rfid", &mRFID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetRfidCommand(endPointId, mUserID, mUserStatus, mUserType, mRFID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetRfidResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetRfidResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
    uint8_t mUserStatus;
    uint8_t mUserType;
    char * mRFID;
};

/*
 * Command SetUserType
 */
class DoorLockSetUserType : public ModelCommand
{
public:
    DoorLockSetUserType() : ModelCommand("set-user-type", kDoorLockClusterId, 0x14)
    {
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("userType", 0, UINT8_MAX, &mUserType);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetUserTypeCommand(endPointId, mUserID, mUserType);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetUserTypeResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetUserTypeResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mUserID;
    uint8_t mUserType;
};

/*
 * Command SetWeekdaySchedule
 */
class DoorLockSetWeekdaySchedule : public ModelCommand
{
public:
    DoorLockSetWeekdaySchedule() : ModelCommand("set-weekday-schedule", kDoorLockClusterId, 0x0B)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("daysMask", 0, UINT8_MAX, &mDaysMask);
        AddArgument("startHour", 0, UINT8_MAX, &mStartHour);
        AddArgument("startMinute", 0, UINT8_MAX, &mStartMinute);
        AddArgument("endHour", 0, UINT8_MAX, &mEndHour);
        AddArgument("endMinute", 0, UINT8_MAX, &mEndMinute);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetWeekdayScheduleCommand(endPointId, mScheduleID, mUserID, mDaysMask, mStartHour, mStartMinute,
                                                              mEndHour, mEndMinute);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetWeekdayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetWeekdayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
    uint8_t mDaysMask;
    uint8_t mStartHour;
    uint8_t mStartMinute;
    uint8_t mEndHour;
    uint8_t mEndMinute;
};

/*
 * Command SetYeardaySchedule
 */
class DoorLockSetYeardaySchedule : public ModelCommand
{
public:
    DoorLockSetYeardaySchedule() : ModelCommand("set-yearday-schedule", kDoorLockClusterId, 0x0E)
    {
        AddArgument("scheduleID", 0, UINT8_MAX, &mScheduleID);
        AddArgument("userID", 0, UINT16_MAX, &mUserID);
        AddArgument("localStartTime", 0, UINT32_MAX, &mLocalStartTime);
        AddArgument("localEndTime", 0, UINT32_MAX, &mLocalEndTime);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterSetYeardayScheduleCommand(endPointId, mScheduleID, mUserID, mLocalStartTime, mLocalEndTime);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: SetYeardayScheduleResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        SetYeardayScheduleResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mScheduleID;
    uint16_t mUserID;
    uint32_t mLocalStartTime;
    uint32_t mLocalEndTime;
};

/*
 * Command UnlockDoor
 */
class DoorLockUnlockDoor : public ModelCommand
{
public:
    DoorLockUnlockDoor() : ModelCommand("unlock-door", kDoorLockClusterId, 0x01)
    {
        AddArgument("pINOrRFIDCode", &mPINOrRFIDCode);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterUnlockDoorCommand(endPointId, mPINOrRFIDCode);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: UnlockDoorResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        UnlockDoorResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    char * mPINOrRFIDCode;
};

/*
 * Command UnlockWithTimeout
 */
class DoorLockUnlockWithTimeout : public ModelCommand
{
public:
    DoorLockUnlockWithTimeout() : ModelCommand("unlock-with-timeout", kDoorLockClusterId, 0x03)
    {
        AddArgument("timeoutInSeconds", 0, UINT16_MAX, &mTimeoutInSeconds);
        AddArgument("pINOrRFIDCode", &mPINOrRFIDCode);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterUnlockWithTimeoutCommand(endPointId, mTimeoutInSeconds, mPINOrRFIDCode);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: UnlockWithTimeoutResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        UnlockWithTimeoutResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mTimeoutInSeconds;
    char * mPINOrRFIDCode;
};

/*
 * Discover attributes
 */
class DiscoverDoorLockAttributes : public ModelCommand
{
public:
    DiscoverDoorLockAttributes() : ModelCommand("discover", kDoorLockClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeDoorLockClusterDiscoverAttributes(endPointId); }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute LockState
 */
class ReadDoorLockLockState : public ModelCommand
{
public:
    ReadDoorLockLockState() : ModelCommand("read", kDoorLockClusterId, 0x00)
    {
        AddArgument("attr-name", "lock-state");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterReadLockStateAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportDoorLockLockState : public ModelCommand
{
public:
    ReportDoorLockLockState() : ModelCommand("report", kDoorLockClusterId, 0x06)
    {
        AddArgument("attr-name", "lock-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterReportLockStateAttribute(endPointId, mMinInterval, mMaxInterval);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
};

/*
 * Attribute LockType
 */
class ReadDoorLockLockType : public ModelCommand
{
public:
    ReadDoorLockLockType() : ModelCommand("read", kDoorLockClusterId, 0x00)
    {
        AddArgument("attr-name", "lock-type");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeDoorLockClusterReadLockTypeAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ActuatorEnabled
 */
class ReadDoorLockActuatorEnabled : public ModelCommand
{
public:
    ReadDoorLockActuatorEnabled() : ModelCommand("read", kDoorLockClusterId, 0x00)
    {
        AddArgument("attr-name", "actuator-enabled");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeDoorLockClusterReadActuatorEnabledAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster Groups                                                      | 0x0004 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
| * AddGroupResponse                                                  |   0x00 |
| * GetGroupMembershipResponse                                        |   0x02 |
| * RemoveGroupResponse                                               |   0x03 |
| * ViewGroupResponse                                                 |   0x01 |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddGroup                                                          |   0x00 |
| * AddGroupIfIdentifying                                             |   0x05 |
| * GetGroupMembership                                                |   0x02 |
| * RemoveAllGroups                                                   |   0x04 |
| * RemoveGroup                                                       |   0x03 |
| * ViewGroup                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NameSupport                                                       | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command Response AddGroupResponse
 */
class AddGroupResponse : public ModelCommandResponse
{
public:
    AddGroupResponse() : ModelCommandResponse(0x00) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "AddGroupResponse (0x00):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // enum8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        return success;
    }
};

/*
 * Command Response GetGroupMembershipResponse
 */
class GetGroupMembershipResponse : public ModelCommandResponse
{
public:
    GetGroupMembershipResponse() : ModelCommandResponse(0x02) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetGroupMembershipResponse (0x02):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t capacity = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "capacity", capacity);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t groupCount = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "groupCount", groupCount);

        // uint16_t uint16[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t groupList = chip::Encoding::LittleEndian::Read16(message); // uint16
            ChipLogProgress(chipTool, "  %s: 0x%04x", "groupList", groupList);
        }

        return success;
    }
};

/*
 * Command Response RemoveGroupResponse
 */
class RemoveGroupResponse : public ModelCommandResponse
{
public:
    RemoveGroupResponse() : ModelCommandResponse(0x03) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "RemoveGroupResponse (0x03):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // enum8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        return success;
    }
};

/*
 * Command Response ViewGroupResponse
 */
class ViewGroupResponse : public ModelCommandResponse
{
public:
    ViewGroupResponse() : ModelCommandResponse(0x01) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ViewGroupResponse (0x01):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // enum8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "status", status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        {
            uint8_t groupNameLen = chip::Encoding::Read8(message);                   // string
            ChipLogProgress(chipTool, "  %s: 0x%02x", "groupNameLen", groupNameLen); // string

            // FIXME Strings are not supported yet. For the moment the code just checks that
            // there is enough bytes in the buffer
            CHECK_MESSAGE_LENGTH(groupNameLen);
            message += groupNameLen;
        }

        return success;
    }
};

/*
 * Command AddGroup
 */
class GroupsAddGroup : public ModelCommand
{
public:
    GroupsAddGroup() : ModelCommand("add-group", kGroupsClusterId, 0x00)
    {
        AddArgument("groupId", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupId);
        AddArgument("groupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeGroupsClusterAddGroupCommand(endPointId, mGroupId, mGroupName);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: AddGroupResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        AddGroupResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupId;
    char * mGroupName;
};

/*
 * Command AddGroupIfIdentifying
 */
class GroupsAddGroupIfIdentifying : public ModelCommand
{
public:
    GroupsAddGroupIfIdentifying() : ModelCommand("add-group-if-identifying", kGroupsClusterId, 0x05)
    {
        AddArgument("groupId", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupId);
        AddArgument("groupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeGroupsClusterAddGroupIfIdentifyingCommand(endPointId, mGroupId, mGroupName);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupId;
    char * mGroupName;
};

/*
 * Command GetGroupMembership
 */
class GroupsGetGroupMembership : public ModelCommand
{
public:
    GroupsGetGroupMembership() : ModelCommand("get-group-membership", kGroupsClusterId, 0x02)
    {
        AddArgument("groupCount", 0, UINT8_MAX, &mGroupCount);
        // groupList is an array, but since chip-tool does not support variable
        // number of arguments, only a single instance is supported.
        AddArgument("groupList", 0, UINT16_MAX, &mGroupList);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeGroupsClusterGetGroupMembershipCommand(endPointId, mGroupCount, mGroupList);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetGroupMembershipResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetGroupMembershipResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mGroupCount;
    uint16_t mGroupList;
};

/*
 * Command RemoveAllGroups
 */
class GroupsRemoveAllGroups : public ModelCommand
{
public:
    GroupsRemoveAllGroups() : ModelCommand("remove-all-groups", kGroupsClusterId, 0x04) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeGroupsClusterRemoveAllGroupsCommand(endPointId); }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command RemoveGroup
 */
class GroupsRemoveGroup : public ModelCommand
{
public:
    GroupsRemoveGroup() : ModelCommand("remove-group", kGroupsClusterId, 0x03)
    {
        AddArgument("groupId", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupId);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeGroupsClusterRemoveGroupCommand(endPointId, mGroupId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: RemoveGroupResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        RemoveGroupResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupId;
};

/*
 * Command ViewGroup
 */
class GroupsViewGroup : public ModelCommand
{
public:
    GroupsViewGroup() : ModelCommand("view-group", kGroupsClusterId, 0x01)
    {
        AddArgument("groupId", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupId);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeGroupsClusterViewGroupCommand(endPointId, mGroupId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ViewGroupResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ViewGroupResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupId;
};

/*
 * Discover attributes
 */
class DiscoverGroupsAttributes : public ModelCommand
{
public:
    DiscoverGroupsAttributes() : ModelCommand("discover", kGroupsClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeGroupsClusterDiscoverAttributes(endPointId); }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute NameSupport
 */
class ReadGroupsNameSupport : public ModelCommand
{
public:
    ReadGroupsNameSupport() : ModelCommand("read", kGroupsClusterId, 0x00)
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeGroupsClusterReadNameSupportAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster IasZone                                                     | 0x0500 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ZoneState                                                         | 0x0000 |
| * ZoneType                                                          | 0x0001 |
| * ZoneStatus                                                        | 0x0002 |
| * IasCieAddress                                                     | 0x0010 |
| * ZoneID                                                            | 0x0011 |
\*----------------------------------------------------------------------------*/

/*
 * Discover attributes
 */
class DiscoverIasZoneAttributes : public ModelCommand
{
public:
    DiscoverIasZoneAttributes() : ModelCommand("discover", kIasZoneClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeIasZoneClusterDiscoverAttributes(endPointId); }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ZoneState
 */
class ReadIasZoneZoneState : public ModelCommand
{
public:
    ReadIasZoneZoneState() : ModelCommand("read", kIasZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "zone-state");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeIasZoneClusterReadZoneStateAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ZoneType
 */
class ReadIasZoneZoneType : public ModelCommand
{
public:
    ReadIasZoneZoneType() : ModelCommand("read", kIasZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "zone-type");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeIasZoneClusterReadZoneTypeAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute ZoneStatus
 */
class ReadIasZoneZoneStatus : public ModelCommand
{
public:
    ReadIasZoneZoneStatus() : ModelCommand("read", kIasZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "zone-status");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeIasZoneClusterReadZoneStatusAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute IasCieAddress
 */
class ReadIasZoneIasCieAddress : public ModelCommand
{
public:
    ReadIasZoneIasCieAddress() : ModelCommand("read", kIasZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "ias-cie-address");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeIasZoneClusterReadIasCieAddressAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class WriteIasZoneIasCieAddress : public ModelCommand
{
public:
    WriteIasZoneIasCieAddress() : ModelCommand("write", kIasZoneClusterId, 0x01)
    {
        AddArgument("attr-name", "ias-cie-address");
        AddArgument("attr-value", 0, UINT64_MAX, &mIasCieAddress);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeIasZoneClusterWriteIasCieAddressAttribute(endPointId, mIasCieAddress);
    }

    // Global Response: WriteAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        WriteAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint64_t mIasCieAddress;
};

/*
 * Attribute ZoneID
 */
class ReadIasZoneZoneID : public ModelCommand
{
public:
    ReadIasZoneZoneID() : ModelCommand("read", kIasZoneClusterId, 0x00)
    {
        AddArgument("attr-name", "zone-id");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeIasZoneClusterReadZoneIdAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster Identify                                                    | 0x0003 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
| * IdentifyQueryResponse                                             |   0x00 |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Identify                                                          |   0x00 |
| * IdentifyQuery                                                     |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * IdentifyTime                                                      | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command Response IdentifyQueryResponse
 */
class IdentifyQueryResponse : public ModelCommandResponse
{
public:
    IdentifyQueryResponse() : ModelCommandResponse(0x00) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "IdentifyQueryResponse (0x00):");

        CHECK_MESSAGE_LENGTH(2);
        uint16_t timeout = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "timeout", timeout);

        return success;
    }
};

/*
 * Command Identify
 */
class IdentifyIdentify : public ModelCommand
{
public:
    IdentifyIdentify() : ModelCommand("identify", kIdentifyClusterId, 0x00)
    {
        AddArgument("identifyTime", 0, UINT16_MAX, &mIdentifyTime);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeIdentifyClusterIdentifyCommand(endPointId, mIdentifyTime);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mIdentifyTime;
};

/*
 * Command IdentifyQuery
 */
class IdentifyIdentifyQuery : public ModelCommand
{
public:
    IdentifyIdentifyQuery() : ModelCommand("identify-query", kIdentifyClusterId, 0x01) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeIdentifyClusterIdentifyQueryCommand(endPointId); }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: IdentifyQueryResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        IdentifyQueryResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverIdentifyAttributes : public ModelCommand
{
public:
    DiscoverIdentifyAttributes() : ModelCommand("discover", kIdentifyClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeIdentifyClusterDiscoverAttributes(endPointId); }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute IdentifyTime
 */
class ReadIdentifyIdentifyTime : public ModelCommand
{
public:
    ReadIdentifyIdentifyTime() : ModelCommand("read", kIdentifyClusterId, 0x00)
    {
        AddArgument("attr-name", "identify-time");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeIdentifyClusterReadIdentifyTimeAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster Level                                                       | 0x0008 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Move                                                              |   0x01 |
| * MoveToLevel                                                       |   0x00 |
| * MoveToLevelWithOnOff                                              |   0x04 |
| * MoveWithOnOff                                                     |   0x05 |
| * Step                                                              |   0x02 |
| * StepWithOnOff                                                     |   0x06 |
| * Stop                                                              |   0x03 |
| * StopWithOnOff                                                     |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentLevel                                                      | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command Move
 */
class LevelMove : public ModelCommand
{
public:
    LevelMove() : ModelCommand("move", kLevelClusterId, 0x01)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT8_MAX, &mRate);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterMoveCommand(endPointId, mMoveMode, mRate, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToLevel
 */
class LevelMoveToLevel : public ModelCommand
{
public:
    LevelMoveToLevel() : ModelCommand("move-to-level", kLevelClusterId, 0x00)
    {
        AddArgument("level", 0, UINT8_MAX, &mLevel);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterMoveToLevelCommand(endPointId, mLevel, mTransitionTime, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToLevelWithOnOff
 */
class LevelMoveToLevelWithOnOff : public ModelCommand
{
public:
    LevelMoveToLevelWithOnOff() : ModelCommand("move-to-level-with-on-off", kLevelClusterId, 0x04)
    {
        AddArgument("level", 0, UINT8_MAX, &mLevel);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterMoveToLevelWithOnOffCommand(endPointId, mLevel, mTransitionTime);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
};

/*
 * Command MoveWithOnOff
 */
class LevelMoveWithOnOff : public ModelCommand
{
public:
    LevelMoveWithOnOff() : ModelCommand("move-with-on-off", kLevelClusterId, 0x05)
    {
        AddArgument("moveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("rate", 0, UINT8_MAX, &mRate);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterMoveWithOnOffCommand(endPointId, mMoveMode, mRate);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
};

/*
 * Command Step
 */
class LevelStep : public ModelCommand
{
public:
    LevelStep() : ModelCommand("step", kLevelClusterId, 0x02)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterStepCommand(endPointId, mStepMode, mStepSize, mTransitionTime, mOptionsMask,
                                                    mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepWithOnOff
 */
class LevelStepWithOnOff : public ModelCommand
{
public:
    LevelStepWithOnOff() : ModelCommand("step-with-on-off", kLevelClusterId, 0x06)
    {
        AddArgument("stepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("stepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterStepWithOnOffCommand(endPointId, mStepMode, mStepSize, mTransitionTime);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
};

/*
 * Command Stop
 */
class LevelStop : public ModelCommand
{
public:
    LevelStop() : ModelCommand("stop", kLevelClusterId, 0x03)
    {
        AddArgument("optionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("optionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterStopCommand(endPointId, mOptionsMask, mOptionsOverride);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StopWithOnOff
 */
class LevelStopWithOnOff : public ModelCommand
{
public:
    LevelStopWithOnOff() : ModelCommand("stop-with-on-off", kLevelClusterId, 0x07) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterStopWithOnOffCommand(endPointId);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverLevelAttributes : public ModelCommand
{
public:
    DiscoverLevelAttributes() : ModelCommand("discover", kLevelClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterDiscoverAttributes(endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentLevel
 */
class ReadLevelCurrentLevel : public ModelCommand
{
public:
    ReadLevelCurrentLevel() : ModelCommand("read", kLevelClusterId, 0x00)
    {
        AddArgument("attr-name", "current-level");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterReadCurrentLevelAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportLevelCurrentLevel : public ModelCommand
{
public:
    ReportLevelCurrentLevel() : ModelCommand("report", kLevelClusterId, 0x06)
    {
        AddArgument("attr-name", "current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", 0, UINT8_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeLevelControlClusterReportCurrentLevelAttribute(endPointId, mMinInterval, mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    uint8_t mChange;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOff                                                       | 0x0006 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Off                                                               |   0x00 |
| * On                                                                |   0x01 |
| * Toggle                                                            |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OnOff                                                             | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command Off
 */
class OnOffOff : public ModelCommand
{
public:
    OnOffOff() : ModelCommand("off", kOnOffClusterId, 0x00) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeOnOffClusterOffCommand(endPointId); }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command On
 */
class OnOffOn : public ModelCommand
{
public:
    OnOffOn() : ModelCommand("on", kOnOffClusterId, 0x01) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeOnOffClusterOnCommand(endPointId); }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Command Toggle
 */
class OnOffToggle : public ModelCommand
{
public:
    OnOffToggle() : ModelCommand("toggle", kOnOffClusterId, 0x02) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeOnOffClusterToggleCommand(endPointId); }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Discover attributes
 */
class DiscoverOnOffAttributes : public ModelCommand
{
public:
    DiscoverOnOffAttributes() : ModelCommand("discover", kOnOffClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeOnOffClusterDiscoverAttributes(endPointId); }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute OnOff
 */
class ReadOnOffOnOff : public ModelCommand
{
public:
    ReadOnOffOnOff() : ModelCommand("read", kOnOffClusterId, 0x00)
    {
        AddArgument("attr-name", "on-off");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeOnOffClusterReadOnOffAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportOnOffOnOff : public ModelCommand
{
public:
    ReportOnOffOnOff() : ModelCommand("report", kOnOffClusterId, 0x06)
    {
        AddArgument("attr-name", "on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeOnOffClusterReportOnOffAttribute(endPointId, mMinInterval, mMaxInterval);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
};

/*----------------------------------------------------------------------------*\
| Cluster Scenes                                                      | 0x0005 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
| * AddSceneResponse                                                  |   0x00 |
| * GetSceneMembershipResponse                                        |   0x06 |
| * RemoveAllScenesResponse                                           |   0x03 |
| * RemoveSceneResponse                                               |   0x02 |
| * StoreSceneResponse                                                |   0x04 |
| * ViewSceneResponse                                                 |   0x01 |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddScene                                                          |   0x00 |
| * GetSceneMembership                                                |   0x06 |
| * RecallScene                                                       |   0x05 |
| * RemoveAllScenes                                                   |   0x03 |
| * RemoveScene                                                       |   0x02 |
| * StoreScene                                                        |   0x04 |
| * ViewScene                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SceneCount                                                        | 0x0000 |
| * CurrentScene                                                      | 0x0001 |
| * CurrentGroup                                                      | 0x0002 |
| * SceneValid                                                        | 0x0003 |
| * NameSupport                                                       | 0x0004 |
\*----------------------------------------------------------------------------*/

/*
 * Command Response AddSceneResponse
 */
class AddSceneResponse : public ModelCommandResponse
{
public:
    AddSceneResponse() : ModelCommandResponse(0x00) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "AddSceneResponse (0x00):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t sceneId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneId", sceneId);

        return success;
    }
};

/*
 * Command Response GetSceneMembershipResponse
 */
class GetSceneMembershipResponse : public ModelCommandResponse
{
public:
    GetSceneMembershipResponse() : ModelCommandResponse(0x06) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "GetSceneMembershipResponse (0x06):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t capacity = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "capacity", capacity);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        // uint8_t uint8[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(1);
            uint8_t sceneList = chip::Encoding::Read8(message); // uint8
            ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneList", sceneList);
        }

        return success;
    }
};

/*
 * Command Response RemoveAllScenesResponse
 */
class RemoveAllScenesResponse : public ModelCommandResponse
{
public:
    RemoveAllScenesResponse() : ModelCommandResponse(0x03) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "RemoveAllScenesResponse (0x03):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        return success;
    }
};

/*
 * Command Response RemoveSceneResponse
 */
class RemoveSceneResponse : public ModelCommandResponse
{
public:
    RemoveSceneResponse() : ModelCommandResponse(0x02) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "RemoveSceneResponse (0x02):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t sceneId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneId", sceneId);

        return success;
    }
};

/*
 * Command Response StoreSceneResponse
 */
class StoreSceneResponse : public ModelCommandResponse
{
public:
    StoreSceneResponse() : ModelCommandResponse(0x04) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "StoreSceneResponse (0x04):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t sceneId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneId", sceneId);

        return success;
    }
};

/*
 * Command Response ViewSceneResponse
 */
class ViewSceneResponse : public ModelCommandResponse
{
public:
    ViewSceneResponse() : ModelCommandResponse(0x01) {}

    bool HandleResponse(uint8_t * message, uint16_t messageLen) const override
    {
        bool success = true;
        ChipLogProgress(chipTool, "ViewSceneResponse (0x01):");

        CHECK_MESSAGE_LENGTH(1);
        uint8_t status = chip::Encoding::Read8(message); // zclStatus
        success        = CheckStatus(status);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t groupId = chip::Encoding::LittleEndian::Read16(message); // SGroupId
        ChipLogProgress(chipTool, "  %s: 0x%04x", "groupId", groupId);

        CHECK_MESSAGE_LENGTH(1);
        uint8_t sceneId = chip::Encoding::Read8(message); // uint8
        ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneId", sceneId);

        CHECK_MESSAGE_LENGTH(2);
        uint16_t transitionTime = chip::Encoding::LittleEndian::Read16(message); // uint16
        ChipLogProgress(chipTool, "  %s: 0x%04x", "transitionTime", transitionTime);

        CHECK_MESSAGE_LENGTH(1);
        {
            uint8_t sceneNameLen = chip::Encoding::Read8(message);                   // SSceneName
            ChipLogProgress(chipTool, "  %s: 0x%02x", "sceneNameLen", sceneNameLen); // SSceneName

            // FIXME Strings are not supported yet. For the moment the code just checks that
            // there is enough bytes in the buffer
            CHECK_MESSAGE_LENGTH(sceneNameLen);
            message += sceneNameLen;
        }

        // struct SExtensionFieldSetList[]
        while (messageLen)
        {
            CHECK_MESSAGE_LENGTH(2);
            uint16_t clusterId = chip::Encoding::LittleEndian::Read16(message); // uint16
            ChipLogProgress(chipTool, "  %s: 0x%04x", "clusterId", clusterId);

            CHECK_MESSAGE_LENGTH(1);
            {
                uint8_t extensionFieldSetLen = chip::Encoding::Read8(message);                           // octstr
                ChipLogProgress(chipTool, "  %s: 0x%02x", "extensionFieldSetLen", extensionFieldSetLen); // octstr

                // FIXME Strings are not supported yet. For the moment the code just checks that
                // there is enough bytes in the buffer
                CHECK_MESSAGE_LENGTH(extensionFieldSetLen);
                message += extensionFieldSetLen;
            }
        }

        return success;
    }
};

/*
 * Command AddScene
 */
class ScenesAddScene : public ModelCommand
{
public:
    ScenesAddScene() : ModelCommand("add-scene", kScenesClusterId, 0x00)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("sceneName", &mSceneName);
        // extensionFieldSets is an array, but since chip-tool does not support variable
        // number of arguments, only a single instance is supported.
        AddArgument("clusterId", 0, UINT16_MAX, &mClusterId);
        AddArgument("length", 0, UINT8_MAX, &mLength);
        AddArgument("value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterAddSceneCommand(endPointId, mGroupID, mSceneID, mTransitionTime, mSceneName, mClusterId, mLength,
                                                  mValue);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: AddSceneResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        AddSceneResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
    uint16_t mTransitionTime;
    char * mSceneName;
    uint16_t mClusterId;
    uint8_t mLength;
    uint8_t mValue;
};

/*
 * Command GetSceneMembership
 */
class ScenesGetSceneMembership : public ModelCommand
{
public:
    ScenesGetSceneMembership() : ModelCommand("get-scene-membership", kScenesClusterId, 0x06)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterGetSceneMembershipCommand(endPointId, mGroupID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: GetSceneMembershipResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        GetSceneMembershipResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
};

/*
 * Command RecallScene
 */
class ScenesRecallScene : public ModelCommand
{
public:
    ScenesRecallScene() : ModelCommand("recall-scene", kScenesClusterId, 0x05)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        AddArgument("transitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterRecallSceneCommand(endPointId, mGroupID, mSceneID, mTransitionTime);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
    uint16_t mTransitionTime;
};

/*
 * Command RemoveAllScenes
 */
class ScenesRemoveAllScenes : public ModelCommand
{
public:
    ScenesRemoveAllScenes() : ModelCommand("remove-all-scenes", kScenesClusterId, 0x03)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterRemoveAllScenesCommand(endPointId, mGroupID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: RemoveAllScenesResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        RemoveAllScenesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
};

/*
 * Command RemoveScene
 */
class ScenesRemoveScene : public ModelCommand
{
public:
    ScenesRemoveScene() : ModelCommand("remove-scene", kScenesClusterId, 0x02)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterRemoveSceneCommand(endPointId, mGroupID, mSceneID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: RemoveSceneResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        RemoveSceneResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
};

/*
 * Command StoreScene
 */
class ScenesStoreScene : public ModelCommand
{
public:
    ScenesStoreScene() : ModelCommand("store-scene", kScenesClusterId, 0x04)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterStoreSceneCommand(endPointId, mGroupID, mSceneID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: StoreSceneResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        StoreSceneResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
};

/*
 * Command ViewScene
 */
class ScenesViewScene : public ModelCommand
{
public:
    ScenesViewScene() : ModelCommand("view-scene", kScenesClusterId, 0x01)
    {
        AddArgument("groupID", 0, std::numeric_limits<chip::GroupId>::max(), &mGroupID);
        AddArgument("sceneID", 0, UINT8_MAX, &mSceneID);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterViewSceneCommand(endPointId, mGroupID, mSceneID);
    }

    // Global Response: DefaultResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DefaultResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

    // Specific Response: ViewSceneResponse
    bool HandleSpecificResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ViewSceneResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    chip::GroupId mGroupID;
    uint8_t mSceneID;
};

/*
 * Discover attributes
 */
class DiscoverScenesAttributes : public ModelCommand
{
public:
    DiscoverScenesAttributes() : ModelCommand("discover", kScenesClusterId, 0x0c) { ModelCommand::AddArguments(); }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeScenesClusterDiscoverAttributes(endPointId); }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute SceneCount
 */
class ReadScenesSceneCount : public ModelCommand
{
public:
    ReadScenesSceneCount() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "scene-count");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeScenesClusterReadSceneCountAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentScene
 */
class ReadScenesCurrentScene : public ModelCommand
{
public:
    ReadScenesCurrentScene() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "current-scene");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterReadCurrentSceneAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute CurrentGroup
 */
class ReadScenesCurrentGroup : public ModelCommand
{
public:
    ReadScenesCurrentGroup() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "current-group");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterReadCurrentGroupAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute SceneValid
 */
class ReadScenesSceneValid : public ModelCommand
{
public:
    ReadScenesSceneValid() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "scene-valid");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override { return encodeScenesClusterReadSceneValidAttribute(endPointId); }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute NameSupport
 */
class ReadScenesNameSupport : public ModelCommand
{
public:
    ReadScenesNameSupport() : ModelCommand("read", kScenesClusterId, 0x00)
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeScenesClusterReadNameSupportAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Cluster TemperatureMeasurement                                      | 0x0402 |
|------------------------------------------------------------------------------|
| Responses:                                                          |        |
|                                                                     |        |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Discover attributes
 */
class DiscoverTemperatureMeasurementAttributes : public ModelCommand
{
public:
    DiscoverTemperatureMeasurementAttributes() : ModelCommand("discover", kTempMeasurementClusterId, 0x0c)
    {
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterDiscoverAttributes(endPointId);
    }

    // Global Response: DiscoverAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        DiscoverAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute MeasuredValue
 */
class ReadTemperatureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMeasuredValue() : ModelCommand("read", kTempMeasurementClusterId, 0x00)
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterReadMeasuredValueAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

class ReportTemperatureMeasurementMeasuredValue : public ModelCommand
{
public:
    ReportTemperatureMeasurementMeasuredValue() : ModelCommand("report", kTempMeasurementClusterId, 0x06)
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("change", INT16_MIN, INT16_MAX, &mChange);
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterReportMeasuredValueAttribute(endPointId, mMinInterval, mMaxInterval, mChange);
    }

    // Global Response: ConfigureReportingResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ConfigureReportingResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    int16_t mChange;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadTemperatureMeasurementMinMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMinMeasuredValue() : ModelCommand("read", kTempMeasurementClusterId, 0x00)
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterReadMinMeasuredValueAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadTemperatureMeasurementMaxMeasuredValue : public ModelCommand
{
public:
    ReadTemperatureMeasurementMaxMeasuredValue() : ModelCommand("read", kTempMeasurementClusterId, 0x00)
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    PacketBufferHandle EncodeCommand(uint8_t endPointId) override
    {
        return encodeTemperatureMeasurementClusterReadMaxMeasuredValueAttribute(endPointId);
    }

    // Global Response: ReadAttributesResponse
    bool HandleGlobalResponse(uint8_t commandId, uint8_t * message, uint16_t messageLen) const override
    {
        ReadAttributesResponse response;
        return response.HandleCommandResponse(commandId, message, messageLen);
    }
};

/*----------------------------------------------------------------------------*\
| Register all Clusters commands                                               |
\*----------------------------------------------------------------------------*/
void registerClusterBarrierControl(Commands & commands)
{
    const char * clusterName = "BarrierControl";

    commands_list clusterCommands = {
        make_unique<BarrierControlGoToPercent>(),         make_unique<BarrierControlStop>(),
        make_unique<DiscoverBarrierControlAttributes>(),  make_unique<ReadBarrierControlMovingState>(),
        make_unique<ReadBarrierControlSafetyStatus>(),    make_unique<ReadBarrierControlCapabilities>(),
        make_unique<ReadBarrierControlBarrierPosition>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterBasic(Commands & commands)
{
    const char * clusterName = "Basic";

    commands_list clusterCommands = {
        make_unique<BasicResetToFactoryDefaults>(), make_unique<BasicMfgSpecificPing>(), make_unique<DiscoverBasicAttributes>(),
        make_unique<ReadBasicZclVersion>(),         make_unique<ReadBasicPowerSource>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterColorControl(Commands & commands)
{
    const char * clusterName = "ColorControl";

    commands_list clusterCommands = {
        make_unique<ColorControlMoveColor>(),
        make_unique<ColorControlMoveColorTemperature>(),
        make_unique<ColorControlMoveHue>(),
        make_unique<ColorControlMoveSaturation>(),
        make_unique<ColorControlMoveToColor>(),
        make_unique<ColorControlMoveToColorTemperature>(),
        make_unique<ColorControlMoveToHue>(),
        make_unique<ColorControlMoveToHueAndSaturation>(),
        make_unique<ColorControlMoveToSaturation>(),
        make_unique<ColorControlStepColor>(),
        make_unique<ColorControlStepColorTemperature>(),
        make_unique<ColorControlStepHue>(),
        make_unique<ColorControlStepSaturation>(),
        make_unique<ColorControlStopMoveStep>(),
        make_unique<DiscoverColorControlAttributes>(),
        make_unique<ReadColorControlCurrentHue>(),
        make_unique<ReportColorControlCurrentHue>(),
        make_unique<ReadColorControlCurrentSaturation>(),
        make_unique<ReportColorControlCurrentSaturation>(),
        make_unique<ReadColorControlRemainingTime>(),
        make_unique<ReadColorControlCurrentX>(),
        make_unique<ReportColorControlCurrentX>(),
        make_unique<ReadColorControlCurrentY>(),
        make_unique<ReportColorControlCurrentY>(),
        make_unique<ReadColorControlColorTemperature>(),
        make_unique<ReportColorControlColorTemperature>(),
        make_unique<ReadColorControlColorMode>(),
        make_unique<ReadColorControlNumberOfPrimaries>(),
        make_unique<ReadColorControlPrimary1X>(),
        make_unique<ReadColorControlPrimary1Y>(),
        make_unique<ReadColorControlPrimary1Intensity>(),
        make_unique<ReadColorControlPrimary2X>(),
        make_unique<ReadColorControlPrimary2Y>(),
        make_unique<ReadColorControlPrimary2Intensity>(),
        make_unique<ReadColorControlPrimary3X>(),
        make_unique<ReadColorControlPrimary3Y>(),
        make_unique<ReadColorControlPrimary3Intensity>(),
        make_unique<ReadColorControlPrimary4X>(),
        make_unique<ReadColorControlPrimary4Y>(),
        make_unique<ReadColorControlPrimary4Intensity>(),
        make_unique<ReadColorControlPrimary5X>(),
        make_unique<ReadColorControlPrimary5Y>(),
        make_unique<ReadColorControlPrimary5Intensity>(),
        make_unique<ReadColorControlPrimary6X>(),
        make_unique<ReadColorControlPrimary6Y>(),
        make_unique<ReadColorControlPrimary6Intensity>(),
        make_unique<ReadColorControlEnhancedCurrentHue>(),
        make_unique<ReadColorControlEnhancedColorMode>(),
        make_unique<ReadColorControlColorLoopActive>(),
        make_unique<ReadColorControlColorLoopDirection>(),
        make_unique<ReadColorControlColorLoopTime>(),
        make_unique<ReadColorControlColorCapabilities>(),
        make_unique<ReadColorControlColorTempPhysicalMin>(),
        make_unique<ReadColorControlColorTempPhysicalMax>(),
        make_unique<ReadColorControlCoupleColorTempToLevelMinMireds>(),
        make_unique<ReadColorControlStartUpColorTemperatureMireds>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterDoorLock(Commands & commands)
{
    const char * clusterName = "DoorLock";

    commands_list clusterCommands = {
        make_unique<DoorLockClearAllPins>(),
        make_unique<DoorLockClearAllRfids>(),
        make_unique<DoorLockClearHolidaySchedule>(),
        make_unique<DoorLockClearPin>(),
        make_unique<DoorLockClearRfid>(),
        make_unique<DoorLockClearWeekdaySchedule>(),
        make_unique<DoorLockClearYeardaySchedule>(),
        make_unique<DoorLockGetHolidaySchedule>(),
        make_unique<DoorLockGetPin>(),
        make_unique<DoorLockGetRfid>(),
        make_unique<DoorLockGetUserType>(),
        make_unique<DoorLockGetWeekdaySchedule>(),
        make_unique<DoorLockGetYeardaySchedule>(),
        make_unique<DoorLockLockDoor>(),
        make_unique<DoorLockSetHolidaySchedule>(),
        make_unique<DoorLockSetPin>(),
        make_unique<DoorLockSetRfid>(),
        make_unique<DoorLockSetUserType>(),
        make_unique<DoorLockSetWeekdaySchedule>(),
        make_unique<DoorLockSetYeardaySchedule>(),
        make_unique<DoorLockUnlockDoor>(),
        make_unique<DoorLockUnlockWithTimeout>(),
        make_unique<DiscoverDoorLockAttributes>(),
        make_unique<ReadDoorLockLockState>(),
        make_unique<ReportDoorLockLockState>(),
        make_unique<ReadDoorLockLockType>(),
        make_unique<ReadDoorLockActuatorEnabled>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterGroups(Commands & commands)
{
    const char * clusterName = "Groups";

    commands_list clusterCommands = {
        make_unique<GroupsAddGroup>(),           make_unique<GroupsAddGroupIfIdentifying>(),
        make_unique<GroupsGetGroupMembership>(), make_unique<GroupsRemoveAllGroups>(),
        make_unique<GroupsRemoveGroup>(),        make_unique<GroupsViewGroup>(),
        make_unique<DiscoverGroupsAttributes>(), make_unique<ReadGroupsNameSupport>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterIasZone(Commands & commands)
{
    const char * clusterName = "IasZone";

    commands_list clusterCommands = {
        make_unique<DiscoverIasZoneAttributes>(), make_unique<ReadIasZoneZoneState>(),     make_unique<ReadIasZoneZoneType>(),
        make_unique<ReadIasZoneZoneStatus>(),     make_unique<ReadIasZoneIasCieAddress>(), make_unique<WriteIasZoneIasCieAddress>(),
        make_unique<ReadIasZoneZoneID>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterIdentify(Commands & commands)
{
    const char * clusterName = "Identify";

    commands_list clusterCommands = {
        make_unique<IdentifyIdentify>(),
        make_unique<IdentifyIdentifyQuery>(),
        make_unique<DiscoverIdentifyAttributes>(),
        make_unique<ReadIdentifyIdentifyTime>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterLevel(Commands & commands)
{
    const char * clusterName = "LevelControl";

    commands_list clusterCommands = {
        make_unique<LevelMove>(),
        make_unique<LevelMoveToLevel>(),
        make_unique<LevelMoveToLevelWithOnOff>(),
        make_unique<LevelMoveWithOnOff>(),
        make_unique<LevelStep>(),
        make_unique<LevelStepWithOnOff>(),
        make_unique<LevelStop>(),
        make_unique<LevelStopWithOnOff>(),
        make_unique<DiscoverLevelAttributes>(),
        make_unique<ReadLevelCurrentLevel>(),
        make_unique<ReportLevelCurrentLevel>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterOnOff(Commands & commands)
{
    const char * clusterName = "OnOff";

    commands_list clusterCommands = {
        make_unique<OnOffOff>(),       make_unique<OnOffOn>(),
        make_unique<OnOffToggle>(),    make_unique<DiscoverOnOffAttributes>(),
        make_unique<ReadOnOffOnOff>(), make_unique<ReportOnOffOnOff>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterScenes(Commands & commands)
{
    const char * clusterName = "Scenes";

    commands_list clusterCommands = {
        make_unique<ScenesAddScene>(),         make_unique<ScenesGetSceneMembership>(), make_unique<ScenesRecallScene>(),
        make_unique<ScenesRemoveAllScenes>(),  make_unique<ScenesRemoveScene>(),        make_unique<ScenesStoreScene>(),
        make_unique<ScenesViewScene>(),        make_unique<DiscoverScenesAttributes>(), make_unique<ReadScenesSceneCount>(),
        make_unique<ReadScenesCurrentScene>(), make_unique<ReadScenesCurrentGroup>(),   make_unique<ReadScenesSceneValid>(),
        make_unique<ReadScenesNameSupport>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusterTempMeasurement(Commands & commands)
{
    const char * clusterName = "TemperatureMeasurement";

    commands_list clusterCommands = {
        make_unique<DiscoverTemperatureMeasurementAttributes>(),   make_unique<ReadTemperatureMeasurementMeasuredValue>(),
        make_unique<ReportTemperatureMeasurementMeasuredValue>(),  make_unique<ReadTemperatureMeasurementMinMeasuredValue>(),
        make_unique<ReadTemperatureMeasurementMaxMeasuredValue>(),
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusters(Commands & commands)
{
    registerClusterBarrierControl(commands);
    registerClusterBasic(commands);
    registerClusterColorControl(commands);
    registerClusterDoorLock(commands);
    registerClusterGroups(commands);
    registerClusterIasZone(commands);
    registerClusterIdentify(commands);
    registerClusterLevel(commands);
    registerClusterOnOff(commands);
    registerClusterScenes(commands);
    registerClusterTempMeasurement(commands);
}
