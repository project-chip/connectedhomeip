{{#chip_tests tests}}
class {{filename}}: public TestCommand
{
  public:
    {{filename}}(): TestCommand("{{filename}}"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
      CHIP_ERROR err = CHIP_NO_ERROR;

      if (mTestCount == mTestIndex)
      {
          ChipLogProgress(chipTool, "{{filename}}: Test complete");
          SetCommandExitStatus(CHIP_NO_ERROR);
      }

      // Ensure we increment mTestIndex before we start running the relevant
      // command.  That way if we lose the timeslice after we send the message
      // but before our function call returns, we won't end up with an
      // incorrect mTestIndex value observed when we get the response.
      switch (mTestIndex++)
      {
        {{#chip_tests_items}}
        case {{index}}:
          err = TestSendCluster{{asUpperCamelCase cluster}}Command{{asUpperCamelCase command}}_{{index}}();
          break;
        {{/chip_tests_items}}
      }

      if (CHIP_NO_ERROR != err)
      {
          ChipLogProgress(chipTool, "{{filename}}: %s", chip::ErrorStr(err));
          SetCommandExitStatus(err);
      }
    }


  private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = {{totalTests}};

    //
    // Tests methods
    //

    {{#chip_tests_items}}
    {{#if (isTestOnlyCluster cluster)}}
    CHIP_ERROR TestSendCluster{{asUpperCamelCase cluster}}Command{{asUpperCamelCase command}}_{{index}}()
    {
        ChipLogProgress(chipTool, "{{cluster}} - {{label}}");

        return {{command}}({{#chip_tests_item_parameters}}{{#not_first}}, {{/not_first}}{{definedValue}}{{/chip_tests_item_parameters}});
    }
    {{else}}
    // Test {{label}}
    {{#if isSubscribeAttribute}}
    using SuccessCallback_{{index}} = void (*)(void * context);
    {{else}}
    using SuccessCallback_{{index}} = void (*)(void * context{{#chip_tests_item_response_parameters}}, {{#if isList}}uint16_t count, {{/if}}{{chipType}} {{#if isList}}* {{/if}}{{asLowerCamelCase name}}{{/chip_tests_item_response_parameters}});
    {{/if}}
    chip::Callback::Callback<SuccessCallback_{{index}}> mOnSuccessCallback_{{index}} { OnTestSendCluster{{asUpperCamelCase cluster}}Command{{asUpperCamelCase command}}_{{index}}_SuccessResponse, this };
    chip::Callback::Callback<DefaultFailureCallback> mOnFailureCallback_{{index}} { OnTestSendCluster{{asUpperCamelCase cluster}}Command{{asUpperCamelCase command}}_{{index}}_FailureResponse, this };
    {{#if isSubscribeAttribute}}
    chip::Callback::Callback<{{#chip_tests_with_command_attribute_info}}{{chipCallback.name}}{{/chip_tests_with_command_attribute_info}}AttributeCallback> mOnReportCallback_{{index}} { SubscribeAttribute_{{ index }}_OnReportCallback, this };
    {{/if}}

    bool mIsFailureExpected_{{index}} = {{response.error}};

    {{#if isSubscribeAttribute}}
    size_t mReceivedReport_{{index}} = 0;
    static constexpr size_t kExpectedReport_{{index}} = {{ kickCommands.length }} + 1;
    {{/if}}

    CHIP_ERROR TestSendCluster{{asUpperCamelCase cluster}}Command{{asUpperCamelCase command}}_{{index}}()
    {
        ChipLogProgress(chipTool, "{{cluster}} - {{label}}: Sending command...");

        chip::Controller::{{asUpperCamelCase cluster}}Cluster cluster;
        cluster.Associate(mDevice, {{endpoint}});

        CHIP_ERROR err = CHIP_NO_ERROR;

        {{#if isCommand}}
        {{#chip_tests_item_parameters}}
        {{#if (isString type)}}
        {{chipType}} {{asLowerCamelCase name}}Argument = chip::ByteSpan(chip::Uint8::from_const_char("{{definedValue}}"), strlen("{{definedValue}}"));
        {{else}}
        {{chipType}} {{asLowerCamelCase name}}Argument = {{definedValue}}{{asTypeLiteralSuffix chipType}};
        {{/if}}
        {{/chip_tests_item_parameters}}
        err = cluster.{{asUpperCamelCase command}}(mOnSuccessCallback_{{index}}.Cancel(), mOnFailureCallback_{{index}}.Cancel(){{#chip_tests_item_parameters}}, {{asLowerCamelCase name}}Argument{{/chip_tests_item_parameters}});
        {{else if isReadAttribute}}
        err = cluster.ReadAttribute{{asUpperCamelCase attribute}}(mOnSuccessCallback_{{index}}.Cancel(), mOnFailureCallback_{{index}}.Cancel());
        {{else if isWriteAttribute}}
        {{#chip_tests_item_parameters}}
        {{#if (isString type)}}
        {{chipType}} {{asLowerCamelCase name}}Argument = chip::ByteSpan(chip::Uint8::from_const_char("{{definedValue}}"), strlen("{{definedValue}}"));
        {{else}}
        {{chipType}} {{asLowerCamelCase name}}Argument = {{definedValue}}{{asTypeLiteralSuffix chipType}};
        {{/if}}
        {{/chip_tests_item_parameters}}
        err = cluster.WriteAttribute{{asUpperCamelCase attribute}}(mOnSuccessCallback_{{index}}.Cancel(), mOnFailureCallback_{{index}}.Cancel(), {{#chip_tests_item_parameters}}{{asLowerCamelCase name}}Argument{{/chip_tests_item_parameters}});
        {{else if isSubscribeAttribute}}
        cluster.ReportAttribute{{asUpperCamelCase attribute}}(mOnReportCallback_{{index}}.Cancel());
        err = cluster.ConfigureAttribute{{asUpperCamelCase attribute}}(mOnSuccessCallback_{{index}}.Cancel(), mOnFailureCallback_{{index}}.Cancel(), {{minInterval}}, {{maxInterval}});
        {{else}}
        err = CHIP_ERROR_NOT_IMPLEMENTED;
        {{/if}}

        return err;
    }

    {{#if isSubscribeAttribute }}
    static void SubscribeAttribute_{{ index }}_OnReportCallback(void * context, {{#chip_tests_with_command_attribute_info}}{{chipType}}{{/chip_tests_with_command_attribute_info}} value)
    {
        ChipLogProgress(chipTool, "On/Off - Subscribe {{asUpperCamelCase attribute}} Attribute: Report Data");
        IgnoreUnusedVariable(value);
        {{parent.filename}} * runner = reinterpret_cast<{{parent.filename}} *>(context);

        switch (runner->mReceivedReport_{{index}}) {
          {{#chip_tests_subscribe_kick_commands}}
          case {{index}}:
            chip::DeviceLayer::SystemLayer.StartTimer({{ waitSeconds }} * 1000, SubscribeAttribute_{{ parent.index }}_kick_{{ index }}, runner);
            break;
          {{/chip_tests_subscribe_kick_commands}}
          default:
            runner->NextTest();
            break;
        }
        runner->mReceivedReport_{{index}}++;

        ChipLogProgress(chipTool, "On/Off - %zu report received, %zu report expected.", runner->mReceivedReport_{{ index }},
                        kExpectedReport_{{ index }});


    }

    {{#chip_tests_subscribe_kick_commands}}
    static void SubscribeAttribute_{{ parent.index }}_kick_{{ index }}(chip::System::Layer* layer, void* context)
    {
      IgnoreUnusedVariable(layer);
      {{parent.filename}} * runner = reinterpret_cast<{{parent.filename}} *>(context);
      chip::Controller::{{asUpperCamelCase cluster}}Cluster cluster;
      cluster.Associate(runner->mDevice, {{endpoint}});
      {{#if isCommand}}
        {{#chip_tests_item_parameters}}
          {{#if (isString type)}}
      {{chipType}} {{asLowerCamelCase name}}Argument = chip::ByteSpan(chip::Uint8::from_const_char("{{definedValue}}"), strlen("{{definedValue}}"));
          {{else}}
      {{chipType}} {{asLowerCamelCase name}}Argument = {{definedValue}}{{asTypeLiteralSuffix chipType}};
          {{/if}}
        {{/chip_tests_item_parameters}}
      /* The we will check the command result by checking if we have received reports, so OnSuccess and OnFailure are nullptr here. */
      cluster.{{asUpperCamelCase command}}(nullptr, nullptr {{#chip_tests_item_parameters}}, {{asLowerCamelCase name}}Argument{{/chip_tests_item_parameters}});
      {{/if}}
    }
    {{/chip_tests_subscribe_kick_commands}}
    {{/if}}

    static void OnTestSendCluster{{asUpperCamelCase cluster}}Command{{asUpperCamelCase command}}_{{index}}_FailureResponse(void * context, uint8_t status)
    {
        ChipLogProgress(chipTool, "{{cluster}} - {{label}}: Failure Response");

        {{parent.filename}} * runner = reinterpret_cast<{{parent.filename}} *>(context);

        {{#if optional}}
        if (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) {
            runner->NextTest();
            return;
        }
        {{/if}}

        if (runner->mIsFailureExpected_{{index}} == false) {
            ChipLogError(chipTool, "Error: The test was expecting a success callback. Got failure callback");
            runner->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
            return;
        }

        runner->NextTest();
    }

    static void OnTestSendCluster{{asUpperCamelCase cluster}}Command{{asUpperCamelCase command}}_{{index}}_SuccessResponse
    {{#if isSubscribeAttribute}}
    (void * context)
    {{else}}
    (void * context {{#chip_tests_item_response_parameters}}, {{#if isList}}uint16_t count, {{/if}}{{chipType}} {{#if isList}}* {{/if}}{{asLowerCamelCase name}}{{/chip_tests_item_response_parameters}})
    {{/if}}
    {
        ChipLogProgress(chipTool, "{{cluster}} - {{label}}: Success Response");

        {{parent.filename}} * runner = reinterpret_cast<{{parent.filename}} *>(context);

        if (runner->mIsFailureExpected_{{index}} == true)
        {
            ChipLogError(chipTool, "Error: The test was expecting a failure callback. Got success callback");
            runner->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
            return;
        }

        {{#chip_tests_item_response_parameters}}
        {{#if hasExpectedValue}}
        {{#if isList}}
        if (count != {{expectedValue.length}})
        {
            ChipLogError(chipTool, "Error: Value mismatch. Expected: '%s'", "{{expectedValue}}");
            runner->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
            return;
        }
        {{else}}
        {{#if (isString type)}}
        {{chipType}} {{asLowerCamelCase name}}Argument = chip::ByteSpan(chip::Uint8::from_const_char("{{expectedValue}}"), strlen("{{expectedValue}}"));
        if (!{{asLowerCamelCase name}}.data_equal({{asLowerCamelCase name}}Argument))
        {{else}}
        if ({{asLowerCamelCase name}} != {{expectedValue}}{{asTypeLiteralSuffix chipType}})
        {{/if}}
        {
            ChipLogError(chipTool, "Error: Value mismatch. Expected: '%s'", "{{expectedValue}}");
            runner->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
            return;
        }
        {{/if}}
        {{/if}}
        {{#if hasExpectedConstraints}}
        {{#if expectedConstraints.type}}
        ChipLogError(chipTool, "Warning: {{asLowerCamelCase name}} type checking is not implemented yet. Expected type: '%s'", "{{expectedConstraints.type}}");
        {{/if}}

        {{#if expectedConstraints.format}}
        ChipLogError(chipTool, "Warning: {{asLowerCamelCase name}} format checking is not implemented yet. Expected format: '%s'", "{{expectedConstraints.format}}");
        {{/if}}

        {{#if expectedConstraints.minLength}}
          if ({{asLowerCamelCase name}}.size() < {{expectedConstraints.minLength}})
          {
            ChipLogError(chipTool, "Error: {{asLowerCamelCase name}} is too short. Min size is {{expectedConstraints.minLength}} but got '%zu'", {{asLowerCamelCase name}}.size());
            runner->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
            return;
          }
        {{/if}}

        {{#if expectedConstraints.maxLength}}
          if ({{asLowerCamelCase name}}.size() > {{expectedConstraints.maxLength}})
          {
            ChipLogError(chipTool, "Error: {{asLowerCamelCase name}} is too long. Max size is {{expectedConstraints.maxLength}} but got '%zu'", {{asLowerCamelCase name}}.size());
            runner->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
            return;
          }
        {{/if}}

        {{#if expectedConstraints.minValue}}
          if ({{asLowerCamelCase name}} < {{expectedConstraints.minValue}})
          {
            ChipLogError(chipTool, "Error: {{asLowerCamelCase name}} is lower than expected. Min value is {{expectedConstraints.minValue}} but got '%d'", {{asLowerCamelCase name}});
            runner->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
            return;
          }
        {{/if}}

        {{#if expectedConstraints.maxValue}}
          if ({{asLowerCamelCase name}} > {{expectedConstraints.maxValue}})
          {
            ChipLogError(chipTool, "Error: {{asLowerCamelCase name}} is higher than expected. Max value is {{expectedConstraints.maxValue}} but got '%d'", {{asLowerCamelCase name}});
            runner->SetCommandExitStatus(CHIP_ERROR_INTERNAL);
            return;
          }
        {{/if}}
        {{/if}}
        {{/chip_tests_item_response_parameters}}

        {{#unless isSubscribeAttribute}}
        runner->NextTest();
        {{/unless}}
    }

    {{/if}}
    {{/chip_tests_items}}
};

{{/chip_tests}}

void registerCommandsTests(Commands & commands)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
      {{#chip_tests tests}}
        make_unique<{{filename}}>(),
      {{/chip_tests}}
    };

    commands.Register(clusterName, clusterCommands);
}
