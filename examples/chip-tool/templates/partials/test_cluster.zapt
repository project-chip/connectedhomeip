{{#chip_tests tests}}
class {{filename}}: public TestCommand
{
  public:
    {{#if ../credsIssuerConfigArg}}
    {{filename}}(CredentialIssuerCommands * credsIssuerConfig): TestCommand("{{filename}}", credsIssuerConfig), mTestIndex(0)
    {{else}}
    {{filename}}(): TestCommand("{{filename}}"), mTestIndex(0)
    {{/if}}
    {
        {{#chip_tests_config}}
          {{#if (isString type)}}
          AddArgument("{{name}}", &m{{asUpperCamelCase name}});
          {{else}}
          AddArgument("{{name}}", {{asTypeMinValue type}}, {{asTypeMaxValue type}}, &m{{asUpperCamelCase name}});
          {{/if}}
        {{/chip_tests_config}}
    }

    骈戾钺礤īｃ栝疬翦篝筮轸屙簖ｃ栝疬翦篝筮轸屙唑弩痫铙暹疳蜥礤翦蝮ｉ筢鲥馏ｉㄩ笥趄轭豉疱殒筢鲥馏迈骀弪〗铛祆痿颟汨轲汉徐狒骘蝽汉湾盹蝙乞邋筢鲥馏迈骀弪┗筢鲥馏迈骀弪铛祆痿蚧殒殒汨轲唪弩趔唛翦磉蝈箴镱箦唣狎犴弭弪簖汨轲唪弩趔唛翦眢藻篝蔑眄犷深翦蜴徙鲲殇五粼弩舁秭弪蜷溴萌尚吲乙弦弪萌尚呶线乓蚁一殒ò浇碓弩羯钿屮描轲田缧蝻珧弩蟥汨轲燥镬藻篝郁狎艉骈戾钺礤茴┗殒碓弩裘秕铘浇碓弩羯钿屮描轲田缧蝻珧弩蟥汨轲燥镬藻篝蔑眇戾翦骈戾钺礤茴┗渝裘镯磲钿砒轸郁狒躞萌尚呶线乓蚁药蝈趱蝾揍轸ī蓬篚蝈麇轭泸屙孱碓弩羯钿屮忮骘蝈麇篝狎蝓铑轭翳蝈戾鲠铘泔眄犷洚澡狒麽殒麇祜箦翳糸礤箪殂徭翦麇箦钿翳礤篌徵怩忮骘蝈秕骢钽糸镱汜祆蝈趱蝾蟋麇黠瞌孱躔鏖翳犷轭泔蝌邈碓弩羯钿屮鲠祯镡箦蝣邃麒孱麇珏翳蝈箴镱箦篦轸汨碓弩羯钿屮ｃ栝疬翦篝筮轸屙簖汜箦轭溴描轲田缧蝻珧弩蟥汨轲燥镬藻篝郁屦轭溴灬忮忑茴┗ｉ猩糜殒ㄓ栾蹯溆腴皎Ⅺ猩糜┅五粼弩舁┗蝈趱蝾殒弪藻篝狍震疱蛎犴屐冕箦灬忮忑啕轭溴ī怛遽牖汨轲唪弩趔唛翦眢殒萌尚呶线乓蚁〗弪颟描轲田缗蝌矧ㄣ栝鹪镲飕藻篝漆殪躜搴ン茴汨轲汉膨蝻蛴趄ㄥ蝌┅渝裘镯磲钿砒轸郁狒躞ㄥ蝌┗ｉ糸礤秕酏汨轲汉御篝屙汉渺镢牒涸轫屣豸清糇衢裟躜狒轱瞑泔铙秭弪蜷溴蝈趱蝾汨轲汉御篝屙汉渺镢牒河邈镱潴倍碓轫屣豸柔笾犰蹂ī碓轫屣豸轴祯濞糸礤秕酏┗殒痱轹狒搴篝浜横麸黹氵蹰铘倍唪碓弩羯钿屮泔铙蹰铘倍唪碓弩裘秕铘麸翎煸弩趔ｃ栝疬翦篝筮泔铈殓汨轲汉橡糸镱犰见汨轲赠疱睇狍震疱蛎犴屐冕箦钺礤汨轲唪弩趔咩镱骈琮ｃ栝疬翦篝筮轸屙簖ｃ栝疬翦篝筮轸屙唑弩痫铙暹疳蜥礤翦蝮ｉ筢鲥馏ｉㄩ笥趄轭豉疱ｉㄩ笙泗弭郁蜷铉豉疱蹰铘高酐屐箦汨狎殒筢鲥馏迈骀弪铛祆痿蚧殒}
    {{zapTypeToDecodableClusterObjectType type ns=../cluster}} {{saveAs}};
    {{/if}}
    {{/chip_tests_item_response_parameters}}
    {{/chip_tests_items}}

    void OnDiscoveryCommandsResults(const DiscoveryCommandResult & nodeData) override
    {
      bool isExpectedDnssdResult = false;
      {{#chip_tests_items}}
      {{#if (isStrEqual cluster "DiscoveryCommands")}}
      if ((mTestIndex - 1) == {{index}})
      {
          isExpectedDnssdResult = true;
          {{#chip_tests_item_response_parameters}}
          {{#*inline "itemValue"}}nodeData.{{name}}{{#if isOptional}}.Value(){{/if}}{{/inline}}
          {{#if hasExpectedValue}}
            {{#if isOptional}}VerifyOrReturn(CheckValuePresent("{{name}}", nodeData.{{name}}));{{/if}}
            VerifyOrReturn(CheckValue("{{name}}", {{>itemValue}},
            {{#if (chip_tests_config_has expectedValue)}}
            m{{asUpperCamelCase expectedValue}}.HasValue() ? m{{asUpperCamelCase expectedValue}}.Value() : {{asTypedLiteral (chip_tests_config_get_default_value expectedValue) (chip_tests_config_get_type expectedValue)}}
            {{else}}
            {{expectedValue}}
            {{/if}}
          ));
          {{/if}}
          {{#if hasExpectedConstraints}}
            {{#if isOptional}}VerifyOrReturn(CheckValuePresent("{{name}}", nodeData.{{name}}));{{/if}}
            {{#if (hasProperty expectedConstraints "minLength")}}VerifyOrReturn(CheckConstraintMinLength("{{name}}", {{>itemValue}}.size(), {{expectedConstraints.minLength}}));{{/if}}
            {{#if (hasProperty expectedConstraints "maxLength")}}VerifyOrReturn(CheckConstraintMaxLength("{{name}}", {{>itemValue}}.size(), {{expectedConstraints.maxLength}}));{{/if}}
            {{#if (hasProperty expectedConstraints "minValue")}}VerifyOrReturn(CheckConstraintMinValue<{{chipType}}>("{{name}}", {{>itemValue}}, {{asTypedLiteral expectedConstraints.minValue type}}));{{/if}}
            {{#if (hasProperty expectedConstraints "maxValue")}}VerifyOrReturn(CheckConstraintMaxValue<{{chipType}}>("{{name}}", {{>itemValue}}, {{asTypedLiteral expectedConstraints.maxValue type}}));{{/if}}
            {{#if (hasProperty expectedConstraints "notValue")}}VerifyOrReturn(CheckConstraintNotValue("{{name}}", {{>itemValue}}, {{asTypedLiteral expectedConstraints.notValue type}}));{{/if}}
          {{/if}}

          {{#if saveAs}}
          {{#if (isString type)}}
          if ({{saveAs}}Buffer != nullptr)
          {
             chip::Platform::MemoryFree({{saveAs}}Buffer);
          }
          {{saveAs}}Buffer = static_cast<{{#if (isOctetString type)}}uint8_t{{else}}char{{/if}} *>(chip::Platform::MemoryAlloc({{>itemValue}}.size()));
          memcpy({{saveAs}}Buffer, {{>itemValue}}.data(), {{>itemValue}}.size());
          {{saveAs}} = {{chipType}}({{saveAs}}Buffer, {{>itemValue}}.size());
          {{else}}
          {{saveAs}} = {{>itemValue}};
          {{/if}}
          {{/if}}
          {{/chip_tests_item_response_parameters}}
      }
      {{/if}}
      {{/chip_tests_items}}

      VerifyOrReturn(isExpectedDnssdResult, Exit("An unexpected dnssd result has been received"));
      NextTest();
    }

    {{! Helper around zapTypeToDecodableClusterObjectType that lets us set the
        array/nullable/etc context appropriately.}}
    {{#*inline "subscribeResponseDataArgument"}}
      {{zapTypeToDecodableClusterObjectType type ns=cluster isArgument=true}} value
    {{/inline}}
    {{#*inline "subscribeResponseArguments"}}
    {{> subscribeResponseDataArgument type=attr.type isArray=attr.isArray isNullable=attr.isNullable}}
    {{/inline}}

    {{#*inline "subscribeDataCallback"}}
    mTest_{{parent.filename}}_{{attribute}}_Reported
    {{/inline}}
    {{#*inline "subscribeDataCallbackType"}}
    Test_{{parent.filename}}_{{attribute}}_ReportCallback
    {{/inline}}
    {{#chip_tests_items}}
    {{#if allocateSubscribeDataCallback}}
    typedef void (*{{> subscribeDataCallbackType}})(void * context, {{> subscribeResponseArguments attr=attributeObject}});
    {{> subscribeDataCallbackType}} {{> subscribeDataCallback}} = nullptr;
    {{/if}}
    {{/chip_tests_items}}

    {{#*inline "failureResponse"}}OnFailureResponse_{{index}}{{/inline}}
    {{#*inline "successResponse"}}OnSuccessResponse_{{index}}{{/inline}}
    {{#*inline "subscriptionEstablished"}}OnSubscriptionEstablishedResponse_{{index}}{{/inline}}
    {{#*inline "doneResponse"}}OnDoneResponse_{{index}}{{/inline}}

    {{#*inline "staticFailureResponse"}}OnFailureCallback_{{index}}{{/inline}}
    {{#*inline "staticSuccessResponse"}}OnSuccessCallback_{{index}}{{/inline}}
    {{#*inline "staticSubscriptionEstablished"}}OnSubscriptionEstablished_{{index}}{{/inline}}
    {{#*inline "staticDoneResponse"}}OnDoneCallback_{{index}}{{/inline}}

    {{#*inline "successArguments"}}{{#chip_tests_item_response_parameters}}{{#first}}{{#if ../leadingComma}}, {{/if}}{{/first}} {{zapTypeToDecodableClusterObjectType type ns=parent.cluster isArgument=true}} {{asLowerCamelCase name}}{{#not_last}}, {{/not_last}}{{/chip_tests_item_response_parameters}}{{/inline}}
    {{! TODO: Temporary if cascade until everything is converted to the new status setup }}
    {{#*inline "failureArguments"}}{{#if leadingComma}}, {{/if}}CHIP_ERROR error{{/inline}}
    {{#*inline "staticSuccessArguments"}}void * context{{> successArguments leadingComma=true}}{{/inline}}
    {{#*inline "staticFailureArguments"}}void * context{{> failureArguments leadingComma=true}}{{/inline}}
    {{#*inline "staticDoneArguments"}}void * context{{/inline}}
    {{#*inline "doneArguments"}}{{/inline}}

    {{#*inline "staticSubscriptionEstablishedArguments"}}void * context{{/inline}}
    {{#*inline "subscriptionEstablishedArguments"}}{{/inline}}

    {{#chip_tests_items}}
    {{#unless (isTestOnlyCluster cluster)}}
    {{#unless isWait}}
    {{#unless isCommand}}
    {{#if isWriteAttribute}}
      {{#if isGroupCommand}}
      static void {{>staticDoneResponse}}({{>staticDoneArguments}})
      {
          (static_cast<{{filename}} *>(context))->{{> doneResponse }}();
      }
      {{/if}}
    {{/if}}

    static void {{>staticFailureResponse}}({{>staticFailureArguments}})
    {
        (static_cast<{{filename}} *>(context))->{{>failureResponse}}(error);
    }

    static void {{>staticSuccessResponse}}({{> staticSuccessArguments}})
    {
        (static_cast<{{filename}} *>(context))->{{>successResponse}}({{#chip_tests_item_response_parameters}}{{#not_first}}, {{/not_first}}{{asLowerCamelCase name}}{{/chip_tests_item_response_parameters}});
    }

    {{#if isSubscribe}}
    static void {{> staticSubscriptionEstablished}}({{> staticSubscriptionEstablishedArguments}})
    {
        (static_cast<{{filename}} *>(context))->{{> subscriptionEstablished}}();
    }
    {{/if}}

    {{#if isWaitForReport}}
    bool mReceivedReport_{{index}} = false;
    {{/if}}

    {{/unless}}
    {{/unless}}
    {{/unless}}
    {{/chip_tests_items}}

    //
    // Tests methods
    //

    {{#chip_tests_items}}
    {{#*inline "testCommand"}}Test{{asUpperCamelCase label}}_{{index}}{{/inline}}
    {{#if (isTestOnlyCluster cluster)}}
    CHIP_ERROR {{>testCommand}}()
    {
        SetIdentity(kIdentity{{asUpperCamelCase identity}});
        return {{command}}({{#chip_tests_item_parameters}}{{#not_first}},{{/not_first}}
          {{#*inline "defaultValue"}}{{asTypedLiteral (chip_tests_config_get_default_value definedValue) (chip_tests_config_get_type definedValue)}}{{/inline}}
          {{#if (chip_tests_config_has definedValue)}}
          m{{asUpperCamelCase definedValue}}.HasValue() ? m{{asUpperCamelCase definedValue}}.Value() : {{#if (isString type)}}chip::CharSpan::fromCharString("{{>defaultValue}}"){{else}}{{>defaultValue}}{{/if}}
          {{else if (isString type)}}"{{definedValue}}"
          {{else}}{{definedValue}}
          {{/if}}
          {{/chip_tests_item_parameters}});
    }
    {{else if isWait}}
    CHIP_ERROR {{>testCommand}}()
    {
      const chip::EndpointId endpoint = {{#if (chip_tests_config_has "endpoint")}}mEndpoint.HasValue() ? mEndpoint.Value() : {{/if}}{{endpoint}};
      ChipLogError(chipTool, "[Endpoint: 0x%08x Cluster: {{cluster}} {{#if isAttribute}}Attribute: {{attribute}}{{else}}Command: {{wait}}{{/if}}] {{label}}", endpoint);
      {{#*inline "waitForTypeName"}}{{#if isAttribute}}Attribute{{else}}Command{{/if}}{{/inline}}
      {{#*inline "waitForTypeId"}}chip::app::Clusters::{{asUpperCamelCase cluster}}::{{#if isAttribute}}Attributes::{{attribute}}{{else}}Commands::{{wait}}{{/if}}::Id{{/inline}}
      ClearAttributeAndCommandPaths();
      m{{>waitForTypeName}}Path = chip::app::Concrete{{>waitForTypeName}}Path(endpoint, chip::app::Clusters::{{asUpperCamelCase cluster}}::Id, {{>waitForTypeId}});
      return CHIP_NO_ERROR;
    }
    {{else}}

    {{#*inline "device"}}mDevices[kIdentity{{asUpperCamelCase identity}}]{{/inline}}
    CHIP_ERROR {{>testCommand}}()
    {
        {{#if isGroupCommand}}
        const chip::GroupId groupId = {{groupId}};
        {{else}}
        const chip::EndpointId endpoint = {{#if (chip_tests_config_has "endpoint")}}mEndpoint.HasValue() ? mEndpoint.Value() : {{/if}}{{endpoint}};
        {{/if}}

        {{#*inline "maybeTimedInteractionTimeout"}}
          {{#if timedInteractionTimeoutMs}}
          , {{timedInteractionTimeoutMs}}
          {{else if commandObject.mustUseTimedInvoke}}
          , chip::NullOptional
          {{else if attributeObject.mustUseTimedWrite}}
          , chip::NullOptional
          {{/if}}
        {{/inline}}

        {{#*inline "maybeWait"}}
          {{#if busyWaitMs}}
          {
            using namespace chip::System::Clock::Literals;
            // Busy-wait for {{busyWaitMs}} milliseconds.
            auto & clock = chip::System::SystemClock();
            auto start = clock.GetMonotonicTimestamp();
            while (clock.GetMonotonicTimestamp() - start < {{busyWaitMs}}_ms);
          }
          {{/if}}
        {{/inline}}

        {{#if isCommand}}
        using RequestType = chip::app::Clusters::{{asUpperCamelCase cluster}}::Commands::{{asUpperCamelCase command}}::Type;

        ListFreer listFreer;
        RequestType request;
        {{#chip_tests_item_parameters}}
        {{>commandValue ns=parent.cluster container=(concat "request." (asLowerCamelCase label)) definedValue=definedValue depth=0}}
        {{/chip_tests_item_parameters}}

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<{{filename}} *>(context))->{{>successResponse}}({{#chip_tests_item_response_parameters}}{{#not_first}}, {{/not_first}}data.{{asLowerCamelCase name}}{{/chip_tests_item_response_parameters}});
        };

        auto failure = [](void * context, CHIP_ERROR error) {
            (static_cast<{{filename}} *>(context))->{{>failureResponse}}(error);
        };

        {{#if isGroupCommand}}
        auto done = [](void * context) {
            (static_cast<{{filename}} *>(context))->OnDoneResponse_{{index}}();
        };
        {{/if}}

        ReturnErrorOnFailure(chip::Controller::{{#if isGroupCommand}}InvokeGroupCommand{{else}}InvokeCommand{{/if}}({{>device}}, this, success, failure, {{#if isGroupCommand}}done,{{/if}}
          {{#if isGroupCommand}}groupId{{else}}endpoint{{/if}},
          request
          {{> maybeTimedInteractionTimeout }}
          ));
        {{> maybeWait }}
        {{else}}
        chip::Controller::{{asUpperCamelCase cluster}}ClusterTest cluster;
        {{#if isGroupCommand}}
        cluster.AssociateWithGroup({{>device}}, groupId);
        {{else}}
        cluster.Associate({{>device}}, endpoint);
        {{/if}}

        ListFreer listFreer;
        {{#chip_tests_item_parameters}}
        {{zapTypeToEncodableClusterObjectType type ns=parent.cluster}} {{asLowerCamelCase name}}Argument;
        {{>commandValue ns=parent.cluster container=(concat (asLowerCamelCase name) "Argument") definedValue=definedValue depth=0}}
        {{/chip_tests_item_parameters}}

        {{#if isWriteAttribute}}
          ReturnErrorOnFailure(cluster.WriteAttribute<chip::app::Clusters::{{asUpperCamelCase cluster}}::Attributes::{{asUpperCamelCase attribute}}::TypeInfo>({{#chip_tests_item_parameters}}{{asLowerCamelCase name}}Argument, {{/chip_tests_item_parameters}}this, {{>staticSuccessResponse}}, {{>staticFailureResponse}}
            {{> maybeTimedInteractionTimeout }}
            {{#if isGroupCommand}}, {{>staticDoneResponse}}{{/if}}
            ));
          {{> maybeWait }}
        {{else if isReadEvent}}
          ReturnErrorOnFailure(cluster.ReadEvent<{{zapTypeToDecodableClusterObjectType event ns=cluster isArgument=true}}>(this, {{>staticSuccessResponse}}, {{>staticFailureResponse}}));
        {{else if isSubscribeEvent}}
          ReturnErrorOnFailure(cluster.SubscribeEvent<{{zapTypeToDecodableClusterObjectType event ns=cluster isArgument=true}}>(this, {{>staticSuccessResponse}}, {{>staticFailureResponse}}, minIntervalArgument, maxIntervalArgument, {{>staticSubscriptionEstablished}}));
        {{else if isReadAttribute}}
          ReturnErrorOnFailure(cluster.ReadAttribute<chip::app::Clusters::{{asUpperCamelCase cluster}}::Attributes::{{asUpperCamelCase attribute}}::TypeInfo>({{#chip_tests_item_parameters}}{{asLowerCamelCase name}}Argument, {{/chip_tests_item_parameters}}this, {{>staticSuccessResponse}}, {{>staticFailureResponse}}, {{fabricFiltered}}));
        {{else if isSubscribeAttribute}}
          ReturnErrorOnFailure(cluster.SubscribeAttribute<chip::app::Clusters::{{asUpperCamelCase cluster}}::Attributes::{{asUpperCamelCase attribute}}::TypeInfo>(this, {{>staticSuccessResponse}}, {{>staticFailureResponse}}, minIntervalArgument, maxIntervalArgument, {{>staticSubscriptionEstablished}}, {{fabricFiltered}}));
        {{else if isWaitForReport}}
          {{> subscribeDataCallback}} = {{> staticSuccessResponse}};
        {{else}}
          UNEXPECTED COMMAND: {{>commandName}}
        {{/if}}
        {{/if}}
        {{#if async}}
          return WaitForMs(0);
        {{else}}
          return CHIP_NO_ERROR;
        {{/if}}
    }

    void {{>failureResponse}}({{>failureArguments}})
    {
        chip::app::StatusIB status(error);
        {{#if response.error}}
          VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), {{response.error}}));
          {{#unless async}}NextTest();{{/unless}}
        {{else if response.errorWrongValue}}
          VerifyOrReturn(CheckConstraintNotValue("status", chip::to_underlying(status.mStatus), 0));
          {{#unless async}}NextTest();{{/unless}}
        {{else}}
          {{#if optional}}(status.mStatus == chip::Protocols::InteractionModel::Status::UnsupportedAttribute) ? NextTest() : {{/if}}ThrowFailureResponse();
        {{/if}}
    }

    {{#if isSubscribe}}
    void {{>successResponse}}({{> subscribeResponseArguments attr=attributeObject}})
    {
        {{#if response.error}}
          ThrowSuccessResponse();
        {{else if response.errorWrongValue}}
          ThrowSuccessResponse();
        {{else}}
          if ({{> subscribeDataCallback}}) {
              auto callback = {{> subscribeDataCallback}};
              {{> subscribeDataCallback}} = nullptr;
              callback(this, value);
          }
       {{/if}}
    }

    void {{>subscriptionEstablished}}({{> subscriptionEstablishedArguments}})
    {
        {{#if hasWaitForReport}}
          VerifyOrReturn(mReceivedReport_{{waitForReport.index}}, Exit("Initial report not received!"));
        {{/if}}
        {{#unless async}}NextTest();{{/unless}}
    }
    {{else}}
    void {{>successResponse}}({{>successArguments}})
    {
        {{#if response.error}}
          ThrowSuccessResponse();
        {{else if response.errorWrongValue}}
          ThrowSuccessResponse();
        {{else}}
          {{#if isWaitForReport}}
          mReceivedReport_{{index}} = true;
          {{/if}}
          {{#chip_tests_item_response_parameters}}
            {{#*inline "item"}}{{asLowerCamelCase name}}{{#if isOptional}}.Value(){{/if}}{{/inline}}
            {{#if hasExpectedValue}}
              {{>valueEquals actual=(asLowerCamelCase name) label=(asLowerCamelCase name) expected=expectedValue depth=0}}
            {{/if}}
            {{#if hasExpectedConstraints}}
              {{#if isOptional}}
                {{#*inline "item"}}{{asLowerCamelCase name}}{{/inline}}
                VerifyOrReturn(CheckValuePresent("{{> item}}", {{> item}}));
              {{/if}}
              {{#if (hasProperty expectedConstraints "type")}}VerifyOrReturn(CheckConstraintType("{{>item}}", "", "{{expectedConstraints.type}}"));{{/if}}
              {{#if (hasProperty expectedConstraints "format")}}VerifyOrReturn(CheckConstraintFormat("{{>item}}", "", "{{expectedConstraints.format}}"));{{/if}}
              {{#if (hasProperty expectedConstraints "startsWith")}}VerifyOrReturn(CheckConstraintStartsWith("{{>item}}", {{>item}}, "{{expectedConstraints.startsWith}}"));{{/if}}
              {{#if (hasProperty expectedConstraints "endsWith")}}VerifyOrReturn(CheckConstraintEndsWith("{{>item}}", {{>item}}, "{{expectedConstraints.endsWith}}"));{{/if}}
              {{#if (hasProperty expectedConstraints "isUpperCase")}}VerifyOrReturn(CheckConstraintIsUpperCase("{{>item}}", {{>item}}, {{expectedConstraints.isUpperCase}}));{{/if}}
              {{#if (hasProperty expectedConstraints "isLowerCase")}}VerifyOrReturn(CheckConstraintIsLowerCase("{{>item}}", {{>item}}, {{expectedConstraints.isLowerCase}}));{{/if}}
              {{#if (hasProperty expectedConstraints "isHexString")}}VerifyOrReturn(CheckConstraintIsHexString("{{>item}}", {{>item}}, {{expectedConstraints.isHexString}}));{{/if}}
              {{#if (hasProperty expectedConstraints "minLength")}}VerifyOrReturn(CheckConstraintMinLength("{{>item}}", {{>item}}.size(), {{expectedConstraints.minLength}}));{{/if}}
              {{#if (hasProperty expectedConstraints "maxLength")}}VerifyOrReturn(CheckConstraintMaxLength("{{>item}}", {{>item}}.size(), {{expectedConstraints.maxLength}}));{{/if}}
              {{#if (hasProperty expectedConstraints "minValue")}}VerifyOrReturn(CheckConstraintMinValue<{{chipType}}>("{{>item}}", {{>item}}, {{asTypedLiteral expectedConstraints.minValue type}}));{{/if}}
              {{#if (hasProperty expectedConstraints "maxValue")}}VerifyOrReturn(CheckConstraintMaxValue<{{chipType}}>("{{>item}}", {{>item}}, {{asTypedLiteral expectedConstraints.maxValue type}}));{{/if}}
              {{#if (hasProperty expectedConstraints "notValue")}}
                {{#if (isLiteralNull expectedConstraints.notValue)}}
                VerifyOrReturn(CheckValueNonNull("{{>item}}", {{>item}}));
                {{else}}
                VerifyOrReturn(CheckConstraintNotValue("{{>item}}", {{>item}}, {{asTypedLiteral expectedConstraints.notValue type}}));
                {{/if}}
              {{/if}}
            {{/if}}

            {{#if saveAs}}
            {{#if (isString type)}}
            if ({{saveAs}}Buffer != nullptr)
            {
                chip::Platform::MemoryFree({{saveAs}}Buffer);
            }
            {{saveAs}}Buffer = static_cast<{{#if (isOctetString type)}}uint8_t{{else}}char{{/if}} *>(chip::Platform::MemoryAlloc({{>item}}.size()));
            memcpy({{saveAs}}Buffer, {{>item}}.data(), {{>item}}.size());
            {{saveAs}} = {{chipType}}({{saveAs}}Buffer, {{>item}}.size());
            {{else}}
            {{saveAs}} = {{>item}};
            {{/if}}
            {{/if}}
          {{/chip_tests_item_response_parameters}}
        {{#unless async}}NextTest();{{/unless}}
        {{/if}}
    }
    {{/if}}

    {{#if isGroupCommand}}
    void {{>doneResponse}}({{>doneArguments}})
    {
      NextTest();
    }
    {{/if}}

    {{/if}}
    {{/chip_tests_items}}
};

{{/chip_tests}}
