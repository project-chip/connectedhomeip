// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
}

struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
}

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
server cluster Identify = 3 {
  enum IdentifyEffectIdentifier : ENUM8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum IdentifyEffectVariant : ENUM8 {
    kDefault = 0;
  }

  enum IdentifyIdentifyType : ENUM8 {
    kNone = 0;
    kVisibleLight = 1;
    kVisibleLED = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute enum8 identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    INT16U identifyTime = 0;
  }

  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
}

/** Attributes and commands for group configuration and manipulation. */
server cluster Groups = 4 {
  bitmap GroupsFeature : BITMAP32 {
    kGroupNames = 0x1;
  }

  readonly attribute bitmap8 nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    CHAR_STRING groupName = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    CHAR_STRING groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    ENUM8 status = 0;
    group_id groupID = 1;
  }

  response struct ViewGroupResponse = 1 {
    ENUM8 status = 0;
    group_id groupID = 1;
    CHAR_STRING groupName = 2;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable INT8U capacity = 0;
    group_id groupList[] = 1;
  }

  response struct RemoveGroupResponse = 3 {
    ENUM8 status = 0;
    group_id groupID = 1;
  }

  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

/** Attributes and commands for switching devices between 'On' and 'Off' states. */
client cluster OnOff = 6 {
  enum OnOffDelayedAllOffEffectVariant : ENUM8 {
    kFadeToOffIn0p8Seconds = 0;
    kNoFade = 1;
    k50PercentDimDownIn0p8SecondsThenFadeToOffIn12Seconds = 2;
  }

  enum OnOffDyingLightEffectVariant : ENUM8 {
    k20PercenterDimUpIn0p5SecondsThenFadeToOffIn1Second = 0;
  }

  enum OnOffEffectIdentifier : ENUM8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum OnOffStartUpOnOff : ENUM8 {
    kOff = 0;
    kOn = 1;
    kTogglePreviousOnOff = 2;
  }

  bitmap OnOffControl : BITMAP8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  bitmap OnOffFeature : BITMAP32 {
    kLighting = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute optional boolean globalSceneControl = 16384;
  attribute optional int16u onTime = 16385;
  attribute optional int16u offWaitTime = 16386;
  attribute access(write: manage) optional nullable OnOffStartUpOnOff startUpOnOff = 16387;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OffWithEffectRequest {
    OnOffEffectIdentifier effectIdentifier = 0;
    int8u effectVariant = 1;
  }

  request struct OnWithTimedOffRequest {
    OnOffControl onOffControl = 0;
    int16u onTime = 1;
    int16u offWaitTime = 2;
  }

  /** On receipt of this command, a device SHALL enter its ‘Off’ state. This state is device dependent, but it is recommended that it is used for power off or similar functions. On receipt of the Off command, the OnTime attribute SHALL be set to 0. */
  command Off(): DefaultSuccess = 0;
  /** On receipt of this command, a device SHALL enter its ‘On’ state. This state is device dependent, but it is recommended that it is used for power on or similar functions. On receipt of the On command, if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. */
  command On(): DefaultSuccess = 1;
  /** On receipt of this command, if a device is in its ‘Off’ state it SHALL enter its ‘On’ state. Otherwise, if it is in its ‘On’ state it SHALL enter its ‘Off’ state. On receipt of the Toggle command, if the value of the OnOff attribute is equal to FALSE and if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. If the value of the OnOff attribute is equal to TRUE, the OnTime attribute SHALL be set to 0. */
  command Toggle(): DefaultSuccess = 2;
  /** The OffWithEffect command allows devices to be turned off using enhanced ways of fading. */
  command OffWithEffect(OffWithEffectRequest): DefaultSuccess = 64;
  /** The OnWithRecallGlobalScene command allows the recall of the settings when the device was turned off. */
  command OnWithRecallGlobalScene(): DefaultSuccess = 65;
  /** The OnWithTimedOff command allows devices to be turned on for a specific duration with a guarded off duration so that SHOULD the device be subsequently switched off, further OnWithTimedOff commands, received during this time, are prevented from turning the devices back on. */
  command OnWithTimedOff(OnWithTimedOffRequest): DefaultSuccess = 66;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
client cluster LevelControl = 8 {
  enum MoveMode : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepMode : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap LevelControlFeature : BITMAP32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap LevelControlOptions : BITMAP8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute optional int16u remainingTime = 1;
  readonly attribute optional int8u minLevel = 2;
  readonly attribute optional int8u maxLevel = 3;
  readonly attribute optional int16u currentFrequency = 4;
  readonly attribute optional int16u minFrequency = 5;
  readonly attribute optional int16u maxFrequency = 6;
  attribute LevelControlOptions options = 15;
  attribute optional int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute optional nullable int16u onTransitionTime = 18;
  attribute optional nullable int16u offTransitionTime = 19;
  attribute optional nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) optional nullable int8u startUpCurrentLevel = 16384;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    INT8U level = 0;
    nullable INT16U transitionTime = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveMode moveMode = 0;
    nullable INT8U rate = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct StepRequest {
    StepMode stepMode = 0;
    INT8U stepSize = 1;
    nullable INT16U transitionTime = 2;
    LevelControlOptions optionsMask = 3;
    LevelControlOptions optionsOverride = 4;
  }

  request struct StopRequest {
    LevelControlOptions optionsMask = 0;
    LevelControlOptions optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    INT8U level = 0;
    nullable INT16U transitionTime = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveMode moveMode = 0;
    nullable INT8U rate = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepMode stepMode = 0;
    INT8U stepSize = 1;
    nullable INT16U transitionTime = 2;
    LevelControlOptions optionsMask = 3;
    LevelControlOptions optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    LevelControlOptions optionsMask = 0;
    LevelControlOptions optionsOverride = 1;
  }

  request struct MoveToClosestFrequencyRequest {
    INT16U frequency = 0;
  }

  /** Command description for MoveToLevel */
  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  /** Command description for Move */
  command Move(MoveRequest): DefaultSuccess = 1;
  /** Command description for Step */
  command Step(StepRequest): DefaultSuccess = 2;
  /** Command description for Stop */
  command Stop(StopRequest): DefaultSuccess = 3;
  /** Command description for MoveToLevelWithOnOff */
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  /** Command description for MoveWithOnOff */
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  /** Command description for StepWithOnOff */
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  /** Command description for StopWithOnOff */
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
  /** Change the currrent frequency to the provided one, or a close
        approximation if the exact provided one is not possible. */
  command MoveToClosestFrequency(MoveToClosestFrequencyRequest): DefaultSuccess = 8;
}

/** An interface for reading the value of a binary measurement and accessing various characteristics of that measurement. */
server cluster BinaryInputBasic = 15 {
  attribute boolean outOfService = 81;
  attribute boolean presentValue = 85;
  readonly attribute bitmap8 statusFlags = 111;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
client cluster Descriptor = 29 {
  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute CLUSTER_ID serverList[] = 1;
  readonly attribute CLUSTER_ID clientList[] = 2;
  readonly attribute ENDPOINT_NO partsList[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
server cluster Descriptor = 29 {
  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute CLUSTER_ID serverList[] = 1;
  readonly attribute CLUSTER_ID clientList[] = 2;
  readonly attribute ENDPOINT_NO partsList[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Binding Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table. */
server cluster Binding = 30 {
  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
server cluster AccessControl = 31 {
  enum AccessControlEntryAuthModeEnum : ENUM8 {
    kPase = 1;
    kCase = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : ENUM8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum ChangeTypeEnum : ENUM8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  struct Target {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive Target targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
server cluster BasicInformation = 40 {
  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  critical event StartUp = 0 {
    INT32U softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute char_string<16> manufacturingDate = 11;
  readonly attribute char_string<32> partNumber = 12;
  readonly attribute long_char_string<256> productURL = 13;
  readonly attribute char_string<64> productLabel = 14;
  readonly attribute char_string<32> serialNumber = 15;
  attribute access(write: manage) boolean localConfigDisabled = 16;
  readonly attribute boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
server cluster LocalizationConfiguration = 43 {
  attribute char_string<35> activeLocale = 0;
  readonly attribute CHAR_STRING supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for how dates and times are conveyed. As such, Nodes that visually
      or audibly convey time information need a mechanism by which they can be configured to use a
      user’s preferred format. */
server cluster TimeFormatLocalization = 44 {
  enum CalendarTypeEnum : ENUM8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
  }

  enum HourFormatEnum : ENUM8 {
    k12hr = 0;
    k24hr = 1;
  }

  attribute HourFormatEnum hourFormat = 0;
  attribute CalendarTypeEnum activeCalendarType = 1;
  readonly attribute CalendarTypeEnum supportedCalendarTypes[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for the units in which values are conveyed in communication to a
      user. As such, Nodes that visually or audibly convey measurable values to the user need a
      mechanism by which they can be configured to use a user’s preferred unit. */
server cluster UnitLocalization = 45 {
  enum TempUnitEnum : ENUM8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap UnitLocalizationFeature : BITMAP32 {
    kTemperatureUnit = 0x1;
  }

  attribute TempUnitEnum temperatureUnit = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
server cluster GeneralCommissioning = 48 {
  enum CommissioningError : ENUM8 {
    kOk = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationType : ENUM8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationType regulatoryConfig = 2;
  readonly attribute RegulatoryLocationType locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    INT16U expiryLengthSeconds = 0;
    INT64U breadcrumb = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationType newRegulatoryConfig = 0;
    CHAR_STRING countryCode = 1;
    INT64U breadcrumb = 2;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
server cluster NetworkCommissioning = 49 {
  enum NetworkCommissioningStatus : ENUM8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBand : ENUM8 {
    k2g4 = 0;
    k3g65 = 1;
    k5g = 2;
    k6g = 3;
    k60g = 4;
  }

  bitmap NetworkCommissioningFeature : BITMAP32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
  }

  bitmap WiFiSecurity : BITMAP8 {
    kUnencrypted = 0x1;
    kWep = 0x2;
    kWpaPersonal = 0x4;
    kWpa2Personal = 0x8;
    kWpa3Personal = 0x10;
  }

  struct NetworkInfo {
    octet_string<32> networkID = 0;
    boolean connected = 1;
  }

  struct ThreadInterfaceScanResult {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResult {
    WiFiSecurity security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBand wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfo networks[] = 1;
  readonly attribute int8u scanMaxTimeSeconds = 2;
  readonly attribute int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatus lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable OCTET_STRING<32> ssid = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    OCTET_STRING<32> ssid = 0;
    OCTET_STRING<64> credentials = 1;
    optional INT64U breadcrumb = 2;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    OCTET_STRING<254> operationalDataset = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ConnectNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ReorderNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    INT8U networkIndex = 1;
    optional INT64U breadcrumb = 2;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    optional WiFiInterfaceScanResult wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResult threadScanResults[] = 3;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING<512> debugText = 1;
    optional INT8U networkIndex = 2;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    nullable INT32S errorValue = 2;
  }

  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster GeneralDiagnostics = 51 {
  enum BootReasonEnum : ENUM8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : ENUM8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : ENUM8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : ENUM8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : ENUM8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute int64u upTime = 2;
  readonly attribute int32u totalOperationalHours = 3;
  readonly attribute BootReasonEnum bootReason = 4;
  readonly attribute HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    OCTET_STRING<16> enableKey = 0;
    INT64U eventTrigger = 1;
  }

  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster SoftwareDiagnostics = 52 {
  bitmap SoftwareDiagnosticsFeature : BITMAP32 {
    kWaterMarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    INT64U id = 0;
    optional CHAR_STRING name = 1;
    optional OCTET_STRING faultRecording = 2;
  }

  readonly attribute ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute int64u currentHeapFree = 1;
  readonly attribute int64u currentHeapUsed = 2;
  readonly attribute int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Wi-Fi Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster WiFiNetworkDiagnostics = 54 {
  enum AssociationFailureCauseEnum : ENUM8 {
    kUnknown = 0;
    kAssociationFailed = 1;
    kAuthenticationFailed = 2;
    kSsidNotFound = 3;
  }

  enum ConnectionStatusEnum : ENUM8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum SecurityTypeEnum : ENUM8 {
    kUnspecified = 0;
    kNone = 1;
    kWep = 2;
    kWpa = 3;
    kWpa2 = 4;
    kWpa3 = 5;
  }

  enum WiFiVersionEnum : ENUM8 {
    kA = 0;
    kB = 1;
    kG = 2;
    kN = 3;
    kAc = 4;
    kAx = 5;
  }

  bitmap WiFiNetworkDiagnosticsFeature : BITMAP32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  info event Disconnection = 0 {
    INT16U reasonCode = 0;
  }

  info event AssociationFailure = 1 {
    AssociationFailureCauseEnum associationFailure = 0;
    INT16U status = 1;
  }

  info event ConnectionStatus = 2 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  readonly attribute nullable octet_string<6> bssid = 0;
  readonly attribute nullable SecurityTypeEnum securityType = 1;
  readonly attribute nullable WiFiVersionEnum wiFiVersion = 2;
  readonly attribute nullable int16u channelNumber = 3;
  readonly attribute nullable int8s rssi = 4;
  readonly attribute nullable int32u beaconLostCount = 5;
  readonly attribute nullable int32u beaconRxCount = 6;
  readonly attribute nullable int32u packetMulticastRxCount = 7;
  readonly attribute nullable int32u packetMulticastTxCount = 8;
  readonly attribute nullable int32u packetUnicastRxCount = 9;
  readonly attribute nullable int32u packetUnicastTxCount = 10;
  readonly attribute nullable int64u currentMaxRate = 11;
  readonly attribute nullable int64u overrunCount = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Ethernet Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster EthernetNetworkDiagnostics = 55 {
  enum PHYRateEnum : ENUM8 {
    kRate10M = 0;
    kRate100M = 1;
    kRate1G = 2;
    kRate25g = 3;
    kRate5G = 4;
    kRate10G = 5;
    kRate40G = 6;
    kRate100G = 7;
    kRate200G = 8;
    kRate400G = 9;
  }

  bitmap EthernetNetworkDiagnosticsFeature : BITMAP32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  readonly attribute nullable PHYRateEnum PHYRate = 0;
  readonly attribute nullable boolean fullDuplex = 1;
  readonly attribute int64u packetRxCount = 2;
  readonly attribute int64u packetTxCount = 3;
  readonly attribute int64u txErrCount = 4;
  readonly attribute int64u collisionCount = 5;
  readonly attribute int64u overrunCount = 6;
  readonly attribute nullable boolean carrierDetect = 7;
  readonly attribute int64u timeSinceReset = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command ResetCounts(): DefaultSuccess = 0;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
server cluster AdministratorCommissioning = 60 {
  enum CommissioningWindowStatusEnum : ENUM8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : ENUM8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable int16u adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
    OCTET_STRING PAKEPasscodeVerifier = 1;
    INT16U discriminator = 2;
    INT32U iterations = 3;
    OCTET_STRING salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
  }

  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
server cluster OperationalCredentials = 62 {
  enum CertificateChainTypeEnum : ENUM8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : ENUM8 {
    kOk = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute OCTET_STRING trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    OCTET_STRING attestationNonce = 0;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  request struct CSRRequestRequest {
    OCTET_STRING CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  request struct AddNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
    OCTET_STRING IPKValue = 2;
    Int64u caseAdminSubject = 3;
    VENDOR_ID adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
  }

  request struct UpdateFabricLabelRequest {
    CHAR_STRING<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    OCTET_STRING rootCACertificate = 0;
  }

  response struct AttestationResponse = 1 {
    OCTET_STRING attestationElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  response struct CertificateChainResponse = 3 {
    OCTET_STRING certificate = 0;
  }

  response struct CSRResponse = 5 {
    OCTET_STRING NOCSRElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional CHAR_STRING debugText = 2;
  }

  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
server cluster GroupKeyManagement = 63 {
  enum GroupKeySecurityPolicyEnum : ENUM8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetRemoveRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetReadAllIndicesRequest {
    INT16U groupKeySetIDs[] = 0;
  }

  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  fabric command access(invoke: administer) KeySetReadAllIndices(KeySetReadAllIndicesRequest): KeySetReadAllIndicesResponse = 4;
}

/** The Fixed Label Cluster provides a feature for the device to tag an endpoint with zero or more read only
labels. */
server cluster FixedLabel = 64 {
  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for managing low power mode on a device that supports the Wake On LAN protocol. */
client cluster WakeOnLan = 1283 {
  readonly attribute optional char_string<32> MACAddress = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for controlling the current Channel on a device. */
client cluster Channel = 1284 {
  enum ChannelStatusEnum : ENUM8 {
    kSuccess = 0;
    kMultipleMatches = 1;
    kNoMatches = 2;
  }

  enum LineupInfoTypeEnum : ENUM8 {
    kMso = 0;
  }

  bitmap ChannelFeature : BITMAP32 {
    kChannelList = 0x1;
    kLineupInfo = 0x2;
  }

  struct ChannelInfoStruct {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
    optional char_string name = 2;
    optional char_string callSign = 3;
    optional char_string affiliateCallSign = 4;
  }

  struct LineupInfoStruct {
    char_string operatorName = 0;
    optional char_string lineupName = 1;
    optional char_string postalCode = 2;
    LineupInfoTypeEnum lineupInfoType = 3;
  }

  readonly attribute optional ChannelInfoStruct channelList[] = 0;
  readonly attribute optional nullable LineupInfoStruct lineup = 1;
  readonly attribute optional nullable ChannelInfoStruct currentChannel = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeChannelRequest {
    CHAR_STRING match = 0;
  }

  response struct ChangeChannelResponse = 1 {
    ChannelStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  request struct ChangeChannelByNumberRequest {
    INT16U majorNumber = 0;
    INT16U minorNumber = 1;
  }

  request struct SkipChannelRequest {
    INT16U count = 0;
  }

  /** Change the channel on the media player to the channel case-insensitive exact matching the value passed as an argument. */
  command ChangeChannel(ChangeChannelRequest): ChangeChannelResponse = 0;
  /** Change the channel on the media plaeyer to the channel with the given Number in the ChannelList attribute. */
  command ChangeChannelByNumber(ChangeChannelByNumberRequest): DefaultSuccess = 2;
  /** This command provides channel up and channel down functionality, but allows channel index jumps of size Count. When the value of the increase or decrease is larger than the number of channels remaining in the given direction, then the behavior SHALL be to return to the beginning (or end) of the channel list and continue. For example, if the current channel is at index 0 and count value of -1 is given, then the current channel should change to the last channel. */
  command SkipChannel(SkipChannelRequest): DefaultSuccess = 3;
}

/** This cluster provides an interface for UX navigation within a set of targets on a device or endpoint. */
client cluster TargetNavigator = 1285 {
  enum TargetNavigatorStatusEnum : ENUM8 {
    kSuccess = 0;
    kTargetNotFound = 1;
    kNotAllowed = 2;
  }

  struct TargetInfoStruct {
    int8u identifier = 0;
    char_string<32> name = 1;
  }

  readonly attribute TargetInfoStruct targetList[] = 0;
  readonly attribute optional int8u currentTarget = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct NavigateTargetRequest {
    INT8U target = 0;
    optional CHAR_STRING data = 1;
  }

  response struct NavigateTargetResponse = 1 {
    TargetNavigatorStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  /** Upon receipt, this SHALL navigation the UX to the target identified. */
  command NavigateTarget(NavigateTargetRequest): NavigateTargetResponse = 0;
}

/** This cluster provides an interface for controlling Media Playback (PLAY, PAUSE, etc) on a media device such as a TV or Speaker. */
client cluster MediaPlayback = 1286 {
  enum MediaPlaybackStatusEnum : ENUM8 {
    kSuccess = 0;
    kInvalidStateForCommand = 1;
    kNotAllowed = 2;
    kNotActive = 3;
    kSpeedOutOfRange = 4;
    kSeekOutOfRange = 5;
  }

  enum PlaybackStateEnum : ENUM8 {
    kPlaying = 0;
    kPaused = 1;
    kNotPlaying = 2;
    kBuffering = 3;
  }

  bitmap MediaPlaybackFeature : BITMAP32 {
    kAdvancedSeek = 0x1;
    kVariableSpeed = 0x2;
  }

  struct PlaybackPositionStruct {
    epoch_us updatedAt = 0;
    nullable int64u position = 1;
  }

  readonly attribute PlaybackStateEnum currentState = 0;
  readonly attribute optional nullable epoch_us startTime = 1;
  readonly attribute optional nullable int64u duration = 2;
  readonly attribute optional nullable PlaybackPositionStruct sampledPosition = 3;
  readonly attribute optional single playbackSpeed = 4;
  readonly attribute optional nullable int64u seekRangeEnd = 5;
  readonly attribute optional nullable int64u seekRangeStart = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SkipForwardRequest {
    INT64U deltaPositionMilliseconds = 0;
  }

  request struct SkipBackwardRequest {
    INT64U deltaPositionMilliseconds = 0;
  }

  response struct PlaybackResponse = 10 {
    MediaPlaybackStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  request struct SeekRequest {
    INT64U position = 0;
  }

  /** Upon receipt, this SHALL play media. */
  command Play(): PlaybackResponse = 0;
  /** Upon receipt, this SHALL pause media. */
  command Pause(): PlaybackResponse = 1;
  /** Upon receipt, this SHALL stop media. User experience is context-specific. This will often navigate the user back to the location where media was originally launched. */
  command Stop(): PlaybackResponse = 2;
  /** Upon receipt, this SHALL Start Over with the current media playback item. */
  command StartOver(): PlaybackResponse = 3;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Previous". User experience is context-specific. This will often Go back to the previous media playback item. */
  command Previous(): PlaybackResponse = 4;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Next". User experience is context-specific. This will often Go forward to the next media playback item. */
  command Next(): PlaybackResponse = 5;
  /** Upon receipt, this SHALL Rewind through media. Different Rewind speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command Rewind(): PlaybackResponse = 6;
  /** Upon receipt, this SHALL Advance through media. Different FF speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command FastForward(): PlaybackResponse = 7;
  /** Upon receipt, this SHALL Skip forward in the media by the given number of seconds, using the data as follows: */
  command SkipForward(SkipForwardRequest): PlaybackResponse = 8;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command SkipBackward(SkipBackwardRequest): PlaybackResponse = 9;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command Seek(SeekRequest): PlaybackResponse = 11;
}

/** This cluster provides an interface for controlling the Input Selector on a media device such as a TV. */
client cluster MediaInput = 1287 {
  enum InputTypeEnum : ENUM8 {
    kInternal = 0;
    kAux = 1;
    kCoax = 2;
    kComposite = 3;
    kHdmi = 4;
    kInput = 5;
    kLine = 6;
    kOptical = 7;
    kVideo = 8;
    kScart = 9;
    kUsb = 10;
    kOther = 11;
  }

  bitmap MediaInputFeature : BITMAP32 {
    kNameUpdates = 0x1;
  }

  struct InputInfoStruct {
    int8u index = 0;
    InputTypeEnum inputType = 1;
    char_string<32> name = 2;
    char_string<32> description = 3;
  }

  readonly attribute InputInfoStruct inputList[] = 0;
  readonly attribute int8u currentInput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectInputRequest {
    INT8U index = 0;
  }

  request struct RenameInputRequest {
    INT8U index = 0;
    CHAR_STRING name = 1;
  }

  /** Upon receipt, this SHALL change the input on the media device to the input at a specific index in the Input List. */
  command SelectInput(SelectInputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL display the active status of the input list on screen. */
  command ShowInputStatus(): DefaultSuccess = 1;
  /** Upon receipt, this SHALL hide the input list from the screen. */
  command HideInputStatus(): DefaultSuccess = 2;
  /** Upon receipt, this SHALL rename the input at a specific index in the Input List. Updates to the input name SHALL appear in the TV settings menus. */
  command RenameInput(RenameInputRequest): DefaultSuccess = 3;
}

/** This cluster provides an interface for managing low power mode on a device. */
client cluster LowPower = 1288 {
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command shall put the device into low power mode. */
  command Sleep(): DefaultSuccess = 0;
}

/** This cluster provides an interface for controlling a device like a TV using action commands such as UP, DOWN, and SELECT. */
client cluster KeypadInput = 1289 {
  enum CecKeyCode : ENUM8 {
    kSelect = 0;
    kUp = 1;
    kDown = 2;
    kLeft = 3;
    kRight = 4;
    kRightUp = 5;
    kRightDown = 6;
    kLeftUp = 7;
    kLeftDown = 8;
    kRootMenu = 9;
    kSetupMenu = 10;
    kContentsMenu = 11;
    kFavoriteMenu = 12;
    kExit = 13;
    kMediaTopMenu = 16;
    kMediaContextSensitiveMenu = 17;
    kNumberEntryMode = 29;
    kNumber11 = 30;
    kNumber12 = 31;
    kNumber0OrNumber10 = 32;
    kNumbers1 = 33;
    kNumbers2 = 34;
    kNumbers3 = 35;
    kNumbers4 = 36;
    kNumbers5 = 37;
    kNumbers6 = 38;
    kNumbers7 = 39;
    kNumbers8 = 40;
    kNumbers9 = 41;
    kDot = 42;
    kEnter = 43;
    kClear = 44;
    kNextFavorite = 47;
    kChannelUp = 48;
    kChannelDown = 49;
    kPreviousChannel = 50;
    kSoundSelect = 51;
    kInputSelect = 52;
    kDisplayInformation = 53;
    kHelp = 54;
    kPageUp = 55;
    kPageDown = 56;
    kPower = 64;
    kVolumeUp = 65;
    kVolumeDown = 66;
    kMute = 67;
    kPlay = 68;
    kStop = 69;
    kPause = 70;
    kRecord = 71;
    kRewind = 72;
    kFastForward = 73;
    kEject = 74;
    kForward = 75;
    kBackward = 76;
    kStopRecord = 77;
    kPauseRecord = 78;
    kReserved = 79;
    kAngle = 80;
    kSubPicture = 81;
    kVideoOnDemand = 82;
    kElectronicProgramGuide = 83;
    kTimerProgramming = 84;
    kInitialConfiguration = 85;
    kSelectBroadcastType = 86;
    kSelectSoundPresentation = 87;
    kPlayFunction = 96;
    kPausePlayFunction = 97;
    kRecordFunction = 98;
    kPauseRecordFunction = 99;
    kStopFunction = 100;
    kMuteFunction = 101;
    kRestoreVolumeFunction = 102;
    kTuneFunction = 103;
    kSelectMediaFunction = 104;
    kSelectAvInputFunction = 105;
    kSelectAudioInputFunction = 106;
    kPowerToggleFunction = 107;
    kPowerOffFunction = 108;
    kPowerOnFunction = 109;
    kF1Blue = 113;
    kF2Red = 114;
    kF3Green = 115;
    kF4Yellow = 116;
    kF5 = 117;
    kData = 118;
  }

  enum KeypadInputStatusEnum : ENUM8 {
    kSuccess = 0;
    kUnsupportedKey = 1;
    kInvalidKeyInCurrentState = 2;
  }

  bitmap KeypadInputFeature : BITMAP32 {
    kNavigationKeyCodes = 0x1;
    kLocationKeys = 0x2;
    kNumberKeys = 0x4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SendKeyRequest {
    CecKeyCode keyCode = 0;
  }

  response struct SendKeyResponse = 1 {
    KeypadInputStatusEnum status = 0;
  }

  /** Upon receipt, this SHALL process a keycode as input to the media device. */
  command SendKey(SendKeyRequest): SendKeyResponse = 0;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
client cluster ContentLauncher = 1290 {
  enum ContentLaunchStatusEnum : ENUM8 {
    kSuccess = 0;
    kUrlNotAvailable = 1;
    kAuthFailed = 2;
  }

  enum MetricTypeEnum : ENUM8 {
    kPixels = 0;
    kPercentage = 1;
  }

  enum ParameterEnum : ENUM8 {
    kActor = 0;
    kChannel = 1;
    kCharacter = 2;
    kDirector = 3;
    kEvent = 4;
    kFranchise = 5;
    kGenre = 6;
    kLeague = 7;
    kPopularity = 8;
    kProvider = 9;
    kSport = 10;
    kSportsTeam = 11;
    kType = 12;
    kVideo = 13;
  }

  bitmap ContentLauncherFeature : BITMAP32 {
    kContentSearch = 0x1;
    kURLPlayback = 0x2;
  }

  bitmap SupportedStreamingProtocol : BITMAP32 {
    kDash = 0x1;
    kHls = 0x2;
  }

  struct DimensionStruct {
    double width = 0;
    double height = 1;
    MetricTypeEnum metric = 2;
  }

  struct AdditionalInfoStruct {
    char_string name = 0;
    char_string value = 1;
  }

  struct ParameterStruct {
    ParameterEnum type = 0;
    char_string value = 1;
    optional AdditionalInfoStruct externalIDList[] = 2;
  }

  struct ContentSearchStruct {
    ParameterStruct parameterList[] = 0;
  }

  struct StyleInformationStruct {
    optional char_string imageURL = 0;
    optional char_string color = 1;
    optional DimensionStruct size = 2;
  }

  struct BrandingInformationStruct {
    char_string providerName = 0;
    optional StyleInformationStruct background = 1;
    optional StyleInformationStruct logo = 2;
    optional StyleInformationStruct progressBar = 3;
    optional StyleInformationStruct splash = 4;
    optional StyleInformationStruct waterMark = 5;
  }

  readonly attribute optional CHAR_STRING acceptHeader[] = 0;
  attribute optional bitmap32 supportedStreamingProtocols = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchContentRequest {
    ContentSearchStruct search = 0;
    BOOLEAN autoPlay = 1;
    optional CHAR_STRING data = 2;
  }

  request struct LaunchURLRequest {
    CHAR_STRING contentURL = 0;
    optional CHAR_STRING displayString = 1;
    optional BrandingInformationStruct brandingInformation = 2;
  }

  response struct LauncherResponse = 2 {
    ContentLaunchStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  /** Upon receipt, this SHALL launch the specified content with optional search criteria. */
  command LaunchContent(LaunchContentRequest): LauncherResponse = 0;
  /** Upon receipt, this SHALL launch content from the specified URL. */
  command LaunchURL(LaunchURLRequest): LauncherResponse = 1;
}

/** This cluster provides an interface for controlling the Output on a media device such as a TV. */
client cluster AudioOutput = 1291 {
  enum OutputTypeEnum : ENUM8 {
    kHdmi = 0;
    kBt = 1;
    kOptical = 2;
    kHeadphone = 3;
    kInternal = 4;
    kOther = 5;
  }

  bitmap AudioOutputFeature : BITMAP32 {
    kNameUpdates = 0x1;
  }

  struct OutputInfoStruct {
    int8u index = 0;
    OutputTypeEnum outputType = 1;
    char_string<32> name = 2;
  }

  readonly attribute OutputInfoStruct outputList[] = 0;
  readonly attribute optional int8u currentOutput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectOutputRequest {
    INT8U index = 0;
  }

  request struct RenameOutputRequest {
    INT8U index = 0;
    CHAR_STRING name = 1;
  }

  /** Upon receipt, this SHALL change the output on the media device to the output at a specific index in the Output List. */
  command SelectOutput(SelectOutputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL rename the output at a specific index in the Output List. Updates to the output name SHALL appear in the TV settings menus. */
  command RenameOutput(RenameOutputRequest): DefaultSuccess = 1;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
client cluster ApplicationLauncher = 1292 {
  enum ApplicationLauncherStatusEnum : ENUM8 {
    kSuccess = 0;
    kAppNotAvailable = 1;
    kSystemBusy = 2;
  }

  bitmap ApplicationLauncherFeature : BITMAP32 {
    kApplicationPlatform = 0x1;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  struct ApplicationEPStruct {
    ApplicationStruct application = 0;
    optional endpoint_no endpoint = 1;
  }

  readonly attribute optional INT16U catalogList[] = 0;
  attribute optional nullable ApplicationEPStruct currentApp = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchAppRequest {
    optional ApplicationStruct application = 0;
    optional OCTET_STRING data = 1;
  }

  request struct StopAppRequest {
    optional ApplicationStruct application = 0;
  }

  request struct HideAppRequest {
    optional ApplicationStruct application = 0;
  }

  response struct LauncherResponse = 3 {
    ApplicationLauncherStatusEnum status = 0;
    optional OCTET_STRING data = 1;
  }

  /** Upon receipt, this SHALL launch the specified app with optional data. The TV Device SHALL launch and bring to foreground the identified application in the command if the application is not already launched and in foreground. The TV Device SHALL update state attribute on the Application Basic cluster of the Endpoint corresponding to the launched application. This command returns a Launch Response. */
  command LaunchApp(LaunchAppRequest): LauncherResponse = 0;
  /** Upon receipt on a Video Player endpoint this SHALL stop the specified application if it is running. */
  command StopApp(StopAppRequest): LauncherResponse = 1;
  /** Upon receipt on a Video Player endpoint this SHALL hide the specified application if it is running and visible. */
  command HideApp(HideAppRequest): LauncherResponse = 2;
}

/** This cluster provides information about an application running on a TV or media player device which is represented as an endpoint. */
client cluster ApplicationBasic = 1293 {
  enum ApplicationStatusEnum : ENUM8 {
    kStopped = 0;
    kActiveVisibleFocus = 1;
    kActiveHidden = 2;
    kActiveVisibleNotFocus = 3;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  readonly attribute optional char_string<32> vendorName = 0;
  readonly attribute optional vendor_id vendorID = 1;
  readonly attribute char_string<32> applicationName = 2;
  readonly attribute optional int16u productID = 3;
  readonly attribute ApplicationStruct application = 4;
  readonly attribute ApplicationStatusEnum status = 5;
  readonly attribute char_string<32> applicationVersion = 6;
  readonly attribute vendor_id allowedVendorList[] = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides commands that facilitate user account login on a Content App or a node. For example, a Content App running on a Video Player device, which is represented as an endpoint (see [TV Architecture]), can use this cluster to help make the user account on the Content App match the user account on the Client. */
client cluster AccountLogin = 1294 {
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GetSetupPINRequest {
    CHAR_STRING<100> tempAccountIdentifier = 0;
  }

  response struct GetSetupPINResponse = 1 {
    CHAR_STRING setupPIN = 0;
  }

  request struct LoginRequest {
    CHAR_STRING<100> tempAccountIdentifier = 0;
    CHAR_STRING setupPIN = 1;
  }

  /** Upon receipt, the Content App checks if the account associated with the client Temp Account Identifier Rotating ID is the same acount that is active on the given Content App. If the accounts are the same, then the Content App includes the Setup PIN in the GetSetupPIN Response. */
  timed command GetSetupPIN(GetSetupPINRequest): GetSetupPINResponse = 0;
  /** Upon receipt, the Content App checks if the account associated with the client’s Temp Account Identifier (Rotating ID) has a current active Setup PIN with the given value. If the Setup PIN is valid for the user account associated with the Temp Account Identifier, then the Content App MAY make that user account active. */
  timed command Login(LoginRequest): DefaultSuccess = 2;
  /** The purpose of this command is to instruct the Content App to clear the current user account. This command SHOULD be used by clients of a Content App to indicate the end of a user session. */
  timed command Logout(): DefaultSuccess = 3;
}

endpoint 0 {
  device type rootdevice = 22, version 1;

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster Binding {
    callback attribute binding;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    emits event AccessControlExtensionChanged;
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry default = 4;
    callback attribute targetsPerAccessControlEntry default = 3;
    callback attribute accessControlEntriesPerFabric default = 4;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    callback attribute dataModelRevision default = 10;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location default = "XX";
    callback attribute hardwareVersion default = 0;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion default = 0;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate default = "20210614123456ZZ";
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    persist  attribute localConfigDisabled default = 0;
    ram      attribute reachable default = 1;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster LocalizationConfiguration {
    persist  attribute activeLocale default = "en-US";
    callback attribute supportedLocales;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TimeFormatLocalization {
    persist  attribute hourFormat default = 0;
    persist  attribute activeCalendarType default = 0;
    callback attribute supportedCalendarTypes;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UnitLocalization {
    persist  attribute temperatureUnit default = 0;
    ram      attribute featureMap default = 0x1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig default = 0;
    callback attribute locationCapability default = 0;
    callback attribute supportsConcurrentConnection default = 1;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    ram      attribute featureMap default = 5;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralDiagnostics {
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount default = 0x0000;
    callback attribute upTime default = 0x0000000000000000;
    callback attribute totalOperationalHours default = 0x00000000;
    callback attribute bootReason;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    callback attribute testEventTriggersEnabled default = false;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster SoftwareDiagnostics {
    callback attribute threadMetrics;
    callback attribute currentHeapFree default = 0x0000000000000000;
    callback attribute currentHeapUsed default = 0x0000000000000000;
    callback attribute currentHeapHighWatermark default = 0x0000000000000000;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster WiFiNetworkDiagnostics {
    emits event Disconnection;
    emits event AssociationFailure;
    emits event ConnectionStatus;
    callback attribute bssid;
    callback attribute securityType;
    callback attribute wiFiVersion;
    callback attribute channelNumber default = 0x0000;
    callback attribute rssi default = 0x00;
    callback attribute beaconLostCount default = 0x00000000;
    callback attribute beaconRxCount default = 0x00000000;
    callback attribute packetMulticastRxCount default = 0x00000000;
    callback attribute packetMulticastTxCount default = 0x00000000;
    callback attribute packetUnicastRxCount default = 0x00000000;
    callback attribute packetUnicastTxCount default = 0x00000000;
    callback attribute currentMaxRate default = 0x0000000000000000;
    callback attribute overrunCount default = 0x0000000000000000;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;
  }

  server cluster EthernetNetworkDiagnostics {
    callback attribute PHYRate;
    callback attribute fullDuplex default = 0x00;
    callback attribute packetRxCount default = 0x0000000000000000;
    callback attribute packetTxCount default = 0x0000000000000000;
    callback attribute txErrCount default = 0x0000000000000000;
    callback attribute collisionCount default = 0x0000000000000000;
    callback attribute overrunCount default = 0x0000000000000000;
    callback attribute carrierDetect default = 0x00;
    callback attribute timeSinceReset default = 0x0000000000000000;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus default = 0;
    callback attribute adminFabricIndex default = 1;
    callback attribute adminVendorId default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 1 {
  device type videoplayer = 41, version 1;
  binding cluster OnOff;
  binding cluster LevelControl;
  binding cluster Descriptor;
  binding cluster WakeOnLan;
  binding cluster Channel;
  binding cluster TargetNavigator;
  binding cluster MediaPlayback;
  binding cluster MediaInput;
  binding cluster LowPower;
  binding cluster KeypadInput;
  binding cluster ContentLauncher;
  binding cluster AudioOutput;
  binding cluster ApplicationLauncher;
  binding cluster ApplicationBasic;
  binding cluster AccountLogin;

  server cluster Identify {
    ram      attribute identifyTime default = 0x0000;
    ram      attribute identifyType default = 0x0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;
  }

  server cluster Groups {
    ram      attribute nameSupport;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;
  }

  server cluster BinaryInputBasic {
    ram      attribute outOfService default = 0x00;
    ram      attribute presentValue;
    ram      attribute statusFlags default = 0x00;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster Binding {
    callback attribute binding;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster FixedLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }
}


