/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#import "MCAttributeObjects.h"

#import "../MCAttribute_Internal.h"
#import "../MCCastingApp.h"
#import "../MCErrorUtils.h"
#import "../NSDataSpanConversion.h"
#import "../NSStringSpanConversion.h"

#include "core/Attribute.h"
#include <app-common/zap-generated/cluster-objects.h>

#import <Foundation/Foundation.h>

// OnOff cluster attributes:

@implementation MCOnOffClusterOnOffAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithBool:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterGlobalSceneControlAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithBool:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterOnTimeAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterOffWaitTimeAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterStartUpOnOffAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedChar:chip::to_underlying(_cppValue.Value())];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCOnOffClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

// LevelControl cluster attributes:

@implementation MCLevelControlClusterCurrentLevelAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedChar:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterRemainingTimeAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::RemainingTime::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterMinLevelAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedChar:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterMaxLevelAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedChar:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterCurrentFrequencyAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterMinFrequencyAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::MinFrequency::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterMaxFrequencyAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::MaxFrequency::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterOptionsAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::Options::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedChar:_cppValue.Raw()];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterOnOffTransitionTimeAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterOnLevelAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::OnLevel::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedChar:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterOnTransitionTimeAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedShort:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterOffTransitionTimeAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedShort:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterDefaultMoveRateAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedChar:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterStartUpCurrentLevelAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedChar:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCLevelControlClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

// WakeOnLan cluster attributes:

@implementation MCWakeOnLanClusterMACAddressAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSString * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::WakeOnLan::Attributes::MACAddress::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSString * _Nonnull value;
        value = AsString(_cppValue);
        if (value == nil) {
            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
            *aError = err;
            return nil;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCWakeOnLanClusterLinkLocalAddressAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::LinkLocalAddress::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::LinkLocalAddress::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::LinkLocalAddress::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::LinkLocalAddress::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSData * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::LinkLocalAddress::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::LinkLocalAddress::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::LinkLocalAddress::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::WakeOnLan::Attributes::LinkLocalAddress::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSData * _Nonnull value;
        value = AsData(_cppValue);
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCWakeOnLanClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::WakeOnLan::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCWakeOnLanClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::WakeOnLan::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCWakeOnLanClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::WakeOnLan::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCWakeOnLanClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::WakeOnLan::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCWakeOnLanClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCWakeOnLanClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

// TargetNavigator cluster attributes:

@implementation MCTargetNavigatorClusterTargetListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::TargetNavigator::Attributes::TargetList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                MCTargetNavigatorClusterTargetInfoStruct * newElement_0;
                newElement_0 = [MCTargetNavigatorClusterTargetInfoStruct new];
                newElement_0.identifier = [NSNumber numberWithUnsignedChar:entry_0.identifier];
                newElement_0.name = AsString(entry_0.name);
                if (newElement_0.name == nil) {
                    CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                    *aError = err;
                    return nil;
                }
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCTargetNavigatorClusterCurrentTargetAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedChar:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCTargetNavigatorClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::TargetNavigator::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCTargetNavigatorClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::TargetNavigator::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCTargetNavigatorClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::TargetNavigator::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCTargetNavigatorClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::TargetNavigator::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCTargetNavigatorClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCTargetNavigatorClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

// MediaPlayback cluster attributes:

@implementation MCMediaPlaybackClusterCurrentStateAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::CurrentState::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedChar:chip::to_underlying(_cppValue)];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterStartTimeAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::StartTime::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedLongLong:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterDurationAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::Duration::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedLongLong:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterSampledPositionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    MCMediaPlaybackClusterPlaybackPositionStruct * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::SampledPosition::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        MCMediaPlaybackClusterPlaybackPositionStruct * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [MCMediaPlaybackClusterPlaybackPositionStruct new];
            value.updatedAt = [NSNumber numberWithUnsignedLongLong:_cppValue.Value().updatedAt];
            if (_cppValue.Value().position.IsNull()) {
                value.position = nil;
            } else {
                value.position = [NSNumber numberWithUnsignedLongLong:_cppValue.Value().position.Value()];
            }
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterPlaybackSpeedAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithFloat:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterSeekRangeEndAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedLongLong:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterSeekRangeStartAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [NSNumber numberWithUnsignedLongLong:_cppValue.Value()];
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterActiveAudioTrackAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ActiveAudioTrack::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ActiveAudioTrack::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ActiveAudioTrack::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ActiveAudioTrack::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    MCMediaPlaybackClusterTrackStruct * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ActiveAudioTrack::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ActiveAudioTrack::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ActiveAudioTrack::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::ActiveAudioTrack::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        MCMediaPlaybackClusterTrackStruct * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [MCMediaPlaybackClusterTrackStruct new];
            value.id = AsString(_cppValue.Value().id);
            if (value.id == nil) {
                CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                *aError = err;
                return nil;
            }
            if (_cppValue.Value().trackAttributes.IsNull()) {
                value.trackAttributes = nil;
            } else {
                value.trackAttributes = [MCMediaPlaybackClusterTrackAttributesStruct new];
                value.trackAttributes.languageCode = AsString(_cppValue.Value().trackAttributes.Value().languageCode);
                if (value.trackAttributes.languageCode == nil) {
                    CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                    *aError = err;
                    return nil;
                }
                if (_cppValue.Value().trackAttributes.Value().displayName.HasValue()) {
                    if (_cppValue.Value().trackAttributes.Value().displayName.Value().IsNull()) {
                        value.trackAttributes.displayName = nil;
                    } else {
                        value.trackAttributes.displayName = AsString(_cppValue.Value().trackAttributes.Value().displayName.Value().Value());
                        if (value.trackAttributes.displayName == nil) {
                            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                            *aError = err;
                            return nil;
                        }
                    }
                } else {
                    value.trackAttributes.displayName = nil;
                }
            }
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterAvailableAudioTracksAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AvailableAudioTracks::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AvailableAudioTracks::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AvailableAudioTracks::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AvailableAudioTracks::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AvailableAudioTracks::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AvailableAudioTracks::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AvailableAudioTracks::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::AvailableAudioTracks::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            { // Scope for our temporary variables
                auto * array_1 = [NSMutableArray new];
                auto iter_1 = _cppValue.Value().begin();
                while (iter_1.Next()) {
                    auto & entry_1 = iter_1.GetValue();
                    MCMediaPlaybackClusterTrackStruct * newElement_1;
                    newElement_1 = [MCMediaPlaybackClusterTrackStruct new];
                    newElement_1.id = AsString(entry_1.id);
                    if (newElement_1.id == nil) {
                        CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                        *aError = err;
                        return nil;
                    }
                    if (entry_1.trackAttributes.IsNull()) {
                        newElement_1.trackAttributes = nil;
                    } else {
                        newElement_1.trackAttributes = [MCMediaPlaybackClusterTrackAttributesStruct new];
                        newElement_1.trackAttributes.languageCode = AsString(entry_1.trackAttributes.Value().languageCode);
                        if (newElement_1.trackAttributes.languageCode == nil) {
                            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                            *aError = err;
                            return nil;
                        }
                        if (entry_1.trackAttributes.Value().displayName.HasValue()) {
                            if (entry_1.trackAttributes.Value().displayName.Value().IsNull()) {
                                newElement_1.trackAttributes.displayName = nil;
                            } else {
                                newElement_1.trackAttributes.displayName = AsString(entry_1.trackAttributes.Value().displayName.Value().Value());
                                if (newElement_1.trackAttributes.displayName == nil) {
                                    CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                                    *aError = err;
                                    return nil;
                                }
                            }
                        } else {
                            newElement_1.trackAttributes.displayName = nil;
                        }
                    }
                    [array_1 addObject:newElement_1];
                }
                CHIP_ERROR err = iter_1.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    *aError = err;
                    return nil;
                }
                value = array_1;
            }
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterActiveTextTrackAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ActiveTextTrack::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ActiveTextTrack::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ActiveTextTrack::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ActiveTextTrack::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    MCMediaPlaybackClusterTrackStruct * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ActiveTextTrack::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ActiveTextTrack::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ActiveTextTrack::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::ActiveTextTrack::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        MCMediaPlaybackClusterTrackStruct * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [MCMediaPlaybackClusterTrackStruct new];
            value.id = AsString(_cppValue.Value().id);
            if (value.id == nil) {
                CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                *aError = err;
                return nil;
            }
            if (_cppValue.Value().trackAttributes.IsNull()) {
                value.trackAttributes = nil;
            } else {
                value.trackAttributes = [MCMediaPlaybackClusterTrackAttributesStruct new];
                value.trackAttributes.languageCode = AsString(_cppValue.Value().trackAttributes.Value().languageCode);
                if (value.trackAttributes.languageCode == nil) {
                    CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                    *aError = err;
                    return nil;
                }
                if (_cppValue.Value().trackAttributes.Value().displayName.HasValue()) {
                    if (_cppValue.Value().trackAttributes.Value().displayName.Value().IsNull()) {
                        value.trackAttributes.displayName = nil;
                    } else {
                        value.trackAttributes.displayName = AsString(_cppValue.Value().trackAttributes.Value().displayName.Value().Value());
                        if (value.trackAttributes.displayName == nil) {
                            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                            *aError = err;
                            return nil;
                        }
                    }
                } else {
                    value.trackAttributes.displayName = nil;
                }
            }
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterAvailableTextTracksAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AvailableTextTracks::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AvailableTextTracks::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AvailableTextTracks::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AvailableTextTracks::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AvailableTextTracks::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AvailableTextTracks::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AvailableTextTracks::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::AvailableTextTracks::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            { // Scope for our temporary variables
                auto * array_1 = [NSMutableArray new];
                auto iter_1 = _cppValue.Value().begin();
                while (iter_1.Next()) {
                    auto & entry_1 = iter_1.GetValue();
                    MCMediaPlaybackClusterTrackStruct * newElement_1;
                    newElement_1 = [MCMediaPlaybackClusterTrackStruct new];
                    newElement_1.id = AsString(entry_1.id);
                    if (newElement_1.id == nil) {
                        CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                        *aError = err;
                        return nil;
                    }
                    if (entry_1.trackAttributes.IsNull()) {
                        newElement_1.trackAttributes = nil;
                    } else {
                        newElement_1.trackAttributes = [MCMediaPlaybackClusterTrackAttributesStruct new];
                        newElement_1.trackAttributes.languageCode = AsString(entry_1.trackAttributes.Value().languageCode);
                        if (newElement_1.trackAttributes.languageCode == nil) {
                            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                            *aError = err;
                            return nil;
                        }
                        if (entry_1.trackAttributes.Value().displayName.HasValue()) {
                            if (entry_1.trackAttributes.Value().displayName.Value().IsNull()) {
                                newElement_1.trackAttributes.displayName = nil;
                            } else {
                                newElement_1.trackAttributes.displayName = AsString(entry_1.trackAttributes.Value().displayName.Value().Value());
                                if (newElement_1.trackAttributes.displayName == nil) {
                                    CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                                    *aError = err;
                                    return nil;
                                }
                            }
                        } else {
                            newElement_1.trackAttributes.displayName = nil;
                        }
                    }
                    [array_1 addObject:newElement_1];
                }
                CHIP_ERROR err = iter_1.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    *aError = err;
                    return nil;
                }
                value = array_1;
            }
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCMediaPlaybackClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

// KeypadInput cluster attributes:

@implementation MCKeypadInputClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::KeypadInput::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCKeypadInputClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::KeypadInput::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCKeypadInputClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::KeypadInput::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCKeypadInputClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::KeypadInput::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCKeypadInputClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::KeypadInput::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCKeypadInputClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

// ContentLauncher cluster attributes:

@implementation MCContentLauncherClusterAcceptHeaderAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ContentLauncher::Attributes::AcceptHeader::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSString * newElement_0;
                newElement_0 = AsString(entry_0);
                if (newElement_0 == nil) {
                    CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                    *aError = err;
                    return nil;
                }
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCContentLauncherClusterSupportedStreamingProtocolsAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue.Raw()];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCContentLauncherClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ContentLauncher::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCContentLauncherClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ContentLauncher::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCContentLauncherClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ContentLauncher::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCContentLauncherClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ContentLauncher::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCContentLauncherClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCContentLauncherClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

// ApplicationLauncher cluster attributes:

@implementation MCApplicationLauncherClusterCatalogListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationLauncher::Attributes::CatalogList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedShort:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationLauncherClusterCurrentAppAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    MCApplicationLauncherClusterApplicationEPStruct * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationLauncher::Attributes::CurrentApp::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        MCApplicationLauncherClusterApplicationEPStruct * _Nullable value;
        if (_cppValue.IsNull()) {
            value = nil;
        } else {
            value = [MCApplicationLauncherClusterApplicationEPStruct new];
            value.application = [MCApplicationLauncherClusterApplicationStruct new];
            value.application.catalogVendorID = [NSNumber numberWithUnsignedShort:_cppValue.Value().application.catalogVendorID];
            value.application.applicationID = AsString(_cppValue.Value().application.applicationID);
            if (value.application.applicationID == nil) {
                CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
                *aError = err;
                return nil;
            }
            if (_cppValue.Value().endpoint.HasValue()) {
                value.endpoint = [NSNumber numberWithUnsignedShort:_cppValue.Value().endpoint.Value()];
            } else {
                value.endpoint = nil;
            }
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationLauncherClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationLauncherClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationLauncherClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationLauncher::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationLauncherClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationLauncher::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationLauncherClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationLauncherClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

// ApplicationBasic cluster attributes:

@implementation MCApplicationBasicClusterVendorNameAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSString * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::VendorName::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSString * _Nonnull value;
        value = AsString(_cppValue);
        if (value == nil) {
            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
            *aError = err;
            return nil;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterVendorIDAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::VendorID::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:chip::to_underlying(_cppValue)];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterApplicationNameAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSString * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSString * _Nonnull value;
        value = AsString(_cppValue);
        if (value == nil) {
            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
            *aError = err;
            return nil;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterProductIDAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::ProductID::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterApplicationAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    MCApplicationBasicClusterApplicationStruct * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::Application::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        MCApplicationBasicClusterApplicationStruct * _Nonnull value;
        value = [MCApplicationBasicClusterApplicationStruct new];
        value.catalogVendorID = [NSNumber numberWithUnsignedShort:_cppValue.catalogVendorID];
        value.applicationID = AsString(_cppValue.applicationID);
        if (value.applicationID == nil) {
            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
            *aError = err;
            return nil;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterStatusAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::Status::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedChar:chip::to_underlying(_cppValue)];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterApplicationVersionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSString * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSString * _Nonnull value;
        value = AsString(_cppValue);
        if (value == nil) {
            CHIP_ERROR err = CHIP_ERROR_INVALID_ARGUMENT;
            *aError = err;
            return nil;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterAllowedVendorListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::AllowedVendorList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedShort:chip::to_underlying(entry_0)];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterGeneratedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterAcceptedCommandListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterEventListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::EventList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::EventList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::EventList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::EventList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::EventList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::EventList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterAttributeListAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AttributeList::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::AttributeList::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSArray * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AttributeList::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AttributeList::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::AttributeList::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::AttributeList::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSArray * _Nonnull value;
        { // Scope for our temporary variables
            auto * array_0 = [NSMutableArray new];
            auto iter_0 = _cppValue.begin();
            while (iter_0.Next()) {
                auto & entry_0 = iter_0.GetValue();
                NSNumber * newElement_0;
                newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
                [array_0 addObject:newElement_0];
            }
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                *aError = err;
                return nil;
            }
            value = array_0;
        }
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterFeatureMapAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedInt:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end

@implementation MCApplicationBasicClusterClusterRevisionAttribute
- (void)read:(void * _Nullable)context
    completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->read(context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
        completion(context, before, after, err);
        delete mcAttribute;
    });
}

- (void)subscribe:(void * _Nullable)context
       completion:(void (^_Nonnull __strong)(void * _Nullable, id _Nullable __strong before, id _Nullable __strong after, NSError * _Nullable __strong error))completion
      minInterval:(NSNumber * _Nonnull)minInterval
      maxInterval:(NSNumber * _Nonnull)maxInterval
{
    MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::TypeInfo> * mcAttribute = new MCAttributeTemplate<chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::TypeInfo>(self.cppAttribute,
        [self](std::any cppValue, CHIP_ERROR * errPtr) {
            return [self getObjCTypeFromCpp:cppValue errorCode:errPtr];
        });
    mcAttribute->subscribe(
        context, [mcAttribute, completion](void * context, id before, id after, NSError * err) {
            completion(context, before, after, err);
            delete mcAttribute;
        }, minInterval, maxInterval);
}

- (id _Nullable)getObjCTypeFromCpp:(std::any)cppValue errorCode:(CHIP_ERROR *)aError
{
    NSNumber * value = nil;
    if (cppValue.type() == typeid(std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::TypeInfo::DecodableType>)) {
        std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::TypeInfo::DecodableType> sharedPtr = std::any_cast<std::shared_ptr<chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::TypeInfo::DecodableType>>(cppValue);
        chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::TypeInfo::DecodableType _cppValue = *sharedPtr;
        *aError = CHIP_NO_ERROR;
        NSNumber * _Nonnull value;
        value = [NSNumber numberWithUnsignedShort:_cppValue];
        return value;
    }
    *aError = CHIP_ERROR_INTERNAL;
    return value;
}
@end
