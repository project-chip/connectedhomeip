/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#import "MCCommandObjects.h"
#import "MCCommandPayloads.h"
#import "MCCommandPayloads_internal.h"

#import "../MCCastingApp.h"
#import "../MCCommand_Internal.h"
#import "../MCErrorUtils.h"

#include "core/Command.h"
#include <app-common/zap-generated/cluster-objects.h>

#import <Foundation/Foundation.h>

@implementation MCNullObjectType
- (CHIP_ERROR)setObjCResponseFromCppResponse:(std::any)cppDecodableStruct
{
    return CHIP_NO_ERROR;
}
@end

// OnOff cluster:

@implementation MCOnOffClusterOffCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::OnOff::Commands::Off::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::OnOff::Commands::Off::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCOnOffClusterOffParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::OnOff::Commands::Off::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::OnOff::Commands::Off::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::OnOff::Commands::Off::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCOnOffClusterOffCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCOnOffClusterOnCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::OnOff::Commands::On::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::OnOff::Commands::On::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCOnOffClusterOnParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::OnOff::Commands::On::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::OnOff::Commands::On::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::OnOff::Commands::On::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCOnOffClusterOnCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCOnOffClusterToggleCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::OnOff::Commands::Toggle::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::OnOff::Commands::Toggle::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCOnOffClusterToggleParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::OnOff::Commands::Toggle::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::OnOff::Commands::Toggle::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::OnOff::Commands::Toggle::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCOnOffClusterToggleCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCOnOffClusterOffWithEffectCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::OnOff::Commands::OffWithEffect::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::OnOff::Commands::OffWithEffect::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCOnOffClusterOffWithEffectParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::OnOff::Commands::OffWithEffect::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::OnOff::Commands::OffWithEffect::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::OnOff::Commands::OffWithEffect::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCOnOffClusterOffWithEffectCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCOnOffClusterOnWithRecallGlobalSceneCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCOnOffClusterOnWithRecallGlobalSceneParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::OnOff::Commands::OnWithRecallGlobalScene::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCOnOffClusterOnWithRecallGlobalSceneCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCOnOffClusterOnWithTimedOffCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCOnOffClusterOnWithTimedOffParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::OnOff::Commands::OnWithTimedOff::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCOnOffClusterOnWithTimedOffCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

// LevelControl cluster:

@implementation MCLevelControlClusterMoveToLevelCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterMoveToLevelParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterMoveToLevelCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCLevelControlClusterMoveCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::Move::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::Move::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterMoveParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::Move::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::Move::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::Move::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterMoveCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCLevelControlClusterStepCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::Step::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::Step::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterStepParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::Step::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::Step::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::Step::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterStepCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCLevelControlClusterStopCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::Stop::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::Stop::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterStopParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::Stop::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::Stop::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::Stop::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterStopCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCLevelControlClusterMoveToLevelWithOnOffCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterMoveToLevelWithOnOffParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::MoveToLevelWithOnOff::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterMoveToLevelWithOnOffCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCLevelControlClusterMoveWithOnOffCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterMoveWithOnOffParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::MoveWithOnOff::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterMoveWithOnOffCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCLevelControlClusterStepWithOnOffCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterStepWithOnOffParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::StepWithOnOff::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterStepWithOnOffCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCLevelControlClusterStopWithOnOffCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterStopWithOnOffParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::StopWithOnOff::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterStopWithOnOffCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCLevelControlClusterMoveToClosestFrequencyCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::MoveToClosestFrequency::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::LevelControl::Commands::MoveToClosestFrequency::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCLevelControlClusterMoveToClosestFrequencyParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::LevelControl::Commands::MoveToClosestFrequency::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::LevelControl::Commands::MoveToClosestFrequency::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::LevelControl::Commands::MoveToClosestFrequency::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCLevelControlClusterMoveToClosestFrequencyCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

// WakeOnLan cluster:

// TargetNavigator cluster:

@implementation MCTargetNavigatorClusterNavigateTargetCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCTargetNavigatorClusterNavigateTargetParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCTargetNavigatorClusterNavigateTargetResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type::ResponseType>)) {
        objCResponse = [[MCTargetNavigatorClusterNavigateTargetResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCTargetNavigatorClusterNavigateTargetCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

// MediaPlayback cluster:

@implementation MCMediaPlaybackClusterPlayCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Play::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Play::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterPlayParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::Play::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::Play::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::Play::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterPlayCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterPauseCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Pause::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Pause::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterPauseParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::Pause::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::Pause::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::Pause::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterPauseCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterStopCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Stop::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Stop::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterStopParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::Stop::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::Stop::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::Stop::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterStopCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterStartOverCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::StartOver::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::StartOver::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterStartOverParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::StartOver::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::StartOver::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::StartOver::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterStartOverCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterPreviousCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Previous::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Previous::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterPreviousParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::Previous::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::Previous::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::Previous::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterPreviousCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterNextCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Next::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Next::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterNextParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::Next::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::Next::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::Next::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterNextCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterRewindCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Rewind::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Rewind::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterRewindParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::Rewind::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::Rewind::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::Rewind::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterRewindCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterFastForwardCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::FastForward::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::FastForward::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterFastForwardParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::FastForward::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::FastForward::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::FastForward::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterFastForwardCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterSkipForwardCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::SkipForward::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::SkipForward::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterSkipForwardParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::SkipForward::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::SkipForward::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::SkipForward::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterSkipForwardCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterSkipBackwardCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::SkipBackward::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::SkipBackward::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterSkipBackwardParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::SkipBackward::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::SkipBackward::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::SkipBackward::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterSkipBackwardCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterSeekCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Seek::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::Seek::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterSeekParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::Seek::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::Seek::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCMediaPlaybackClusterPlaybackResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::Seek::Type::ResponseType>)) {
        objCResponse = [[MCMediaPlaybackClusterPlaybackResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterSeekCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterActivateAudioTrackCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::ActivateAudioTrack::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::ActivateAudioTrack::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterActivateAudioTrackParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::ActivateAudioTrack::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::ActivateAudioTrack::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::ActivateAudioTrack::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterActivateAudioTrackCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterActivateTextTrackCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::ActivateTextTrack::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::ActivateTextTrack::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterActivateTextTrackParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::ActivateTextTrack::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::ActivateTextTrack::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::ActivateTextTrack::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterActivateTextTrackCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCMediaPlaybackClusterDeactivateTextTrackCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::DeactivateTextTrack::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::MediaPlayback::Commands::DeactivateTextTrack::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCMediaPlaybackClusterDeactivateTextTrackParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::MediaPlayback::Commands::DeactivateTextTrack::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::MediaPlayback::Commands::DeactivateTextTrack::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCNullObjectType * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::MediaPlayback::Commands::DeactivateTextTrack::Type::ResponseType>)) {
        objCResponse = [[MCNullObjectType
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCMediaPlaybackClusterDeactivateTextTrackCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

// KeypadInput cluster:

@implementation MCKeypadInputClusterSendKeyCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::KeypadInput::Commands::SendKey::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::KeypadInput::Commands::SendKey::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCKeypadInputClusterSendKeyParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::KeypadInput::Commands::SendKey::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::KeypadInput::Commands::SendKey::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCKeypadInputClusterSendKeyResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::KeypadInput::Commands::SendKey::Type::ResponseType>)) {
        objCResponse = [[MCKeypadInputClusterSendKeyResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCKeypadInputClusterSendKeyCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

// ContentLauncher cluster:

@implementation MCContentLauncherClusterLaunchContentCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCContentLauncherClusterLaunchContentParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCContentLauncherClusterLauncherResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type::ResponseType>)) {
        objCResponse = [[MCContentLauncherClusterLauncherResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCContentLauncherClusterLaunchContentCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCContentLauncherClusterLaunchURLCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCContentLauncherClusterLaunchURLParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCContentLauncherClusterLauncherResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type::ResponseType>)) {
        objCResponse = [[MCContentLauncherClusterLauncherResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCContentLauncherClusterLaunchURLCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

// ApplicationLauncher cluster:

@implementation MCApplicationLauncherClusterLaunchAppCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCApplicationLauncherClusterLaunchAppParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCApplicationLauncherClusterLauncherResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type::ResponseType>)) {
        objCResponse = [[MCApplicationLauncherClusterLauncherResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCApplicationLauncherClusterLaunchAppCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCApplicationLauncherClusterStopAppCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCApplicationLauncherClusterStopAppParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCApplicationLauncherClusterLauncherResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type::ResponseType>)) {
        objCResponse = [[MCApplicationLauncherClusterLauncherResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCApplicationLauncherClusterStopAppCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

@implementation MCApplicationLauncherClusterHideAppCommand
- (void)invoke:(id)request
                 context:(void * _Nullable)context
              completion:(void (^_Nonnull __strong)(void *, NSError *, id))completion
    timedInvokeTimeoutMs:(NSNumber * _Nullable)timedInvokeTimeoutMs
{
    MCCommandTemplate<chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type> * mcCommand = new MCCommandTemplate<chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type>(
        self.cppCommand,
        [self](id objCRequest) {
            return [self getCppRequestFromObjC:objCRequest];
        },
        [self](std::any cppResponse) {
            return [self getObjCResponseFromCpp:cppResponse];
        });
    mcCommand->invoke(
        request, context, [mcCommand, completion](void * context, NSError * err, id response) {
            completion(context, err, response);
            delete mcCommand;
        }, timedInvokeTimeoutMs);
}

- (std::any)getCppRequestFromObjC:(MCApplicationLauncherClusterHideAppParams *)objcRequest
{
    VerifyOrReturnValue(objcRequest != nil, nullptr);
    std::any anyCppRequest = [objcRequest getCppRequestFromObjCRequest];
    if (anyCppRequest.has_value()) {
        try {
            // Extract the object from std::any and convert it to a std::shared_ptr
            auto & cppRequest = std::any_cast<chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type &>(anyCppRequest);
            return std::any(std::make_shared<chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type>(cppRequest));
        } catch (const std::bad_any_cast & e) {
            return nullptr;
        }
    }
    return nullptr;
}

- (id)getObjCResponseFromCpp:(std::any)cppResponse
{
    MCApplicationLauncherClusterLauncherResponseParams * objCResponse = nil;
    CHIP_ERROR err = CHIP_NO_ERROR;
    if (cppResponse.type() == typeid(std::shared_ptr<const chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type::ResponseType>)) {
        objCResponse = [[MCApplicationLauncherClusterLauncherResponseParams
            alloc] init];
        // Set the ObjC response fields using the given cpp Response
        err = [objCResponse setObjCResponseFromCppResponse:cppResponse];
        VerifyOrReturnValue(err == CHIP_NO_ERROR, nil, ChipLogError(AppServer, "MCApplicationLauncherClusterHideAppCommand getObjCResponseFromCpp() failed"));
    }
    return objCResponse;
}
@end

// ApplicationBasic cluster:
