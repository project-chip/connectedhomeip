From 035a1b3f568971ba7368c3dadef6a9827509246f Mon Sep 17 00:00:00 2001
From: "sungmok.shin" <sungmok.shin@lge.com>
Date: Wed, 22 Dec 2021 09:55:53 +0900
Subject: [PATCH] Add webOS OS port

:Release Notes:
Add webOS OS port

:Detailed Notes:
This commit introduces additional platform layer for webOS.

Base commit is 7fb48ab2ff47c7e155f3f133a3ada3f5201adf0e
2021-12-18 09:27 Pankaj Garg o Set CASESession state after successful message

:Testing Performed:
TBD

:QA Notes:

:Issues Addressed:
TBD
---
 build/config/BUILDCONFIG.gn                   |    6 +-
 build/config/compiler/BUILD.gn                |    4 +-
 src/platform/BUILD.gn                         |   13 +-
 src/platform/device.gni                       |   10 +-
 src/platform/webos/BLEManagerImpl.cpp         |  837 ++++++++
 src/platform/webos/BLEManagerImpl.h           |  255 +++
 src/platform/webos/BUILD.gn                   |  136 ++
 src/platform/webos/BlePlatformConfig.h        |   39 +
 src/platform/webos/CHIPDevicePlatformConfig.h |   88 +
 src/platform/webos/CHIPDevicePlatformEvent.h  |  116 ++
 src/platform/webos/CHIPLinuxStorage.cpp       |  321 +++
 src/platform/webos/CHIPLinuxStorage.h         |   95 +
 src/platform/webos/CHIPLinuxStorageIni.cpp    |  366 ++++
 src/platform/webos/CHIPLinuxStorageIni.h      |   62 +
 src/platform/webos/CHIPPlatformConfig.h       |  125 ++
 .../webos/ConfigurationManagerImpl.cpp        |  369 ++++
 src/platform/webos/ConfigurationManagerImpl.h |   87 +
 .../webos/ConnectivityManagerImpl.cpp         | 1116 ++++++++++
 src/platform/webos/ConnectivityManagerImpl.h  |  250 +++
 src/platform/webos/ConnectivityUtils.cpp      |  646 ++++++
 src/platform/webos/ConnectivityUtils.h        |   66 +
 .../DeviceNetworkProvisioningDelegateImpl.cpp |   47 +
 .../DeviceNetworkProvisioningDelegateImpl.h   |   43 +
 .../webos/DiagnosticDataProviderImpl.cpp      |  790 ++++++++
 .../webos/DiagnosticDataProviderImpl.h        |  107 +
 src/platform/webos/DnssdImpl.cpp              |  850 ++++++++
 src/platform/webos/DnssdImpl.h                |  173 ++
 src/platform/webos/GlibTypeDeleter.h          |   71 +
 src/platform/webos/InetPlatformConfig.h       |   48 +
 .../webos/KeyValueStoreManagerImpl.cpp        |  114 ++
 src/platform/webos/KeyValueStoreManagerImpl.h |   79 +
 src/platform/webos/Logging.cpp                |   58 +
 src/platform/webos/OTAImageProcessorImpl.cpp  |  203 ++
 src/platform/webos/OTAImageProcessorImpl.h    |   63 +
 src/platform/webos/OTARequestorDriverImpl.cpp |   41 +
 src/platform/webos/OTARequestorDriverImpl.h   |   46 +
 src/platform/webos/PlatformManagerImpl.cpp    |  538 +++++
 src/platform/webos/PlatformManagerImpl.h      |  123 ++
 src/platform/webos/PosixConfig.cpp            |  545 +++++
 src/platform/webos/PosixConfig.h              |  130 ++
 src/platform/webos/README.md                  |   59 +
 src/platform/webos/SystemPlatformConfig.h     |   49 +
 src/platform/webos/SystemTimeSupport.cpp      |   70 +
 src/platform/webos/ThreadStackManagerImpl.cpp |  512 +++++
 src/platform/webos/ThreadStackManagerImpl.h   |  121 ++
 src/platform/webos/WirelessDefs.h             |  186 ++
 src/platform/webos/args.gni                   |   15 +
 src/platform/webos/bluez/AdapterIterator.cpp  |  133 ++
 src/platform/webos/bluez/AdapterIterator.h    |   94 +
 .../webos/bluez/BluezObjectIterator.h         |   68 +
 src/platform/webos/bluez/BluezObjectList.h    |   65 +
 .../webos/bluez/ChipDeviceScanner.cpp         |  311 +++
 src/platform/webos/bluez/ChipDeviceScanner.h  |  107 +
 src/platform/webos/bluez/Helper.cpp           | 1790 +++++++++++++++++
 src/platform/webos/bluez/Helper.h             |   84 +
 src/platform/webos/bluez/MainLoop.cpp         |  185 ++
 src/platform/webos/bluez/MainLoop.h           |  108 +
 src/platform/webos/bluez/Types.h              |  197 ++
 src/platform/webos/dbus/bluez/BUILD.gn        |   26 +
 src/platform/webos/dbus/bluez/DbusBluez.xml   |  255 +++
 src/platform/webos/dbus/openthread/BUILD.gn   |   25 +
 .../webos/dbus/openthread/introspect.xml      |  476 +++++
 src/platform/webos/dbus/wpa/BUILD.gn          |   30 +
 src/platform/webos/dbus/wpa/DBusWpa.xml       |   36 +
 src/platform/webos/dbus/wpa/DBusWpaBss.xml    |   10 +
 .../webos/dbus/wpa/DBusWpaInterface.xml       |  265 +++
 .../webos/dbus/wpa/DBusWpaNetwork.xml         |   11 +
 67 files changed, 14355 insertions(+), 9 deletions(-)
 create mode 100644 src/platform/webos/BLEManagerImpl.cpp
 create mode 100644 src/platform/webos/BLEManagerImpl.h
 create mode 100644 src/platform/webos/BUILD.gn
 create mode 100644 src/platform/webos/BlePlatformConfig.h
 create mode 100644 src/platform/webos/CHIPDevicePlatformConfig.h
 create mode 100644 src/platform/webos/CHIPDevicePlatformEvent.h
 create mode 100644 src/platform/webos/CHIPLinuxStorage.cpp
 create mode 100644 src/platform/webos/CHIPLinuxStorage.h
 create mode 100644 src/platform/webos/CHIPLinuxStorageIni.cpp
 create mode 100644 src/platform/webos/CHIPLinuxStorageIni.h
 create mode 100644 src/platform/webos/CHIPPlatformConfig.h
 create mode 100644 src/platform/webos/ConfigurationManagerImpl.cpp
 create mode 100644 src/platform/webos/ConfigurationManagerImpl.h
 create mode 100644 src/platform/webos/ConnectivityManagerImpl.cpp
 create mode 100644 src/platform/webos/ConnectivityManagerImpl.h
 create mode 100644 src/platform/webos/ConnectivityUtils.cpp
 create mode 100644 src/platform/webos/ConnectivityUtils.h
 create mode 100644 src/platform/webos/DeviceNetworkProvisioningDelegateImpl.cpp
 create mode 100644 src/platform/webos/DeviceNetworkProvisioningDelegateImpl.h
 create mode 100644 src/platform/webos/DiagnosticDataProviderImpl.cpp
 create mode 100644 src/platform/webos/DiagnosticDataProviderImpl.h
 create mode 100644 src/platform/webos/DnssdImpl.cpp
 create mode 100644 src/platform/webos/DnssdImpl.h
 create mode 100644 src/platform/webos/GlibTypeDeleter.h
 create mode 100644 src/platform/webos/InetPlatformConfig.h
 create mode 100644 src/platform/webos/KeyValueStoreManagerImpl.cpp
 create mode 100644 src/platform/webos/KeyValueStoreManagerImpl.h
 create mode 100644 src/platform/webos/Logging.cpp
 create mode 100644 src/platform/webos/OTAImageProcessorImpl.cpp
 create mode 100644 src/platform/webos/OTAImageProcessorImpl.h
 create mode 100644 src/platform/webos/OTARequestorDriverImpl.cpp
 create mode 100644 src/platform/webos/OTARequestorDriverImpl.h
 create mode 100644 src/platform/webos/PlatformManagerImpl.cpp
 create mode 100644 src/platform/webos/PlatformManagerImpl.h
 create mode 100644 src/platform/webos/PosixConfig.cpp
 create mode 100644 src/platform/webos/PosixConfig.h
 create mode 100644 src/platform/webos/README.md
 create mode 100644 src/platform/webos/SystemPlatformConfig.h
 create mode 100644 src/platform/webos/SystemTimeSupport.cpp
 create mode 100644 src/platform/webos/ThreadStackManagerImpl.cpp
 create mode 100644 src/platform/webos/ThreadStackManagerImpl.h
 create mode 100644 src/platform/webos/WirelessDefs.h
 create mode 100644 src/platform/webos/args.gni
 create mode 100644 src/platform/webos/bluez/AdapterIterator.cpp
 create mode 100644 src/platform/webos/bluez/AdapterIterator.h
 create mode 100644 src/platform/webos/bluez/BluezObjectIterator.h
 create mode 100644 src/platform/webos/bluez/BluezObjectList.h
 create mode 100644 src/platform/webos/bluez/ChipDeviceScanner.cpp
 create mode 100644 src/platform/webos/bluez/ChipDeviceScanner.h
 create mode 100644 src/platform/webos/bluez/Helper.cpp
 create mode 100644 src/platform/webos/bluez/Helper.h
 create mode 100644 src/platform/webos/bluez/MainLoop.cpp
 create mode 100644 src/platform/webos/bluez/MainLoop.h
 create mode 100644 src/platform/webos/bluez/Types.h
 create mode 100644 src/platform/webos/dbus/bluez/BUILD.gn
 create mode 100644 src/platform/webos/dbus/bluez/DbusBluez.xml
 create mode 100644 src/platform/webos/dbus/openthread/BUILD.gn
 create mode 100644 src/platform/webos/dbus/openthread/introspect.xml
 create mode 100644 src/platform/webos/dbus/wpa/BUILD.gn
 create mode 100644 src/platform/webos/dbus/wpa/DBusWpa.xml
 create mode 100644 src/platform/webos/dbus/wpa/DBusWpaBss.xml
 create mode 100644 src/platform/webos/dbus/wpa/DBusWpaInterface.xml
 create mode 100644 src/platform/webos/dbus/wpa/DBusWpaNetwork.xml

diff --git a/build/config/BUILDCONFIG.gn b/build/config/BUILDCONFIG.gn
index b273b4d96..3c21679bb 100644
--- a/build/config/BUILDCONFIG.gn
+++ b/build/config/BUILDCONFIG.gn
@@ -33,9 +33,9 @@ if (current_os == "") {
 }
 
 #[webos] if target_os is webos, set current_os as linux.
-if(target_os == "webos") {
-  current_os = "linux"
-}
+#if(target_os == "webos") {
+#  current_os = "linux"
+#}
 
 _build_overrides = {
   import("//build_overrides/build.gni")
diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index 81fb08caa..895f4fa2f 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -191,7 +191,7 @@ config("warnings_common") {
   }
 
   if (current_os != "mac" && current_os != "ios" && current_os != "linux" &&
-      current_os != "win" && current_os != "tizen") {
+      current_os != "win" && current_os != "tizen" && current_os != "webos") {
     cflags += [ "-Wstack-usage=8192" ]
   }
 }
@@ -268,7 +268,7 @@ config("runtime_default") {
       "$dir_pw_toolchain/host_clang:xcode_sysroot",
     ]
   }
-  if (current_os == "linux" || current_os == "tizen") {
+  if (current_os == "linux" || current_os == "tizen" || current_os == "webos") {
     libs = [
       "dl",
       "pthread",
diff --git a/src/platform/BUILD.gn b/src/platform/BUILD.gn
index cd12ba5da..38b5cdc89 100644
--- a/src/platform/BUILD.gn
+++ b/src/platform/BUILD.gn
@@ -68,7 +68,7 @@ if (chip_device_platform != "none") {
   }
 
   if (chip_stack_lock_tracking == "auto") {
-    if (chip_device_platform == "linux" || chip_device_platform == "tizen" ||
+    if (chip_device_platform == "linux" || chip_device_platform == "tizen" || chip_device_platform == "webos" ||
         chip_device_platform == "android") {
       # TODO: should be fatal for development. Change once bugs are fixed
       chip_stack_lock_tracking = "log"
@@ -110,6 +110,7 @@ if (chip_device_platform != "none") {
       "CHIP_DEVICE_CONFIG_RUN_AS_ROOT=${chip_device_config_run_as_root}",
     ]
 
+    # Let's not include ble flag for webOS at this moment.
     if (chip_device_platform == "linux" || chip_device_platform == "darwin" ||
         chip_device_platform == "tizen" || chip_device_platform == "android") {
       defines += [ "CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE=${chip_enable_ble}" ]
@@ -168,6 +169,14 @@ if (chip_device_platform != "none") {
         "CHIP_DEVICE_LAYER_TARGET=Linux",
         "CHIP_DEVICE_CONFIG_ENABLE_WIFI=${chip_enable_wifi}",
       ]
+    } else if (chip_device_platform == "webos") {
+      defines += [
+        "CHIP_DEVICE_LAYER_TARGET_LINUX=1",
+        "CHIP_DEVICE_LAYER_TARGET=webos",
+        "CHIP_DEVICE_CONFIG_ENABLE_WIFI=${chip_enable_wifi}",
+      ]
+      defines -=
+          [ "CHIP_DEVICE_CONFIG_ENABLE_WPA=${chip_device_config_enable_wpa}" ]
     } else if (chip_device_platform == "tizen") {
       defines += [
         "CHIP_DEVICE_LAYER_TARGET_TIZEN=1",
@@ -336,6 +345,8 @@ if (chip_device_platform != "none") {
       _platform_target = "P6"
     } else if (chip_device_platform == "ameba") {
       _platform_target = "Ameba"
+    } else if (chip_device_platform == "webos") {
+      _platform_target = "webos"
     } else if (chip_device_platform == "fake") {
       _platform_target = "fake"
     } else {
diff --git a/src/platform/device.gni b/src/platform/device.gni
index ff9ce0b0e..48718b96f 100755
--- a/src/platform/device.gni
+++ b/src/platform/device.gni
@@ -34,6 +34,8 @@ if (chip_device_platform == "auto") {
     chip_device_platform = "linux"
   } else if (current_os == "tizen") {
     chip_device_platform = "tizen"
+  } else if (current_os == "webos") {
+    chip_device_platform = "webos"
   } else if (current_os == "android") {
     chip_device_platform = "android"
   } else {
@@ -55,7 +57,7 @@ declare_args() {
   chip_enable_wifi =
       chip_device_platform == "linux" || chip_device_platform == "esp32" ||
       chip_device_platform == "mbed" || chip_device_platform == "tizen" ||
-      chip_device_platform == "android" || chip_device_platform == "ameba"
+      chip_device_platform == "android" || chip_device_platform == "ameba" || chip_device_platform == "webos"
 
   # Enable ble support.
   if (chip_device_platform == "fake") {
@@ -73,7 +75,7 @@ declare_args() {
   # Select DNS-SD implementation
   if (chip_device_platform == "linux" || chip_device_platform == "esp32" ||
       chip_device_platform == "mbed" || chip_device_platform == "p6" ||
-      chip_device_platform == "ameba") {
+      chip_device_platform == "ameba" || chip_device_platform == "webos") {
     chip_mdns = "minimal"
   } else if (chip_device_platform == "darwin" ||
              chip_device_platform == "cc13x2_26x2" || current_os == "android" ||
@@ -98,6 +100,8 @@ if (chip_device_platform == "cc13x2_26x2") {
   _chip_device_layer = "Linux"
 } else if (chip_device_platform == "tizen") {
   _chip_device_layer = "Tizen"
+} else if (chip_device_platform == "webos") {
+  _chip_device_layer = "webos"
 } else if (chip_device_platform == "nrfconnect") {
   _chip_device_layer = "nrfconnect"
 } else if (chip_device_platform == "qpg") {
@@ -151,7 +155,7 @@ assert(
         chip_device_platform == "cc13x2_26x2" ||
         chip_device_platform == "darwin" || chip_device_platform == "efr32" ||
         chip_device_platform == "esp32" || chip_device_platform == "external" ||
-        chip_device_platform == "linux" || chip_device_platform == "tizen" ||
+        chip_device_platform == "linux" || chip_device_platform == "tizen" || chip_device_platform == "webos" ||
         chip_device_platform == "nrfconnect" ||
         chip_device_platform == "k32w0" || chip_device_platform == "qpg" ||
         chip_device_platform == "telink" || chip_device_platform == "mbed" ||
diff --git a/src/platform/webos/BLEManagerImpl.cpp b/src/platform/webos/BLEManagerImpl.cpp
new file mode 100644
index 000000000..020783698
--- /dev/null
+++ b/src/platform/webos/BLEManagerImpl.cpp
@@ -0,0 +1,837 @@
+/*
+ *
+ *    Copyright (c) 2020-2021 Project CHIP Authors
+ *    Copyright (c) 2018 Nest Labs, Inc.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the BLEManager singleton object
+ *          for Linux platforms.
+ */
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+#include <ble/CHIPBleServiceData.h>
+#include <lib/support/CodeUtils.h>
+#include <lib/support/SafeInt.h>
+#include <new>
+#include <platform/internal/BLEManager.h>
+
+#include <cassert>
+#include <type_traits>
+#include <utility>
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+#include "bluez/Helper.h"
+
+using namespace ::nl;
+using namespace ::chip::Ble;
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+namespace {
+
+static constexpr System::Clock::Timeout kNewConnectionScanTimeout = System::Clock::Seconds16(10);
+static constexpr System::Clock::Timeout kConnectTimeout           = System::Clock::Seconds16(10);
+
+const ChipBleUUID ChipUUID_CHIPoBLEChar_RX = { { 0x18, 0xEE, 0x2E, 0xF5, 0x26, 0x3D, 0x45, 0x59, 0x95, 0x9F, 0x4F, 0x9C, 0x42, 0x9F,
+                                                 0x9D, 0x11 } };
+const ChipBleUUID ChipUUID_CHIPoBLEChar_TX = { { 0x18, 0xEE, 0x2E, 0xF5, 0x26, 0x3D, 0x45, 0x59, 0x95, 0x9F, 0x4F, 0x9C, 0x42, 0x9F,
+                                                 0x9D, 0x12 } };
+
+void HandleConnectTimeout(chip::System::Layer *, void * apEndpoint)
+{
+    assert(apEndpoint != nullptr);
+
+    CancelConnect(static_cast<BluezEndpoint *>(apEndpoint));
+    BLEManagerImpl::HandleConnectFailed(CHIP_ERROR_TIMEOUT);
+}
+
+} // namespace
+
+BLEManagerImpl BLEManagerImpl::sInstance;
+
+void HandleIncomingBleConnection(BLEEndPoint * bleEP)
+{
+    ChipLogProgress(DeviceLayer, "CHIPoBluez con rcvd");
+}
+
+CHIP_ERROR BLEManagerImpl::_Init()
+{
+    CHIP_ERROR err;
+
+    err = BleLayer::Init(this, this, this, &DeviceLayer::SystemLayer());
+    SuccessOrExit(err);
+
+    mServiceMode = ConnectivityManager::kCHIPoBLEServiceMode_Enabled;
+    mFlags.ClearAll().Set(Flags::kAdvertisingEnabled, CHIP_DEVICE_CONFIG_CHIPOBLE_ENABLE_ADVERTISING_AUTOSTART && !mIsCentral);
+    mFlags.Set(Flags::kFastAdvertisingEnabled, true);
+
+    memset(mDeviceName, 0, sizeof(mDeviceName));
+
+    OnChipBleConnectReceived = HandleIncomingBleConnection;
+
+    PlatformMgr().ScheduleWork(DriveBLEState, 0);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR BLEManagerImpl::_Shutdown()
+{
+    // ensure scan resources are cleared (e.g. timeout timers)
+    mDeviceScanner.reset();
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR BLEManagerImpl::_SetCHIPoBLEServiceMode(CHIPoBLEServiceMode val)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    VerifyOrExit(val != ConnectivityManager::kCHIPoBLEServiceMode_NotSupported, err = CHIP_ERROR_INVALID_ARGUMENT);
+    VerifyOrExit(mServiceMode == ConnectivityManager::kCHIPoBLEServiceMode_NotSupported, err = CHIP_ERROR_UNSUPPORTED_CHIP_FEATURE);
+
+    if (val != mServiceMode)
+    {
+        mServiceMode = val;
+        PlatformMgr().ScheduleWork(DriveBLEState, 0);
+    }
+
+exit:
+    return err;
+}
+
+CHIP_ERROR BLEManagerImpl::_SetAdvertisingEnabled(bool val)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    if (mFlags.Has(Flags::kAdvertisingEnabled) != val)
+    {
+        mFlags.Set(Flags::kAdvertisingEnabled, val);
+    }
+
+    PlatformMgr().ScheduleWork(DriveBLEState, 0);
+
+    return err;
+}
+
+CHIP_ERROR BLEManagerImpl::_SetAdvertisingMode(BLEAdvertisingMode mode)
+{
+    switch (mode)
+    {
+    case BLEAdvertisingMode::kFastAdvertising:
+        mFlags.Set(Flags::kFastAdvertisingEnabled, true);
+        break;
+    case BLEAdvertisingMode::kSlowAdvertising:
+        mFlags.Set(Flags::kFastAdvertisingEnabled, false);
+        break;
+    default:
+        return CHIP_ERROR_INVALID_ARGUMENT;
+    }
+    mFlags.Set(Flags::kAdvertisingRefreshNeeded);
+    PlatformMgr().ScheduleWork(DriveBLEState, 0);
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR BLEManagerImpl::_GetDeviceName(char * buf, size_t bufSize)
+{
+    if (strlen(mDeviceName) >= bufSize)
+    {
+        return CHIP_ERROR_BUFFER_TOO_SMALL;
+    }
+    strcpy(buf, mDeviceName);
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR BLEManagerImpl::_SetDeviceName(const char * deviceName)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    VerifyOrExit(mServiceMode != ConnectivityManager::kCHIPoBLEServiceMode_NotSupported, err = CHIP_ERROR_UNSUPPORTED_CHIP_FEATURE);
+
+    if (deviceName != nullptr && deviceName[0] != 0)
+    {
+        VerifyOrExit(strlen(deviceName) < kMaxDeviceNameLength, err = CHIP_ERROR_INVALID_ARGUMENT);
+        strcpy(mDeviceName, deviceName);
+        mFlags.Set(Flags::kUseCustomDeviceName);
+    }
+    else
+    {
+        uint16_t discriminator;
+        SuccessOrExit(err = ConfigurationMgr().GetSetupDiscriminator(discriminator));
+        snprintf(mDeviceName, sizeof(mDeviceName), "%s%04u", CHIP_DEVICE_CONFIG_BLE_DEVICE_NAME_PREFIX, discriminator);
+        mDeviceName[kMaxDeviceNameLength] = 0;
+        mFlags.Clear(Flags::kUseCustomDeviceName);
+    }
+
+exit:
+    return err;
+}
+
+uint16_t BLEManagerImpl::_NumConnections()
+{
+    uint16_t numCons = 0;
+    return numCons;
+}
+
+CHIP_ERROR BLEManagerImpl::ConfigureBle(uint32_t aAdapterId, bool aIsCentral)
+{
+    CHIP_ERROR err                  = CHIP_NO_ERROR;
+    mBLEAdvConfig.mpBleName         = mDeviceName;
+    mBLEAdvConfig.mAdapterId        = aAdapterId;
+    mBLEAdvConfig.mMajor            = 1;
+    mBLEAdvConfig.mMinor            = 1;
+    mBLEAdvConfig.mVendorId         = 1;
+    mBLEAdvConfig.mProductId        = 1;
+    mBLEAdvConfig.mDeviceId         = 1;
+    mBLEAdvConfig.mDuration         = 2;
+    mBLEAdvConfig.mPairingStatus    = 0;
+    mBLEAdvConfig.mType             = ChipAdvType::BLUEZ_ADV_TYPE_UNDIRECTED_CONNECTABLE_SCANNABLE;
+    mBLEAdvConfig.mpAdvertisingUUID = "0xFFF6";
+
+    mIsCentral = aIsCentral;
+
+    return err;
+}
+
+CHIP_ERROR BLEManagerImpl::StartBLEAdvertising()
+{
+    return StartBluezAdv(mpEndpoint);
+}
+
+CHIP_ERROR BLEManagerImpl::StopBLEAdvertising()
+{
+    return StopBluezAdv(mpEndpoint);
+}
+
+void BLEManagerImpl::_OnPlatformEvent(const ChipDeviceEvent * event)
+{
+    switch (event->Type)
+    {
+    case DeviceEventType::kCHIPoBLESubscribe:
+        HandleSubscribeReceived(event->CHIPoBLESubscribe.ConId, &CHIP_BLE_SVC_ID, &ChipUUID_CHIPoBLEChar_TX);
+        {
+            ChipDeviceEvent connectionEvent;
+            connectionEvent.Type = DeviceEventType::kCHIPoBLEConnectionEstablished;
+            PlatformMgr().PostEventOrDie(&connectionEvent);
+        }
+        break;
+
+    case DeviceEventType::kCHIPoBLEUnsubscribe:
+        HandleUnsubscribeReceived(event->CHIPoBLEUnsubscribe.ConId, &CHIP_BLE_SVC_ID, &ChipUUID_CHIPoBLEChar_TX);
+        break;
+
+    case DeviceEventType::kCHIPoBLEWriteReceived:
+        HandleWriteReceived(event->CHIPoBLEWriteReceived.ConId, &CHIP_BLE_SVC_ID, &ChipUUID_CHIPoBLEChar_RX,
+                            PacketBufferHandle::Adopt(event->CHIPoBLEWriteReceived.Data));
+        break;
+
+    case DeviceEventType::kCHIPoBLEIndicateConfirm:
+        HandleIndicationConfirmation(event->CHIPoBLEIndicateConfirm.ConId, &CHIP_BLE_SVC_ID, &ChipUUID_CHIPoBLEChar_TX);
+        break;
+
+    case DeviceEventType::kCHIPoBLEConnectionError:
+        HandleConnectionError(event->CHIPoBLEConnectionError.ConId, event->CHIPoBLEConnectionError.Reason);
+        break;
+    case DeviceEventType::kFabricMembershipChange:
+    case DeviceEventType::kServiceProvisioningChange:
+    case DeviceEventType::kAccountPairingChange:
+
+        // If CHIPOBLE_DISABLE_ADVERTISING_WHEN_PROVISIONED is enabled, and there is a change to the
+        // device's provisioning state, then automatically disable CHIPoBLE advertising if the device
+        // is now fully provisioned.
+#if CHIP_DEVICE_CONFIG_CHIPOBLE_DISABLE_ADVERTISING_WHEN_PROVISIONED
+        if (ConfigurationMgr().IsFullyProvisioned())
+        {
+            mFlags.Clear(Flags::kAdvertisingEnabled);
+            ChipLogProgress(DeviceLayer, "CHIPoBLE advertising disabled because device is fully provisioned");
+        }
+#endif // CHIP_DEVICE_CONFIG_CHIPOBLE_DISABLE_ADVERTISING_WHEN_PROVISIONED
+
+        // Force the advertising configuration to be refreshed to reflect new provisioning state.
+        mFlags.Clear(Flags::kAdvertisingConfigured);
+
+        DriveBLEState();
+        break;
+    default:
+        HandlePlatformSpecificBLEEvent(event);
+        break;
+    }
+}
+
+void BLEManagerImpl::HandlePlatformSpecificBLEEvent(const ChipDeviceEvent * apEvent)
+{
+    CHIP_ERROR err         = CHIP_NO_ERROR;
+    bool controlOpComplete = false;
+    ChipLogDetail(DeviceLayer, "HandlePlatformSpecificBLEEvent %d", apEvent->Type);
+    switch (apEvent->Type)
+    {
+    case DeviceEventType::kPlatformLinuxBLECentralConnected:
+        if (mBLEScanConfig.mBleScanState == BleScanState::kConnecting)
+        {
+            BleConnectionDelegate::OnConnectionComplete(mBLEScanConfig.mAppState,
+                                                        apEvent->Platform.BLECentralConnected.mConnection);
+            CleanScanConfig();
+        }
+        break;
+    case DeviceEventType::kPlatformLinuxBLECentralConnectFailed:
+        if (mBLEScanConfig.mBleScanState == BleScanState::kConnecting)
+        {
+            BleConnectionDelegate::OnConnectionError(mBLEScanConfig.mAppState, apEvent->Platform.BLECentralConnectFailed.mError);
+            CleanScanConfig();
+        }
+        break;
+    case DeviceEventType::kPlatformLinuxBLEWriteComplete:
+        HandleWriteConfirmation(apEvent->Platform.BLEWriteComplete.mConnection, &CHIP_BLE_SVC_ID, &ChipUUID_CHIPoBLEChar_RX);
+        break;
+    case DeviceEventType::kPlatformLinuxBLESubscribeOpComplete:
+        if (apEvent->Platform.BLESubscribeOpComplete.mIsSubscribed)
+            HandleSubscribeComplete(apEvent->Platform.BLESubscribeOpComplete.mConnection, &CHIP_BLE_SVC_ID,
+                                    &ChipUUID_CHIPoBLEChar_TX);
+        else
+            HandleUnsubscribeComplete(apEvent->Platform.BLESubscribeOpComplete.mConnection, &CHIP_BLE_SVC_ID,
+                                      &ChipUUID_CHIPoBLEChar_TX);
+        break;
+    case DeviceEventType::kPlatformLinuxBLEIndicationReceived:
+        HandleIndicationReceived(apEvent->Platform.BLEIndicationReceived.mConnection, &CHIP_BLE_SVC_ID, &ChipUUID_CHIPoBLEChar_TX,
+                                 PacketBufferHandle::Adopt(apEvent->Platform.BLEIndicationReceived.mData));
+        break;
+    case DeviceEventType::kPlatformLinuxBLEPeripheralAdvConfiguredComplete:
+        VerifyOrExit(apEvent->Platform.BLEPeripheralAdvConfiguredComplete.mIsSuccess, err = CHIP_ERROR_INCORRECT_STATE);
+        sInstance.mFlags.Set(Flags::kAdvertisingConfigured).Clear(Flags::kControlOpInProgress);
+        controlOpComplete = true;
+        ChipLogProgress(DeviceLayer, "CHIPoBLE advertising config complete");
+        break;
+    case DeviceEventType::kPlatformLinuxBLEPeripheralAdvStartComplete:
+        VerifyOrExit(apEvent->Platform.BLEPeripheralAdvStartComplete.mIsSuccess, err = CHIP_ERROR_INCORRECT_STATE);
+        sInstance.mFlags.Clear(Flags::kControlOpInProgress).Clear(Flags::kAdvertisingRefreshNeeded);
+
+        if (!sInstance.mFlags.Has(Flags::kAdvertising))
+        {
+            sInstance.mFlags.Set(Flags::kAdvertising);
+        }
+
+        break;
+    case DeviceEventType::kPlatformLinuxBLEPeripheralAdvStopComplete:
+        VerifyOrExit(apEvent->Platform.BLEPeripheralAdvStopComplete.mIsSuccess, err = CHIP_ERROR_INCORRECT_STATE);
+
+        sInstance.mFlags.Clear(Flags::kControlOpInProgress).Clear(Flags::kAdvertisingRefreshNeeded);
+
+        // Transition to the not Advertising state...
+        if (sInstance.mFlags.Has(Flags::kAdvertising))
+        {
+            sInstance.mFlags.Clear(Flags::kAdvertising);
+            ChipLogProgress(DeviceLayer, "CHIPoBLE advertising stopped");
+        }
+        break;
+    case DeviceEventType::kPlatformLinuxBLEPeripheralRegisterAppComplete:
+        VerifyOrExit(apEvent->Platform.BLEPeripheralRegisterAppComplete.mIsSuccess, err = CHIP_ERROR_INCORRECT_STATE);
+        mFlags.Set(Flags::kAppRegistered);
+        controlOpComplete = true;
+        break;
+    default:
+        break;
+    }
+
+exit:
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Disabling CHIPoBLE service due to error: %s", ErrorStr(err));
+        mServiceMode = ConnectivityManager::kCHIPoBLEServiceMode_Disabled;
+        sInstance.mFlags.Clear(Flags::kControlOpInProgress);
+    }
+
+    if (controlOpComplete)
+    {
+        mFlags.Clear(Flags::kControlOpInProgress);
+        DriveBLEState();
+    }
+}
+
+uint16_t BLEManagerImpl::GetMTU(BLE_CONNECTION_OBJECT conId) const
+{
+    BluezConnection * connection = static_cast<BluezConnection *>(conId);
+    return (connection != nullptr) ? connection->mMtu : 0;
+}
+
+bool BLEManagerImpl::SubscribeCharacteristic(BLE_CONNECTION_OBJECT conId, const ChipBleUUID * svcId, const ChipBleUUID * charId)
+{
+    bool result = false;
+
+    VerifyOrExit(Ble::UUIDsMatch(svcId, &CHIP_BLE_SVC_ID),
+                 ChipLogError(DeviceLayer, "SubscribeCharacteristic() called with invalid service ID"));
+    VerifyOrExit(Ble::UUIDsMatch(charId, &ChipUUID_CHIPoBLEChar_TX),
+                 ChipLogError(DeviceLayer, "SubscribeCharacteristic() called with invalid characteristic ID"));
+
+    result = BluezSubscribeCharacteristic(conId);
+exit:
+    return result;
+}
+
+bool BLEManagerImpl::UnsubscribeCharacteristic(BLE_CONNECTION_OBJECT conId, const ChipBleUUID * svcId, const ChipBleUUID * charId)
+{
+    bool result = false;
+
+    VerifyOrExit(Ble::UUIDsMatch(svcId, &CHIP_BLE_SVC_ID),
+                 ChipLogError(DeviceLayer, "UnsubscribeCharacteristic() called with invalid service ID"));
+    VerifyOrExit(Ble::UUIDsMatch(charId, &ChipUUID_CHIPoBLEChar_TX),
+                 ChipLogError(DeviceLayer, "UnsubscribeCharacteristic() called with invalid characteristic ID"));
+
+    result = BluezUnsubscribeCharacteristic(conId);
+exit:
+    return result;
+}
+
+bool BLEManagerImpl::CloseConnection(BLE_CONNECTION_OBJECT conId)
+{
+    ChipLogProgress(DeviceLayer, "Closing BLE GATT connection (con %p)", conId);
+    return CloseBluezConnection(conId);
+}
+
+bool BLEManagerImpl::SendIndication(BLE_CONNECTION_OBJECT conId, const ChipBleUUID * svcId, const Ble::ChipBleUUID * charId,
+                                    chip::System::PacketBufferHandle pBuf)
+{
+    return SendBluezIndication(conId, std::move(pBuf));
+}
+
+bool BLEManagerImpl::SendWriteRequest(BLE_CONNECTION_OBJECT conId, const Ble::ChipBleUUID * svcId, const Ble::ChipBleUUID * charId,
+                                      chip::System::PacketBufferHandle pBuf)
+{
+    bool result = false;
+
+    VerifyOrExit(Ble::UUIDsMatch(svcId, &CHIP_BLE_SVC_ID),
+                 ChipLogError(DeviceLayer, "SendWriteRequest() called with invalid service ID"));
+    VerifyOrExit(Ble::UUIDsMatch(charId, &ChipUUID_CHIPoBLEChar_RX),
+                 ChipLogError(DeviceLayer, "SendWriteRequest() called with invalid characteristic ID"));
+
+    result = BluezSendWriteRequest(conId, std::move(pBuf));
+exit:
+    return result;
+}
+
+bool BLEManagerImpl::SendReadRequest(BLE_CONNECTION_OBJECT conId, const Ble::ChipBleUUID * svcId, const Ble::ChipBleUUID * charId,
+                                     chip::System::PacketBufferHandle pBuf)
+{
+    ChipLogError(Ble, "SendReadRequest: Not implemented");
+    return true;
+}
+
+bool BLEManagerImpl::SendReadResponse(BLE_CONNECTION_OBJECT conId, BLE_READ_REQUEST_CONTEXT requestContext,
+                                      const Ble::ChipBleUUID * svcId, const Ble::ChipBleUUID * charId)
+{
+    ChipLogError(Ble, "SendReadRBluezonse: Not implemented");
+    return true;
+}
+
+void BLEManagerImpl::HandleNewConnection(BLE_CONNECTION_OBJECT conId)
+{
+    if (sInstance.mIsCentral)
+    {
+        ChipDeviceEvent event;
+        event.Type                                     = DeviceEventType::kPlatformLinuxBLECentralConnected;
+        event.Platform.BLECentralConnected.mConnection = conId;
+        PlatformMgr().PostEventOrDie(&event);
+    }
+}
+
+void BLEManagerImpl::HandleConnectFailed(CHIP_ERROR error)
+{
+    if (sInstance.mIsCentral)
+    {
+        ChipDeviceEvent event;
+        event.Type                                    = DeviceEventType::kPlatformLinuxBLECentralConnectFailed;
+        event.Platform.BLECentralConnectFailed.mError = error;
+        PlatformMgr().PostEventOrDie(&event);
+    }
+}
+
+void BLEManagerImpl::HandleWriteComplete(BLE_CONNECTION_OBJECT conId)
+{
+    ChipDeviceEvent event;
+    event.Type                                  = DeviceEventType::kPlatformLinuxBLEWriteComplete;
+    event.Platform.BLEWriteComplete.mConnection = conId;
+    PlatformMgr().PostEventOrDie(&event);
+}
+
+void BLEManagerImpl::HandleSubscribeOpComplete(BLE_CONNECTION_OBJECT conId, bool subscribed)
+{
+    ChipDeviceEvent event;
+    event.Type                                          = DeviceEventType::kPlatformLinuxBLESubscribeOpComplete;
+    event.Platform.BLESubscribeOpComplete.mConnection   = conId;
+    event.Platform.BLESubscribeOpComplete.mIsSubscribed = subscribed;
+    PlatformMgr().PostEventOrDie(&event);
+}
+
+void BLEManagerImpl::HandleTXCharChanged(BLE_CONNECTION_OBJECT conId, const uint8_t * value, size_t len)
+{
+    CHIP_ERROR err                 = CHIP_NO_ERROR;
+    System::PacketBufferHandle buf = System::PacketBufferHandle::NewWithData(value, len);
+
+    ChipLogDetail(DeviceLayer, "Indication received, conn = %p", conId);
+
+    VerifyOrExit(!buf.IsNull(), err = CHIP_ERROR_NO_MEMORY);
+
+    ChipDeviceEvent event;
+    event.Type                                       = DeviceEventType::kPlatformLinuxBLEIndicationReceived;
+    event.Platform.BLEIndicationReceived.mConnection = conId;
+    event.Platform.BLEIndicationReceived.mData       = std::move(buf).UnsafeRelease();
+    PlatformMgr().PostEventOrDie(&event);
+
+exit:
+    if (err != CHIP_NO_ERROR)
+        ChipLogError(DeviceLayer, "HandleTXCharChanged() failed: %s", ErrorStr(err));
+}
+
+void BLEManagerImpl::HandleRXCharWrite(BLE_CONNECTION_OBJECT conId, const uint8_t * value, size_t len)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    System::PacketBufferHandle buf;
+
+    // Copy the data to a packet buffer.
+    buf = System::PacketBufferHandle::NewWithData(value, len);
+    VerifyOrExit(!buf.IsNull(), err = CHIP_ERROR_NO_MEMORY);
+
+    // Post an event to the Chip queue to deliver the data into the Chip stack.
+    {
+        ChipDeviceEvent event;
+        event.Type = DeviceEventType::kCHIPoBLEWriteReceived;
+        ChipLogProgress(Ble, "Write request received debug %p", conId);
+        event.CHIPoBLEWriteReceived.ConId = conId;
+        event.CHIPoBLEWriteReceived.Data  = std::move(buf).UnsafeRelease();
+        PlatformMgr().PostEventOrDie(&event);
+    }
+
+exit:
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "HandleRXCharWrite() failed: %s", ErrorStr(err));
+    }
+}
+
+void BLEManagerImpl::CHIPoBluez_ConnectionClosed(BLE_CONNECTION_OBJECT conId)
+{
+    ChipLogProgress(DeviceLayer, "Bluez notify CHIPoBluez connection disconnected");
+
+    // If this was a CHIPoBLE connection, post an event to deliver a connection error to the CHIPoBLE layer.
+    {
+        ChipDeviceEvent event;
+        event.Type                           = DeviceEventType::kCHIPoBLEConnectionError;
+        event.CHIPoBLEConnectionError.ConId  = conId;
+        event.CHIPoBLEConnectionError.Reason = BLE_ERROR_REMOTE_DEVICE_DISCONNECTED;
+        PlatformMgr().PostEventOrDie(&event);
+    }
+}
+
+void BLEManagerImpl::HandleTXCharCCCDWrite(BLE_CONNECTION_OBJECT conId)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    BluezConnection * connection = static_cast<BluezConnection *>(conId);
+
+    VerifyOrExit(connection != nullptr, ChipLogError(DeviceLayer, "Connection is NULL in HandleTXCharCCCDWrite"));
+    VerifyOrExit(connection->mpC2 != nullptr, ChipLogError(DeviceLayer, "C2 is NULL in HandleTXCharCCCDWrite"));
+
+    // Post an event to the Chip queue to process either a CHIPoBLE Subscribe or Unsubscribe based on
+    // whether the client is enabling or disabling indications.
+    {
+        ChipDeviceEvent event;
+        event.Type = connection->mIsNotify ? DeviceEventType::kCHIPoBLESubscribe : DeviceEventType::kCHIPoBLEUnsubscribe;
+        event.CHIPoBLESubscribe.ConId = connection;
+        PlatformMgr().PostEventOrDie(&event);
+    }
+
+    ChipLogProgress(DeviceLayer, "CHIPoBLE %s received", connection->mIsNotify ? "subscribe" : "unsubscribe");
+
+exit:
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "HandleTXCharCCCDWrite() failed: %s", ErrorStr(err));
+        // TODO: fail connection
+    }
+}
+
+void BLEManagerImpl::HandleTXComplete(BLE_CONNECTION_OBJECT conId)
+{
+    // Post an event to the Chip queue to process the indicate confirmation.
+    ChipDeviceEvent event;
+    event.Type                          = DeviceEventType::kCHIPoBLEIndicateConfirm;
+    event.CHIPoBLEIndicateConfirm.ConId = conId;
+    PlatformMgr().PostEventOrDie(&event);
+}
+
+void BLEManagerImpl::DriveBLEState()
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    // Perform any initialization actions that must occur after the Chip task is running.
+    if (!mFlags.Has(Flags::kAsyncInitCompleted))
+    {
+        mFlags.Set(Flags::kAsyncInitCompleted);
+
+        // If CHIP_DEVICE_CONFIG_CHIPOBLE_DISABLE_ADVERTISING_WHEN_PROVISIONED is enabled,
+        // disable CHIPoBLE advertising if the device is fully provisioned.
+#if CHIP_DEVICE_CONFIG_CHIPOBLE_DISABLE_ADVERTISING_WHEN_PROVISIONED
+        if (ConfigurationMgr().IsFullyProvisioned())
+        {
+            mFlags.Clear(Flags::kAdvertisingEnabled);
+            ChipLogProgress(DeviceLayer, "CHIPoBLE advertising disabled because device is fully provisioned");
+        }
+#endif // CHIP_DEVICE_CONFIG_CHIPOBLE_DISABLE_ADVERTISING_WHEN_PROVISIONED
+        ExitNow();
+    }
+
+    // If there's already a control operation in progress, wait until it completes.
+    VerifyOrExit(!mFlags.Has(Flags::kControlOpInProgress), /* */);
+
+    // Initializes the Bluez BLE layer if needed.
+    if (mServiceMode == ConnectivityManager::kCHIPoBLEServiceMode_Enabled && !mFlags.Has(Flags::kBluezBLELayerInitialized))
+    {
+        err = InitBluezBleLayer(mIsCentral, nullptr, mBLEAdvConfig, mpEndpoint);
+        SuccessOrExit(err);
+        mFlags.Set(Flags::kBluezBLELayerInitialized);
+    }
+
+    // Register the CHIPoBLE application with the Bluez BLE layer if needed.
+    if (!mIsCentral && mServiceMode == ConnectivityManager::kCHIPoBLEServiceMode_Enabled && !mFlags.Has(Flags::kAppRegistered))
+    {
+        err = BluezGattsAppRegister(mpEndpoint);
+        mFlags.Set(Flags::kControlOpInProgress);
+        ExitNow();
+    }
+
+    // If the application has enabled CHIPoBLE and BLE advertising...
+    if (mServiceMode == ConnectivityManager::kCHIPoBLEServiceMode_Enabled && mFlags.Has(Flags::kAdvertisingEnabled))
+    {
+        // Start/re-start advertising if not already advertising, or if the advertising state of the
+        // Bluez BLE layer needs to be refreshed.
+        if (!mFlags.Has(Flags::kAdvertising) || mFlags.Has(Flags::kAdvertisingRefreshNeeded))
+        {
+            mFlags.Clear(Flags::kAdvertisingRefreshNeeded);
+
+            // Configure advertising data if it hasn't been done yet.  This is an asynchronous step which
+            // must complete before advertising can be started.  When that happens, this method will
+            // be called again, and execution will proceed to the code below.
+            if (!mFlags.Has(Flags::kAdvertisingConfigured))
+            {
+                err = BluezAdvertisementSetup(mpEndpoint);
+                ExitNow();
+            }
+
+            // Start advertising.  This is also an asynchronous step.
+            err = StartBLEAdvertising();
+            SuccessOrExit(err);
+
+            sInstance.mFlags.Set(Flags::kAdvertising);
+            ExitNow();
+        }
+    }
+
+    // Otherwise stop advertising if needed...
+    else
+    {
+        if (mFlags.Has(Flags::kAdvertising))
+        {
+            err = StopBLEAdvertising();
+            SuccessOrExit(err);
+            mFlags.Set(Flags::kControlOpInProgress);
+
+            ExitNow();
+        }
+    }
+
+exit:
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Disabling CHIPoBLE service due to error: %s", ErrorStr(err));
+        mServiceMode = ConnectivityManager::kCHIPoBLEServiceMode_Disabled;
+    }
+}
+
+void BLEManagerImpl::DriveBLEState(intptr_t arg)
+{
+    sInstance.DriveBLEState();
+}
+
+void BLEManagerImpl::NotifyChipConnectionClosed(BLE_CONNECTION_OBJECT conId)
+{
+    ChipLogProgress(Ble, "Got notification regarding chip connection closure");
+}
+
+void BLEManagerImpl::InitiateScan(BleScanState scanType)
+{
+    DriveBLEState();
+
+    if (scanType == BleScanState::kNotScanning)
+    {
+        BleConnectionDelegate::OnConnectionError(mBLEScanConfig.mAppState, CHIP_ERROR_INCORRECT_STATE);
+        ChipLogError(Ble, "Invalid scan type requested");
+        return;
+    }
+
+    if (mpEndpoint == nullptr)
+    {
+        BleConnectionDelegate::OnConnectionError(mBLEScanConfig.mAppState, CHIP_ERROR_INCORRECT_STATE);
+        ChipLogError(Ble, "BLE Layer is not yet initialized");
+        return;
+    }
+
+    if (mpEndpoint->mpAdapter == nullptr)
+    {
+        BleConnectionDelegate::OnConnectionError(mBLEScanConfig.mAppState, CHIP_ERROR_INCORRECT_STATE);
+        ChipLogError(Ble, "No adapter available for new connection establishment");
+        return;
+    }
+
+    mDeviceScanner               = Internal::ChipDeviceScanner::Create(mpEndpoint->mpAdapter, this);
+    mBLEScanConfig.mBleScanState = scanType;
+
+    if (!mDeviceScanner)
+    {
+        mBLEScanConfig.mBleScanState = BleScanState::kNotScanning;
+        BleConnectionDelegate::OnConnectionError(mBLEScanConfig.mAppState, CHIP_ERROR_INTERNAL);
+        ChipLogError(Ble, "Failed to create a BLE device scanner");
+        return;
+    }
+
+    CHIP_ERROR err = mDeviceScanner->StartScan(kNewConnectionScanTimeout);
+    if (err != CHIP_NO_ERROR)
+    {
+        mBLEScanConfig.mBleScanState = BleScanState::kNotScanning;
+        ChipLogError(Ble, "Failed to start a BLE can: %s", chip::ErrorStr(err));
+        BleConnectionDelegate::OnConnectionError(mBLEScanConfig.mAppState, err);
+        return;
+    }
+}
+
+void BLEManagerImpl::CleanScanConfig()
+{
+    if (mBLEScanConfig.mBleScanState == BleScanState::kConnecting)
+        DeviceLayer::SystemLayer().CancelTimer(HandleConnectTimeout, mpEndpoint);
+
+    mBLEScanConfig.mBleScanState = BleScanState::kNotScanning;
+}
+
+void BLEManagerImpl::InitiateScan(intptr_t arg)
+{
+    sInstance.InitiateScan(static_cast<BleScanState>(arg));
+}
+
+void BLEManagerImpl::NewConnection(BleLayer * bleLayer, void * appState, const uint16_t connDiscriminator)
+{
+    mBLEScanConfig.mDiscriminator = connDiscriminator;
+    mBLEScanConfig.mAppState      = appState;
+
+    // Scan initiation performed async, to ensure that the BLE subsystem is initialized.
+    PlatformMgr().ScheduleWork(InitiateScan, static_cast<intptr_t>(BleScanState::kScanForDiscriminator));
+}
+
+CHIP_ERROR BLEManagerImpl::CancelConnection()
+{
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+void BLEManagerImpl::NotifyBLEPeripheralRegisterAppComplete(bool aIsSuccess, void * apAppstate)
+{
+    ChipDeviceEvent event;
+    event.Type                                                 = DeviceEventType::kPlatformLinuxBLEPeripheralRegisterAppComplete;
+    event.Platform.BLEPeripheralRegisterAppComplete.mIsSuccess = aIsSuccess;
+    event.Platform.BLEPeripheralRegisterAppComplete.mpAppstate = apAppstate;
+    PlatformMgr().PostEventOrDie(&event);
+}
+
+void BLEManagerImpl::NotifyBLEPeripheralAdvConfiguredComplete(bool aIsSuccess, void * apAppstate)
+{
+    ChipDeviceEvent event;
+    event.Type = DeviceEventType::kPlatformLinuxBLEPeripheralAdvConfiguredComplete;
+    event.Platform.BLEPeripheralAdvConfiguredComplete.mIsSuccess = aIsSuccess;
+    event.Platform.BLEPeripheralAdvConfiguredComplete.mpAppstate = apAppstate;
+    PlatformMgr().PostEventOrDie(&event);
+}
+
+void BLEManagerImpl::NotifyBLEPeripheralAdvStartComplete(bool aIsSuccess, void * apAppstate)
+{
+    ChipDeviceEvent event;
+    event.Type                                              = DeviceEventType::kPlatformLinuxBLEPeripheralAdvStartComplete;
+    event.Platform.BLEPeripheralAdvStartComplete.mIsSuccess = aIsSuccess;
+    event.Platform.BLEPeripheralAdvStartComplete.mpAppstate = apAppstate;
+    PlatformMgr().PostEventOrDie(&event);
+}
+
+void BLEManagerImpl::NotifyBLEPeripheralAdvStopComplete(bool aIsSuccess, void * apAppstate)
+{
+    ChipDeviceEvent event;
+    event.Type                                             = DeviceEventType::kPlatformLinuxBLEPeripheralAdvStopComplete;
+    event.Platform.BLEPeripheralAdvStopComplete.mIsSuccess = aIsSuccess;
+    event.Platform.BLEPeripheralAdvStopComplete.mpAppstate = apAppstate;
+    PlatformMgr().PostEventOrDie(&event);
+}
+
+void BLEManagerImpl::OnDeviceScanned(BluezDevice1 * device, const chip::Ble::ChipBLEDeviceIdentificationInfo & info)
+{
+    ChipLogProgress(Ble, "New device scanned: %s", bluez_device1_get_address(device));
+
+    if (mBLEScanConfig.mBleScanState == BleScanState::kScanForDiscriminator)
+    {
+        if (info.GetDeviceDiscriminator() != mBLEScanConfig.mDiscriminator)
+        {
+            return;
+        }
+        ChipLogProgress(Ble, "Device discriminator match. Attempting to connect.");
+    }
+    else if (mBLEScanConfig.mBleScanState == BleScanState::kScanForAddress)
+    {
+        if (strcmp(bluez_device1_get_address(device), mBLEScanConfig.mAddress.c_str()) != 0)
+        {
+            return;
+        }
+        ChipLogProgress(Ble, "Device address match. Attempting to connect.");
+    }
+    else
+    {
+        // Internal consistency eerror
+        ChipLogError(Ble, "Unknown discovery type. Ignoring scanned device.");
+        return;
+    }
+
+    mBLEScanConfig.mBleScanState = BleScanState::kConnecting;
+    DeviceLayer::SystemLayer().StartTimer(kConnectTimeout, HandleConnectTimeout, mpEndpoint);
+    mDeviceScanner->StopScan();
+
+    ConnectDevice(device, mpEndpoint);
+}
+
+void BLEManagerImpl::OnScanComplete()
+{
+    if (mBLEScanConfig.mBleScanState != BleScanState::kScanForDiscriminator &&
+        mBLEScanConfig.mBleScanState != BleScanState::kScanForAddress)
+    {
+        ChipLogProgress(Ble, "Scan complete notification without an active scan.");
+        return;
+    }
+
+    BleConnectionDelegate::OnConnectionError(mBLEScanConfig.mAppState, CHIP_ERROR_TIMEOUT);
+    mBLEScanConfig.mBleScanState = BleScanState::kNotScanning;
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/BLEManagerImpl.h b/src/platform/webos/BLEManagerImpl.h
new file mode 100644
index 000000000..87a8f83f8
--- /dev/null
+++ b/src/platform/webos/BLEManagerImpl.h
@@ -0,0 +1,255 @@
+/*
+ *
+ *    Copyright (c) 2020-2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the BLEManager singleton object
+ *          for the Linux platforms.
+ */
+
+#pragma once
+
+#include <ble/BleLayer.h>
+#include <platform/internal/BLEManager.h>
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+#include "bluez/ChipDeviceScanner.h"
+#include "bluez/Types.h"
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+void HandleIncomingBleConnection(Ble::BLEEndPoint * bleEP);
+
+struct BLEAdvConfig
+{
+    char * mpBleName;
+    uint32_t mAdapterId;
+    uint8_t mMajor;
+    uint8_t mMinor;
+    uint16_t mVendorId;
+    uint16_t mProductId;
+    uint64_t mDeviceId;
+    uint8_t mPairingStatus;
+    ChipAdvType mType;
+    uint16_t mDuration;
+    const char * mpAdvertisingUUID;
+};
+
+enum class BleScanState : uint8_t
+{
+    kNotScanning,
+    kScanForDiscriminator,
+    kScanForAddress,
+    kConnecting,
+};
+
+struct BLEScanConfig
+{
+    // If an active scan for connection is being performed
+    BleScanState mBleScanState = BleScanState::kNotScanning;
+
+    // If scanning by discriminator, what are we scanning for
+    uint16_t mDiscriminator = 0;
+
+    // If scanning by address, what address are we searching for
+    std::string mAddress;
+
+    // Optional argument to be passed to callback functions provided by the BLE scan/connect requestor
+    void * mAppState = nullptr;
+};
+
+/**
+ * Concrete implementation of the BLEManagerImpl singleton object for the Linux platforms.
+ */
+class BLEManagerImpl final : public BLEManager,
+                             private Ble::BleLayer,
+                             private Ble::BlePlatformDelegate,
+                             private Ble::BleApplicationDelegate,
+                             private Ble::BleConnectionDelegate,
+                             private ChipDeviceScannerDelegate
+{
+    // Allow the BLEManager interface class to delegate method calls to
+    // the implementation methods provided by this class.
+    friend BLEManager;
+
+public:
+    CHIP_ERROR ConfigureBle(uint32_t aAdapterId, bool aIsCentral);
+
+    // Driven by BlueZ IO
+    static void HandleNewConnection(BLE_CONNECTION_OBJECT conId);
+    static void HandleConnectFailed(CHIP_ERROR error);
+    static void HandleWriteComplete(BLE_CONNECTION_OBJECT conId);
+    static void HandleSubscribeOpComplete(BLE_CONNECTION_OBJECT conId, bool subscribed);
+    static void HandleTXCharChanged(BLE_CONNECTION_OBJECT conId, const uint8_t * value, size_t len);
+    static void HandleRXCharWrite(BLE_CONNECTION_OBJECT user_data, const uint8_t * value, size_t len);
+    static void CHIPoBluez_ConnectionClosed(BLE_CONNECTION_OBJECT user_data);
+    static void HandleTXCharCCCDWrite(BLE_CONNECTION_OBJECT user_data);
+    static void HandleTXComplete(BLE_CONNECTION_OBJECT user_data);
+
+    static void NotifyBLEPeripheralRegisterAppComplete(bool aIsSuccess, void * apAppstate);
+    static void NotifyBLEPeripheralAdvConfiguredComplete(bool aIsSuccess, void * apAppstate);
+    static void NotifyBLEPeripheralAdvStartComplete(bool aIsSuccess, void * apAppstate);
+    static void NotifyBLEPeripheralAdvStopComplete(bool aIsSuccess, void * apAppstate);
+
+private:
+    // ===== Members that implement the BLEManager internal interface.
+
+    CHIP_ERROR _Init();
+    CHIP_ERROR _Shutdown();
+    CHIPoBLEServiceMode _GetCHIPoBLEServiceMode();
+    CHIP_ERROR _SetCHIPoBLEServiceMode(CHIPoBLEServiceMode val);
+    bool _IsAdvertisingEnabled();
+    CHIP_ERROR _SetAdvertisingEnabled(bool val);
+    bool _IsAdvertising();
+    CHIP_ERROR _SetAdvertisingMode(BLEAdvertisingMode mode);
+    CHIP_ERROR _GetDeviceName(char * buf, size_t bufSize);
+    CHIP_ERROR _SetDeviceName(const char * deviceName);
+    uint16_t _NumConnections();
+
+    void _OnPlatformEvent(const ChipDeviceEvent * event);
+    void HandlePlatformSpecificBLEEvent(const ChipDeviceEvent * event);
+    BleLayer * _GetBleLayer();
+
+    // ===== Members that implement virtual methods on BlePlatformDelegate.
+
+    bool SubscribeCharacteristic(BLE_CONNECTION_OBJECT conId, const Ble::ChipBleUUID * svcId,
+                                 const Ble::ChipBleUUID * charId) override;
+    bool UnsubscribeCharacteristic(BLE_CONNECTION_OBJECT conId, const Ble::ChipBleUUID * svcId,
+                                   const Ble::ChipBleUUID * charId) override;
+    bool CloseConnection(BLE_CONNECTION_OBJECT conId) override;
+    uint16_t GetMTU(BLE_CONNECTION_OBJECT conId) const override;
+    bool SendIndication(BLE_CONNECTION_OBJECT conId, const Ble::ChipBleUUID * svcId, const Ble::ChipBleUUID * charId,
+                        System::PacketBufferHandle pBuf) override;
+    bool SendWriteRequest(BLE_CONNECTION_OBJECT conId, const Ble::ChipBleUUID * svcId, const Ble::ChipBleUUID * charId,
+                          System::PacketBufferHandle pBuf) override;
+    bool SendReadRequest(BLE_CONNECTION_OBJECT conId, const Ble::ChipBleUUID * svcId, const Ble::ChipBleUUID * charId,
+                         System::PacketBufferHandle pBuf) override;
+    bool SendReadResponse(BLE_CONNECTION_OBJECT conId, BLE_READ_REQUEST_CONTEXT requestContext, const Ble::ChipBleUUID * svcId,
+                          const Ble::ChipBleUUID * charId) override;
+
+    // ===== Members that implement virtual methods on BleApplicationDelegate.
+
+    void NotifyChipConnectionClosed(BLE_CONNECTION_OBJECT conId) override;
+
+    // ===== Members that implement virtual methods on BleConnectionDelegate.
+
+    void NewConnection(BleLayer * bleLayer, void * appState, uint16_t connDiscriminator) override;
+    CHIP_ERROR CancelConnection() override;
+
+    // ===== Members that implement virtual methods on ChipDeviceScannerDelegate
+    void OnDeviceScanned(BluezDevice1 * device, const chip::Ble::ChipBLEDeviceIdentificationInfo & info) override;
+    void OnScanComplete() override;
+
+    // ===== Members for internal use by the following friends.
+
+    friend BLEManager & BLEMgr();
+    friend BLEManagerImpl & BLEMgrImpl();
+
+    static BLEManagerImpl sInstance;
+
+    // ===== Private members reserved for use by this class only.
+    enum class Flags : uint16_t
+    {
+        kAsyncInitCompleted       = 0x0001, /**< One-time asynchronous initialization actions have been performed. */
+        kBluezBLELayerInitialized = 0x0002, /**< The Bluez layer has been initialized. */
+        kAppRegistered            = 0x0004, /**< The CHIPoBLE application has been registered with the Bluez layer. */
+        kAdvertisingConfigured    = 0x0008, /**< CHIPoBLE advertising has been configured in the Bluez layer. */
+        kAdvertising              = 0x0010, /**< The system is currently CHIPoBLE advertising. */
+        kControlOpInProgress      = 0x0020, /**< An async control operation has been issued to the ESP BLE layer. */
+        kAdvertisingEnabled       = 0x0040, /**< The application has enabled CHIPoBLE advertising. */
+        kFastAdvertisingEnabled   = 0x0080, /**< The application has enabled fast advertising. */
+        kUseCustomDeviceName      = 0x0100, /**< The application has configured a custom BLE device name. */
+        kAdvertisingRefreshNeeded = 0x0200, /**< The advertising configuration/state in BLE layer needs to be updated. */
+    };
+
+    enum
+    {
+        kMaxConnections             = 1,  // TODO: right max connection
+        kMaxDeviceNameLength        = 20, // TODO: right-size this
+        kMaxAdvertismentDataSetSize = 31  // TODO: verify this
+    };
+
+    CHIP_ERROR StartBLEAdvertising();
+    CHIP_ERROR StopBLEAdvertising();
+
+    void DriveBLEState();
+    static void DriveBLEState(intptr_t arg);
+
+    void InitiateScan(BleScanState scanType);
+    static void InitiateScan(intptr_t arg);
+    void CleanScanConfig();
+
+    CHIPoBLEServiceMode mServiceMode;
+    BLEAdvConfig mBLEAdvConfig;
+    BLEScanConfig mBLEScanConfig;
+    BitFlags<Flags> mFlags;
+    char mDeviceName[kMaxDeviceNameLength + 1];
+    bool mIsCentral            = false;
+    BluezEndpoint * mpEndpoint = nullptr;
+    std::unique_ptr<ChipDeviceScanner> mDeviceScanner;
+};
+
+/**
+ * Returns a reference to the public interface of the BLEManager singleton object.
+ *
+ * Internal components should use this to access features of the BLEManager object
+ * that are common to all platforms.
+ */
+inline BLEManager & BLEMgr()
+{
+    return BLEManagerImpl::sInstance;
+}
+
+/**
+ * Returns the platform-specific implementation of the BLEManager singleton object.
+ *
+ * Internal components can use this to gain access to features of the BLEManager
+ * that are specific to the Linux platforms.
+ */
+inline BLEManagerImpl & BLEMgrImpl()
+{
+    return BLEManagerImpl::sInstance;
+}
+
+inline Ble::BleLayer * BLEManagerImpl::_GetBleLayer()
+{
+    return this;
+}
+
+inline BLEManager::CHIPoBLEServiceMode BLEManagerImpl::_GetCHIPoBLEServiceMode()
+{
+    return mServiceMode;
+}
+
+inline bool BLEManagerImpl::_IsAdvertisingEnabled()
+{
+    return mFlags.Has(Flags::kAdvertisingEnabled);
+}
+
+inline bool BLEManagerImpl::_IsAdvertising()
+{
+    return mFlags.Has(Flags::kAdvertising);
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/BUILD.gn b/src/platform/webos/BUILD.gn
new file mode 100644
index 000000000..570f2d4fd
--- /dev/null
+++ b/src/platform/webos/BUILD.gn
@@ -0,0 +1,136 @@
+# Copyright (c) 2021 Project CHIP Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build_overrides/build.gni")
+import("//build_overrides/chip.gni")
+
+import("${build_root}/config/linux/pkg_config.gni")
+
+import("${chip_root}/src/platform/device.gni")
+
+assert(chip_device_platform == "webos")
+
+declare_args() {
+  # Support syslog along instead of stdout(printf)
+  enable_syslog = true
+}
+
+if (chip_enable_openthread) {
+  import("//build_overrides/openthread.gni")
+  import("//build_overrides/ot_br_posix.gni")
+}
+
+if (chip_mdns != "none") {
+  pkg_config("avahi_client_config") {
+    packages = [ "avahi-client" ]
+  }
+}
+
+static_library("webos") {
+  if(enable_syslog) {
+    print("### enable syslog logging ###")
+    defines = [ "USE_SYSLOG=1" ]
+  }
+  sources = [
+    "../DeviceSafeQueue.cpp",
+    "../DeviceSafeQueue.h",
+    "../SingletonConfigurationManager.cpp",
+    "BLEManagerImpl.cpp",
+    "BLEManagerImpl.h",
+    "BlePlatformConfig.h",
+    "CHIPDevicePlatformConfig.h",
+    "CHIPDevicePlatformEvent.h",
+    "CHIPLinuxStorage.cpp",
+    "CHIPLinuxStorage.h",
+    "CHIPLinuxStorageIni.cpp",
+    "CHIPLinuxStorageIni.h",
+    "CHIPPlatformConfig.h",
+    "ConfigurationManagerImpl.cpp",
+    "ConfigurationManagerImpl.h",
+    "ConnectivityManagerImpl.cpp",
+    "ConnectivityManagerImpl.h",
+    "ConnectivityUtils.cpp",
+    "ConnectivityUtils.h",
+    "DeviceNetworkProvisioningDelegateImpl.cpp",
+    "DeviceNetworkProvisioningDelegateImpl.h",
+    "DiagnosticDataProviderImpl.cpp",
+    "DiagnosticDataProviderImpl.h",
+    "InetPlatformConfig.h",
+    "KeyValueStoreManagerImpl.cpp",
+    "KeyValueStoreManagerImpl.h",
+    "Logging.cpp",
+    "PlatformManagerImpl.cpp",
+    "PlatformManagerImpl.h",
+    "PosixConfig.cpp",
+    "PosixConfig.h",
+    "SystemPlatformConfig.h",
+    "SystemTimeSupport.cpp",
+    "bluez/AdapterIterator.cpp",
+    "bluez/AdapterIterator.h",
+    "bluez/ChipDeviceScanner.cpp",
+    "bluez/ChipDeviceScanner.h",
+    "bluez/Helper.cpp",
+    "bluez/Helper.h",
+    "bluez/MainLoop.cpp",
+    "bluez/MainLoop.h",
+    "bluez/Types.h",
+  ]
+
+  deps = [ "${chip_root}/src/setup_payload" ]
+
+  public_deps = [
+    "${chip_root}/src/platform:platform_base",
+    "${chip_root}/third_party/inipp",
+  ]
+
+  public_configs = []
+
+  if (chip_mdns != "none") {
+    sources += [
+      "DnssdImpl.cpp",
+      "DnssdImpl.h",
+    ]
+
+    deps += [ "${chip_root}/src/lib/dnssd:platform_header" ]
+
+    public_configs += [ ":avahi_client_config" ]
+  }
+
+  if (chip_enable_ota_requestor) {
+    sources += [
+      "OTAImageProcessorImpl.cpp",
+      "OTAImageProcessorImpl.h",
+      "OTARequestorDriverImpl.cpp",
+      "OTARequestorDriverImpl.h",
+    ]
+  }
+
+  if (chip_enable_openthread) {
+    sources += [
+      "GlibTypeDeleter.h",
+      "ThreadStackManagerImpl.cpp",
+      "ThreadStackManagerImpl.h",
+    ]
+
+    public_deps += [ "dbus/openthread" ]
+  }
+
+  if (chip_enable_wifi) {
+    public_deps += [ "dbus/wpa" ]
+  }
+
+  if (chip_enable_ble) {
+    public_deps += [ "dbus/bluez" ]
+  }
+}
diff --git a/src/platform/webos/BlePlatformConfig.h b/src/platform/webos/BlePlatformConfig.h
new file mode 100644
index 000000000..4c1ffd4e6
--- /dev/null
+++ b/src/platform/webos/BlePlatformConfig.h
@@ -0,0 +1,39 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Platform-specific configuration overrides for the CHIP BLE
+ *          Layer on Linux platforms.
+ *
+ */
+
+#pragma once
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+struct BluezConnection;
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+// ==================== Platform Adaptations ====================
+#define BLE_CONNECTION_UNINITIALIZED nullptr
+// ========== Platform-specific Configuration Overrides =========
+
+/* none so far */
diff --git a/src/platform/webos/CHIPDevicePlatformConfig.h b/src/platform/webos/CHIPDevicePlatformConfig.h
new file mode 100644
index 000000000..7c9a5d6be
--- /dev/null
+++ b/src/platform/webos/CHIPDevicePlatformConfig.h
@@ -0,0 +1,88 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Platform-specific configuration overrides for the chip Device Layer
+ *          on Linux platforms.
+ */
+
+#pragma once
+
+// ==================== Platform Adaptations ====================
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+#define CHIP_DEVICE_CONFIG_ENABLE_WIFI_STATION 1
+#define CHIP_DEVICE_CONFIG_ENABLE_WIFI_AP 0
+#else
+#define CHIP_DEVICE_CONFIG_ENABLE_WIFI_STATION 0
+#define CHIP_DEVICE_CONFIG_ENABLE_WIFI_AP 0
+#endif
+
+#ifndef CHIP_DEVICE_CONFIG_ENABLE_THREAD
+#define CHIP_DEVICE_CONFIG_ENABLE_THREAD CHIP_ENABLE_OPENTHREAD
+#endif
+
+#ifndef CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+#define CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE 0
+#endif
+
+#define CHIP_DEVICE_CONFIG_ENABLE_CHIP_TIME_SERVICE_TIME_SYNC 0
+
+#define CHIP_DEVICE_CONFIG_ENABLE_COMMISSIONABLE_DISCOVERY 1
+
+// ========== Platform-specific Configuration =========
+
+// These are configuration options that are unique to Linux platforms.
+// These can be overridden by the application as needed.
+
+/**
+ * @def CHIP_DEVICE_LAYER_BLE_OBSERVER_PRIORITY
+ *
+ * The priority of the SoftDevice observer event handler registered by the
+ * CHIP BleLayer.
+ */
+#ifndef CHIP_DEVICE_LAYER_BLE_OBSERVER_PRIORITY
+#define CHIP_DEVICE_LAYER_BLE_OBSERVER_PRIORITY 3
+#endif // CHIP_DEVICE_LAYER_BLE_OBSERVER_PRIORITY
+
+/**
+ * @def CHIP_DEVICE_LAYER_BLE_CONN_CFG_TAG
+ *
+ * The SoftDevice BLE connection configuration tag used by the CHIP
+ * BleLayer.
+ */
+#ifndef CHIP_DEVICE_LAYER_BLE_CONN_CFG_TAG
+#define CHIP_DEVICE_LAYER_BLE_CONN_CFG_TAG 1
+#endif // CHIP_DEVICE_LAYER_BLE_CONN_CFG_TAG
+
+// ========== Platform-specific Configuration Overrides =========
+
+#ifndef CHIP_DEVICE_CONFIG_CHIP_TASK_STACK_SIZE
+#define CHIP_DEVICE_CONFIG_CHIP_TASK_STACK_SIZE 8192
+#endif // CHIP_DEVICE_CONFIG_CHIP_TASK_STACK_SIZE
+
+#ifndef CHIP_DEVICE_CONFIG_THREAD_TASK_STACK_SIZE
+#define CHIP_DEVICE_CONFIG_THREAD_TASK_STACK_SIZE 8192
+#endif // CHIP_DEVICE_CONFIG_THREAD_TASK_STACK_SIZE
+
+#define CHIP_DEVICE_CONFIG_ENABLE_WIFI_TELEMETRY 0
+#define CHIP_DEVICE_CONFIG_ENABLE_THREAD_TELEMETRY 0
+#define CHIP_DEVICE_CONFIG_ENABLE_THREAD_TELEMETRY_FULL 0
+
+// TODO: CHIP has redesigned the crypto interface, pending on the final version of CHIP HASH APIs
+#define CHIP_DEVICE_CONFIG_LOG_PROVISIONING_HASH 0
diff --git a/src/platform/webos/CHIPDevicePlatformEvent.h b/src/platform/webos/CHIPDevicePlatformEvent.h
new file mode 100644
index 000000000..009f39148
--- /dev/null
+++ b/src/platform/webos/CHIPDevicePlatformEvent.h
@@ -0,0 +1,116 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Defines platform-specific event types and data for the chip
+ *          Device Layer on Linux platforms.
+ */
+
+#pragma once
+
+#include <platform/CHIPDeviceEvent.h>
+#include <system/SystemPacketBuffer.h>
+
+namespace chip {
+namespace DeviceLayer {
+
+namespace DeviceEventType {
+
+/**
+ * Enumerates Linux platform-specific event types that are visible to the application.
+ */
+enum PublicPlatformSpecificEventTypes
+{
+    /* None currently defined */
+};
+
+/**
+ * Enumerates Linux platform-specific event types that are internal to the chip Device Layer.
+ */
+enum InternalPlatformSpecificEventTypes
+{
+    kPlatformLinuxEvent = kRange_InternalPlatformSpecific,
+    kPlatformLinuxBLECentralConnected,
+    kPlatformLinuxBLECentralConnectFailed,
+    kPlatformLinuxBLEWriteComplete,
+    kPlatformLinuxBLESubscribeOpComplete,
+    kPlatformLinuxBLEIndicationReceived,
+    kPlatformLinuxBLEC1WriteEvent,
+    kPlatformLinuxBLEOutOfBuffersEvent,
+    kPlatformLinuxBLEPeripheralRegisterAppComplete,
+    kPlatformLinuxBLEPeripheralAdvConfiguredComplete,
+    kPlatformLinuxBLEPeripheralAdvStartComplete,
+    kPlatformLinuxBLEPeripheralAdvStopComplete
+};
+
+} // namespace DeviceEventType
+
+/**
+ * Represents platform-specific event information for Linux platforms.
+ */
+struct ChipDevicePlatformEvent
+{
+    union
+    {
+        struct
+        {
+            BLE_CONNECTION_OBJECT mConnection;
+        } BLECentralConnected;
+        struct
+        {
+            CHIP_ERROR mError;
+        } BLECentralConnectFailed;
+        struct
+        {
+            BLE_CONNECTION_OBJECT mConnection;
+        } BLEWriteComplete;
+        struct
+        {
+            BLE_CONNECTION_OBJECT mConnection;
+            bool mIsSubscribed;
+        } BLESubscribeOpComplete;
+        struct
+        {
+            BLE_CONNECTION_OBJECT mConnection;
+            chip::System::PacketBuffer * mData;
+        } BLEIndicationReceived;
+        struct
+        {
+            bool mIsSuccess;
+            void * mpAppstate;
+        } BLEPeripheralRegisterAppComplete;
+        struct
+        {
+            bool mIsSuccess;
+            void * mpAppstate;
+        } BLEPeripheralAdvConfiguredComplete;
+        struct
+        {
+            bool mIsSuccess;
+            void * mpAppstate;
+        } BLEPeripheralAdvStartComplete;
+        struct
+        {
+            bool mIsSuccess;
+            void * mpAppstate;
+        } BLEPeripheralAdvStopComplete;
+    };
+};
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/CHIPLinuxStorage.cpp b/src/platform/webos/CHIPLinuxStorage.cpp
new file mode 100644
index 000000000..9aab1a94a
--- /dev/null
+++ b/src/platform/webos/CHIPLinuxStorage.cpp
@@ -0,0 +1,321 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *         This file implements a class for managing client application
+ *         user-editable settings on Linux platform.
+ *
+ */
+
+#include <errno.h>
+#include <fstream>
+#include <inttypes.h>
+#include <libgen.h>
+#include <string>
+#include <unistd.h>
+
+#include <lib/support/Base64.h>
+#include <lib/support/CHIPMem.h>
+#include <lib/support/CodeUtils.h>
+#include <lib/support/ScopedBuffer.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <platform/webos/CHIPLinuxStorage.h>
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+ChipLinuxStorage::ChipLinuxStorage()
+{
+    mDirty = false;
+}
+
+ChipLinuxStorage::~ChipLinuxStorage() {}
+
+CHIP_ERROR ChipLinuxStorage::Init(const char * configFile)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    mConfigPath.assign(configFile);
+    retval = ChipLinuxStorageIni::Init();
+
+    if (retval == CHIP_NO_ERROR)
+    {
+        std::ifstream ifs;
+
+        ifs.open(configFile, std::ifstream::in);
+
+        // Create default setting file if not exist.
+        if (!ifs.good())
+        {
+            mDirty = true;
+            retval = Commit();
+            mDirty = false;
+        }
+    }
+
+    if (retval == CHIP_NO_ERROR)
+    {
+        retval = ChipLinuxStorageIni::AddConfig(mConfigPath);
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::ReadValue(const char * key, bool & val)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+    uint32_t result;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::GetUIntValue(key, result);
+    val    = (result != 0);
+
+    mLock.unlock();
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::ReadValue(const char * key, uint32_t & val)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::GetUIntValue(key, val);
+
+    mLock.unlock();
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::ReadValue(const char * key, uint64_t & val)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::GetUInt64Value(key, val);
+
+    mLock.unlock();
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::ReadValueStr(const char * key, char * buf, size_t bufSize, size_t & outLen)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::GetStringValue(key, buf, bufSize, outLen);
+
+    mLock.unlock();
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::ReadValueBin(const char * key, uint8_t * buf, size_t bufSize, size_t & outLen)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::GetBinaryBlobValue(key, buf, bufSize, outLen);
+
+    mLock.unlock();
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::WriteValue(const char * key, bool val)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    if (val)
+    {
+        retval = WriteValue(key, static_cast<uint32_t>(1));
+    }
+    else
+    {
+        retval = WriteValue(key, static_cast<uint32_t>(0));
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::WriteValue(const char * key, uint32_t val)
+{
+    char buf[32];
+
+    snprintf(buf, sizeof(buf), "%d", val);
+
+    return WriteValueStr(key, buf);
+}
+
+CHIP_ERROR ChipLinuxStorage::WriteValue(const char * key, uint64_t val)
+{
+    char buf[64];
+
+    snprintf(buf, sizeof(buf), "%" PRIu64, val);
+
+    return WriteValueStr(key, buf);
+}
+
+CHIP_ERROR ChipLinuxStorage::WriteValueStr(const char * key, const char * val)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::AddEntry(key, val);
+
+    mDirty = true;
+
+    mLock.unlock();
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::WriteValueBin(const char * key, const uint8_t * data, size_t dataLen)
+{
+    static const size_t kMaxBlobSize = 5 * 1024;
+
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+    chip::Platform::ScopedMemoryBuffer<char> encodedData;
+    size_t encodedDataLen     = 0;
+    size_t expectedEncodedLen = ((dataLen + 3) * 4) / 3;
+
+    // We only support encoding blobs up to 5kb
+    if (dataLen > kMaxBlobSize)
+    {
+        retval = CHIP_ERROR_INVALID_ARGUMENT;
+    }
+
+    // Compute our expectedEncodedLen
+    // Allocate just enough space for the encoded data, and the NULL terminator
+    if (retval == CHIP_NO_ERROR)
+    {
+        if (!encodedData.Alloc(expectedEncodedLen + 1))
+        {
+            retval = CHIP_ERROR_NO_MEMORY;
+        }
+    }
+
+    // Encode it
+    if (retval == CHIP_NO_ERROR)
+    {
+        // We tested above that dataLen is no more than kMaxBlobSize.
+        static_assert(kMaxBlobSize < UINT16_MAX, "dataLen won't fit");
+        encodedDataLen              = Base64Encode(data, static_cast<uint16_t>(dataLen), encodedData.Get());
+        encodedData[encodedDataLen] = 0;
+    }
+
+    // Store it
+    if (retval == CHIP_NO_ERROR)
+    {
+        WriteValueStr(key, encodedData.Get());
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::ClearValue(const char * key)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::RemoveEntry(key);
+
+    if (retval == CHIP_NO_ERROR)
+    {
+        mDirty = true;
+    }
+    else
+    {
+        retval = CHIP_ERROR_KEY_NOT_FOUND;
+    }
+
+    mLock.unlock();
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::ClearAll()
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::RemoveAll();
+
+    mLock.unlock();
+
+    if (retval == CHIP_NO_ERROR)
+    {
+        mDirty = true;
+        retval = Commit();
+    }
+    else
+    {
+        retval = CHIP_ERROR_WRITE_FAILED;
+    }
+
+    return retval;
+}
+
+bool ChipLinuxStorage::HasValue(const char * key)
+{
+    bool retval;
+
+    mLock.lock();
+
+    retval = ChipLinuxStorageIni::HasValue(key);
+
+    mLock.unlock();
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorage::Commit()
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    if (mDirty && !mConfigPath.empty())
+    {
+        mLock.lock();
+
+        retval = ChipLinuxStorageIni::CommitConfig(mConfigPath);
+
+        mLock.unlock();
+    }
+    else
+    {
+        retval = CHIP_ERROR_WRITE_FAILED;
+    }
+
+    return retval;
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/CHIPLinuxStorage.h b/src/platform/webos/CHIPLinuxStorage.h
new file mode 100644
index 000000000..145d90d19
--- /dev/null
+++ b/src/platform/webos/CHIPLinuxStorage.h
@@ -0,0 +1,95 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *         This file defines a class for managing client application
+ *         user-editable settings. CHIP settings are partitioned into two
+ *         distinct areas:
+ *
+ *         1. immutable / durable: factory parameters (CHIP_DEFAULT_FACTORY_PATH)
+ *         2. mutable / ephemeral: user parameters (CHIP_DEFAULT_CONFIG_PATH/CHIP_DEFAULT_DATA_PATH)
+ *
+ *         The ephemeral partition should be erased during factory reset.
+ *
+ *         ChipLinuxStorage wraps the storage class ChipLinuxStorageIni with mutex.
+ *
+ */
+
+#pragma once
+
+#include <mutex>
+#include <platform/webos/CHIPLinuxStorageIni.h>
+
+#ifndef FATCONFDIR
+#define FATCONFDIR "/tmp"
+#endif
+
+#ifndef SYSCONFDIR
+#define SYSCONFDIR "/tmp"
+#endif
+
+#ifndef LOCALSTATEDIR
+#define LOCALSTATEDIR "/tmp"
+#endif
+
+#define CHIP_DEFAULT_FACTORY_PATH                                                                                                  \
+    FATCONFDIR "/"                                                                                                                 \
+               "chip_factory.ini"
+#define CHIP_DEFAULT_CONFIG_PATH                                                                                                   \
+    SYSCONFDIR "/"                                                                                                                 \
+               "chip_config.ini"
+#define CHIP_DEFAULT_DATA_PATH                                                                                                     \
+    LOCALSTATEDIR "/"                                                                                                              \
+                  "chip_counters.ini"
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+class ChipLinuxStorage : private ChipLinuxStorageIni
+{
+public:
+    ChipLinuxStorage();
+    ~ChipLinuxStorage();
+
+    CHIP_ERROR Init(const char * configFile);
+    CHIP_ERROR ReadValue(const char * key, bool & val);
+    CHIP_ERROR ReadValue(const char * key, uint32_t & val);
+    CHIP_ERROR ReadValue(const char * key, uint64_t & val);
+    CHIP_ERROR ReadValueStr(const char * key, char * buf, size_t bufSize, size_t & outLen);
+    CHIP_ERROR ReadValueBin(const char * key, uint8_t * buf, size_t bufSize, size_t & outLen);
+    CHIP_ERROR WriteValue(const char * key, bool val);
+    CHIP_ERROR WriteValue(const char * key, uint32_t val);
+    CHIP_ERROR WriteValue(const char * key, uint64_t val);
+    CHIP_ERROR WriteValueStr(const char * key, const char * val);
+    CHIP_ERROR WriteValueBin(const char * key, const uint8_t * data, size_t dataLen);
+    CHIP_ERROR ClearValue(const char * key);
+    CHIP_ERROR ClearAll();
+    CHIP_ERROR Commit();
+    bool HasValue(const char * key);
+
+private:
+    std::mutex mLock;
+    bool mDirty;
+    std::string mConfigPath;
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/CHIPLinuxStorageIni.cpp b/src/platform/webos/CHIPLinuxStorageIni.cpp
new file mode 100644
index 000000000..8e68da269
--- /dev/null
+++ b/src/platform/webos/CHIPLinuxStorageIni.cpp
@@ -0,0 +1,366 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the Configuration key-value store object
+ *          using IniPP on Linux platform.
+ *
+ */
+
+#include <fstream>
+#include <string>
+#include <unistd.h>
+
+#include <lib/support/Base64.h>
+#include <lib/support/CHIPMem.h>
+#include <lib/support/CodeUtils.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <platform/webos/CHIPLinuxStorageIni.h>
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+CHIP_ERROR ChipLinuxStorageIni::Init()
+{
+    return RemoveAll();
+}
+
+CHIP_ERROR ChipLinuxStorageIni::GetDefaultSection(std::map<std::string, std::string> & section)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    auto it = mConfigStore.sections.find("DEFAULT");
+
+    if (it != mConfigStore.sections.end())
+    {
+        section = mConfigStore.sections["DEFAULT"];
+    }
+    else
+    {
+        retval = CHIP_ERROR_KEY_NOT_FOUND;
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorageIni::AddConfig(const std::string & configFile)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+    std::ifstream ifs;
+
+    ifs.open(configFile, std::ifstream::in);
+
+    if (ifs.is_open())
+    {
+        mConfigStore.parse(ifs);
+        ifs.close();
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "Failed to open config file: %s", configFile.c_str());
+        retval = CHIP_ERROR_OPEN_FAILED;
+    }
+
+    return retval;
+}
+
+// Updating a file atomically and durably on Linux requires:
+// 1. Writing to a temporary file
+// 2. Sync'ing the temp file to commit updated data
+// 3. Using rename() to overwrite the existing file
+CHIP_ERROR ChipLinuxStorageIni::CommitConfig(const std::string & configFile)
+{
+    CHIP_ERROR retval   = CHIP_NO_ERROR;
+    std::string tmpPath = configFile + "-XXXXXX";
+
+    int fd = mkstemp(&tmpPath[0]);
+    if (fd != -1)
+    {
+        std::ofstream ofs;
+
+        ChipLogProgress(DeviceLayer, "writing settings to file (%s)", tmpPath.c_str());
+
+        ofs.open(tmpPath, std::ofstream::out | std::ofstream::trunc);
+        mConfigStore.generate(ofs);
+
+        close(fd);
+
+        if (rename(tmpPath.c_str(), configFile.c_str()) == 0)
+        {
+            ChipLogError(DeviceLayer, "renamed tmp file to file (%s)", configFile.c_str());
+        }
+        else
+        {
+            ChipLogError(DeviceLayer, "failed to rename (%s), %s (%d)", tmpPath.c_str(), strerror(errno), errno);
+            retval = CHIP_ERROR_WRITE_FAILED;
+        }
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "failed to open file (%s) for writing", tmpPath.c_str());
+        retval = CHIP_ERROR_OPEN_FAILED;
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorageIni::GetUIntValue(const char * key, uint32_t & val)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+    std::map<std::string, std::string> section;
+
+    retval = GetDefaultSection(section);
+
+    if (retval == CHIP_NO_ERROR)
+    {
+        auto it = section.find(key);
+
+        if (it != section.end())
+        {
+            if (!inipp::extract(section[key], val))
+            {
+                retval = CHIP_ERROR_INVALID_ARGUMENT;
+            }
+        }
+        else
+        {
+            retval = CHIP_ERROR_KEY_NOT_FOUND;
+        }
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorageIni::GetUInt64Value(const char * key, uint64_t & val)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+    std::map<std::string, std::string> section;
+
+    retval = GetDefaultSection(section);
+
+    if (retval == CHIP_NO_ERROR)
+    {
+        auto it = section.find(key);
+
+        if (it != section.end())
+        {
+            if (!inipp::extract(section[key], val))
+            {
+                retval = CHIP_ERROR_INVALID_ARGUMENT;
+            }
+        }
+        else
+        {
+            retval = CHIP_ERROR_KEY_NOT_FOUND;
+        }
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorageIni::GetStringValue(const char * key, char * buf, size_t bufSize, size_t & outLen)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+    std::map<std::string, std::string> section;
+
+    retval = GetDefaultSection(section);
+
+    if (retval == CHIP_NO_ERROR)
+    {
+        auto it = section.find(key);
+
+        if (it != section.end())
+        {
+            std::string value;
+            if (inipp::extract(section[key], value))
+            {
+                size_t len = value.size();
+
+                if (len > bufSize - 1)
+                {
+                    outLen = len;
+                    retval = CHIP_ERROR_BUFFER_TOO_SMALL;
+                }
+                else
+                {
+                    outLen      = value.copy(buf, len);
+                    buf[outLen] = '\0';
+                }
+            }
+            else
+            {
+                retval = CHIP_ERROR_INVALID_ARGUMENT;
+            }
+        }
+        else
+        {
+            retval = CHIP_ERROR_KEY_NOT_FOUND;
+        }
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorageIni::GetBinaryBlobDataAndLengths(const char * key,
+                                                            chip::Platform::ScopedMemoryBuffer<char> & encodedData,
+                                                            size_t & encodedDataLen, size_t & decodedDataLen)
+{
+    size_t encodedDataPaddingLen = 0;
+    std::map<std::string, std::string> section;
+    CHIP_ERROR err = GetDefaultSection(section);
+    if (err != CHIP_NO_ERROR)
+    {
+        return err;
+    }
+
+    auto it = section.find(key);
+    if (it == section.end())
+    {
+        return CHIP_ERROR_KEY_NOT_FOUND;
+    }
+
+    std::string value;
+
+    // Compute the expectedDecodedLen
+    if (!inipp::extract(section[key], value))
+    {
+        return CHIP_ERROR_INVALID_ARGUMENT;
+    }
+
+    size_t len = value.size();
+    if (!encodedData.Alloc(len + 1))
+    {
+        return CHIP_ERROR_NO_MEMORY;
+    }
+    encodedDataLen              = value.copy(encodedData.Get(), len);
+    encodedData[encodedDataLen] = '\0';
+
+    // Check if encoded data was padded. Only "=" or "==" padding combinations are allowed.
+    if ((encodedDataLen > 0) && (encodedData[encodedDataLen - 1] == '='))
+    {
+        encodedDataPaddingLen++;
+        if ((encodedDataLen > 1) && (encodedData[encodedDataLen - 2] == '='))
+            encodedDataPaddingLen++;
+    }
+
+    decodedDataLen = ((encodedDataLen - encodedDataPaddingLen) * 3) / 4;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR ChipLinuxStorageIni::GetBinaryBlobValue(const char * key, uint8_t * decodedData, size_t bufSize, size_t & decodedDataLen)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+    chip::Platform::ScopedMemoryBuffer<char> encodedData;
+    size_t encodedDataLen;
+    size_t expectedDecodedLen = 0;
+
+    retval = GetBinaryBlobDataAndLengths(key, encodedData, encodedDataLen, expectedDecodedLen);
+
+    // Check the size
+    if (retval != CHIP_NO_ERROR)
+    {
+        return retval;
+    }
+
+    if (expectedDecodedLen > bufSize)
+    {
+        decodedDataLen = expectedDecodedLen;
+        return CHIP_ERROR_BUFFER_TOO_SMALL;
+    }
+
+    if (encodedDataLen > UINT16_MAX)
+    {
+        // We can't even pass this length into Base64Decode.
+        return CHIP_ERROR_DECODE_FAILED;
+    }
+
+    // Decode it
+    // Cast is safe because we checked encodedDataLen above.
+    decodedDataLen = Base64Decode(encodedData.Get(), static_cast<uint16_t>(encodedDataLen), decodedData);
+    if (decodedDataLen == UINT16_MAX || decodedDataLen > expectedDecodedLen)
+    {
+        return CHIP_ERROR_DECODE_FAILED;
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+bool ChipLinuxStorageIni::HasValue(const char * key)
+{
+    std::map<std::string, std::string> section;
+
+    if (GetDefaultSection(section) != CHIP_NO_ERROR)
+        return false;
+
+    auto it = section.find(key);
+
+    return it != section.end();
+}
+
+CHIP_ERROR ChipLinuxStorageIni::AddEntry(const char * key, const char * value)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    if ((key != nullptr) && (value != nullptr))
+    {
+        std::map<std::string, std::string> & section = mConfigStore.sections["DEFAULT"];
+        section[key]                                 = std::string(value);
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "Invalid input argument, failed to add entry");
+        retval = CHIP_ERROR_INVALID_ARGUMENT;
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorageIni::RemoveEntry(const char * key)
+{
+    CHIP_ERROR retval = CHIP_NO_ERROR;
+
+    std::map<std::string, std::string> & section = mConfigStore.sections["DEFAULT"];
+
+    auto it = section.find(key);
+
+    if (it != section.end())
+    {
+        section.erase(it);
+    }
+    else
+    {
+        retval = CHIP_ERROR_KEY_NOT_FOUND;
+    }
+
+    return retval;
+}
+
+CHIP_ERROR ChipLinuxStorageIni::RemoveAll()
+{
+    mConfigStore.clear();
+
+    return CHIP_NO_ERROR;
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/CHIPLinuxStorageIni.h b/src/platform/webos/CHIPLinuxStorageIni.h
new file mode 100644
index 000000000..a2de7cd04
--- /dev/null
+++ b/src/platform/webos/CHIPLinuxStorageIni.h
@@ -0,0 +1,62 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the Configuration key-value store interface
+ *          using IniPP.
+ *
+ */
+
+#pragma once
+
+#include <inipp/inipp.h>
+#include <lib/support/ScopedBuffer.h>
+#include <platform/PersistedStorage.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+class ChipLinuxStorageIni
+{
+public:
+    CHIP_ERROR Init();
+    CHIP_ERROR AddConfig(const std::string & configFile);
+    CHIP_ERROR CommitConfig(const std::string & configFile);
+    CHIP_ERROR GetUIntValue(const char * key, uint32_t & val);
+    CHIP_ERROR GetUInt64Value(const char * key, uint64_t & val);
+    CHIP_ERROR GetStringValue(const char * key, char * buf, size_t bufSize, size_t & outLen);
+    CHIP_ERROR GetBinaryBlobValue(const char * key, uint8_t * decodedData, size_t bufSize, size_t & decodedDataLen);
+    bool HasValue(const char * key);
+
+protected:
+    CHIP_ERROR AddEntry(const char * key, const char * value);
+    CHIP_ERROR RemoveEntry(const char * key);
+    CHIP_ERROR RemoveAll();
+
+private:
+    CHIP_ERROR GetDefaultSection(std::map<std::string, std::string> & section);
+    CHIP_ERROR GetBinaryBlobDataAndLengths(const char * key, chip::Platform::ScopedMemoryBuffer<char> & encodedData,
+                                           size_t & encodedDataLen, size_t & decodedDataLen);
+    inipp::Ini<char> mConfigStore;
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/CHIPPlatformConfig.h b/src/platform/webos/CHIPPlatformConfig.h
new file mode 100644
index 000000000..fa8cf092f
--- /dev/null
+++ b/src/platform/webos/CHIPPlatformConfig.h
@@ -0,0 +1,125 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Platform-specific configuration overrides for CHIP on
+ *          Linux platforms.
+ */
+
+#pragma once
+
+// ==================== General Platform Adaptations ====================
+
+#define ChipDie() abort()
+
+// TODO:(#756) Add FabricState support
+#define CHIP_CONFIG_ENABLE_FABRIC_STATE 0
+
+using CHIP_CONFIG_PERSISTED_STORAGE_KEY_TYPE = const char *;
+#define CHIP_CONFIG_PERSISTED_STORAGE_MAX_KEY_LENGTH 16
+
+#define CHIP_CONFIG_LIFETIIME_PERSISTED_COUNTER_KEY "life-count"
+
+#define CHIP_CONFIG_TIME_ENABLE_CLIENT 1
+#define CHIP_CONFIG_TIME_ENABLE_SERVER 0
+
+#define CHIP_CONFIG_ERROR_FORMAT_AS_STRING 1
+#define CHIP_CONFIG_ERROR_SOURCE 1
+
+#define CHIP_CONFIG_VERBOSE_VERIFY_OR_DIE 1
+
+// ==================== Security Adaptations ====================
+
+#define CHIP_CONFIG_USE_OPENSSL_ECC 0
+#define CHIP_CONFIG_USE_MICRO_ECC 0
+
+#define CHIP_CONFIG_HASH_IMPLEMENTATION_OPENSSL 0
+#define CHIP_CONFIG_HASH_IMPLEMENTATION_MINCRYPT 1
+#define CHIP_CONFIG_HASH_IMPLEMENTATION_MBEDTLS 0
+#define CHIP_CONFIG_HASH_IMPLEMENTATION_PLATFORM 0
+
+#define CHIP_CONFIG_AES_IMPLEMENTATION_OPENSSL 0
+#define CHIP_CONFIG_AES_IMPLEMENTATION_AESNI 0
+#define CHIP_CONFIG_AES_IMPLEMENTATION_MBEDTLS 1
+#define CHIP_CONFIG_AES_IMPLEMENTATION_PLATFORM 0
+
+#define CHIP_CONFIG_RNG_IMPLEMENTATION_OPENSSL 0
+#define CHIP_CONFIG_RNG_IMPLEMENTATION_CHIPDRBG 1
+#define CHIP_CONFIG_RNG_IMPLEMENTATION_PLATFORM 0
+
+#define CHIP_CONFIG_ENABLE_PASE_INITIATOR 0
+#define CHIP_CONFIG_ENABLE_PASE_RESPONDER 1
+#define CHIP_CONFIG_ENABLE_CASE_INITIATOR 1
+
+#define CHIP_CONFIG_SUPPORT_PASE_CONFIG0 0
+#define CHIP_CONFIG_SUPPORT_PASE_CONFIG1 0
+#define CHIP_CONFIG_SUPPORT_PASE_CONFIG2 0
+#define CHIP_CONFIG_SUPPORT_PASE_CONFIG3 0
+#define CHIP_CONFIG_SUPPORT_PASE_CONFIG4 1
+
+#define CHIP_CONFIG_ENABLE_KEY_EXPORT_INITIATOR 0
+
+#define CHIP_CONFIG_ENABLE_PROVISIONING_BUNDLE_SUPPORT 0
+
+// ==================== General Configuration Overrides ====================
+
+#ifndef CHIP_CONFIG_MAX_PEER_NODES
+#define CHIP_CONFIG_MAX_PEER_NODES 16
+#endif // CHIP_CONFIG_MAX_PEER_NODES
+
+#ifndef CHIP_CONFIG_MAX_UNSOLICITED_MESSAGE_HANDLERS
+#define CHIP_CONFIG_MAX_UNSOLICITED_MESSAGE_HANDLERS 8
+#endif // CHIP_CONFIG_MAX_UNSOLICITED_MESSAGE_HANDLERS
+
+#ifndef CHIP_CONFIG_MAX_EXCHANGE_CONTEXTS
+#define CHIP_CONFIG_MAX_EXCHANGE_CONTEXTS 8
+#endif // CHIP_CONFIG_MAX_EXCHANGE_CONTEXTS
+
+#ifndef CHIP_CONFIG_MAX_ACTIVE_CHANNELS
+#define CHIP_CONFIG_MAX_ACTIVE_CHANNELS 16
+#endif // CHIP_CONFIG_MAX_ACTIVE_CHANNELS
+
+#ifndef CHIP_CONFIG_MAX_CHANNEL_HANDLES
+#define CHIP_CONFIG_MAX_CHANNEL_HANDLES 32
+#endif // CHIP_CONFIG_MAX_CHANNEL_HANDLES
+
+#ifndef CHIP_LOG_FILTERING
+#define CHIP_LOG_FILTERING 0
+#endif // CHIP_LOG_FILTERING
+
+#ifndef CHIP_CONFIG_BDX_MAX_NUM_TRANSFERS
+#define CHIP_CONFIG_BDX_MAX_NUM_TRANSFERS 1
+#endif // CHIP_CONFIG_BDX_MAX_NUM_TRANSFERS
+
+// ==================== Security Configuration Overrides ====================
+
+#ifndef CHIP_CONFIG_MAX_APPLICATION_GROUPS
+#define CHIP_CONFIG_MAX_APPLICATION_GROUPS 4
+#endif // CHIP_CONFIG_MAX_APPLICATION_GROUPS
+
+#ifndef CHIP_CONFIG_DEBUG_CERT_VALIDATION
+#define CHIP_CONFIG_DEBUG_CERT_VALIDATION 0
+#endif // CHIP_CONFIG_DEBUG_CERT_VALIDATION
+
+#ifndef CHIP_CONFIG_ENABLE_CASE_RESPONDER
+#define CHIP_CONFIG_ENABLE_CASE_RESPONDER 1
+#endif // CHIP_CONFIG_ENABLE_CASE_RESPONDER
+
+#ifndef CHIP_CONFIG_KVS_PATH
+#define CHIP_CONFIG_KVS_PATH "/tmp/chip_kvs"
+#endif // CHIP_CONFIG_KVS_PATH
diff --git a/src/platform/webos/ConfigurationManagerImpl.cpp b/src/platform/webos/ConfigurationManagerImpl.cpp
new file mode 100644
index 000000000..7b8562942
--- /dev/null
+++ b/src/platform/webos/ConfigurationManagerImpl.cpp
@@ -0,0 +1,369 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    Copyright (c) 2018 Nest Labs, Inc.
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides the implementation of the Device Layer ConfigurationManager object
+ *          for Linux platforms.
+ */
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+#include <app-common/zap-generated/enums.h>
+#include <ifaddrs.h>
+#include <lib/core/CHIPVendorIdentifiers.hpp>
+#include <lib/support/CodeUtils.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <netpacket/packet.h>
+#include <platform/ConfigurationManager.h>
+#include <platform/DiagnosticDataProvider.h>
+#include <platform/webos/PosixConfig.h>
+#include <platform/internal/GenericConfigurationManagerImpl.cpp>
+
+namespace chip {
+namespace DeviceLayer {
+
+using namespace ::chip::DeviceLayer::Internal;
+
+ConfigurationManagerImpl & ConfigurationManagerImpl::GetDefaultInstance()
+{
+    static ConfigurationManagerImpl sInstance;
+    return sInstance;
+}
+
+CHIP_ERROR ConfigurationManagerImpl::Init()
+{
+    CHIP_ERROR err;
+    uint32_t rebootCount;
+    bool failSafeArmed;
+
+    // Force initialization of NVS namespaces if they doesn't already exist.
+    err = PosixConfig::EnsureNamespace(PosixConfig::kConfigNamespace_ChipFactory);
+    SuccessOrExit(err);
+    err = PosixConfig::EnsureNamespace(PosixConfig::kConfigNamespace_ChipConfig);
+    SuccessOrExit(err);
+    err = PosixConfig::EnsureNamespace(PosixConfig::kConfigNamespace_ChipCounters);
+    SuccessOrExit(err);
+
+    // Initialize the generic implementation base class.
+    err = Internal::GenericConfigurationManagerImpl<PosixConfig>::Init();
+    SuccessOrExit(err);
+
+    if (PosixConfig::ConfigValueExists(PosixConfig::kCounterKey_RebootCount))
+    {
+        err = GetRebootCount(rebootCount);
+        SuccessOrExit(err);
+
+        err = StoreRebootCount(rebootCount + 1);
+        SuccessOrExit(err);
+    }
+    else
+    {
+        // The first boot after factory reset of the Node.
+        err = StoreRebootCount(1);
+        SuccessOrExit(err);
+    }
+
+    if (!PosixConfig::ConfigValueExists(PosixConfig::kCounterKey_TotalOperationalHours))
+    {
+        err = StoreTotalOperationalHours(0);
+        SuccessOrExit(err);
+    }
+
+    if (!PosixConfig::ConfigValueExists(PosixConfig::kCounterKey_BootReason))
+    {
+        err = StoreBootReason(DiagnosticDataProvider::BootReasonType::Unspecified);
+        SuccessOrExit(err);
+    }
+
+    if (!PosixConfig::ConfigValueExists(PosixConfig::kConfigKey_RegulatoryLocation))
+    {
+        uint32_t location = EMBER_ZCL_REGULATORY_LOCATION_TYPE_INDOOR;
+        err               = WriteConfigValue(PosixConfig::kConfigKey_RegulatoryLocation, location);
+        SuccessOrExit(err);
+    }
+
+    if (!PosixConfig::ConfigValueExists(PosixConfig::kConfigKey_LocationCapability))
+    {
+        uint32_t location = EMBER_ZCL_REGULATORY_LOCATION_TYPE_INDOOR;
+        err               = WriteConfigValue(PosixConfig::kConfigKey_LocationCapability, location);
+        SuccessOrExit(err);
+    }
+
+    // If the fail-safe was armed when the device last shutdown, initiate a factory reset.
+    if (GetFailSafeArmed(failSafeArmed) == CHIP_NO_ERROR && failSafeArmed)
+    {
+        ChipLogProgress(DeviceLayer, "Detected fail-safe armed on reboot; initiating factory reset");
+        InitiateFactoryReset();
+    }
+
+    err = CHIP_NO_ERROR;
+
+exit:
+    return err;
+}
+
+CHIP_ERROR ConfigurationManagerImpl::GetPrimaryWiFiMACAddress(uint8_t * buf)
+{
+    struct ifaddrs * addresses = NULL;
+    CHIP_ERROR error           = CHIP_NO_ERROR;
+    bool found                 = false;
+
+    VerifyOrExit(getifaddrs(&addresses) == 0, error = CHIP_ERROR_INTERNAL);
+    for (auto addr = addresses; addr != NULL; addr = addr->ifa_next)
+    {
+        if ((addr->ifa_addr) && (addr->ifa_addr->sa_family == AF_PACKET) && strncmp(addr->ifa_name, "lo", IFNAMSIZ) != 0)
+        {
+            struct sockaddr_ll * mac = (struct sockaddr_ll *) addr->ifa_addr;
+            memcpy(buf, mac->sll_addr, mac->sll_halen);
+            found = true;
+            break;
+        }
+    }
+    freeifaddrs(addresses);
+    if (!found)
+    {
+        error = CHIP_ERROR_NO_ENDPOINT;
+    }
+
+exit:
+    return error;
+}
+
+bool ConfigurationManagerImpl::CanFactoryReset()
+{
+    // TODO(#742): query the application to determine if factory reset is allowed.
+    return true;
+}
+
+void ConfigurationManagerImpl::InitiateFactoryReset()
+{
+    PlatformMgr().ScheduleWork(DoFactoryReset);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::ReadPersistedStorageValue(::chip::Platform::PersistedStorage::Key key, uint32_t & value)
+{
+    PosixConfig::Key configKey{ PosixConfig::kConfigNamespace_ChipCounters, key };
+
+    CHIP_ERROR err = ReadConfigValue(configKey, value);
+    if (err == CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND)
+    {
+        err = CHIP_ERROR_PERSISTED_STORAGE_VALUE_NOT_FOUND;
+    }
+    return err;
+}
+
+CHIP_ERROR ConfigurationManagerImpl::WritePersistedStorageValue(::chip::Platform::PersistedStorage::Key key, uint32_t value)
+{
+    PosixConfig::Key configKey{ PosixConfig::kConfigNamespace_ChipCounters, key };
+    return WriteConfigValue(configKey, value);
+}
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI_STATION
+CHIP_ERROR ConfigurationManagerImpl::GetWiFiStationSecurityType(WiFiAuthSecurityType & secType)
+{
+    CHIP_ERROR err;
+    uint32_t secTypeInt;
+
+    err = ReadConfigValue(PosixConfig::kConfigKey_WiFiStationSecType, secTypeInt);
+    if (err == CHIP_NO_ERROR)
+    {
+        secType = static_cast<WiFiAuthSecurityType>(secTypeInt);
+    }
+    return err;
+}
+
+CHIP_ERROR ConfigurationManagerImpl::UpdateWiFiStationSecurityType(WiFiAuthSecurityType secType)
+{
+    CHIP_ERROR err;
+    WiFiAuthSecurityType curSecType;
+
+    if (secType != kWiFiSecurityType_NotSpecified)
+    {
+        err = GetWiFiStationSecurityType(curSecType);
+        if (err == CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND || (err == CHIP_NO_ERROR && secType != curSecType))
+        {
+            uint32_t secTypeInt = static_cast<uint32_t>(secType);
+            err                 = WriteConfigValue(PosixConfig::kConfigKey_WiFiStationSecType, secTypeInt);
+        }
+        SuccessOrExit(err);
+    }
+    else
+    {
+        err = PosixConfig::ClearConfigValue(PosixConfig::kConfigKey_WiFiStationSecType);
+        SuccessOrExit(err);
+    }
+
+exit:
+    return err;
+}
+#endif // CHIP_DEVICE_CONFIG_ENABLE_WIFI_STATION
+
+CHIP_ERROR ConfigurationManagerImpl::ReadConfigValue(Key key, bool & val)
+{
+    return PosixConfig::ReadConfigValue(key, val);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::ReadConfigValue(Key key, uint32_t & val)
+{
+    return PosixConfig::ReadConfigValue(key, val);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::ReadConfigValue(Key key, uint64_t & val)
+{
+    return PosixConfig::ReadConfigValue(key, val);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::ReadConfigValueStr(Key key, char * buf, size_t bufSize, size_t & outLen)
+{
+    return PosixConfig::ReadConfigValueStr(key, buf, bufSize, outLen);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::ReadConfigValueBin(Key key, uint8_t * buf, size_t bufSize, size_t & outLen)
+{
+    return PosixConfig::ReadConfigValueBin(key, buf, bufSize, outLen);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::WriteConfigValue(Key key, bool val)
+{
+    return PosixConfig::WriteConfigValue(key, val);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::WriteConfigValue(Key key, uint32_t val)
+{
+    return PosixConfig::WriteConfigValue(key, val);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::WriteConfigValue(Key key, uint64_t val)
+{
+    return PosixConfig::WriteConfigValue(key, val);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::WriteConfigValueStr(Key key, const char * str)
+{
+    return PosixConfig::WriteConfigValueStr(key, str);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::WriteConfigValueStr(Key key, const char * str, size_t strLen)
+{
+    return PosixConfig::WriteConfigValueStr(key, str, strLen);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::WriteConfigValueBin(Key key, const uint8_t * data, size_t dataLen)
+{
+    return PosixConfig::WriteConfigValueBin(key, data, dataLen);
+}
+
+void ConfigurationManagerImpl::RunConfigUnitTest(void)
+{
+    PosixConfig::RunConfigUnitTest();
+}
+
+void ConfigurationManagerImpl::DoFactoryReset(intptr_t arg)
+{
+    CHIP_ERROR err;
+
+    ChipLogProgress(DeviceLayer, "Performing factory reset");
+
+    err = PosixConfig::FactoryResetConfig();
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Failed to factory reset configurations: %s", ErrorStr(err));
+    }
+
+    err = PosixConfig::FactoryResetCounters();
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Failed to factory reset counters: %s", ErrorStr(err));
+    }
+
+#if CHIP_DEVICE_CONFIG_ENABLE_THREAD
+
+    ChipLogProgress(DeviceLayer, "Clearing Thread provision");
+    ThreadStackMgr().ErasePersistentInfo();
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_THREAD
+
+    // Restart the system.
+    ChipLogProgress(DeviceLayer, "System restarting (not implemented)");
+    // TODO(#742): restart CHIP exe
+}
+
+CHIP_ERROR ConfigurationManagerImpl::GetRebootCount(uint32_t & rebootCount)
+{
+    return ReadConfigValue(PosixConfig::kCounterKey_RebootCount, rebootCount);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::StoreRebootCount(uint32_t rebootCount)
+{
+    return WriteConfigValue(PosixConfig::kCounterKey_RebootCount, rebootCount);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::GetTotalOperationalHours(uint32_t & totalOperationalHours)
+{
+    return ReadConfigValue(PosixConfig::kCounterKey_TotalOperationalHours, totalOperationalHours);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::StoreTotalOperationalHours(uint32_t totalOperationalHours)
+{
+    return WriteConfigValue(PosixConfig::kCounterKey_TotalOperationalHours, totalOperationalHours);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::GetBootReason(uint32_t & bootReason)
+{
+    return ReadConfigValue(PosixConfig::kCounterKey_BootReason, bootReason);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::StoreBootReason(uint32_t bootReason)
+{
+    return WriteConfigValue(PosixConfig::kCounterKey_BootReason, bootReason);
+}
+
+CHIP_ERROR ConfigurationManagerImpl::GetRegulatoryLocation(uint8_t & location)
+{
+    uint32_t value = 0;
+
+    CHIP_ERROR err = ReadConfigValue(PosixConfig::kConfigKey_RegulatoryLocation, value);
+
+    if (err == CHIP_NO_ERROR)
+    {
+        VerifyOrReturnError(value <= UINT8_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+        location = static_cast<uint8_t>(value);
+    }
+
+    return err;
+}
+
+CHIP_ERROR ConfigurationManagerImpl::GetLocationCapability(uint8_t & location)
+{
+    uint32_t value = 0;
+
+    CHIP_ERROR err = ReadConfigValue(PosixConfig::kConfigKey_LocationCapability, value);
+
+    if (err == CHIP_NO_ERROR)
+    {
+        VerifyOrReturnError(value <= UINT8_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+        location = static_cast<uint8_t>(value);
+    }
+
+    return err;
+}
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/ConfigurationManagerImpl.h b/src/platform/webos/ConfigurationManagerImpl.h
new file mode 100644
index 000000000..6a393428f
--- /dev/null
+++ b/src/platform/webos/ConfigurationManagerImpl.h
@@ -0,0 +1,87 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the ConfigurationManager object
+ *          for Linux platforms.
+ */
+
+#pragma once
+
+#include "platform/internal/DeviceNetworkInfo.h"
+#include <platform/internal/GenericConfigurationManagerImpl.h>
+
+#include <platform/webos/PosixConfig.h>
+
+namespace chip {
+namespace DeviceLayer {
+
+/**
+ * Concrete implementation of the ConfigurationManager singleton object for the Linux platform.
+ */
+class ConfigurationManagerImpl : public Internal::GenericConfigurationManagerImpl<Internal::PosixConfig>
+{
+public:
+    CHIP_ERROR GetRebootCount(uint32_t & rebootCount) override;
+    CHIP_ERROR StoreRebootCount(uint32_t rebootCount) override;
+    CHIP_ERROR GetTotalOperationalHours(uint32_t & totalOperationalHours) override;
+    CHIP_ERROR StoreTotalOperationalHours(uint32_t totalOperationalHours) override;
+    CHIP_ERROR GetBootReason(uint32_t & bootReason) override;
+    CHIP_ERROR StoreBootReason(uint32_t bootReason) override;
+    CHIP_ERROR GetRegulatoryLocation(uint8_t & location) override;
+    CHIP_ERROR GetLocationCapability(uint8_t & location) override;
+    static ConfigurationManagerImpl & GetDefaultInstance();
+
+private:
+    // ===== Members that implement the ConfigurationManager public interface.
+
+    CHIP_ERROR Init() override;
+    CHIP_ERROR GetPrimaryWiFiMACAddress(uint8_t * buf) override;
+    bool CanFactoryReset() override;
+    void InitiateFactoryReset() override;
+    CHIP_ERROR ReadPersistedStorageValue(::chip::Platform::PersistedStorage::Key key, uint32_t & value) override;
+    CHIP_ERROR WritePersistedStorageValue(::chip::Platform::PersistedStorage::Key key, uint32_t value) override;
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI_STATION
+    CHIP_ERROR GetWiFiStationSecurityType(Internal::WiFiAuthSecurityType & secType);
+    CHIP_ERROR UpdateWiFiStationSecurityType(Internal::WiFiAuthSecurityType secType);
+#endif
+
+    // NOTE: Other public interface methods are implemented by GenericConfigurationManagerImpl<>.
+
+    // ===== Members that implement the GenericConfigurationManagerImpl protected interface.
+    CHIP_ERROR ReadConfigValue(Key key, bool & val) override;
+    CHIP_ERROR ReadConfigValue(Key key, uint32_t & val) override;
+    CHIP_ERROR ReadConfigValue(Key key, uint64_t & val) override;
+    CHIP_ERROR ReadConfigValueStr(Key key, char * buf, size_t bufSize, size_t & outLen) override;
+    CHIP_ERROR ReadConfigValueBin(Key key, uint8_t * buf, size_t bufSize, size_t & outLen) override;
+    CHIP_ERROR WriteConfigValue(Key key, bool val) override;
+    CHIP_ERROR WriteConfigValue(Key key, uint32_t val) override;
+    CHIP_ERROR WriteConfigValue(Key key, uint64_t val) override;
+    CHIP_ERROR WriteConfigValueStr(Key key, const char * str) override;
+    CHIP_ERROR WriteConfigValueStr(Key key, const char * str, size_t strLen) override;
+    CHIP_ERROR WriteConfigValueBin(Key key, const uint8_t * data, size_t dataLen) override;
+    void RunConfigUnitTest(void) override;
+
+    // ===== Private members reserved for use by this class only.
+
+    static void DoFactoryReset(intptr_t arg);
+};
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/ConnectivityManagerImpl.cpp b/src/platform/webos/ConnectivityManagerImpl.cpp
new file mode 100644
index 000000000..4ddda19e9
--- /dev/null
+++ b/src/platform/webos/ConnectivityManagerImpl.cpp
@@ -0,0 +1,1116 @@
+/*
+ *
+ *    Copyright (c) 2020-2021 Project CHIP Authors
+ *    Copyright (c) 2019 Nest Labs, Inc.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+#include <platform/ConnectivityManager.h>
+#include <platform/DiagnosticDataProvider.h>
+#include <platform/webos/ConnectivityUtils.h>
+#include <platform/webos/DiagnosticDataProviderImpl.h>
+#include <platform/webos/WirelessDefs.h>
+#include <platform/internal/BLEManager.h>
+
+#include <cstdlib>
+#include <new>
+
+#include <ifaddrs.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+
+#include <lib/support/CodeUtils.h>
+#include <lib/support/logging/CHIPLogging.h>
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+#include <platform/internal/GenericConnectivityManagerImpl_BLE.cpp>
+#endif
+
+#if CHIP_DEVICE_CONFIG_ENABLE_THREAD
+#include <platform/internal/GenericConnectivityManagerImpl_Thread.cpp>
+#endif
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+#include <platform/internal/GenericConnectivityManagerImpl_WiFi.cpp>
+#endif
+
+#ifndef CHIP_DEVICE_CONFIG_LINUX_DHCPC_CMD
+#define CHIP_DEVICE_CONFIG_LINUX_DHCPC_CMD "dhclient -nw %s"
+#endif
+
+using namespace ::chip;
+using namespace ::chip::TLV;
+using namespace ::chip::DeviceLayer;
+using namespace ::chip::DeviceLayer::Internal;
+using namespace ::chip::app::Clusters::GeneralDiagnostics;
+using namespace ::chip::app::Clusters::WiFiNetworkDiagnostics;
+
+namespace chip {
+namespace DeviceLayer {
+
+ConnectivityManagerImpl ConnectivityManagerImpl::sInstance;
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+char ConnectivityManagerImpl::sWiFiIfName[];
+#endif
+
+CHIP_ERROR ConnectivityManagerImpl::_Init()
+{
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+    mWiFiStationMode              = kWiFiStationMode_Disabled;
+    mWiFiStationReconnectInterval = System::Clock::Milliseconds32(CHIP_DEVICE_CONFIG_WIFI_STATION_RECONNECT_INTERVAL);
+#endif
+
+    if (ConnectivityUtils::GetEthInterfaceName(mEthIfName, IFNAMSIZ) == CHIP_NO_ERROR)
+    {
+        ChipLogProgress(DeviceLayer, "Got Ethernet interface: %s", mEthIfName);
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "Failed to get Ethernet interface");
+        mEthIfName[0] = '\0';
+    }
+
+    if (GetDiagnosticDataProvider().ResetEthNetworkDiagnosticsCounts() != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Failed to reset Ethernet statistic counts");
+    }
+
+    // Initialize the generic base classes that require it.
+#if CHIP_DEVICE_CONFIG_ENABLE_THREAD
+    GenericConnectivityManagerImpl_Thread<ConnectivityManagerImpl>::_Init();
+#endif
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+    if (ConnectivityUtils::GetWiFiInterfaceName(sWiFiIfName, IFNAMSIZ) == CHIP_NO_ERROR)
+    {
+        ChipLogProgress(DeviceLayer, "Got WiFi interface: %s", sWiFiIfName);
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "Failed to get WiFi interface");
+        sWiFiIfName[0] = '\0';
+    }
+
+    if (GetDiagnosticDataProvider().ResetWiFiNetworkDiagnosticsCounts() != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Failed to reset WiFi statistic counts");
+    }
+#endif
+
+    return CHIP_NO_ERROR;
+}
+
+void ConnectivityManagerImpl::_OnPlatformEvent(const ChipDeviceEvent * event)
+{
+    // Forward the event to the generic base classes as needed.
+#if CHIP_DEVICE_CONFIG_ENABLE_THREAD
+    GenericConnectivityManagerImpl_Thread<ConnectivityManagerImpl>::_OnPlatformEvent(event);
+#endif
+}
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+bool ConnectivityManagerImpl::mAssociattionStarted = false;
+BitFlags<Internal::GenericConnectivityManagerImpl_WiFi<ConnectivityManagerImpl>::ConnectivityFlags>
+    ConnectivityManagerImpl::mConnectivityFlag;
+struct GDBusWpaSupplicant ConnectivityManagerImpl::mWpaSupplicant;
+std::mutex ConnectivityManagerImpl::mWpaSupplicantMutex;
+
+ConnectivityManager::WiFiStationMode ConnectivityManagerImpl::_GetWiFiStationMode()
+{
+    if (mWiFiStationMode != kWiFiStationMode_ApplicationControlled)
+    {
+        mWiFiStationMode = (mWpaSupplicant.iface != nullptr) ? kWiFiStationMode_Enabled : kWiFiStationMode_Disabled;
+    }
+
+    return mWiFiStationMode;
+}
+
+CHIP_ERROR ConnectivityManagerImpl::_SetWiFiStationMode(ConnectivityManager::WiFiStationMode val)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    VerifyOrExit(val != ConnectivityManager::kWiFiStationMode_NotSupported, err = CHIP_ERROR_INVALID_ARGUMENT);
+
+    if (mWiFiStationMode != val)
+    {
+        ChipLogProgress(DeviceLayer, "WiFi station mode change: %s -> %s", WiFiStationModeToStr(mWiFiStationMode),
+                        WiFiStationModeToStr(val));
+    }
+
+    mWiFiStationMode = val;
+exit:
+    return err;
+}
+
+System::Clock::Timeout ConnectivityManagerImpl::_GetWiFiStationReconnectInterval()
+{
+    return mWiFiStationReconnectInterval;
+}
+
+CHIP_ERROR ConnectivityManagerImpl::_SetWiFiStationReconnectInterval(System::Clock::Timeout val)
+{
+    mWiFiStationReconnectInterval = val;
+
+    return CHIP_NO_ERROR;
+}
+
+bool ConnectivityManagerImpl::_IsWiFiStationEnabled()
+{
+    return GetWiFiStationMode() == kWiFiStationMode_Enabled;
+}
+
+bool ConnectivityManagerImpl::_IsWiFiStationConnected()
+{
+    bool ret            = false;
+    const gchar * state = nullptr;
+
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    if (mWpaSupplicant.state != GDBusWpaSupplicant::WPA_INTERFACE_CONNECTED)
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: _IsWiFiStationConnected: interface not connected");
+        return false;
+    }
+
+    state = wpa_fi_w1_wpa_supplicant1_interface_get_state(mWpaSupplicant.iface);
+    if (g_strcmp0(state, "completed") == 0)
+    {
+        mConnectivityFlag.Set(ConnectivityFlags::kHaveIPv4InternetConnectivity)
+            .Set(ConnectivityFlags::kHaveIPv6InternetConnectivity);
+        ret = true;
+    }
+
+    return ret;
+}
+
+bool ConnectivityManagerImpl::_IsWiFiStationApplicationControlled()
+{
+    return mWiFiStationMode == ConnectivityManager::kWiFiStationMode_ApplicationControlled;
+}
+
+bool ConnectivityManagerImpl::_IsWiFiStationProvisioned()
+{
+    bool ret          = false;
+    const gchar * bss = nullptr;
+
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    if (mWpaSupplicant.state != GDBusWpaSupplicant::WPA_INTERFACE_CONNECTED)
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: _IsWiFiStationProvisioned: interface not connected");
+        return false;
+    }
+
+    bss = wpa_fi_w1_wpa_supplicant1_interface_get_current_bss(mWpaSupplicant.iface);
+    if (g_str_match_string("BSSs", bss, true))
+    {
+        ret = true;
+    }
+
+    return ret;
+}
+
+void ConnectivityManagerImpl::_ClearWiFiStationProvision()
+{
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    if (mWpaSupplicant.state != GDBusWpaSupplicant::WPA_INTERFACE_CONNECTED)
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: _ClearWiFiStationProvision: interface not connected");
+        return;
+    }
+
+    if (mWiFiStationMode != kWiFiStationMode_ApplicationControlled)
+    {
+        GError * err = nullptr;
+        wpa_fi_w1_wpa_supplicant1_interface_call_remove_all_networks_sync(mWpaSupplicant.iface, nullptr, &err);
+
+        if (err != nullptr)
+        {
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to remove all networks with error: %s",
+                            err ? err->message : "unknown error");
+            g_error_free(err);
+        }
+    }
+}
+
+bool ConnectivityManagerImpl::_CanStartWiFiScan()
+{
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    bool ret = mWpaSupplicant.state == GDBusWpaSupplicant::WPA_INTERFACE_CONNECTED &&
+        mWpaSupplicant.scanState == GDBusWpaSupplicant::WIFI_SCANNING_IDLE;
+
+    return ret;
+}
+
+CHIP_ERROR ConnectivityManagerImpl::_SetWiFiAPMode(WiFiAPMode val)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    VerifyOrExit(val != kWiFiAPMode_NotSupported, err = CHIP_ERROR_INVALID_ARGUMENT);
+
+    if (mWiFiAPMode != val)
+    {
+        ChipLogProgress(DeviceLayer, "WiFi AP mode change: %s -> %s", WiFiAPModeToStr(mWiFiAPMode), WiFiAPModeToStr(val));
+        mWiFiAPMode = val;
+
+        DeviceLayer::SystemLayer().ScheduleWork(DriveAPState, NULL);
+    }
+
+exit:
+    return err;
+}
+
+void ConnectivityManagerImpl::_DemandStartWiFiAP()
+{
+    if (mWiFiAPMode == kWiFiAPMode_OnDemand || mWiFiAPMode == kWiFiAPMode_OnDemand_NoStationProvision)
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: Demand start WiFi AP");
+        mLastAPDemandTime = System::SystemClock().GetMonotonicTimestamp();
+        DeviceLayer::SystemLayer().ScheduleWork(DriveAPState, NULL);
+    }
+    else
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: Demand start WiFi AP ignored, mode: %s", WiFiAPModeToStr(mWiFiAPMode));
+    }
+}
+
+void ConnectivityManagerImpl::_StopOnDemandWiFiAP()
+{
+    if (mWiFiAPMode == kWiFiAPMode_OnDemand || mWiFiAPMode == kWiFiAPMode_OnDemand_NoStationProvision)
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: Demand stop WiFi AP");
+        mLastAPDemandTime = System::Clock::kZero;
+        DeviceLayer::SystemLayer().ScheduleWork(DriveAPState, NULL);
+    }
+    else
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: Demand stop WiFi AP ignored, mode: %s", WiFiAPModeToStr(mWiFiAPMode));
+    }
+}
+
+void ConnectivityManagerImpl::_MaintainOnDemandWiFiAP()
+{
+    if (mWiFiAPMode == kWiFiAPMode_OnDemand || mWiFiAPMode == kWiFiAPMode_OnDemand_NoStationProvision)
+    {
+        if (mWiFiAPState == kWiFiAPState_Active)
+        {
+            mLastAPDemandTime = System::SystemClock().GetMonotonicTimestamp();
+        }
+    }
+}
+
+void ConnectivityManagerImpl::_SetWiFiAPIdleTimeout(System::Clock::Timeout val)
+{
+    mWiFiAPIdleTimeout = val;
+    DeviceLayer::SystemLayer().ScheduleWork(DriveAPState, NULL);
+}
+
+void ConnectivityManagerImpl::_OnWpaPropertiesChanged(WpaFiW1Wpa_supplicant1Interface * proxy, GVariant * changed_properties,
+                                                      const gchar * const * invalidated_properties, gpointer user_data)
+{
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    if (g_variant_n_children(changed_properties) > 0)
+    {
+        GVariantIter * iter;
+        const gchar * key;
+        GVariant * value;
+
+        WiFiDiagnosticsDelegate * delegate = GetDiagnosticDataProvider().GetWiFiDiagnosticsDelegate();
+
+        g_variant_get(changed_properties, "a{sv}", &iter);
+
+        while (g_variant_iter_loop(iter, "{&sv}", &key, &value))
+        {
+            gchar * value_str;
+            value_str = g_variant_print(value, TRUE);
+            ChipLogProgress(DeviceLayer, "wpa_supplicant:PropertiesChanged:key:%s -> %s", key, value_str);
+
+            if (g_strcmp0(key, "State") == 0)
+            {
+                if (g_strcmp0(value_str, "\'associating\'") == 0)
+                {
+                    mAssociattionStarted = true;
+                }
+                else if (g_strcmp0(value_str, "\'disconnected\'") == 0)
+                {
+                    gint reason = wpa_fi_w1_wpa_supplicant1_interface_get_disconnect_reason(mWpaSupplicant.iface);
+
+                    if (delegate)
+                    {
+                        delegate->OnDisconnectionDetected(reason);
+                        delegate->OnConnectionStatusChanged(static_cast<uint8_t>(WiFiConnectionStatus::kConnected));
+                    }
+
+                    if (mAssociattionStarted)
+                    {
+                        uint8_t associationFailureCause = static_cast<uint8_t>(AssociationFailureCause::kUnknown);
+                        uint16_t status                 = WLAN_STATUS_UNSPECIFIED_FAILURE;
+
+                        switch (abs(reason))
+                        {
+                        case WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY:
+                        case WLAN_REASON_DISASSOC_AP_BUSY:
+                        case WLAN_REASON_DISASSOC_STA_HAS_LEFT:
+                        case WLAN_REASON_DISASSOC_LOW_ACK:
+                        case WLAN_REASON_BSS_TRANSITION_DISASSOC:
+                            associationFailureCause = static_cast<uint8_t>(AssociationFailureCause::kAssociationFailed);
+                            status = wpa_fi_w1_wpa_supplicant1_interface_get_assoc_status_code(mWpaSupplicant.iface);
+                            break;
+                        case WLAN_REASON_PREV_AUTH_NOT_VALID:
+                        case WLAN_REASON_DEAUTH_LEAVING:
+                        case WLAN_REASON_IEEE_802_1X_AUTH_FAILED:
+                            associationFailureCause = static_cast<uint8_t>(AssociationFailureCause::kAuthenticationFailed);
+                            status = wpa_fi_w1_wpa_supplicant1_interface_get_auth_status_code(mWpaSupplicant.iface);
+                            break;
+                        default:
+                            break;
+                        }
+
+                        delegate->OnAssociationFailureDetected(associationFailureCause, status);
+                    }
+
+                    mAssociattionStarted = false;
+                }
+                else if (g_strcmp0(value_str, "\'associated\'") == 0)
+                {
+                    if (delegate)
+                    {
+                        delegate->OnConnectionStatusChanged(static_cast<uint8_t>(WiFiConnectionStatus::kNotConnected));
+                    }
+                }
+            }
+
+            g_free(value_str);
+        }
+
+        g_variant_iter_free(iter);
+    }
+}
+
+void ConnectivityManagerImpl::_OnWpaInterfaceProxyReady(GObject * source_object, GAsyncResult * res, gpointer user_data)
+{
+    GError * err = nullptr;
+
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    WpaFiW1Wpa_supplicant1Interface * iface = wpa_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus_finish(res, &err);
+
+    if (mWpaSupplicant.iface)
+    {
+        g_object_unref(mWpaSupplicant.iface);
+        mWpaSupplicant.iface = nullptr;
+    }
+
+    if (iface != nullptr && err == nullptr)
+    {
+        mWpaSupplicant.iface = iface;
+        mWpaSupplicant.state = GDBusWpaSupplicant::WPA_INTERFACE_CONNECTED;
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: connected to wpa_supplicant interface proxy");
+
+        g_signal_connect(mWpaSupplicant.iface, "properties-changed", G_CALLBACK(_OnWpaPropertiesChanged), NULL);
+    }
+    else
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to create wpa_supplicant interface proxy %s: %s",
+                        mWpaSupplicant.interfacePath, err ? err->message : "unknown error");
+
+        mWpaSupplicant.state = GDBusWpaSupplicant::WPA_NOT_CONNECTED;
+    }
+
+    if (err != nullptr)
+        g_error_free(err);
+}
+
+void ConnectivityManagerImpl::_OnWpaBssProxyReady(GObject * source_object, GAsyncResult * res, gpointer user_data)
+{
+    GError * err = nullptr;
+
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    WpaFiW1Wpa_supplicant1BSS * bss = wpa_fi_w1_wpa_supplicant1_bss_proxy_new_for_bus_finish(res, &err);
+
+    if (mWpaSupplicant.bss)
+    {
+        g_object_unref(mWpaSupplicant.bss);
+        mWpaSupplicant.bss = nullptr;
+    }
+
+    if (bss != nullptr && err == nullptr)
+    {
+        mWpaSupplicant.bss = bss;
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: connected to wpa_supplicant bss proxy");
+    }
+    else
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to create wpa_supplicant bss proxy %s: %s",
+                        mWpaSupplicant.interfacePath, err ? err->message : "unknown error");
+    }
+
+    if (err != nullptr)
+        g_error_free(err);
+}
+
+void ConnectivityManagerImpl::_OnWpaInterfaceReady(GObject * source_object, GAsyncResult * res, gpointer user_data)
+{
+    GError * err = nullptr;
+
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    gboolean result =
+        wpa_fi_w1_wpa_supplicant1_call_get_interface_finish(mWpaSupplicant.proxy, &mWpaSupplicant.interfacePath, res, &err);
+    if (result)
+    {
+        mWpaSupplicant.state = GDBusWpaSupplicant::WPA_GOT_INTERFACE_PATH;
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: WiFi interface: %s", mWpaSupplicant.interfacePath);
+
+        wpa_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, kWpaSupplicantServiceName,
+                                                              mWpaSupplicant.interfacePath, nullptr, _OnWpaInterfaceProxyReady,
+                                                              nullptr);
+
+        wpa_fi_w1_wpa_supplicant1_bss_proxy_new_for_bus(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, kWpaSupplicantServiceName,
+                                                        mWpaSupplicant.interfacePath, nullptr, _OnWpaBssProxyReady, nullptr);
+    }
+    else
+    {
+        GError * error  = nullptr;
+        GVariant * args = nullptr;
+        GVariantBuilder builder;
+
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: can't find interface %s: %s", sWiFiIfName,
+                        err ? err->message : "unknown error");
+
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: try to create interface %s", CHIP_DEVICE_CONFIG_WIFI_STATION_IF_NAME);
+
+        g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);
+        g_variant_builder_add(&builder, "{sv}", "Ifname", g_variant_new_string(CHIP_DEVICE_CONFIG_WIFI_STATION_IF_NAME));
+        args = g_variant_builder_end(&builder);
+
+        result = wpa_fi_w1_wpa_supplicant1_call_create_interface_sync(mWpaSupplicant.proxy, args, &mWpaSupplicant.interfacePath,
+                                                                      nullptr, &error);
+
+        if (result)
+        {
+            mWpaSupplicant.state = GDBusWpaSupplicant::WPA_GOT_INTERFACE_PATH;
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: WiFi interface: %s", mWpaSupplicant.interfacePath);
+
+            strncpy(sWiFiIfName, CHIP_DEVICE_CONFIG_WIFI_STATION_IF_NAME, IFNAMSIZ);
+            sWiFiIfName[IFNAMSIZ - 1] = '\0';
+
+            wpa_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE,
+                                                                  kWpaSupplicantServiceName, mWpaSupplicant.interfacePath, nullptr,
+                                                                  _OnWpaInterfaceProxyReady, nullptr);
+
+            wpa_fi_w1_wpa_supplicant1_bss_proxy_new_for_bus(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, kWpaSupplicantServiceName,
+                                                            mWpaSupplicant.interfacePath, nullptr, _OnWpaBssProxyReady, nullptr);
+        }
+        else
+        {
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to create interface %s: %s",
+                            CHIP_DEVICE_CONFIG_WIFI_STATION_IF_NAME, error ? error->message : "unknown error");
+
+            mWpaSupplicant.state = GDBusWpaSupplicant::WPA_NO_INTERFACE_PATH;
+
+            if (mWpaSupplicant.interfacePath)
+            {
+                g_free(mWpaSupplicant.interfacePath);
+                mWpaSupplicant.interfacePath = nullptr;
+            }
+        }
+
+        if (error != nullptr)
+            g_error_free(error);
+    }
+
+    if (err != nullptr)
+        g_error_free(err);
+}
+
+void ConnectivityManagerImpl::_OnWpaInterfaceAdded(WpaFiW1Wpa_supplicant1 * proxy, const gchar * path, GVariant * properties,
+                                                   gpointer user_data)
+{
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    if (mWpaSupplicant.interfacePath)
+    {
+        return;
+    }
+
+    mWpaSupplicant.interfacePath = const_cast<gchar *>(path);
+    if (mWpaSupplicant.interfacePath)
+    {
+        mWpaSupplicant.state = GDBusWpaSupplicant::WPA_GOT_INTERFACE_PATH;
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: WiFi interface added: %s", mWpaSupplicant.interfacePath);
+
+        wpa_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, kWpaSupplicantServiceName,
+                                                              mWpaSupplicant.interfacePath, nullptr, _OnWpaInterfaceProxyReady,
+                                                              nullptr);
+
+        wpa_fi_w1_wpa_supplicant1_bss_proxy_new_for_bus(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, kWpaSupplicantServiceName,
+                                                        mWpaSupplicant.interfacePath, nullptr, _OnWpaBssProxyReady, nullptr);
+    }
+}
+
+void ConnectivityManagerImpl::_OnWpaInterfaceRemoved(WpaFiW1Wpa_supplicant1 * proxy, const gchar * path, GVariant * properties,
+                                                     gpointer user_data)
+{
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    if (mWpaSupplicant.interfacePath == nullptr)
+    {
+        return;
+    }
+
+    if (g_strcmp0(mWpaSupplicant.interfacePath, path) == 0)
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: WiFi interface removed: %s", path);
+
+        mWpaSupplicant.state = GDBusWpaSupplicant::WPA_NO_INTERFACE_PATH;
+
+        if (mWpaSupplicant.interfacePath)
+        {
+            g_free(mWpaSupplicant.interfacePath);
+            mWpaSupplicant.interfacePath = nullptr;
+        }
+
+        if (mWpaSupplicant.iface)
+        {
+            g_object_unref(mWpaSupplicant.iface);
+            mWpaSupplicant.iface = nullptr;
+        }
+
+        if (mWpaSupplicant.bss)
+        {
+            g_object_unref(mWpaSupplicant.bss);
+            mWpaSupplicant.bss = nullptr;
+        }
+
+        mWpaSupplicant.scanState = GDBusWpaSupplicant::WIFI_SCANNING_IDLE;
+    }
+}
+
+void ConnectivityManagerImpl::_OnWpaProxyReady(GObject * source_object, GAsyncResult * res, gpointer user_data)
+{
+    GError * err = nullptr;
+
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    mWpaSupplicant.proxy = wpa_fi_w1_wpa_supplicant1_proxy_new_for_bus_finish(res, &err);
+    if (mWpaSupplicant.proxy != nullptr && err == nullptr)
+    {
+        mWpaSupplicant.state = GDBusWpaSupplicant::WPA_CONNECTED;
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: connected to wpa_supplicant proxy");
+
+        g_signal_connect(mWpaSupplicant.proxy, "interface-added", G_CALLBACK(_OnWpaInterfaceAdded), NULL);
+
+        g_signal_connect(mWpaSupplicant.proxy, "interface-removed", G_CALLBACK(_OnWpaInterfaceRemoved), NULL);
+
+        wpa_fi_w1_wpa_supplicant1_call_get_interface(mWpaSupplicant.proxy, sWiFiIfName, nullptr, _OnWpaInterfaceReady, nullptr);
+    }
+    else
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to create wpa_supplicant proxy %s",
+                        err ? err->message : "unknown error");
+        mWpaSupplicant.state = GDBusWpaSupplicant::WPA_NOT_CONNECTED;
+    }
+
+    if (err != nullptr)
+        g_error_free(err);
+}
+
+void ConnectivityManagerImpl::StartWiFiManagement()
+{
+    mConnectivityFlag.ClearAll();
+    mWpaSupplicant.state         = GDBusWpaSupplicant::INIT;
+    mWpaSupplicant.scanState     = GDBusWpaSupplicant::WIFI_SCANNING_IDLE;
+    mWpaSupplicant.proxy         = nullptr;
+    mWpaSupplicant.iface         = nullptr;
+    mWpaSupplicant.bss           = nullptr;
+    mWpaSupplicant.interfacePath = nullptr;
+    mWpaSupplicant.networkPath   = nullptr;
+
+    ChipLogProgress(DeviceLayer, "wpa_supplicant: Start WiFi management");
+
+    wpa_fi_w1_wpa_supplicant1_proxy_new_for_bus(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, kWpaSupplicantServiceName,
+                                                kWpaSupplicantObjectPath, nullptr, _OnWpaProxyReady, nullptr);
+}
+
+bool ConnectivityManagerImpl::IsWiFiManagementStarted()
+{
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    bool ret = mWpaSupplicant.state == GDBusWpaSupplicant::WPA_INTERFACE_CONNECTED;
+
+    return ret;
+}
+
+void ConnectivityManagerImpl::DriveAPState()
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    WiFiAPState targetState;
+
+    // If the AP interface is not under application control...
+    if (mWiFiAPMode != kWiFiAPMode_ApplicationControlled)
+    {
+        // Determine the target (desired) state for AP interface...
+
+        // The target state is 'NotActive' if the application has expressly disabled the AP interface.
+        if (mWiFiAPMode == kWiFiAPMode_Disabled)
+        {
+            targetState = kWiFiAPState_NotActive;
+        }
+
+        // The target state is 'Active' if the application has expressly enabled the AP interface.
+        else if (mWiFiAPMode == kWiFiAPMode_Enabled)
+        {
+            targetState = kWiFiAPState_Active;
+        }
+
+        // The target state is 'Active' if the AP mode is 'On demand, when no station is available'
+        // and the station interface is not provisioned or the application has disabled the station
+        // interface.
+        else if (mWiFiAPMode == kWiFiAPMode_OnDemand_NoStationProvision &&
+                 (!IsWiFiStationProvisioned() || GetWiFiStationMode() == kWiFiStationMode_Disabled))
+        {
+            targetState = kWiFiAPState_Active;
+        }
+
+        // The target state is 'Active' if the AP mode is one of the 'On demand' modes and there
+        // has been demand for the AP within the idle timeout period.
+        else if (mWiFiAPMode == kWiFiAPMode_OnDemand || mWiFiAPMode == kWiFiAPMode_OnDemand_NoStationProvision)
+        {
+            System::Clock::Timestamp now = System::SystemClock().GetMonotonicTimestamp();
+
+            if (mLastAPDemandTime != System::Clock::kZero && now < (mLastAPDemandTime + mWiFiAPIdleTimeout))
+            {
+                targetState = kWiFiAPState_Active;
+
+                // Compute the amount of idle time before the AP should be deactivated and
+                // arm a timer to fire at that time.
+                System::Clock::Timeout apTimeout = (mLastAPDemandTime + mWiFiAPIdleTimeout) - now;
+                err                              = DeviceLayer::SystemLayer().StartTimer(apTimeout, DriveAPState, NULL);
+                SuccessOrExit(err);
+                ChipLogProgress(DeviceLayer, "Next WiFi AP timeout in %" PRIu32 " s",
+                                std::chrono::duration_cast<System::Clock::Seconds32>(apTimeout).count());
+            }
+            else
+            {
+                targetState = kWiFiAPState_NotActive;
+            }
+        }
+
+        // Otherwise the target state is 'NotActive'.
+        else
+        {
+            targetState = kWiFiAPState_NotActive;
+        }
+
+        // If the current AP state does not match the target state...
+        if (mWiFiAPState != targetState)
+        {
+            if (targetState == kWiFiAPState_Active)
+            {
+                err = ConfigureWiFiAP();
+                SuccessOrExit(err);
+
+                ChangeWiFiAPState(kWiFiAPState_Active);
+            }
+            else
+            {
+                if (mWpaSupplicant.networkPath)
+                {
+                    GError * error = nullptr;
+
+                    gboolean result = wpa_fi_w1_wpa_supplicant1_interface_call_remove_network_sync(
+                        mWpaSupplicant.iface, mWpaSupplicant.networkPath, nullptr, &error);
+
+                    if (result)
+                    {
+                        ChipLogProgress(DeviceLayer, "wpa_supplicant: removed network: %s", mWpaSupplicant.networkPath);
+                        g_free(mWpaSupplicant.networkPath);
+                        mWpaSupplicant.networkPath = nullptr;
+                        ChangeWiFiAPState(kWiFiAPState_NotActive);
+                    }
+                    else
+                    {
+                        ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to stop AP mode with error: %s",
+                                        error ? error->message : "unknown error");
+                        err = CHIP_ERROR_INTERNAL;
+                    }
+
+                    if (error != nullptr)
+                        g_error_free(error);
+                }
+            }
+        }
+    }
+
+exit:
+    if (err != CHIP_NO_ERROR)
+    {
+        SetWiFiAPMode(kWiFiAPMode_Disabled);
+        ChipLogError(DeviceLayer, "Drive AP state failed: %s", ErrorStr(err));
+    }
+}
+
+CHIP_ERROR ConnectivityManagerImpl::ConfigureWiFiAP()
+{
+    CHIP_ERROR ret  = CHIP_NO_ERROR;
+    GError * err    = nullptr;
+    GVariant * args = nullptr;
+    GVariantBuilder builder;
+
+    uint16_t channel       = 1;
+    uint16_t discriminator = 0;
+    char ssid[32];
+
+    channel = ConnectivityUtils::MapChannelToFrequency(kWiFi_BAND_2_4_GHZ, CHIP_DEVICE_CONFIG_WIFI_AP_CHANNEL);
+
+    if (ConfigurationMgr().GetSetupDiscriminator(discriminator) != CHIP_NO_ERROR)
+        discriminator = 0;
+
+    snprintf(ssid, 32, "%s%04u", CHIP_DEVICE_CONFIG_WIFI_AP_SSID_PREFIX, discriminator);
+
+    ChipLogProgress(DeviceLayer, "wpa_supplicant: ConfigureWiFiAP, ssid: %s, channel: %d", ssid, channel);
+
+    // Clean up current network if exists
+    if (mWpaSupplicant.networkPath)
+    {
+        g_object_unref(mWpaSupplicant.networkPath);
+        mWpaSupplicant.networkPath = nullptr;
+    }
+
+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);
+    g_variant_builder_add(&builder, "{sv}", "ssid", g_variant_new_string(ssid));
+    g_variant_builder_add(&builder, "{sv}", "key_mgmt", g_variant_new_string("NONE"));
+    g_variant_builder_add(&builder, "{sv}", "mode", g_variant_new_int32(2));
+    g_variant_builder_add(&builder, "{sv}", "frequency", g_variant_new_int32(channel));
+    args = g_variant_builder_end(&builder);
+
+    gboolean result = wpa_fi_w1_wpa_supplicant1_interface_call_add_network_sync(mWpaSupplicant.iface, args,
+                                                                                &mWpaSupplicant.networkPath, nullptr, &err);
+
+    if (result)
+    {
+        GError * error = nullptr;
+
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: added network: SSID: %s: %s", ssid, mWpaSupplicant.networkPath);
+
+        result = wpa_fi_w1_wpa_supplicant1_interface_call_select_network_sync(mWpaSupplicant.iface, mWpaSupplicant.networkPath,
+                                                                              nullptr, &error);
+        if (result)
+        {
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: succeeded to start softAP: SSID: %s", ssid);
+        }
+        else
+        {
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to start softAP: SSID: %s: %s", ssid,
+                            error ? error->message : "unknown error");
+
+            ret = CHIP_ERROR_INTERNAL;
+        }
+
+        if (error != nullptr)
+            g_error_free(error);
+    }
+    else
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to add network: %s: %s", ssid, err ? err->message : "unknown error");
+
+        if (mWpaSupplicant.networkPath)
+        {
+            g_object_unref(mWpaSupplicant.networkPath);
+            mWpaSupplicant.networkPath = nullptr;
+        }
+
+        ret = CHIP_ERROR_INTERNAL;
+    }
+
+    if (err != nullptr)
+        g_error_free(err);
+
+    return ret;
+}
+
+void ConnectivityManagerImpl::ChangeWiFiAPState(WiFiAPState newState)
+{
+    if (mWiFiAPState != newState)
+    {
+        ChipLogProgress(DeviceLayer, "WiFi AP state change: %s -> %s", WiFiAPStateToStr(mWiFiAPState), WiFiAPStateToStr(newState));
+        mWiFiAPState = newState;
+    }
+}
+
+void ConnectivityManagerImpl::DriveAPState(::chip::System::Layer * aLayer, void * aAppState)
+{
+    sInstance.DriveAPState();
+}
+
+CHIP_ERROR ConnectivityManagerImpl::ProvisionWiFiNetwork(const char * ssid, const char * key)
+{
+    CHIP_ERROR ret  = CHIP_NO_ERROR;
+    GError * err    = nullptr;
+    GVariant * args = nullptr;
+    GVariantBuilder builder;
+    gboolean result;
+
+    // Clean up current network if exists
+    if (mWpaSupplicant.networkPath)
+    {
+        GError * error = nullptr;
+
+        result = wpa_fi_w1_wpa_supplicant1_interface_call_remove_network_sync(mWpaSupplicant.iface, mWpaSupplicant.networkPath,
+                                                                              nullptr, &error);
+
+        if (result)
+        {
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: removed network: %s", mWpaSupplicant.networkPath);
+            g_free(mWpaSupplicant.networkPath);
+            mWpaSupplicant.networkPath = nullptr;
+        }
+        else
+        {
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to stop AP mode with error: %s",
+                            error ? error->message : "unknown error");
+            ret = CHIP_ERROR_INTERNAL;
+        }
+
+        if (error != nullptr)
+            g_error_free(error);
+
+        SuccessOrExit(ret);
+    }
+
+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);
+    g_variant_builder_add(&builder, "{sv}", "ssid", g_variant_new_string(ssid));
+    g_variant_builder_add(&builder, "{sv}", "psk", g_variant_new_string(key));
+    g_variant_builder_add(&builder, "{sv}", "key_mgmt", g_variant_new_string("WPA-PSK"));
+    args = g_variant_builder_end(&builder);
+
+    result = wpa_fi_w1_wpa_supplicant1_interface_call_add_network_sync(mWpaSupplicant.iface, args, &mWpaSupplicant.networkPath,
+                                                                       nullptr, &err);
+
+    if (result)
+    {
+        GError * error = nullptr;
+
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: added network: SSID: %s: %s", ssid, mWpaSupplicant.networkPath);
+
+        result = wpa_fi_w1_wpa_supplicant1_interface_call_select_network_sync(mWpaSupplicant.iface, mWpaSupplicant.networkPath,
+                                                                              nullptr, &error);
+        if (result)
+        {
+            GError * gerror = nullptr;
+
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: connected to network: SSID: %s", ssid);
+
+            result = wpa_fi_w1_wpa_supplicant1_interface_call_save_config_sync(mWpaSupplicant.iface, nullptr, &gerror);
+
+            if (result)
+            {
+                ChipLogProgress(DeviceLayer, "wpa_supplicant: save config succeeded!");
+            }
+            else
+            {
+                ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to save config: %s",
+                                gerror ? gerror->message : "unknown error");
+            }
+
+            if (gerror != nullptr)
+                g_error_free(gerror);
+
+            // Iterate on the network interface to see if we already have beed assigned addresses.
+            // The temporary hack for getting IP address change on linux for network provisioning in the rendezvous session.
+            // This should be removed or find a better place once we depercate the rendezvous session.
+            for (chip::Inet::InterfaceAddressIterator it; it.HasCurrent(); it.Next())
+            {
+                char ifName[chip::Inet::InterfaceId::kMaxIfNameLength];
+                if (it.IsUp() && CHIP_NO_ERROR == it.GetInterfaceName(ifName, sizeof(ifName)) &&
+                    strncmp(ifName, sWiFiIfName, sizeof(ifName)) == 0)
+                {
+                    chip::Inet::IPAddress addr;
+                    if ((it.GetAddress(addr) == CHIP_NO_ERROR) && addr.IsIPv4())
+                    {
+                        ChipDeviceEvent event;
+                        event.Type                            = DeviceEventType::kInternetConnectivityChange;
+                        event.InternetConnectivityChange.IPv4 = kConnectivity_Established;
+                        event.InternetConnectivityChange.IPv6 = kConnectivity_NoChange;
+                        addr.ToString(event.InternetConnectivityChange.address);
+
+                        ChipLogDetail(DeviceLayer, "Got IP address on interface: %s IP: %s", ifName,
+                                      event.InternetConnectivityChange.address);
+
+                        PlatformMgr().PostEventOrDie(&event);
+                    }
+                }
+            }
+
+            // Run dhclient for IP on WiFi.
+            // TODO: The wifi can be managed by networkmanager on linux so we don't have to care about this.
+            char cmdBuffer[128];
+            sprintf(cmdBuffer, CHIP_DEVICE_CONFIG_LINUX_DHCPC_CMD, sWiFiIfName);
+            int dhclientSystemRet = system(cmdBuffer);
+            if (dhclientSystemRet != 0)
+            {
+                ChipLogError(DeviceLayer, "Failed to run dhclient, system() returns %d", dhclientSystemRet);
+            }
+            else
+            {
+                ChipLogProgress(DeviceLayer, "dhclient is running on the %s interface.", sWiFiIfName);
+            }
+
+            // Return success as long as the device is connected to the network
+            ret = CHIP_NO_ERROR;
+        }
+        else
+        {
+            ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to connect to network: SSID: %s: %s", ssid,
+                            error ? error->message : "unknown error");
+
+            ret = CHIP_ERROR_INTERNAL;
+        }
+
+        if (error != nullptr)
+            g_error_free(error);
+    }
+    else
+    {
+        ChipLogProgress(DeviceLayer, "wpa_supplicant: failed to add network: %s: %s", ssid, err ? err->message : "unknown error");
+
+        if (mWpaSupplicant.networkPath)
+        {
+            g_object_unref(mWpaSupplicant.networkPath);
+            mWpaSupplicant.networkPath = nullptr;
+        }
+
+        ret = CHIP_ERROR_INTERNAL;
+    }
+
+exit:
+    if (err != nullptr)
+        g_error_free(err);
+
+    return ret;
+}
+
+CHIP_ERROR ConnectivityManagerImpl::GetWiFiBssId(ByteSpan & value)
+{
+    CHIP_ERROR err          = CHIP_ERROR_READ_FAILED;
+    struct ifaddrs * ifaddr = nullptr;
+
+    // On Linux simulation, we don't have the DBus API to get the BSSID of connected AP. Use mac address
+    // of local WiFi network card instead.
+    if (getifaddrs(&ifaddr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to get network interfaces");
+    }
+    else
+    {
+        uint8_t macAddress[kMaxHardwareAddrSize];
+
+        // Walk through linked list, maintaining head pointer so we can free list later.
+        for (struct ifaddrs * ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (ConnectivityUtils::GetInterfaceConnectionType(ifa->ifa_name) == InterfaceType::EMBER_ZCL_INTERFACE_TYPE_WI_FI)
+            {
+                if (ConnectivityUtils::GetInterfaceHardwareAddrs(ifa->ifa_name, macAddress, kMaxHardwareAddrSize) != CHIP_NO_ERROR)
+                {
+                    ChipLogError(DeviceLayer, "Failed to get WiFi network hardware address");
+                }
+                else
+                {
+                    // Set 48-bit IEEE MAC Address
+                    value = ByteSpan(macAddress, 6);
+                    err   = CHIP_NO_ERROR;
+                    break;
+                }
+            }
+        }
+
+        freeifaddrs(ifaddr);
+    }
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityManagerImpl::GetWiFiSecurityType(uint8_t & securityType)
+{
+    const gchar * mode = nullptr;
+
+    std::lock_guard<std::mutex> lock(mWpaSupplicantMutex);
+
+    if (mWpaSupplicant.state != GDBusWpaSupplicant::WPA_INTERFACE_CONNECTED)
+    {
+        ChipLogError(DeviceLayer, "wpa_supplicant: _GetWiFiSecurityType: interface proxy not connected");
+        return CHIP_ERROR_INCORRECT_STATE;
+    }
+
+    mode = wpa_fi_w1_wpa_supplicant1_interface_get_current_auth_mode(mWpaSupplicant.iface);
+    ChipLogProgress(DeviceLayer, "wpa_supplicant: current Wi-Fi security type: %s", mode);
+
+    if (strncmp(mode, "WPA-PSK", 7) == 0)
+    {
+        securityType = EMBER_ZCL_SECURITY_TYPE_WPA;
+    }
+    else if (strncmp(mode, "WPA2-PSK", 8) == 0)
+    {
+        securityType = EMBER_ZCL_SECURITY_TYPE_WPA2;
+    }
+    else if (strncmp(mode, "WPA2-EAP", 8) == 0)
+    {
+        securityType = EMBER_ZCL_SECURITY_TYPE_WPA2;
+    }
+    else if (strncmp(mode, "WPA3-PSK", 8) == 0)
+    {
+        securityType = EMBER_ZCL_SECURITY_TYPE_WPA3;
+    }
+    else if (strncmp(mode, "WEP", 3) == 0)
+    {
+        securityType = EMBER_ZCL_SECURITY_TYPE_WEP;
+    }
+    else if (strncmp(mode, "NONE", 4) == 0)
+    {
+        securityType = EMBER_ZCL_SECURITY_TYPE_NONE;
+    }
+    else if (strncmp(mode, "WPA-NONE", 8) == 0)
+    {
+        securityType = EMBER_ZCL_SECURITY_TYPE_NONE;
+    }
+    else
+    {
+        securityType = EMBER_ZCL_SECURITY_TYPE_UNSPECIFIED;
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR ConnectivityManagerImpl::GetWiFiVersion(uint8_t & wiFiVersion)
+{
+    // We don't have driect API to get the WiFi version yet, retrun 802.11n on Linux simulation.
+    wiFiVersion = EMBER_ZCL_WI_FI_VERSION_TYPE_802__11N;
+
+    return CHIP_NO_ERROR;
+}
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_WPA
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/ConnectivityManagerImpl.h b/src/platform/webos/ConnectivityManagerImpl.h
new file mode 100644
index 000000000..f37cc0d54
--- /dev/null
+++ b/src/platform/webos/ConnectivityManagerImpl.h
@@ -0,0 +1,250 @@
+/*
+ *
+ *    Copyright (c) 2020-2021 Project CHIP Authors
+ *    Copyright (c) 2018 Nest Labs, Inc.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <platform/ConnectivityManager.h>
+#include <platform/internal/GenericConnectivityManagerImpl.h>
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+#include <platform/internal/GenericConnectivityManagerImpl_BLE.h>
+#else
+#include <platform/internal/GenericConnectivityManagerImpl_NoBLE.h>
+#endif
+#if CHIP_DEVICE_CONFIG_ENABLE_THREAD
+#include <platform/internal/GenericConnectivityManagerImpl_Thread.h>
+#else
+#include <platform/internal/GenericConnectivityManagerImpl_NoThread.h>
+#endif
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+#include <platform/internal/GenericConnectivityManagerImpl_WiFi.h>
+#else
+#include <platform/internal/GenericConnectivityManagerImpl_NoWiFi.h>
+#endif
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+#include <platform/webos/dbus/wpa/DBusWpa.h>
+#include <platform/webos/dbus/wpa/DBusWpaBss.h>
+#include <platform/webos/dbus/wpa/DBusWpaInterface.h>
+#include <platform/webos/dbus/wpa/DBusWpaNetwork.h>
+
+#include <mutex>
+#endif
+
+namespace chip {
+namespace Inet {
+class IPAddress;
+} // namespace Inet
+} // namespace chip
+
+namespace chip {
+namespace DeviceLayer {
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+struct GDBusWpaSupplicant
+{
+    enum
+    {
+        INIT,
+        WPA_CONNECTING,
+        WPA_CONNECTED,
+        WPA_NOT_CONNECTED,
+        WPA_NO_INTERFACE_PATH,
+        WPA_GOT_INTERFACE_PATH,
+        WPA_INTERFACE_CONNECTED,
+    } state;
+
+    enum
+    {
+        WIFI_SCANNING_IDLE,
+        WIFI_SCANNING,
+    } scanState;
+
+    WpaFiW1Wpa_supplicant1 * proxy;
+    WpaFiW1Wpa_supplicant1Interface * iface;
+    WpaFiW1Wpa_supplicant1BSS * bss;
+    gchar * interfacePath;
+    gchar * networkPath;
+};
+#endif
+
+/**
+ * Concrete implementation of the ConnectivityManager singleton object for Linux platforms.
+ */
+class ConnectivityManagerImpl final : public ConnectivityManager,
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+                                      public Internal::GenericConnectivityManagerImpl_BLE<ConnectivityManagerImpl>,
+#else
+                                      public Internal::GenericConnectivityManagerImpl_NoBLE<ConnectivityManagerImpl>,
+#endif
+#if CHIP_DEVICE_CONFIG_ENABLE_THREAD
+                                      public Internal::GenericConnectivityManagerImpl_Thread<ConnectivityManagerImpl>,
+#else
+                                      public Internal::GenericConnectivityManagerImpl_NoThread<ConnectivityManagerImpl>,
+#endif
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+                                      public Internal::GenericConnectivityManagerImpl_WiFi<ConnectivityManagerImpl>,
+#else
+                                      public Internal::GenericConnectivityManagerImpl_NoWiFi<ConnectivityManagerImpl>,
+#endif
+                                      public Internal::GenericConnectivityManagerImpl<ConnectivityManagerImpl>
+{
+    // Allow the ConnectivityManager interface class to delegate method calls to
+    // the implementation methods provided by this class.
+    friend class ConnectivityManager;
+
+public:
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+    CHIP_ERROR ProvisionWiFiNetwork(const char * ssid, const char * key);
+    void StartWiFiManagement();
+    bool IsWiFiManagementStarted();
+    CHIP_ERROR GetWiFiBssId(ByteSpan & value);
+    CHIP_ERROR GetWiFiSecurityType(uint8_t & securityType);
+    CHIP_ERROR GetWiFiVersion(uint8_t & wiFiVersion);
+#endif
+
+    const char * GetEthernetIfName() { return (mEthIfName[0] == '\0') ? nullptr : mEthIfName; }
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+    static const char * GetWiFiIfName() { return (sWiFiIfName[0] == '\0') ? nullptr : sWiFiIfName; }
+#endif
+
+private:
+    // ===== Members that implement the ConnectivityManager abstract interface.
+
+    CHIP_ERROR _Init();
+    void _OnPlatformEvent(const ChipDeviceEvent * event);
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+    WiFiStationMode _GetWiFiStationMode();
+    CHIP_ERROR _SetWiFiStationMode(ConnectivityManager::WiFiStationMode val);
+    System::Clock::Timeout _GetWiFiStationReconnectInterval();
+    CHIP_ERROR _SetWiFiStationReconnectInterval(System::Clock::Timeout val);
+    bool _IsWiFiStationEnabled();
+    bool _IsWiFiStationConnected();
+    bool _IsWiFiStationApplicationControlled();
+    bool _IsWiFiStationProvisioned();
+    void _ClearWiFiStationProvision();
+    bool _CanStartWiFiScan();
+
+    WiFiAPMode _GetWiFiAPMode();
+    CHIP_ERROR _SetWiFiAPMode(WiFiAPMode val);
+    bool _IsWiFiAPActive();
+    bool _IsWiFiAPApplicationControlled();
+    void _DemandStartWiFiAP();
+    void _StopOnDemandWiFiAP();
+    void _MaintainOnDemandWiFiAP();
+    System::Clock::Timeout _GetWiFiAPIdleTimeout();
+    void _SetWiFiAPIdleTimeout(System::Clock::Timeout val);
+
+    static void _OnWpaProxyReady(GObject * source_object, GAsyncResult * res, gpointer user_data);
+    static void _OnWpaInterfaceRemoved(WpaFiW1Wpa_supplicant1 * proxy, const gchar * path, GVariant * properties,
+                                       gpointer user_data);
+    static void _OnWpaInterfaceAdded(WpaFiW1Wpa_supplicant1 * proxy, const gchar * path, GVariant * properties, gpointer user_data);
+    static void _OnWpaPropertiesChanged(WpaFiW1Wpa_supplicant1Interface * proxy, GVariant * changed_properties,
+                                        const gchar * const * invalidated_properties, gpointer user_data);
+    static void _OnWpaInterfaceReady(GObject * source_object, GAsyncResult * res, gpointer user_data);
+    static void _OnWpaInterfaceProxyReady(GObject * source_object, GAsyncResult * res, gpointer user_data);
+    static void _OnWpaBssProxyReady(GObject * source_object, GAsyncResult * res, gpointer user_data);
+
+    static bool mAssociattionStarted;
+    static BitFlags<ConnectivityFlags> mConnectivityFlag;
+    static struct GDBusWpaSupplicant mWpaSupplicant;
+    static std::mutex mWpaSupplicantMutex;
+#endif
+
+    // ==================== ConnectivityManager Private Methods ====================
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+    void DriveAPState();
+    CHIP_ERROR ConfigureWiFiAP();
+    void ChangeWiFiAPState(WiFiAPState newState);
+    static void DriveAPState(::chip::System::Layer * aLayer, void * aAppState);
+#endif
+
+    // ===== Members for internal use by the following friends.
+
+    friend ConnectivityManager & ConnectivityMgr();
+    friend ConnectivityManagerImpl & ConnectivityMgrImpl();
+
+    static ConnectivityManagerImpl sInstance;
+
+    // ===== Private members reserved for use by this class only.
+
+    char mEthIfName[IFNAMSIZ];
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+    ConnectivityManager::WiFiStationMode mWiFiStationMode;
+    ConnectivityManager::WiFiAPMode mWiFiAPMode;
+    WiFiAPState mWiFiAPState;
+    System::Clock::Timestamp mLastAPDemandTime;
+    System::Clock::Timeout mWiFiStationReconnectInterval;
+    System::Clock::Timeout mWiFiAPIdleTimeout;
+#endif
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+    static char sWiFiIfName[IFNAMSIZ];
+#endif
+};
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+inline ConnectivityManager::WiFiAPMode ConnectivityManagerImpl::_GetWiFiAPMode()
+{
+    return mWiFiAPMode;
+}
+
+inline bool ConnectivityManagerImpl::_IsWiFiAPActive()
+{
+    return mWiFiAPState == kWiFiAPState_Active;
+}
+
+inline bool ConnectivityManagerImpl::_IsWiFiAPApplicationControlled()
+{
+    return mWiFiAPMode == kWiFiAPMode_ApplicationControlled;
+}
+
+inline System::Clock::Timeout ConnectivityManagerImpl::_GetWiFiAPIdleTimeout()
+{
+    return mWiFiAPIdleTimeout;
+}
+
+#endif
+
+/**
+ * Returns the public interface of the ConnectivityManager singleton object.
+ *
+ * chip applications should use this to access features of the ConnectivityManager object
+ * that are common to all platforms.
+ */
+inline ConnectivityManager & ConnectivityMgr()
+{
+    return ConnectivityManagerImpl::sInstance;
+}
+
+/**
+ * Returns the platform-specific implementation of the ConnectivityManager singleton object.
+ *
+ * chip applications can use this to gain access to features of the ConnectivityManager
+ * that are specific to the ESP32 platform.
+ */
+inline ConnectivityManagerImpl & ConnectivityMgrImpl()
+{
+    return ConnectivityManagerImpl::sInstance;
+}
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/ConnectivityUtils.cpp b/src/platform/webos/ConnectivityUtils.cpp
new file mode 100644
index 000000000..87277ccc4
--- /dev/null
+++ b/src/platform/webos/ConnectivityUtils.cpp
@@ -0,0 +1,646 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Utilities for accessing parameters of the network interface and the wireless
+ *          statistics(extracted from /proc/net/wireless) on Linux platforms.
+ */
+
+#include <app-common/zap-generated/enums.h>
+#include <platform/webos/ConnectivityUtils.h>
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+#include <linux/ethtool.h>
+#include <linux/if_link.h>
+#include <linux/sockios.h>
+#include <linux/wireless.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <lib/core/CHIPEncoding.h>
+#include <lib/support/CodeUtils.h>
+
+using namespace ::chip::app::Clusters::GeneralDiagnostics;
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+uint16_t ConnectivityUtils::Map2400MHz(const uint8_t inChannel)
+{
+    uint16_t frequency = 0;
+
+    if (inChannel >= 1 && inChannel <= 13)
+    {
+        frequency = static_cast<uint16_t>(2412 + ((inChannel - 1) * 5));
+    }
+    else if (inChannel == 14)
+    {
+        frequency = 2484;
+    }
+
+    return frequency;
+}
+
+uint16_t ConnectivityUtils::Map5000MHz(const uint8_t inChannel)
+{
+    uint16_t frequency = 0;
+
+    switch (inChannel)
+    {
+    case 183:
+        frequency = 4915;
+        break;
+    case 184:
+        frequency = 4920;
+        break;
+    case 185:
+        frequency = 4925;
+        break;
+    case 187:
+        frequency = 4935;
+        break;
+    case 188:
+        frequency = 4940;
+        break;
+    case 189:
+        frequency = 4945;
+        break;
+    case 192:
+        frequency = 4960;
+        break;
+    case 196:
+        frequency = 4980;
+        break;
+    case 7:
+        frequency = 5035;
+        break;
+    case 8:
+        frequency = 5040;
+        break;
+    case 9:
+        frequency = 5045;
+        break;
+    case 11:
+        frequency = 5055;
+        break;
+    case 12:
+        frequency = 5060;
+        break;
+    case 16:
+        frequency = 5080;
+        break;
+    case 34:
+        frequency = 5170;
+        break;
+    case 36:
+        frequency = 5180;
+        break;
+    case 38:
+        frequency = 5190;
+        break;
+    case 40:
+        frequency = 5200;
+        break;
+    case 42:
+        frequency = 5210;
+        break;
+    case 44:
+        frequency = 5220;
+        break;
+    case 46:
+        frequency = 5230;
+        break;
+    case 48:
+        frequency = 5240;
+        break;
+    case 52:
+        frequency = 5260;
+        break;
+    case 56:
+        frequency = 5280;
+        break;
+    case 60:
+        frequency = 5300;
+        break;
+    case 64:
+        frequency = 5320;
+        break;
+    case 100:
+        frequency = 5500;
+        break;
+    case 104:
+        frequency = 5520;
+        break;
+    case 108:
+        frequency = 5540;
+        break;
+    case 112:
+        frequency = 5560;
+        break;
+    case 116:
+        frequency = 5580;
+        break;
+    case 120:
+        frequency = 5600;
+        break;
+    case 124:
+        frequency = 5620;
+        break;
+    case 128:
+        frequency = 5640;
+        break;
+    case 132:
+        frequency = 5660;
+        break;
+    case 136:
+        frequency = 5680;
+        break;
+    case 140:
+        frequency = 5700;
+        break;
+    case 149:
+        frequency = 5745;
+        break;
+    case 153:
+        frequency = 5765;
+        break;
+    case 157:
+        frequency = 5785;
+        break;
+    case 161:
+        frequency = 5805;
+        break;
+    case 165:
+        frequency = 5825;
+        break;
+    }
+
+    return frequency;
+}
+
+uint16_t ConnectivityUtils::MapChannelToFrequency(const uint16_t inBand, const uint8_t inChannel)
+{
+    uint16_t frequency = 0;
+
+    if (inBand == kWiFi_BAND_2_4_GHZ)
+    {
+        frequency = Map2400MHz(inChannel);
+    }
+    else if (inBand == kWiFi_BAND_5_0_GHZ)
+    {
+        frequency = Map5000MHz(inChannel);
+    }
+
+    return frequency;
+}
+
+uint8_t ConnectivityUtils::MapFrequencyToChannel(const uint16_t frequency)
+{
+    if (frequency < 2412)
+        return 0;
+
+    if (frequency < 2484)
+        return (frequency - 2407) / 5;
+
+    if (frequency == 2484)
+        return 14;
+
+    return frequency / 5 - 1000;
+}
+
+double ConnectivityUtils::ConvertFrequenceToFloat(const iw_freq * in)
+{
+    double result = (double) in->m;
+
+    for (int i = 0; i < in->e; i++)
+        result *= 10;
+
+    return result;
+}
+
+InterfaceType ConnectivityUtils::GetInterfaceConnectionType(const char * ifname)
+{
+    InterfaceType ret = InterfaceType::EMBER_ZCL_INTERFACE_TYPE_UNSPECIFIED;
+    int sock          = -1;
+
+    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to open socket");
+        return InterfaceType::EMBER_ZCL_INTERFACE_TYPE_UNSPECIFIED;
+    }
+
+    // Test wireless extensions for CONNECTION_WIFI
+    struct iwreq pwrq = {};
+    strncpy(pwrq.ifr_name, ifname, IFNAMSIZ - 1);
+
+    if (ioctl(sock, SIOCGIWNAME, &pwrq) != -1)
+    {
+        ret = InterfaceType::EMBER_ZCL_INTERFACE_TYPE_WI_FI;
+    }
+    else if ((strncmp(ifname, "en", 2) == 0) || (strncmp(ifname, "eth", 3) == 0))
+    {
+        struct ethtool_cmd ecmd = {};
+        ecmd.cmd                = ETHTOOL_GSET;
+        struct ifreq ifr        = {};
+        ifr.ifr_data            = reinterpret_cast<char *>(&ecmd);
+        strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
+
+        if (ioctl(sock, SIOCETHTOOL, &ifr) != -1)
+            ret = InterfaceType::EMBER_ZCL_INTERFACE_TYPE_ETHERNET;
+    }
+
+    close(sock);
+
+    return ret;
+}
+
+CHIP_ERROR ConnectivityUtils::GetInterfaceHardwareAddrs(const char * ifname, uint8_t * buf, size_t bufSize)
+{
+    CHIP_ERROR err = CHIP_ERROR_READ_FAILED;
+    int skfd;
+
+    if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        ChipLogError(DeviceLayer, "Failed to create a channel to the NET kernel.");
+        return CHIP_ERROR_OPEN_FAILED;
+    }
+
+    if (ifname[0] != '\0')
+    {
+        struct ifreq req;
+
+        strcpy(req.ifr_name, ifname);
+        if (ioctl(skfd, SIOCGIFHWADDR, &req) != -1)
+        {
+            // Copy 48-bit IEEE MAC Address
+            VerifyOrReturnError(bufSize >= 6, CHIP_ERROR_BUFFER_TOO_SMALL);
+
+            memset(buf, 0, bufSize);
+            memcpy(buf, req.ifr_ifru.ifru_hwaddr.sa_data, 6);
+            err = CHIP_NO_ERROR;
+        }
+    }
+
+    close(skfd);
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityUtils::GetWiFiInterfaceName(char * ifname, size_t bufSize)
+{
+    CHIP_ERROR err          = CHIP_ERROR_READ_FAILED;
+    struct ifaddrs * ifaddr = nullptr;
+
+    if (getifaddrs(&ifaddr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to get network interfaces");
+    }
+    else
+    {
+        struct ifaddrs * ifa = nullptr;
+
+        /* Walk through linked list, maintaining head pointer so we
+          can free list later */
+        for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (GetInterfaceConnectionType(ifa->ifa_name) == InterfaceType::EMBER_ZCL_INTERFACE_TYPE_WI_FI)
+            {
+                strncpy(ifname, ifa->ifa_name, bufSize);
+                ifname[bufSize - 1] = '\0';
+                err                 = CHIP_NO_ERROR;
+                break;
+            }
+        }
+
+        freeifaddrs(ifaddr);
+    }
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityUtils::GetWiFiParameter(int skfd,            /* Socket to the kernel */
+                                               const char * ifname, /* Device name */
+                                               int request,         /* WE ID */
+                                               struct iwreq * pwrq) /* Fixed part of the request */
+{
+    /* Set device name */
+    strncpy(pwrq->ifr_name, ifname, IFNAMSIZ);
+
+    /* Do the request */
+    if (ioctl(skfd, request, pwrq) < 0)
+    {
+        return CHIP_ERROR_BAD_REQUEST;
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR ConnectivityUtils::GetWiFiStats(int skfd, const char * ifname, struct iw_statistics * stats)
+{
+    struct iwreq wrq;
+
+    wrq.u.data.pointer = (caddr_t) stats;
+    wrq.u.data.length  = sizeof(struct iw_statistics);
+    wrq.u.data.flags   = 1; /*Clear updated flag */
+    strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+
+    return GetWiFiParameter(skfd, ifname, SIOCGIWSTATS, &wrq);
+}
+
+CHIP_ERROR ConnectivityUtils::GetWiFiChannelNumber(const char * ifname, uint16_t & channelNumber)
+{
+    CHIP_ERROR err = CHIP_ERROR_READ_FAILED;
+
+    struct iwreq wrq;
+    int skfd;
+
+    if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        ChipLogError(DeviceLayer, "Failed to create a channel to the NET kernel.");
+        return CHIP_ERROR_OPEN_FAILED;
+    }
+
+    if (GetWiFiParameter(skfd, ifname, SIOCGIWFREQ, &wrq) == CHIP_NO_ERROR)
+    {
+        double freq = ConvertFrequenceToFloat(&(wrq.u.freq));
+        VerifyOrReturnError((freq / 1000000) <= UINT16_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+        channelNumber = MapFrequencyToChannel(static_cast<uint16_t>(freq / 1000000));
+
+        err = CHIP_NO_ERROR;
+    }
+
+    close(skfd);
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityUtils::GetWiFiRssi(const char * ifname, int8_t & rssi)
+{
+    CHIP_ERROR err = CHIP_ERROR_READ_FAILED;
+    struct iw_statistics stats;
+    int skfd;
+
+    if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        ChipLogError(DeviceLayer, "Failed to create a channel to the NET kernel.");
+        return CHIP_ERROR_OPEN_FAILED;
+    }
+
+    if (GetWiFiStats(skfd, ifname, &stats) == CHIP_NO_ERROR)
+    {
+        struct iw_quality * qual = &stats.qual;
+
+        /* Check if the statistics are in RCPI (IEEE 802.11k) */
+        if (qual->updated & IW_QUAL_RCPI)
+        { /* Deal with signal level in RCPI */
+            /* RCPI = int{(Power in dBm +110)*2} for 0dbm > Power > -110dBm */
+            if (!(qual->updated & IW_QUAL_LEVEL_INVALID))
+            {
+                double rcpilevel = (qual->level / 2.0) - 110.0;
+                VerifyOrReturnError(rcpilevel <= INT8_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+                rssi = static_cast<int8_t>(rcpilevel);
+                err  = CHIP_NO_ERROR;
+            }
+        }
+        else
+        { /* Check if the statistics are in dBm */
+            if (qual->updated & IW_QUAL_DBM)
+            { /* Deal with signal level in dBm  (absolute power measurement) */
+                if (!(qual->updated & IW_QUAL_LEVEL_INVALID))
+                {
+                    int dblevel = qual->level;
+                    /* Implement a range for dBm[-192; 63] */
+                    if (qual->level >= 64)
+                        dblevel -= 0x100;
+
+                    VerifyOrReturnError(dblevel <= INT8_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+                    rssi = static_cast<int8_t>(dblevel);
+                    err  = CHIP_NO_ERROR;
+                }
+            }
+            else
+            { /* Deal with signal level as relative value (0 -> max) */
+                if (!(qual->updated & IW_QUAL_LEVEL_INVALID))
+                {
+                    VerifyOrReturnError(qual->level <= INT8_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+                    rssi = static_cast<int8_t>(qual->level);
+                    err  = CHIP_NO_ERROR;
+                }
+            }
+        }
+    }
+
+    close(skfd);
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityUtils::GetWiFiBeaconLostCount(const char * ifname, uint32_t & beaconLostCount)
+{
+    CHIP_ERROR err = CHIP_ERROR_READ_FAILED;
+    struct iw_statistics stats;
+    int skfd;
+
+    if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        ChipLogError(DeviceLayer, "Failed to create a channel to the NET kernel.");
+        return CHIP_ERROR_OPEN_FAILED;
+    }
+
+    if (GetWiFiStats(skfd, ifname, &stats) == CHIP_NO_ERROR)
+    {
+        beaconLostCount = stats.miss.beacon;
+        err             = CHIP_NO_ERROR;
+    }
+
+    close(skfd);
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityUtils::GetWiFiCurrentMaxRate(const char * ifname, uint64_t & currentMaxRate)
+{
+    CHIP_ERROR err = CHIP_ERROR_READ_FAILED;
+    struct iwreq wrq;
+    int skfd;
+
+    if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        ChipLogError(DeviceLayer, "Failed to create a channel to the NET kernel.");
+        return CHIP_ERROR_OPEN_FAILED;
+    }
+
+    if (GetWiFiParameter(skfd, ifname, SIOCGIWRATE, &wrq) == CHIP_NO_ERROR)
+    {
+        currentMaxRate = wrq.u.bitrate.value;
+        err            = CHIP_NO_ERROR;
+    }
+
+    close(skfd);
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityUtils::GetEthInterfaceName(char * ifname, size_t bufSize)
+{
+    CHIP_ERROR err          = CHIP_ERROR_READ_FAILED;
+    struct ifaddrs * ifaddr = nullptr;
+
+    if (getifaddrs(&ifaddr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to get network interfaces");
+    }
+    else
+    {
+        struct ifaddrs * ifa = nullptr;
+
+        /* Walk through linked list, maintaining head pointer so we
+          can free list later */
+        for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (GetInterfaceConnectionType(ifa->ifa_name) == InterfaceType::EMBER_ZCL_INTERFACE_TYPE_ETHERNET)
+            {
+                strncpy(ifname, ifa->ifa_name, bufSize);
+                ifname[bufSize - 1] = '\0';
+                err                 = CHIP_NO_ERROR;
+                break;
+            }
+        }
+
+        freeifaddrs(ifaddr);
+    }
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityUtils::GetEthPHYRate(const char * ifname, uint8_t & pHYRate)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    int skfd;
+    uint32_t speed          = 0;
+    struct ethtool_cmd ecmd = {};
+    ecmd.cmd                = ETHTOOL_GSET;
+    struct ifreq ifr        = {};
+
+    ifr.ifr_data = reinterpret_cast<char *>(&ecmd);
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
+
+    if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        ChipLogError(DeviceLayer, "Failed to create a channel to the NET kernel.");
+        return CHIP_ERROR_OPEN_FAILED;
+    }
+
+    if (ioctl(skfd, SIOCETHTOOL, &ifr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Cannot get device settings");
+        close(skfd);
+        return CHIP_ERROR_READ_FAILED;
+    }
+
+    speed = (ecmd.speed_hi << 16) | ecmd.speed;
+    switch (speed)
+    {
+    case 10:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_10_M);
+        break;
+    case 100:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_100_M);
+        break;
+    case 1000:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_1000_M);
+        break;
+    case 25000:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_2__5_G);
+        break;
+    case 5000:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_5_G);
+        break;
+    case 10000:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_10_G);
+        break;
+    case 40000:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_40_G);
+        break;
+    case 100000:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_100_G);
+        break;
+    case 200000:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_200_G);
+        break;
+    case 400000:
+        pHYRate = static_cast<uint8_t>(EmberAfPHYRateType::EMBER_ZCL_PHY_RATE_TYPE_400_G);
+        break;
+    default:
+        ChipLogError(DeviceLayer, "Undefined speed! (%d)\n", speed);
+        err = CHIP_ERROR_READ_FAILED;
+        break;
+    };
+
+    close(skfd);
+
+    return err;
+}
+
+CHIP_ERROR ConnectivityUtils::GetEthFullDuplex(const char * ifname, bool & fullDuplex)
+{
+    CHIP_ERROR err = CHIP_ERROR_READ_FAILED;
+
+    int skfd;
+    struct ethtool_cmd ecmd = {};
+    ecmd.cmd                = ETHTOOL_GSET;
+    struct ifreq ifr        = {};
+
+    ifr.ifr_data = reinterpret_cast<char *>(&ecmd);
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
+
+    if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+    {
+        ChipLogError(DeviceLayer, "Failed to create a channel to the NET kernel.");
+        return CHIP_ERROR_OPEN_FAILED;
+    }
+
+    if (ioctl(skfd, SIOCETHTOOL, &ifr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Cannot get device settings");
+        err = CHIP_ERROR_READ_FAILED;
+    }
+    else
+    {
+        fullDuplex = (ecmd.duplex == DUPLEX_FULL) ? true : false;
+        err        = CHIP_NO_ERROR;
+    }
+
+    close(skfd);
+
+    return err;
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/ConnectivityUtils.h b/src/platform/webos/ConnectivityUtils.h
new file mode 100644
index 000000000..328a69f05
--- /dev/null
+++ b/src/platform/webos/ConnectivityUtils.h
@@ -0,0 +1,66 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Utilities for accessing parameters of the network interface and the wireless
+ *          statistics(extracted from /proc/net/wireless) on Linux platforms.
+ */
+
+#pragma once
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+#include <linux/types.h> /* for "caddr_t" et al      */
+#include <linux/wireless.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+static constexpr uint16_t kWiFi_BAND_2_4_GHZ      = 2400;
+static constexpr uint16_t kWiFi_BAND_5_0_GHZ      = 5000;
+static constexpr char kWpaSupplicantServiceName[] = "fi.w1.wpa_supplicant1";
+static constexpr char kWpaSupplicantObjectPath[]  = "/fi/w1/wpa_supplicant1";
+
+class ConnectivityUtils
+{
+public:
+    static uint16_t MapChannelToFrequency(const uint16_t inBand, const uint8_t inChannel);
+    static uint8_t MapFrequencyToChannel(const uint16_t frequency);
+    static app::Clusters::GeneralDiagnostics::InterfaceType GetInterfaceConnectionType(const char * ifname);
+    static CHIP_ERROR GetInterfaceHardwareAddrs(const char * ifname, uint8_t * buf, size_t bufSize);
+    static CHIP_ERROR GetWiFiInterfaceName(char * ifname, size_t bufSize);
+    static CHIP_ERROR GetWiFiChannelNumber(const char * ifname, uint16_t & channelNumber);
+    static CHIP_ERROR GetWiFiRssi(const char * ifname, int8_t & rssi);
+    static CHIP_ERROR GetWiFiBeaconLostCount(const char * ifname, uint32_t & beaconLostCount);
+    static CHIP_ERROR GetWiFiCurrentMaxRate(const char * ifname, uint64_t & currentMaxRate);
+    static CHIP_ERROR GetEthInterfaceName(char * ifname, size_t bufSize);
+    static CHIP_ERROR GetEthPHYRate(const char * ifname, uint8_t & pHYRate);
+    static CHIP_ERROR GetEthFullDuplex(const char * ifname, bool & fullDuplex);
+
+private:
+    static uint16_t Map2400MHz(const uint8_t inChannel);
+    static uint16_t Map5000MHz(const uint8_t inChannel);
+    static double ConvertFrequenceToFloat(const iw_freq * in);
+    static CHIP_ERROR GetWiFiParameter(int skfd, const char * ifname, int request, struct iwreq * pwrq);
+    static CHIP_ERROR GetWiFiStats(int skfd, const char * ifname, struct iw_statistics * stats);
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/DeviceNetworkProvisioningDelegateImpl.cpp b/src/platform/webos/DeviceNetworkProvisioningDelegateImpl.cpp
new file mode 100644
index 000000000..11bfe89cf
--- /dev/null
+++ b/src/platform/webos/DeviceNetworkProvisioningDelegateImpl.cpp
@@ -0,0 +1,47 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#include <lib/support/ErrorStr.h>
+#include <lib/support/logging/CHIPLogging.h>
+
+#include "DeviceNetworkProvisioningDelegateImpl.h"
+
+namespace chip {
+namespace DeviceLayer {
+
+CHIP_ERROR DeviceNetworkProvisioningDelegateImpl::_ProvisionWiFiNetwork(const char * ssid, const char * key)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    ChipLogProgress(NetworkProvisioning, "LinuxNetworkProvisioningDelegate: SSID: %s", ssid);
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+    err = ConnectivityMgrImpl().ProvisionWiFiNetwork(ssid, key);
+#else
+    err = CHIP_ERROR_NOT_IMPLEMENTED;
+#endif
+
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(NetworkProvisioning, "Failed to connect to WiFi network: %s", chip::ErrorStr(err));
+    }
+
+    return err;
+}
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/DeviceNetworkProvisioningDelegateImpl.h b/src/platform/webos/DeviceNetworkProvisioningDelegateImpl.h
new file mode 100644
index 000000000..47c9f0f6e
--- /dev/null
+++ b/src/platform/webos/DeviceNetworkProvisioningDelegateImpl.h
@@ -0,0 +1,43 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <platform/internal/GenericDeviceNetworkProvisioningDelegateImpl.h>
+
+namespace chip {
+namespace DeviceLayer {
+
+namespace Internal {
+
+template <class ImplClass>
+class GenericDeviceNetworkProvisioningDelegateImpl;
+
+} // namespace Internal
+
+class DeviceNetworkProvisioningDelegateImpl final
+    : public Internal::GenericDeviceNetworkProvisioningDelegateImpl<DeviceNetworkProvisioningDelegateImpl>
+{
+    friend class GenericDeviceNetworkProvisioningDelegateImpl<DeviceNetworkProvisioningDelegateImpl>;
+
+private:
+    CHIP_ERROR _ProvisionWiFiNetwork(const char * ssid, const char * passwd);
+    CHIP_ERROR _ProvisionThreadNetwork(ByteSpan threadData) { return CHIP_ERROR_NOT_IMPLEMENTED; }
+};
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/DiagnosticDataProviderImpl.cpp b/src/platform/webos/DiagnosticDataProviderImpl.cpp
new file mode 100644
index 000000000..566b8ffed
--- /dev/null
+++ b/src/platform/webos/DiagnosticDataProviderImpl.cpp
@@ -0,0 +1,790 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the DiagnosticDataProvider object
+ *          for Linux platform.
+ */
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+#include <app-common/zap-generated/enums.h>
+#include <lib/support/CHIPMem.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <platform/DiagnosticDataProvider.h>
+#include <platform/webos/ConnectivityUtils.h>
+#include <platform/webos/DiagnosticDataProviderImpl.h>
+
+#include <arpa/inet.h>
+#include <dirent.h>
+#include <ifaddrs.h>
+#include <linux/ethtool.h>
+#include <linux/if_link.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <malloc.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+using namespace ::chip;
+using namespace ::chip::TLV;
+using namespace ::chip::DeviceLayer;
+using namespace ::chip::DeviceLayer::Internal;
+using namespace ::chip::app::Clusters::GeneralDiagnostics;
+
+namespace {
+
+enum class EthernetStatsCountType
+{
+    kEthPacketRxCount,
+    kEthPacketTxCount,
+    kEthTxErrCount,
+    kEthCollisionCount,
+    kEthOverrunCount
+};
+
+enum class WiFiStatsCountType
+{
+    kWiFiUnicastPacketRxCount,
+    kWiFiUnicastPacketTxCount,
+    kWiFiMulticastPacketRxCount,
+    kWiFiMulticastPacketTxCount,
+    kWiFiOverrunCount
+};
+
+CHIP_ERROR GetEthernetStatsCount(EthernetStatsCountType type, uint64_t & count)
+{
+    CHIP_ERROR err          = CHIP_ERROR_READ_FAILED;
+    struct ifaddrs * ifaddr = nullptr;
+
+    if (getifaddrs(&ifaddr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to get network interfaces");
+    }
+    else
+    {
+        struct ifaddrs * ifa = nullptr;
+
+        // Walk through linked list, maintaining head pointer so we can free list later.
+        for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (ConnectivityUtils::GetInterfaceConnectionType(ifa->ifa_name) == InterfaceType::EMBER_ZCL_INTERFACE_TYPE_ETHERNET)
+            {
+                ChipLogProgress(DeviceLayer, "Found the primary Ethernet interface:%s", ifa->ifa_name);
+                break;
+            }
+        }
+
+        if (ifa != nullptr)
+        {
+            if (ifa->ifa_addr->sa_family == AF_PACKET && ifa->ifa_data != nullptr)
+            {
+                struct rtnl_link_stats * stats = (struct rtnl_link_stats *) ifa->ifa_data;
+                switch (type)
+                {
+                case EthernetStatsCountType::kEthPacketRxCount:
+                    count = stats->rx_packets;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                case EthernetStatsCountType::kEthPacketTxCount:
+                    count = stats->tx_packets;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                case EthernetStatsCountType::kEthTxErrCount:
+                    count = stats->tx_errors;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                case EthernetStatsCountType::kEthCollisionCount:
+                    count = stats->collisions;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                case EthernetStatsCountType::kEthOverrunCount:
+                    count = stats->rx_over_errors;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                default:
+                    ChipLogError(DeviceLayer, "Unknown Ethernet statistic metric type");
+                    break;
+                }
+            }
+        }
+
+        freeifaddrs(ifaddr);
+    }
+
+    return err;
+}
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+CHIP_ERROR GetWiFiStatsCount(WiFiStatsCountType type, uint64_t & count)
+{
+    CHIP_ERROR err          = CHIP_ERROR_READ_FAILED;
+    struct ifaddrs * ifaddr = nullptr;
+
+    if (getifaddrs(&ifaddr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to get network interfaces");
+    }
+    else
+    {
+        struct ifaddrs * ifa = nullptr;
+
+        // Walk through linked list, maintaining head pointer so we can free list later.
+        for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (ConnectivityUtils::GetInterfaceConnectionType(ifa->ifa_name) == InterfaceType::EMBER_ZCL_INTERFACE_TYPE_WI_FI)
+            {
+                ChipLogProgress(DeviceLayer, "Found the primary WiFi interface:%s", ifa->ifa_name);
+                break;
+            }
+        }
+
+        if (ifa != nullptr)
+        {
+            if (ifa->ifa_addr->sa_family == AF_PACKET && ifa->ifa_data != nullptr)
+            {
+                // The usecase of this function is embedded devices,on which we can interact with the WiFi
+                // driver to get the accurate number of muticast and unicast packets accurately.
+                // On Linux simulation, we can only get the total packets received, the total bytes transmitted,
+                // the multicast packets received and receiver ring buff overflow.
+
+                struct rtnl_link_stats * stats = (struct rtnl_link_stats *) ifa->ifa_data;
+                switch (type)
+                {
+                case WiFiStatsCountType::kWiFiUnicastPacketRxCount:
+                    count = stats->rx_packets;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                case WiFiStatsCountType::kWiFiUnicastPacketTxCount:
+                    count = stats->tx_packets;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                case WiFiStatsCountType::kWiFiMulticastPacketRxCount:
+                    count = stats->multicast;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                case WiFiStatsCountType::kWiFiMulticastPacketTxCount:
+                    count = 0;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                case WiFiStatsCountType::kWiFiOverrunCount:
+                    count = stats->rx_over_errors;
+                    err   = CHIP_NO_ERROR;
+                    break;
+                default:
+                    ChipLogError(DeviceLayer, "Unknown WiFi statistic metric type");
+                    break;
+                }
+            }
+        }
+
+        freeifaddrs(ifaddr);
+    }
+
+    return err;
+}
+#endif // #if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+
+} // namespace
+
+namespace chip {
+namespace DeviceLayer {
+
+DiagnosticDataProviderImpl & DiagnosticDataProviderImpl::GetDefaultInstance()
+{
+    static DiagnosticDataProviderImpl sInstance;
+    return sInstance;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetCurrentHeapFree(uint64_t & currentHeapFree)
+{
+    struct mallinfo mallocInfo = mallinfo();
+
+    // Get the current amount of heap memory, in bytes, that are not being utilized
+    // by the current running program.
+    currentHeapFree = mallocInfo.fordblks;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetCurrentHeapUsed(uint64_t & currentHeapUsed)
+{
+    struct mallinfo mallocInfo = mallinfo();
+
+    // Get the current amount of heap memory, in bytes, that are being used by
+    // the current running program.
+    currentHeapUsed = mallocInfo.uordblks;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetCurrentHeapHighWatermark(uint64_t & currentHeapHighWatermark)
+{
+    struct mallinfo mallocInfo = mallinfo();
+
+    // The usecase of this function is embedded devices,on which we would need to intercept
+    // malloc/calloc/free and then record the maximum amount of heap memory,in bytes, that
+    // has been used by the Node.
+    // On Linux, since it uses virtual memory, whereby a page of memory could be copied to
+    // the hard disk, called swap space, and free up that page of memory. So it is impossible
+    // to know accurately peak physical memory it use. We just return the current heap memory
+    // being used by the current running program.
+    currentHeapHighWatermark = mallocInfo.uordblks;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetThreadMetrics(ThreadMetrics ** threadMetricsOut)
+{
+    CHIP_ERROR err = CHIP_ERROR_READ_FAILED;
+    DIR * proc_dir = opendir("/proc/self/task");
+
+    if (proc_dir == nullptr)
+    {
+        ChipLogError(DeviceLayer, "Failed to open current process task directory");
+    }
+    else
+    {
+        ThreadMetrics * head = nullptr;
+        struct dirent * entry;
+
+        /* proc available, iterate through tasks... */
+        while ((entry = readdir(proc_dir)) != NULL)
+        {
+            if (entry->d_name[0] == '.')
+                continue;
+
+            ThreadMetrics * thread = new ThreadMetrics();
+
+            strncpy(thread->NameBuf, entry->d_name, kMaxThreadNameLength);
+            thread->NameBuf[kMaxThreadNameLength] = '\0';
+            thread->name                          = CharSpan(thread->NameBuf, strlen(thread->NameBuf));
+            thread->id                            = atoi(entry->d_name);
+
+            // TODO: Get stack info of each thread
+            thread->stackFreeCurrent = 0;
+            thread->stackFreeMinimum = 0;
+            thread->stackSize        = 0;
+
+            thread->Next = head;
+            head         = thread;
+        }
+
+        closedir(proc_dir);
+
+        *threadMetricsOut = head;
+        err               = CHIP_NO_ERROR;
+    }
+
+    return err;
+}
+
+void DiagnosticDataProviderImpl::ReleaseThreadMetrics(ThreadMetrics * threadMetrics)
+{
+    while (threadMetrics)
+    {
+        ThreadMetrics * del = threadMetrics;
+        threadMetrics       = threadMetrics->Next;
+        delete del;
+    }
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetRebootCount(uint16_t & rebootCount)
+{
+    uint32_t count = 0;
+
+    CHIP_ERROR err = ConfigurationMgr().GetRebootCount(count);
+
+    if (err == CHIP_NO_ERROR)
+    {
+        VerifyOrReturnError(count <= UINT16_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+        rebootCount = static_cast<uint16_t>(count);
+    }
+
+    return err;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetUpTime(uint64_t & upTime)
+{
+    System::Clock::Timestamp currentTime = System::SystemClock().GetMonotonicTimestamp();
+    System::Clock::Timestamp startTime   = PlatformMgrImpl().GetStartTime();
+
+    if (currentTime >= startTime)
+    {
+        upTime = std::chrono::duration_cast<System::Clock::Seconds64>(currentTime - startTime).count();
+        return CHIP_NO_ERROR;
+    }
+
+    return CHIP_ERROR_INVALID_TIME;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetTotalOperationalHours(uint32_t & totalOperationalHours)
+{
+    uint64_t upTime = 0;
+
+    if (GetUpTime(upTime) == CHIP_NO_ERROR)
+    {
+        uint32_t totalHours = 0;
+        if (ConfigurationMgr().GetTotalOperationalHours(totalHours) == CHIP_NO_ERROR)
+        {
+            VerifyOrReturnError(upTime / 3600 <= UINT32_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+            totalOperationalHours = totalHours + static_cast<uint32_t>(upTime / 3600);
+            return CHIP_NO_ERROR;
+        }
+    }
+
+    return CHIP_ERROR_INVALID_TIME;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetBootReason(uint8_t & bootReason)
+{
+    uint32_t reason = 0;
+
+    CHIP_ERROR err = ConfigurationMgr().GetBootReason(reason);
+
+    if (err == CHIP_NO_ERROR)
+    {
+        VerifyOrReturnError(reason <= UINT8_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+        bootReason = static_cast<uint8_t>(reason);
+    }
+
+    return err;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetActiveHardwareFaults(GeneralFaults<kMaxHardwareFaults> & hardwareFaults)
+{
+#if CHIP_CONFIG_TEST
+    // On Linux Simulation, set following hardware faults statically.
+    ReturnErrorOnFailure(hardwareFaults.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_RADIO));
+    ReturnErrorOnFailure(hardwareFaults.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_SENSOR));
+    ReturnErrorOnFailure(hardwareFaults.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_POWER_SOURCE));
+    ReturnErrorOnFailure(hardwareFaults.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_USER_INTERFACE_FAULT));
+#endif
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetActiveRadioFaults(GeneralFaults<kMaxRadioFaults> & radioFaults)
+{
+#if CHIP_CONFIG_TEST
+    // On Linux Simulation, set following radio faults statically.
+    ReturnErrorOnFailure(radioFaults.add(EMBER_ZCL_RADIO_FAULT_TYPE_WI_FI_FAULT));
+    ReturnErrorOnFailure(radioFaults.add(EMBER_ZCL_RADIO_FAULT_TYPE_CELLULAR_FAULT));
+    ReturnErrorOnFailure(radioFaults.add(EMBER_ZCL_RADIO_FAULT_TYPE_THREAD_FAULT));
+    ReturnErrorOnFailure(radioFaults.add(EMBER_ZCL_RADIO_FAULT_TYPE_NFC_FAULT));
+#endif
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetActiveNetworkFaults(GeneralFaults<kMaxNetworkFaults> & networkFaults)
+{
+#if CHIP_CONFIG_TEST
+    // On Linux Simulation, set following radio faults statically.
+    ReturnErrorOnFailure(networkFaults.add(EMBER_ZCL_NETWORK_FAULT_TYPE_HARDWARE_FAILURE));
+    ReturnErrorOnFailure(networkFaults.add(EMBER_ZCL_NETWORK_FAULT_TYPE_NETWORK_JAMMED));
+    ReturnErrorOnFailure(networkFaults.add(EMBER_ZCL_NETWORK_FAULT_TYPE_CONNECTION_FAILED));
+#endif
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetNetworkInterfaces(NetworkInterface ** netifpp)
+{
+    CHIP_ERROR err          = CHIP_ERROR_READ_FAILED;
+    struct ifaddrs * ifaddr = nullptr;
+
+    if (getifaddrs(&ifaddr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to get network interfaces");
+    }
+    else
+    {
+        NetworkInterface * head = nullptr;
+
+        // Walk through linked list, maintaining head pointer so we can free list later.
+        for (struct ifaddrs * ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (ifa->ifa_addr && ifa->ifa_addr->sa_family == AF_PACKET)
+            {
+                NetworkInterface * ifp = new NetworkInterface();
+
+                strncpy(ifp->Name, ifa->ifa_name, Inet::InterfaceId::kMaxIfNameLength);
+                ifp->Name[Inet::InterfaceId::kMaxIfNameLength - 1] = '\0';
+
+                ifp->name                            = CharSpan(ifp->Name, strlen(ifp->Name));
+                ifp->fabricConnected                 = ifa->ifa_flags & IFF_RUNNING;
+                ifp->type                            = ConnectivityUtils::GetInterfaceConnectionType(ifa->ifa_name);
+                ifp->offPremiseServicesReachableIPv4 = false;
+                ifp->offPremiseServicesReachableIPv6 = false;
+
+                if (ConnectivityUtils::GetInterfaceHardwareAddrs(ifa->ifa_name, ifp->MacAddress, kMaxHardwareAddrSize) !=
+                    CHIP_NO_ERROR)
+                {
+                    ChipLogError(DeviceLayer, "Failed to get network hardware address");
+                }
+                else
+                {
+                    // Set 48-bit IEEE MAC Address
+                    ifp->hardwareAddress = ByteSpan(ifp->MacAddress, 6);
+                }
+
+                ifp->Next = head;
+                head      = ifp;
+            }
+        }
+
+        *netifpp = head;
+        err      = CHIP_NO_ERROR;
+
+        freeifaddrs(ifaddr);
+    }
+
+    return err;
+}
+
+void DiagnosticDataProviderImpl::ReleaseNetworkInterfaces(NetworkInterface * netifp)
+{
+    while (netifp)
+    {
+        NetworkInterface * del = netifp;
+        netifp                 = netifp->Next;
+        delete del;
+    }
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetEthPHYRate(uint8_t & pHYRate)
+{
+    if (ConnectivityMgrImpl().GetEthernetIfName() == nullptr)
+    {
+        return CHIP_ERROR_READ_FAILED;
+    }
+
+    return ConnectivityUtils::GetEthPHYRate(ConnectivityMgrImpl().GetEthernetIfName(), pHYRate);
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetEthFullDuplex(bool & fullDuplex)
+{
+    if (ConnectivityMgrImpl().GetEthernetIfName() == nullptr)
+    {
+        return CHIP_ERROR_READ_FAILED;
+    }
+
+    return ConnectivityUtils::GetEthFullDuplex(ConnectivityMgrImpl().GetEthernetIfName(), fullDuplex);
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetEthTimeSinceReset(uint64_t & timeSinceReset)
+{
+    return GetDiagnosticDataProvider().GetUpTime(timeSinceReset);
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetEthPacketRxCount(uint64_t & packetRxCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetEthernetStatsCount(EthernetStatsCountType::kEthPacketRxCount, count));
+    VerifyOrReturnError(count >= mEthPacketRxCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    packetRxCount = count - mEthPacketRxCount;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetEthPacketTxCount(uint64_t & packetTxCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetEthernetStatsCount(EthernetStatsCountType::kEthPacketTxCount, count));
+    VerifyOrReturnError(count >= mEthPacketTxCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    packetTxCount = count - mEthPacketTxCount;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetEthTxErrCount(uint64_t & txErrCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetEthernetStatsCount(EthernetStatsCountType::kEthTxErrCount, count));
+    VerifyOrReturnError(count >= mEthTxErrCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    txErrCount = count - mEthTxErrCount;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetEthCollisionCount(uint64_t & collisionCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetEthernetStatsCount(EthernetStatsCountType::kEthCollisionCount, count));
+    VerifyOrReturnError(count >= mEthCollisionCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    collisionCount = count - mEthCollisionCount;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetEthOverrunCount(uint64_t & overrunCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetEthernetStatsCount(EthernetStatsCountType::kEthOverrunCount, count));
+    VerifyOrReturnError(count >= mEthOverrunCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    overrunCount = count - mEthOverrunCount;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::ResetEthNetworkDiagnosticsCounts()
+{
+    CHIP_ERROR err          = CHIP_ERROR_READ_FAILED;
+    struct ifaddrs * ifaddr = nullptr;
+
+    if (getifaddrs(&ifaddr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to get network interfaces");
+    }
+    else
+    {
+        struct ifaddrs * ifa = nullptr;
+
+        // Walk through linked list, maintaining head pointer so we can free list later.
+        for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (ConnectivityUtils::GetInterfaceConnectionType(ifa->ifa_name) == InterfaceType::EMBER_ZCL_INTERFACE_TYPE_ETHERNET)
+            {
+                ChipLogProgress(DeviceLayer, "Found the primary Ethernet interface:%s", ifa->ifa_name);
+                break;
+            }
+        }
+
+        if (ifa != nullptr)
+        {
+            if (ifa->ifa_addr->sa_family == AF_PACKET && ifa->ifa_data != nullptr)
+            {
+                struct rtnl_link_stats * stats = (struct rtnl_link_stats *) ifa->ifa_data;
+
+                mEthPacketRxCount  = stats->rx_packets;
+                mEthPacketTxCount  = stats->tx_packets;
+                mEthTxErrCount     = stats->tx_errors;
+                mEthCollisionCount = stats->collisions;
+                mEthOverrunCount   = stats->rx_over_errors;
+                err                = CHIP_NO_ERROR;
+            }
+        }
+
+        freeifaddrs(ifaddr);
+    }
+
+    return err;
+}
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiChannelNumber(uint16_t & channelNumber)
+{
+    if (ConnectivityMgrImpl().GetWiFiIfName() == nullptr)
+    {
+        return CHIP_ERROR_READ_FAILED;
+    }
+
+    return ConnectivityUtils::GetWiFiChannelNumber(ConnectivityMgrImpl().GetWiFiIfName(), channelNumber);
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiRssi(int8_t & rssi)
+{
+    if (ConnectivityMgrImpl().GetWiFiIfName() == nullptr)
+    {
+        return CHIP_ERROR_READ_FAILED;
+    }
+
+    return ConnectivityUtils::GetWiFiRssi(ConnectivityMgrImpl().GetWiFiIfName(), rssi);
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiBeaconLostCount(uint32_t & beaconLostCount)
+{
+    uint32_t count;
+
+    if (ConnectivityMgrImpl().GetWiFiIfName() == nullptr)
+    {
+        return CHIP_ERROR_READ_FAILED;
+    }
+
+    ReturnErrorOnFailure(ConnectivityUtils::GetWiFiBeaconLostCount(ConnectivityMgrImpl().GetWiFiIfName(), count));
+    VerifyOrReturnError(count >= mBeaconLostCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+    beaconLostCount = count - mBeaconLostCount;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiCurrentMaxRate(uint64_t & currentMaxRate)
+{
+    if (ConnectivityMgrImpl().GetWiFiIfName() == nullptr)
+    {
+        return CHIP_ERROR_READ_FAILED;
+    }
+
+    return ConnectivityUtils::GetWiFiCurrentMaxRate(ConnectivityMgrImpl().GetWiFiIfName(), currentMaxRate);
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiPacketMulticastRxCount(uint32_t & packetMulticastRxCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetWiFiStatsCount(WiFiStatsCountType::kWiFiMulticastPacketRxCount, count));
+    VerifyOrReturnError(count >= mPacketMulticastRxCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    count -= mPacketMulticastRxCount;
+    VerifyOrReturnError(count <= UINT32_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    packetMulticastRxCount = static_cast<uint32_t>(count);
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiPacketMulticastTxCount(uint32_t & packetMulticastTxCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetWiFiStatsCount(WiFiStatsCountType::kWiFiMulticastPacketTxCount, count));
+    VerifyOrReturnError(count >= mPacketMulticastTxCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    count -= mPacketMulticastTxCount;
+    VerifyOrReturnError(count <= UINT32_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    packetMulticastTxCount = static_cast<uint32_t>(count);
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiPacketUnicastRxCount(uint32_t & packetUnicastRxCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetWiFiStatsCount(WiFiStatsCountType::kWiFiUnicastPacketRxCount, count));
+    VerifyOrReturnError(count >= mPacketUnicastRxCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    count -= mPacketUnicastRxCount;
+    VerifyOrReturnError(count <= UINT32_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    packetUnicastRxCount = static_cast<uint32_t>(count);
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiPacketUnicastTxCount(uint32_t & packetUnicastTxCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetWiFiStatsCount(WiFiStatsCountType::kWiFiUnicastPacketTxCount, count));
+    VerifyOrReturnError(count >= mPacketUnicastTxCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    count -= mPacketUnicastTxCount;
+    VerifyOrReturnError(count <= UINT32_MAX, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    packetUnicastTxCount = static_cast<uint32_t>(count);
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiOverrunCount(uint64_t & overrunCount)
+{
+    uint64_t count;
+
+    ReturnErrorOnFailure(GetWiFiStatsCount(WiFiStatsCountType::kWiFiOverrunCount, count));
+    VerifyOrReturnError(count >= mOverrunCount, CHIP_ERROR_INVALID_INTEGER_VALUE);
+
+    overrunCount = count - mOverrunCount;
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::ResetWiFiNetworkDiagnosticsCounts()
+{
+    CHIP_ERROR err          = CHIP_ERROR_READ_FAILED;
+    struct ifaddrs * ifaddr = nullptr;
+
+    ReturnErrorOnFailure(GetWiFiBeaconLostCount(mBeaconLostCount));
+
+    if (getifaddrs(&ifaddr) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to get network interfaces");
+    }
+    else
+    {
+        struct ifaddrs * ifa = nullptr;
+
+        // Walk through linked list, maintaining head pointer so we can free list later.
+        for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next)
+        {
+            if (ConnectivityUtils::GetInterfaceConnectionType(ifa->ifa_name) == InterfaceType::EMBER_ZCL_INTERFACE_TYPE_WI_FI)
+            {
+                ChipLogProgress(DeviceLayer, "Found the primary WiFi interface:%s", ifa->ifa_name);
+                break;
+            }
+        }
+
+        if (ifa != nullptr)
+        {
+            if (ifa->ifa_addr->sa_family == AF_PACKET && ifa->ifa_data != nullptr)
+            {
+                struct rtnl_link_stats * stats = (struct rtnl_link_stats *) ifa->ifa_data;
+
+                mPacketMulticastRxCount = stats->multicast;
+                mPacketMulticastTxCount = 0;
+                mPacketUnicastRxCount   = stats->rx_packets;
+                mPacketUnicastTxCount   = stats->tx_packets;
+                mOverrunCount           = stats->rx_over_errors;
+
+                err = CHIP_NO_ERROR;
+            }
+        }
+
+        freeifaddrs(ifaddr);
+    }
+
+    return err;
+}
+#endif // CHIP_DEVICE_CONFIG_ENABLE_WIFI
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiVersion(uint8_t & wiFiVersion)
+{
+    return ConnectivityMgrImpl().GetWiFiVersion(wiFiVersion);
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiBssId(ByteSpan & value)
+{
+    return ConnectivityMgrImpl().GetWiFiBssId(value);
+}
+
+CHIP_ERROR DiagnosticDataProviderImpl::GetWiFiSecurityType(uint8_t & securityType)
+{
+    return ConnectivityMgrImpl().GetWiFiSecurityType(securityType);
+}
+#endif // CHIP_DEVICE_CONFIG_ENABLE_WPA
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/DiagnosticDataProviderImpl.h b/src/platform/webos/DiagnosticDataProviderImpl.h
new file mode 100644
index 000000000..db5475188
--- /dev/null
+++ b/src/platform/webos/DiagnosticDataProviderImpl.h
@@ -0,0 +1,107 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the DiagnosticDataProvider object.
+ */
+
+#pragma once
+
+#include <memory>
+
+#include <platform/DiagnosticDataProvider.h>
+
+namespace chip {
+namespace DeviceLayer {
+
+/**
+ * Concrete implementation of the PlatformManager singleton object for Linux platforms.
+ */
+class DiagnosticDataProviderImpl : public DiagnosticDataProvider
+{
+public:
+    static DiagnosticDataProviderImpl & GetDefaultInstance();
+
+    // ===== Methods that implement the PlatformManager abstract interface.
+
+    CHIP_ERROR GetCurrentHeapFree(uint64_t & currentHeapFree) override;
+    CHIP_ERROR GetCurrentHeapUsed(uint64_t & currentHeapUsed) override;
+    CHIP_ERROR GetCurrentHeapHighWatermark(uint64_t & currentHeapHighWatermark) override;
+    CHIP_ERROR GetThreadMetrics(ThreadMetrics ** threadMetricsOut) override;
+    void ReleaseThreadMetrics(ThreadMetrics * threadMetrics) override;
+
+    CHIP_ERROR GetRebootCount(uint16_t & rebootCount) override;
+    CHIP_ERROR GetUpTime(uint64_t & upTime) override;
+    CHIP_ERROR GetTotalOperationalHours(uint32_t & totalOperationalHours) override;
+    CHIP_ERROR GetBootReason(uint8_t & bootReason) override;
+
+    CHIP_ERROR GetActiveHardwareFaults(GeneralFaults<kMaxHardwareFaults> & hardwareFaults) override;
+    CHIP_ERROR GetActiveRadioFaults(GeneralFaults<kMaxRadioFaults> & radioFaults) override;
+    CHIP_ERROR GetActiveNetworkFaults(GeneralFaults<kMaxNetworkFaults> & networkFaults) override;
+
+    CHIP_ERROR GetNetworkInterfaces(NetworkInterface ** netifpp) override;
+    void ReleaseNetworkInterfaces(NetworkInterface * netifp) override;
+
+    CHIP_ERROR GetEthPHYRate(uint8_t & pHYRate) override;
+    CHIP_ERROR GetEthFullDuplex(bool & fullDuplex) override;
+    CHIP_ERROR GetEthTimeSinceReset(uint64_t & timeSinceReset) override;
+    CHIP_ERROR GetEthPacketRxCount(uint64_t & packetRxCount) override;
+    CHIP_ERROR GetEthPacketTxCount(uint64_t & packetTxCount) override;
+    CHIP_ERROR GetEthTxErrCount(uint64_t & txErrCount) override;
+    CHIP_ERROR GetEthCollisionCount(uint64_t & collisionCount) override;
+    CHIP_ERROR GetEthOverrunCount(uint64_t & overrunCount) override;
+    CHIP_ERROR ResetEthNetworkDiagnosticsCounts() override;
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+    CHIP_ERROR GetWiFiChannelNumber(uint16_t & channelNumber) override;
+    CHIP_ERROR GetWiFiRssi(int8_t & rssi) override;
+    CHIP_ERROR GetWiFiBeaconLostCount(uint32_t & beaconLostCount) override;
+    CHIP_ERROR GetWiFiPacketMulticastRxCount(uint32_t & packetMulticastRxCount) override;
+    CHIP_ERROR GetWiFiPacketMulticastTxCount(uint32_t & packetMulticastTxCount) override;
+    CHIP_ERROR GetWiFiPacketUnicastRxCount(uint32_t & packetUnicastRxCount) override;
+    CHIP_ERROR GetWiFiPacketUnicastTxCount(uint32_t & packetUnicastTxCount) override;
+    CHIP_ERROR GetWiFiCurrentMaxRate(uint64_t & currentMaxRate) override;
+    CHIP_ERROR GetWiFiOverrunCount(uint64_t & overrunCount) override;
+    CHIP_ERROR ResetWiFiNetworkDiagnosticsCounts() override;
+#endif
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WPA
+    CHIP_ERROR GetWiFiVersion(uint8_t & wiFiVersion) override;
+    CHIP_ERROR GetWiFiBssId(ByteSpan & value) override;
+    CHIP_ERROR GetWiFiSecurityType(uint8_t & securityType) override;
+#endif
+
+private:
+    uint64_t mEthPacketRxCount  = 0;
+    uint64_t mEthPacketTxCount  = 0;
+    uint64_t mEthTxErrCount     = 0;
+    uint64_t mEthCollisionCount = 0;
+    uint64_t mEthOverrunCount   = 0;
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+    uint32_t mBeaconLostCount        = 0;
+    uint32_t mPacketMulticastRxCount = 0;
+    uint32_t mPacketMulticastTxCount = 0;
+    uint32_t mPacketUnicastRxCount   = 0;
+    uint32_t mPacketUnicastTxCount   = 0;
+    uint64_t mOverrunCount           = 0;
+#endif
+};
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/DnssdImpl.cpp b/src/platform/webos/DnssdImpl.cpp
new file mode 100644
index 000000000..7709a8eee
--- /dev/null
+++ b/src/platform/webos/DnssdImpl.cpp
@@ -0,0 +1,850 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#include "DnssdImpl.h"
+
+#include <algorithm>
+#include <sstream>
+#include <string.h>
+#include <time.h>
+#include <vector>
+
+#include <netinet/in.h>
+
+#include <lib/support/CHIPMem.h>
+#include <lib/support/CHIPMemString.h>
+#include <lib/support/CodeUtils.h>
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+#include <system/SystemLayer.h>
+
+using chip::Dnssd::DnssdServiceProtocol;
+using chip::Dnssd::kDnssdTypeMaxSize;
+using chip::Dnssd::TextEntry;
+using chip::System::SocketEvents;
+using std::chrono::duration_cast;
+using std::chrono::microseconds;
+using std::chrono::seconds;
+using std::chrono::steady_clock;
+
+namespace {
+
+AvahiProtocol ToAvahiProtocol(chip::Inet::IPAddressType addressType)
+{
+    AvahiProtocol protocol;
+
+    switch (addressType)
+    {
+#if INET_CONFIG_ENABLE_IPV4
+    case chip::Inet::IPAddressType::kIPv4:
+        protocol = AVAHI_PROTO_INET;
+        break;
+#endif
+    case chip::Inet::IPAddressType::kIPv6:
+        protocol = AVAHI_PROTO_INET6;
+        break;
+    default:
+        protocol = AVAHI_PROTO_UNSPEC;
+        break;
+    }
+
+    return protocol;
+}
+
+chip::Inet::IPAddressType ToAddressType(AvahiProtocol protocol)
+{
+    chip::Inet::IPAddressType type;
+
+    switch (protocol)
+    {
+#if INET_CONFIG_ENABLE_IPV4
+    case AVAHI_PROTO_INET:
+        type = chip::Inet::IPAddressType::kIPv4;
+        break;
+#endif
+    case AVAHI_PROTO_INET6:
+        type = chip::Inet::IPAddressType::kIPv6;
+        break;
+    default:
+        type = chip::Inet::IPAddressType::kUnknown;
+        break;
+    }
+
+    return type;
+}
+
+AvahiWatchEvent ToAvahiWatchEvent(SocketEvents events)
+{
+    return static_cast<AvahiWatchEvent>((events.Has(chip::System::SocketEventFlags::kRead) ? AVAHI_WATCH_IN : 0) |
+                                        (events.Has(chip::System::SocketEventFlags::kWrite) ? AVAHI_WATCH_OUT : 0) |
+                                        (events.Has(chip::System::SocketEventFlags::kError) ? AVAHI_WATCH_ERR : 0));
+}
+
+void AvahiWatchCallbackTrampoline(chip::System::SocketEvents events, intptr_t data)
+{
+    AvahiWatch * const watch = reinterpret_cast<AvahiWatch *>(data);
+    watch->mPendingIO        = ToAvahiWatchEvent(events);
+    watch->mCallback(watch, watch->mSocket, watch->mPendingIO, watch->mContext);
+}
+
+CHIP_ERROR MakeAvahiStringListFromTextEntries(TextEntry * entries, size_t size, AvahiStringList ** strListOut)
+{
+    *strListOut = avahi_string_list_new(nullptr, nullptr);
+
+    for (size_t i = 0; i < size; i++)
+    {
+        uint8_t buf[chip::Dnssd::kDnssdTextMaxSize];
+        size_t offset = static_cast<size_t>(snprintf(reinterpret_cast<char *>(buf), sizeof(buf), "%s=", entries[i].mKey));
+
+        if (offset + entries[i].mDataSize > sizeof(buf))
+        {
+            avahi_string_list_free(*strListOut);
+            *strListOut = nullptr;
+            return CHIP_ERROR_INVALID_ARGUMENT;
+        }
+
+        memcpy(&buf[offset], entries[i].mData, entries[i].mDataSize);
+        *strListOut = avahi_string_list_add_arbitrary(*strListOut, buf, offset + entries[i].mDataSize);
+    }
+    return CHIP_NO_ERROR;
+}
+
+const char * GetProtocolString(DnssdServiceProtocol protocol)
+{
+    return protocol == DnssdServiceProtocol::kDnssdProtocolUdp ? "_udp" : "_tcp";
+}
+
+std::string GetFullType(const char * type, DnssdServiceProtocol protocol)
+{
+    std::ostringstream typeBuilder;
+    typeBuilder << type << "." << GetProtocolString(protocol);
+    return typeBuilder.str();
+}
+
+} // namespace
+
+namespace chip {
+namespace Dnssd {
+
+MdnsAvahi MdnsAvahi::sInstance;
+
+Poller::Poller()
+{
+    mAvahiPoller.userdata         = this;
+    mAvahiPoller.watch_new        = WatchNew;
+    mAvahiPoller.watch_update     = WatchUpdate;
+    mAvahiPoller.watch_get_events = WatchGetEvents;
+    mAvahiPoller.watch_free       = WatchFree;
+
+    mAvahiPoller.timeout_new    = TimeoutNew;
+    mAvahiPoller.timeout_update = TimeoutUpdate;
+    mAvahiPoller.timeout_free   = TimeoutFree;
+
+    mEarliestTimeout = std::chrono::steady_clock::time_point();
+}
+
+AvahiWatch * Poller::WatchNew(const struct AvahiPoll * poller, int fd, AvahiWatchEvent event, AvahiWatchCallback callback,
+                              void * context)
+{
+    return reinterpret_cast<Poller *>(poller->userdata)->WatchNew(fd, event, callback, context);
+}
+
+AvahiWatch * Poller::WatchNew(int fd, AvahiWatchEvent event, AvahiWatchCallback callback, void * context)
+{
+    VerifyOrDie(callback != nullptr && fd >= 0);
+
+    auto watch     = std::make_unique<AvahiWatch>();
+    watch->mSocket = fd;
+    LogErrorOnFailure(DeviceLayer::SystemLayerSockets().StartWatchingSocket(fd, &watch->mSocketWatch));
+    LogErrorOnFailure(DeviceLayer::SystemLayerSockets().SetCallback(watch->mSocketWatch, AvahiWatchCallbackTrampoline,
+                                                                    reinterpret_cast<intptr_t>(watch.get())));
+    WatchUpdate(watch.get(), event);
+    watch->mCallback = callback;
+    watch->mContext  = context;
+    watch->mPoller   = this;
+    mWatches.emplace_back(std::move(watch));
+
+    return mWatches.back().get();
+}
+
+void Poller::WatchUpdate(AvahiWatch * watch, AvahiWatchEvent event)
+{
+    if (event & AVAHI_WATCH_IN)
+    {
+        LogErrorOnFailure(DeviceLayer::SystemLayerSockets().RequestCallbackOnPendingRead(watch->mSocketWatch));
+    }
+    else
+    {
+        LogErrorOnFailure(DeviceLayer::SystemLayerSockets().ClearCallbackOnPendingRead(watch->mSocketWatch));
+    }
+    if (event & AVAHI_WATCH_OUT)
+    {
+        LogErrorOnFailure(DeviceLayer::SystemLayerSockets().RequestCallbackOnPendingWrite(watch->mSocketWatch));
+    }
+    else
+    {
+        LogErrorOnFailure(DeviceLayer::SystemLayerSockets().ClearCallbackOnPendingWrite(watch->mSocketWatch));
+    }
+}
+
+AvahiWatchEvent Poller::WatchGetEvents(AvahiWatch * watch)
+{
+    return watch->mPendingIO;
+}
+
+void Poller::WatchFree(AvahiWatch * watch)
+{
+    reinterpret_cast<Poller *>(watch->mPoller)->WatchFree(*watch);
+}
+
+void Poller::WatchFree(AvahiWatch & watch)
+{
+    DeviceLayer::SystemLayerSockets().StopWatchingSocket(&watch.mSocketWatch);
+    mWatches.erase(std::remove_if(mWatches.begin(), mWatches.end(),
+                                  [&watch](const std::unique_ptr<AvahiWatch> & aValue) { return aValue.get() == &watch; }),
+                   mWatches.end());
+}
+
+AvahiTimeout * Poller::TimeoutNew(const AvahiPoll * poller, const struct timeval * timeout, AvahiTimeoutCallback callback,
+                                  void * context)
+{
+    VerifyOrDie(poller != nullptr && callback != nullptr);
+
+    return static_cast<Poller *>(poller->userdata)->TimeoutNew(timeout, callback, context);
+}
+
+steady_clock::time_point GetAbsTimeout(const struct timeval * timeout)
+{
+    steady_clock::time_point now        = steady_clock::now();
+    steady_clock::time_point absTimeout = now;
+
+    if (timeout != nullptr)
+    {
+        absTimeout += seconds(timeout->tv_sec);
+        absTimeout += microseconds(timeout->tv_usec);
+    }
+
+    return absTimeout;
+}
+
+AvahiTimeout * Poller::TimeoutNew(const struct timeval * timeout, AvahiTimeoutCallback callback, void * context)
+{
+    mTimers.emplace_back(new AvahiTimeout{ GetAbsTimeout(timeout), callback, timeout != nullptr, context, this });
+    AvahiTimeout * timer = mTimers.back().get();
+    SystemTimerUpdate(timer);
+    return timer;
+}
+
+void Poller::TimeoutUpdate(AvahiTimeout * timer, const struct timeval * timeout)
+{
+    if (timeout)
+    {
+        timer->mAbsTimeout = GetAbsTimeout(timeout);
+        timer->mEnabled    = true;
+        static_cast<Poller *>(timer->mPoller)->SystemTimerUpdate(timer);
+    }
+    else
+    {
+        timer->mEnabled = false;
+    }
+}
+
+void Poller::TimeoutFree(AvahiTimeout * timer)
+{
+    static_cast<Poller *>(timer->mPoller)->TimeoutFree(*timer);
+}
+
+void Poller::TimeoutFree(AvahiTimeout & timer)
+{
+    mTimers.erase(std::remove_if(mTimers.begin(), mTimers.end(),
+                                 [&timer](const std::unique_ptr<AvahiTimeout> & aValue) { return aValue.get() == &timer; }),
+                  mTimers.end());
+}
+
+void Poller::SystemTimerCallback(System::Layer * layer, void * data)
+{
+    static_cast<Poller *>(data)->HandleTimeout();
+}
+
+void Poller::HandleTimeout()
+{
+    mEarliestTimeout             = std::chrono::steady_clock::time_point();
+    steady_clock::time_point now = steady_clock::now();
+
+    AvahiTimeout * earliest = nullptr;
+    for (auto && timer : mTimers)
+    {
+        if (!timer->mEnabled)
+        {
+            continue;
+        }
+        if (timer->mAbsTimeout <= now)
+        {
+            timer->mCallback(timer.get(), timer->mContext);
+        }
+        else
+        {
+            if ((earliest == nullptr) || (timer->mAbsTimeout < earliest->mAbsTimeout))
+            {
+                earliest = timer.get();
+            }
+        }
+    }
+    if (earliest)
+    {
+        SystemTimerUpdate(earliest);
+    }
+}
+
+void Poller::SystemTimerUpdate(AvahiTimeout * timer)
+{
+    if ((mEarliestTimeout == std::chrono::steady_clock::time_point()) || (timer->mAbsTimeout < mEarliestTimeout))
+    {
+        mEarliestTimeout = timer->mAbsTimeout;
+        auto delay       = std::chrono::duration_cast<chip::System::Clock::Milliseconds32>(steady_clock::now() - mEarliestTimeout);
+        DeviceLayer::SystemLayer().StartTimer(delay, SystemTimerCallback, this);
+    }
+}
+
+CHIP_ERROR MdnsAvahi::Init(DnssdAsyncReturnCallback initCallback, DnssdAsyncReturnCallback errorCallback, void * context)
+{
+    CHIP_ERROR error = CHIP_NO_ERROR;
+    int avahiError   = 0;
+
+    VerifyOrExit(initCallback != nullptr, error = CHIP_ERROR_INVALID_ARGUMENT);
+    VerifyOrExit(errorCallback != nullptr, error = CHIP_ERROR_INVALID_ARGUMENT);
+    VerifyOrExit(mClient == nullptr && mGroup == nullptr, error = CHIP_ERROR_INCORRECT_STATE);
+    mInitCallback       = initCallback;
+    mErrorCallback      = errorCallback;
+    mAsyncReturnContext = context;
+    mClient             = avahi_client_new(mPoller.GetAvahiPoll(), AVAHI_CLIENT_NO_FAIL, HandleClientState, this, &avahiError);
+    VerifyOrExit(mClient != nullptr, error = CHIP_ERROR_OPEN_FAILED);
+    VerifyOrExit(avahiError == 0, error = CHIP_ERROR_OPEN_FAILED);
+
+exit:
+    return error;
+}
+
+CHIP_ERROR MdnsAvahi::Shutdown()
+{
+    if (mGroup)
+    {
+        avahi_entry_group_free(mGroup);
+        mGroup = nullptr;
+    }
+    if (mClient)
+    {
+        avahi_client_free(mClient);
+        mClient = nullptr;
+    }
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR MdnsAvahi::SetHostname(const char * hostname)
+{
+    CHIP_ERROR error = CHIP_NO_ERROR;
+    int avahiRet;
+
+    VerifyOrExit(mClient != nullptr, error = CHIP_ERROR_INCORRECT_STATE);
+    avahiRet = avahi_client_set_host_name(mClient, hostname);
+    if (avahiRet == AVAHI_ERR_ACCESS_DENIED)
+    {
+        ChipLogError(DeviceLayer, "Cannot set hostname on this system, continue anyway...");
+    }
+    else if (avahiRet != AVAHI_OK && avahiRet != AVAHI_ERR_NO_CHANGE)
+    {
+        error = CHIP_ERROR_INTERNAL;
+    }
+
+exit:
+    return error;
+}
+
+void MdnsAvahi::HandleClientState(AvahiClient * client, AvahiClientState state, void * context)
+{
+    static_cast<MdnsAvahi *>(context)->HandleClientState(client, state);
+}
+
+void MdnsAvahi::HandleClientState(AvahiClient * client, AvahiClientState state)
+{
+    switch (state)
+    {
+    case AVAHI_CLIENT_S_RUNNING:
+        ChipLogProgress(DeviceLayer, "Avahi client registered");
+        mClient = client;
+        mGroup  = avahi_entry_group_new(client, HandleGroupState, this);
+        if (mGroup == nullptr)
+        {
+            ChipLogError(DeviceLayer, "Failed to create avahi group: %s", avahi_strerror(avahi_client_errno(client)));
+            mInitCallback(mAsyncReturnContext, CHIP_ERROR_OPEN_FAILED);
+        }
+        else
+        {
+            mInitCallback(mAsyncReturnContext, CHIP_NO_ERROR);
+        }
+        break;
+    case AVAHI_CLIENT_FAILURE:
+        ChipLogError(DeviceLayer, "Avahi client failure");
+        mErrorCallback(mAsyncReturnContext, CHIP_ERROR_INTERNAL);
+        break;
+    case AVAHI_CLIENT_S_COLLISION:
+    case AVAHI_CLIENT_S_REGISTERING:
+        ChipLogProgress(DeviceLayer, "Avahi re-register required");
+        if (mGroup != nullptr)
+        {
+            avahi_entry_group_reset(mGroup);
+            avahi_entry_group_free(mGroup);
+        }
+        mGroup = avahi_entry_group_new(client, HandleGroupState, this);
+        mPublishedServices.clear();
+        if (mGroup == nullptr)
+        {
+            ChipLogError(DeviceLayer, "Failed to create avahi group: %s", avahi_strerror(avahi_client_errno(client)));
+            mErrorCallback(mAsyncReturnContext, CHIP_ERROR_OPEN_FAILED);
+        }
+        else
+        {
+            mErrorCallback(mAsyncReturnContext, CHIP_ERROR_FORCED_RESET);
+        }
+        break;
+    case AVAHI_CLIENT_CONNECTING:
+        ChipLogProgress(DeviceLayer, "Avahi connecting");
+        break;
+    }
+}
+
+void MdnsAvahi::HandleGroupState(AvahiEntryGroup * group, AvahiEntryGroupState state, void * context)
+{
+    static_cast<MdnsAvahi *>(context)->HandleGroupState(group, state);
+}
+
+void MdnsAvahi::HandleGroupState(AvahiEntryGroup * group, AvahiEntryGroupState state)
+{
+    switch (state)
+    {
+    case AVAHI_ENTRY_GROUP_ESTABLISHED:
+        ChipLogProgress(DeviceLayer, "Avahi group established");
+        break;
+    case AVAHI_ENTRY_GROUP_COLLISION:
+        ChipLogError(DeviceLayer, "Avahi group collision");
+        mErrorCallback(mAsyncReturnContext, CHIP_ERROR_MDNS_COLLISION);
+        break;
+    case AVAHI_ENTRY_GROUP_FAILURE:
+        ChipLogError(DeviceLayer, "Avahi group internal failure %s",
+                     avahi_strerror(avahi_client_errno(avahi_entry_group_get_client(mGroup))));
+        mErrorCallback(mAsyncReturnContext, CHIP_ERROR_INTERNAL);
+        break;
+    case AVAHI_ENTRY_GROUP_UNCOMMITED:
+    case AVAHI_ENTRY_GROUP_REGISTERING:
+        break;
+    }
+}
+
+CHIP_ERROR MdnsAvahi::PublishService(const DnssdService & service)
+{
+    std::ostringstream keyBuilder;
+    std::string key;
+    std::string type       = GetFullType(service.mType, service.mProtocol);
+    CHIP_ERROR error       = CHIP_NO_ERROR;
+    AvahiStringList * text = nullptr;
+    AvahiIfIndex interface =
+        service.mInterface.IsPresent() ? static_cast<AvahiIfIndex>(service.mInterface.GetPlatformInterface()) : AVAHI_IF_UNSPEC;
+
+    keyBuilder << service.mName << "." << type << service.mPort << "." << interface;
+    key = keyBuilder.str();
+    ChipLogProgress(DeviceLayer, "PublishService %s", key.c_str());
+
+    if (mPublishedServices.find(key) == mPublishedServices.end())
+    {
+        SuccessOrExit(error = MakeAvahiStringListFromTextEntries(service.mTextEntries, service.mTextEntrySize, &text));
+
+        mPublishedServices.emplace(key);
+        VerifyOrExit(avahi_entry_group_add_service_strlst(mGroup, interface, ToAvahiProtocol(service.mAddressType),
+                                                          static_cast<AvahiPublishFlags>(0), service.mName, type.c_str(), nullptr,
+                                                          nullptr, service.mPort, text) == 0,
+                     error = CHIP_ERROR_INTERNAL);
+        for (size_t i = 0; i < service.mSubTypeSize; i++)
+        {
+            std::ostringstream sstream;
+
+            sstream << service.mSubTypes[i] << "._sub." << type;
+
+            VerifyOrExit(avahi_entry_group_add_service_subtype(mGroup, interface, ToAvahiProtocol(service.mAddressType),
+                                                               static_cast<AvahiPublishFlags>(0), service.mName, type.c_str(),
+                                                               nullptr, sstream.str().c_str()) == 0,
+                         error = CHIP_ERROR_INTERNAL);
+        }
+    }
+    else
+    {
+        SuccessOrExit(error = MakeAvahiStringListFromTextEntries(service.mTextEntries, service.mTextEntrySize, &text));
+
+        VerifyOrExit(avahi_entry_group_update_service_txt_strlst(mGroup, interface, ToAvahiProtocol(service.mAddressType),
+                                                                 static_cast<AvahiPublishFlags>(0), service.mName, type.c_str(),
+                                                                 nullptr, text) == 0,
+                     error = CHIP_ERROR_INTERNAL);
+    }
+
+    VerifyOrExit(avahi_entry_group_commit(mGroup) == 0, error = CHIP_ERROR_INTERNAL);
+
+exit:
+    if (text != nullptr)
+    {
+        avahi_string_list_free(text);
+    }
+    if (error != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Avahi publish service failed: %" CHIP_ERROR_FORMAT, error.Format());
+    }
+
+    return error;
+}
+
+CHIP_ERROR MdnsAvahi::StopPublish()
+{
+    CHIP_ERROR error = CHIP_NO_ERROR;
+    mPublishedServices.clear();
+    if (mGroup)
+    {
+        VerifyOrExit(avahi_entry_group_reset(mGroup) == 0, error = CHIP_ERROR_INTERNAL);
+    }
+exit:
+    return error;
+}
+
+CHIP_ERROR MdnsAvahi::Browse(const char * type, DnssdServiceProtocol protocol, chip::Inet::IPAddressType addressType,
+                             chip::Inet::InterfaceId interface, DnssdBrowseCallback callback, void * context)
+{
+    AvahiServiceBrowser * browser;
+    BrowseContext * browseContext = chip::Platform::New<BrowseContext>();
+    AvahiIfIndex avahiInterface   = static_cast<AvahiIfIndex>(interface.GetPlatformInterface());
+
+    browseContext->mInstance    = this;
+    browseContext->mContext     = context;
+    browseContext->mCallback    = callback;
+    browseContext->mAddressType = addressType;
+    if (!interface.IsPresent())
+    {
+        avahiInterface = AVAHI_IF_UNSPEC;
+    }
+
+    browser = avahi_service_browser_new(mClient, avahiInterface, AVAHI_PROTO_UNSPEC, GetFullType(type, protocol).c_str(), nullptr,
+                                        static_cast<AvahiLookupFlags>(0), HandleBrowse, browseContext);
+    // Otherwise the browser will be freed in the callback
+    if (browser == nullptr)
+    {
+        chip::Platform::Delete(browseContext);
+    }
+
+    return browser == nullptr ? CHIP_ERROR_INTERNAL : CHIP_NO_ERROR;
+}
+
+DnssdServiceProtocol GetProtocolInType(const char * type)
+{
+    const char * deliminator = strrchr(type, '.');
+
+    if (deliminator == NULL)
+    {
+        ChipLogError(Discovery, "Failed to find protocol in type: %s", type);
+        return DnssdServiceProtocol::kDnssdProtocolUnknown;
+    }
+
+    if (strcmp("._tcp", deliminator) == 0)
+    {
+        return DnssdServiceProtocol::kDnssdProtocolTcp;
+    }
+    if (strcmp("._udp", deliminator) == 0)
+    {
+        return DnssdServiceProtocol::kDnssdProtocolUdp;
+    }
+
+    ChipLogError(Discovery, "Unknown protocol in type: %s", type);
+    return DnssdServiceProtocol::kDnssdProtocolUnknown;
+}
+
+/// Copies the type from a string containing both type and protocol
+///
+/// e.g. if input is "foo.bar", output is "foo", input is 'a.b._tcp", output is "a.b"
+template <size_t N>
+void CopyTypeWithoutProtocol(char (&dest)[N], const char * typeAndProtocol)
+{
+    const char * dotPos          = strrchr(typeAndProtocol, '.');
+    size_t lengthWithoutProtocol = (dotPos != nullptr) ? static_cast<size_t>(dotPos - typeAndProtocol) : N;
+
+    Platform::CopyString(dest, typeAndProtocol);
+
+    /// above copied everything including the protocol. Truncate the protocol away.
+    if (lengthWithoutProtocol < N)
+    {
+        dest[lengthWithoutProtocol] = 0;
+    }
+}
+
+void MdnsAvahi::HandleBrowse(AvahiServiceBrowser * browser, AvahiIfIndex interface, AvahiProtocol protocol, AvahiBrowserEvent event,
+                             const char * name, const char * type, const char * domain, AvahiLookupResultFlags /*flags*/,
+                             void * userdata)
+{
+    BrowseContext * context = static_cast<BrowseContext *>(userdata);
+
+    switch (event)
+    {
+    case AVAHI_BROWSER_FAILURE:
+        context->mCallback(context->mContext, nullptr, 0, CHIP_ERROR_INTERNAL);
+        avahi_service_browser_free(browser);
+        chip::Platform::Delete(context);
+        break;
+    case AVAHI_BROWSER_NEW:
+        ChipLogProgress(DeviceLayer, "Avahi browse: cache new");
+        if (strcmp("local", domain) == 0)
+        {
+            DnssdService service = {};
+
+            Platform::CopyString(service.mName, name);
+            CopyTypeWithoutProtocol(service.mType, type);
+            service.mProtocol      = GetProtocolInType(type);
+            service.mAddressType   = context->mAddressType;
+            service.mTransportType = ToAddressType(protocol);
+            service.mInterface     = Inet::InterfaceId::Null();
+            if (interface != AVAHI_IF_UNSPEC)
+            {
+                service.mInterface = static_cast<chip::Inet::InterfaceId>(interface);
+            }
+            service.mType[kDnssdTypeMaxSize] = 0;
+            context->mServices.push_back(service);
+        }
+        break;
+    case AVAHI_BROWSER_ALL_FOR_NOW:
+        ChipLogProgress(DeviceLayer, "Avahi browse: all for now");
+        context->mCallback(context->mContext, context->mServices.data(), context->mServices.size(), CHIP_NO_ERROR);
+        avahi_service_browser_free(browser);
+        chip::Platform::Delete(context);
+        break;
+    case AVAHI_BROWSER_REMOVE:
+        ChipLogProgress(DeviceLayer, "Avahi browse: remove");
+        if (strcmp("local", domain) == 0)
+        {
+            std::remove_if(context->mServices.begin(), context->mServices.end(), [name, type](const DnssdService & service) {
+                return strcmp(name, service.mName) == 0 && type == GetFullType(service.mType, service.mProtocol);
+            });
+        }
+        break;
+    case AVAHI_BROWSER_CACHE_EXHAUSTED:
+        ChipLogProgress(DeviceLayer, "Avahi browse: cache exhausted");
+        break;
+    }
+}
+
+CHIP_ERROR MdnsAvahi::Resolve(const char * name, const char * type, DnssdServiceProtocol protocol, Inet::IPAddressType addressType,
+                              Inet::IPAddressType transportType, Inet::InterfaceId interface, DnssdResolveCallback callback,
+                              void * context)
+{
+    AvahiServiceResolver * resolver;
+    AvahiIfIndex avahiInterface     = static_cast<AvahiIfIndex>(interface.GetPlatformInterface());
+    ResolveContext * resolveContext = chip::Platform::New<ResolveContext>();
+    CHIP_ERROR error                = CHIP_NO_ERROR;
+
+    resolveContext->mInstance = this;
+    resolveContext->mCallback = callback;
+    resolveContext->mContext  = context;
+
+    if (!interface.IsPresent())
+    {
+        avahiInterface = AVAHI_IF_UNSPEC;
+    }
+
+    Platform::CopyString(resolveContext->mName, name);
+    resolveContext->mInterface   = avahiInterface;
+    resolveContext->mTransport   = ToAvahiProtocol(transportType);
+    resolveContext->mAddressType = ToAvahiProtocol(addressType);
+    resolveContext->mFullType    = GetFullType(type, protocol);
+
+    resolver = avahi_service_resolver_new(mClient, avahiInterface, resolveContext->mTransport, name,
+                                          resolveContext->mFullType.c_str(), nullptr, resolveContext->mAddressType,
+                                          static_cast<AvahiLookupFlags>(0), HandleResolve, resolveContext);
+    // Otherwise the resolver will be freed in the callback
+    if (resolver == nullptr)
+    {
+        error = CHIP_ERROR_INTERNAL;
+        chip::Platform::Delete(resolveContext);
+    }
+
+    return error;
+}
+
+void MdnsAvahi::HandleResolve(AvahiServiceResolver * resolver, AvahiIfIndex interface, AvahiProtocol protocol,
+                              AvahiResolverEvent event, const char * name, const char * type, const char * /*domain*/,
+                              const char * host_name, const AvahiAddress * address, uint16_t port, AvahiStringList * txt,
+                              AvahiLookupResultFlags flags, void * userdata)
+{
+    ResolveContext * context = reinterpret_cast<ResolveContext *>(userdata);
+    std::vector<TextEntry> textEntries;
+
+    switch (event)
+    {
+    case AVAHI_RESOLVER_FAILURE:
+        if (context->mAttempts++ < 3)
+        {
+            ChipLogProgress(DeviceLayer, "Re-trying resolve");
+            avahi_service_resolver_free(resolver);
+            resolver = avahi_service_resolver_new(context->mInstance->mClient, context->mInterface, context->mTransport,
+                                                  context->mName, context->mFullType.c_str(), nullptr, context->mAddressType,
+                                                  static_cast<AvahiLookupFlags>(0), HandleResolve, context);
+            if (resolver == nullptr)
+            {
+                ChipLogError(DeviceLayer, "Avahi resolve failed on retry");
+                context->mCallback(context->mContext, nullptr, CHIP_ERROR_INTERNAL);
+                chip::Platform::Delete(context);
+            }
+            return;
+        }
+        ChipLogError(DeviceLayer, "Avahi resolve failed");
+        context->mCallback(context->mContext, nullptr, CHIP_ERROR_INTERNAL);
+        break;
+    case AVAHI_RESOLVER_FOUND:
+        DnssdService result   = {};
+        CHIP_ERROR result_err = CHIP_NO_ERROR;
+
+        result.mAddress.SetValue(chip::Inet::IPAddress());
+        ChipLogError(DeviceLayer, "Avahi resolve found");
+
+        Platform::CopyString(result.mName, name);
+        CopyTypeWithoutProtocol(result.mType, type);
+        result.mProtocol    = GetProtocolInType(type);
+        result.mPort        = port;
+        result.mAddressType = ToAddressType(protocol);
+        result.mInterface   = Inet::InterfaceId::Null();
+        // It's not clear if we can get the actual value from avahi, so just assume default.
+        result.mTtlSeconds = AVAHI_DEFAULT_TTL_HOST_NAME;
+        if (interface != AVAHI_IF_UNSPEC)
+        {
+            result.mInterface = static_cast<chip::Inet::InterfaceId>(interface);
+        }
+        Platform::CopyString(result.mHostName, host_name);
+        // Returned value is full QName, want only host part.
+        char * dot = strchr(result.mHostName, '.');
+        if (dot != nullptr)
+        {
+            *dot = '\0';
+        }
+
+        if (address)
+        {
+            switch (address->proto)
+            {
+            case AVAHI_PROTO_INET:
+#if INET_CONFIG_ENABLE_IPV4
+                struct in_addr addr4;
+
+                memcpy(&addr4, &(address->data.ipv4), sizeof(addr4));
+                result.mAddress.SetValue(chip::Inet::IPAddress(addr4));
+#else
+                result_err = CHIP_ERROR_INVALID_ADDRESS;
+                ChipLogError(Discovery, "Ignoring IPv4 mDNS address.");
+#endif
+                break;
+            case AVAHI_PROTO_INET6:
+                struct in6_addr addr6;
+
+                memcpy(&addr6, &(address->data.ipv6), sizeof(addr6));
+                result.mAddress.SetValue(chip::Inet::IPAddress(addr6));
+                break;
+            default:
+                break;
+            }
+        }
+
+        while (txt != nullptr)
+        {
+            for (size_t i = 0; i < txt->size; i++)
+            {
+                if (txt->text[i] == '=')
+                {
+                    txt->text[i] = '\0';
+                    textEntries.push_back(TextEntry{ reinterpret_cast<char *>(txt->text), &txt->text[i + 1], txt->size - i - 1 });
+                    break;
+                }
+            }
+            txt = txt->next;
+        }
+
+        if (!textEntries.empty())
+        {
+            result.mTextEntries = textEntries.data();
+        }
+        result.mTextEntrySize = textEntries.size();
+
+        if (result_err == CHIP_NO_ERROR)
+        {
+            context->mCallback(context->mContext, &result, CHIP_NO_ERROR);
+        }
+        else
+        {
+            context->mCallback(context->mContext, nullptr, result_err);
+        }
+        break;
+    }
+
+    avahi_service_resolver_free(resolver);
+    chip::Platform::Delete(context);
+}
+
+CHIP_ERROR ChipDnssdInit(DnssdAsyncReturnCallback initCallback, DnssdAsyncReturnCallback errorCallback, void * context)
+{
+    return MdnsAvahi::GetInstance().Init(initCallback, errorCallback, context);
+}
+
+CHIP_ERROR ChipDnssdShutdown()
+{
+    return MdnsAvahi::GetInstance().Shutdown();
+}
+
+CHIP_ERROR ChipDnssdPublishService(const DnssdService * service)
+{
+    if (strcmp(service->mHostName, "") != 0)
+    {
+        ReturnErrorOnFailure(MdnsAvahi::GetInstance().SetHostname(service->mHostName));
+    }
+    return MdnsAvahi::GetInstance().PublishService(*service);
+}
+
+CHIP_ERROR ChipDnssdRemoveServices()
+{
+    return MdnsAvahi::GetInstance().StopPublish();
+}
+
+CHIP_ERROR ChipDnssdFinalizeServiceUpdate()
+{
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR ChipDnssdBrowse(const char * type, DnssdServiceProtocol protocol, chip::Inet::IPAddressType addressType,
+                           chip::Inet::InterfaceId interface, DnssdBrowseCallback callback, void * context)
+{
+    return MdnsAvahi::GetInstance().Browse(type, protocol, addressType, interface, callback, context);
+}
+
+CHIP_ERROR ChipDnssdResolve(DnssdService * browseResult, chip::Inet::InterfaceId interface, DnssdResolveCallback callback,
+                            void * context)
+
+{
+    VerifyOrReturnError(browseResult != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
+
+    return MdnsAvahi::GetInstance().Resolve(browseResult->mName, browseResult->mType, browseResult->mProtocol,
+                                            browseResult->mAddressType, Inet::IPAddressType::kAny, interface, callback, context);
+}
+
+} // namespace Dnssd
+} // namespace chip
diff --git a/src/platform/webos/DnssdImpl.h b/src/platform/webos/DnssdImpl.h
new file mode 100644
index 000000000..369ebfc56
--- /dev/null
+++ b/src/platform/webos/DnssdImpl.h
@@ -0,0 +1,173 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <sys/select.h>
+#include <unistd.h>
+
+#include <chrono>
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include <avahi-client/client.h>
+#include <avahi-client/lookup.h>
+#include <avahi-client/publish.h>
+#include <avahi-common/domain.h>
+#include <avahi-common/error.h>
+#include <avahi-common/watch.h>
+
+#include "lib/dnssd/platform/Dnssd.h"
+
+struct AvahiWatch
+{
+    int mSocket;
+    chip::System::SocketWatchToken mSocketWatch;
+    AvahiWatchCallback mCallback; ///< The function to be called when interested events happened on mFd.
+    AvahiWatchEvent mPendingIO;   ///< The pending events from the currently active or most recent callback.
+    void * mContext;              ///< A pointer to application-specific context.
+    void * mPoller;               ///< The poller created this watch.
+};
+
+struct AvahiTimeout
+{
+    std::chrono::steady_clock::time_point mAbsTimeout; ///< Absolute time when this timer timeout.
+    AvahiTimeoutCallback mCallback;                    ///< The function to be called when timeout.
+    bool mEnabled;                                     ///< Whether the timeout is enabled.
+    void * mContext;                                   ///< The pointer to application-specific context.
+    void * mPoller;                                    ///< The poller created this timer.
+};
+
+namespace chip {
+namespace Dnssd {
+
+class Poller
+{
+public:
+    Poller(void);
+
+    void HandleTimeout();
+
+    const AvahiPoll * GetAvahiPoll(void) const { return &mAvahiPoller; }
+
+private:
+    static AvahiWatch * WatchNew(const struct AvahiPoll * poller, int fd, AvahiWatchEvent event, AvahiWatchCallback callback,
+                                 void * context);
+    AvahiWatch * WatchNew(int fd, AvahiWatchEvent event, AvahiWatchCallback callback, void * context);
+
+    static void WatchUpdate(AvahiWatch * watch, AvahiWatchEvent event);
+
+    static AvahiWatchEvent WatchGetEvents(AvahiWatch * watch);
+
+    static void WatchFree(AvahiWatch * watch);
+    void WatchFree(AvahiWatch & watch);
+
+    static AvahiTimeout * TimeoutNew(const AvahiPoll * poller, const struct timeval * timeout, AvahiTimeoutCallback callback,
+                                     void * context);
+    AvahiTimeout * TimeoutNew(const struct timeval * timeout, AvahiTimeoutCallback callback, void * context);
+
+    static void TimeoutUpdate(AvahiTimeout * timer, const struct timeval * timeout);
+
+    static void TimeoutFree(AvahiTimeout * timer);
+    void TimeoutFree(AvahiTimeout & timer);
+
+    void SystemTimerUpdate(AvahiTimeout * timer);
+    static void SystemTimerCallback(System::Layer * layer, void * data);
+
+    std::vector<std::unique_ptr<AvahiWatch>> mWatches;
+    std::vector<std::unique_ptr<AvahiTimeout>> mTimers;
+    std::chrono::steady_clock::time_point mEarliestTimeout;
+
+    AvahiPoll mAvahiPoller;
+};
+
+class MdnsAvahi
+{
+public:
+    MdnsAvahi(const MdnsAvahi &) = delete;
+    MdnsAvahi & operator=(const MdnsAvahi &) = delete;
+
+    CHIP_ERROR Init(DnssdAsyncReturnCallback initCallback, DnssdAsyncReturnCallback errorCallback, void * context);
+    CHIP_ERROR Shutdown();
+    CHIP_ERROR SetHostname(const char * hostname);
+    CHIP_ERROR PublishService(const DnssdService & service);
+    CHIP_ERROR StopPublish();
+    CHIP_ERROR Browse(const char * type, DnssdServiceProtocol protocol, chip::Inet::IPAddressType addressType,
+                      chip::Inet::InterfaceId interface, DnssdBrowseCallback callback, void * context);
+    CHIP_ERROR Resolve(const char * name, const char * type, DnssdServiceProtocol protocol, chip::Inet::IPAddressType addressType,
+                       chip::Inet::IPAddressType transportType, chip::Inet::InterfaceId interface, DnssdResolveCallback callback,
+                       void * context);
+
+    Poller & GetPoller() { return mPoller; }
+
+    static MdnsAvahi & GetInstance() { return sInstance; }
+
+private:
+    struct BrowseContext
+    {
+        MdnsAvahi * mInstance;
+        DnssdBrowseCallback mCallback;
+        void * mContext;
+        Inet::IPAddressType mAddressType;
+        std::vector<DnssdService> mServices;
+    };
+
+    struct ResolveContext
+    {
+        MdnsAvahi * mInstance;
+        DnssdResolveCallback mCallback;
+        void * mContext;
+        char mName[Common::kInstanceNameMaxLength + 1];
+        AvahiIfIndex mInterface;
+        AvahiProtocol mTransport;
+        AvahiProtocol mAddressType;
+        std::string mFullType;
+        uint8_t mAttempts = 0;
+    };
+
+    MdnsAvahi() : mClient(nullptr), mGroup(nullptr) {}
+    static MdnsAvahi sInstance;
+
+    static void HandleClientState(AvahiClient * client, AvahiClientState state, void * context);
+    void HandleClientState(AvahiClient * client, AvahiClientState state);
+
+    static void HandleGroupState(AvahiEntryGroup * group, AvahiEntryGroupState state, void * context);
+    void HandleGroupState(AvahiEntryGroup * group, AvahiEntryGroupState state);
+
+    static void HandleBrowse(AvahiServiceBrowser * broswer, AvahiIfIndex interface, AvahiProtocol protocol, AvahiBrowserEvent event,
+                             const char * name, const char * type, const char * domain, AvahiLookupResultFlags flags,
+                             void * userdata);
+    static void HandleResolve(AvahiServiceResolver * resolver, AvahiIfIndex interface, AvahiProtocol protocol,
+                              AvahiResolverEvent event, const char * name, const char * type, const char * domain,
+                              const char * host_name, const AvahiAddress * address, uint16_t port, AvahiStringList * txt,
+                              AvahiLookupResultFlags flags, void * userdata);
+
+    DnssdAsyncReturnCallback mInitCallback;
+    DnssdAsyncReturnCallback mErrorCallback;
+    void * mAsyncReturnContext;
+
+    std::set<std::string> mPublishedServices;
+    AvahiClient * mClient;
+    AvahiEntryGroup * mGroup;
+    Poller mPoller;
+};
+
+} // namespace Dnssd
+} // namespace chip
diff --git a/src/platform/webos/GlibTypeDeleter.h b/src/platform/webos/GlibTypeDeleter.h
new file mode 100644
index 000000000..476a00a9a
--- /dev/null
+++ b/src/platform/webos/GlibTypeDeleter.h
@@ -0,0 +1,71 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <gio/gio.h>
+
+template <typename T, typename Deleter>
+class UniquePointerReceiver
+{
+public:
+    UniquePointerReceiver(std::unique_ptr<T, Deleter> & target) : mTarget(target) {}
+
+    ~UniquePointerReceiver() { mTarget.reset(mValue); }
+
+    T *& Get() { return mValue; }
+
+private:
+    std::unique_ptr<T, Deleter> & mTarget;
+    T * mValue = nullptr;
+};
+
+template <typename T, typename Deleter>
+UniquePointerReceiver<T, Deleter> MakeUniquePointerReceiver(std::unique_ptr<T, Deleter> & target)
+{
+    return UniquePointerReceiver<T, Deleter>(target);
+}
+
+struct GFree
+{
+    void operator()(gpointer object) { g_free(object); }
+};
+
+struct GObjectDeleter
+{
+    void operator()(gpointer object) { g_object_unref(object); }
+};
+
+struct GErrorDeleter
+{
+    void operator()(GError * object) { g_error_free(object); }
+};
+
+struct GVariantDeleter
+{
+    void operator()(GVariant * object) { g_variant_unref(object); }
+};
+
+struct GVariantIterDeleter
+{
+    void operator()(GVariantIter * object) { g_variant_iter_free(object); }
+};
+
+struct GBytesDeleter
+{
+    void operator()(GBytes * object) { g_bytes_unref(object); }
+};
diff --git a/src/platform/webos/InetPlatformConfig.h b/src/platform/webos/InetPlatformConfig.h
new file mode 100644
index 000000000..3aab9a7b9
--- /dev/null
+++ b/src/platform/webos/InetPlatformConfig.h
@@ -0,0 +1,48 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Platform-specific configuration overrides for the CHIP Inet
+ *          Layer on Linux platforms.
+ *
+ */
+
+#pragma once
+
+// ==================== Platform Adaptations ====================
+
+#ifndef INET_CONFIG_ENABLE_IPV4
+#error Inet IPv4 configuration should be configured at build generation time
+#endif
+
+// ========== Platform-specific Configuration Overrides =========
+
+#ifndef INET_CONFIG_NUM_TCP_ENDPOINTS
+#define INET_CONFIG_NUM_TCP_ENDPOINTS 32
+#endif // INET_CONFIG_NUM_TCP_ENDPOINTS
+
+#ifndef IPV6_MULTICAST_IMPLEMENTED
+#define IPV6_MULTICAST_IMPLEMENTED
+#endif
+
+#ifndef INET_CONFIG_NUM_UDP_ENDPOINTS
+#define INET_CONFIG_NUM_UDP_ENDPOINTS 32
+#endif // INET_CONFIG_NUM_UDP_ENDPOINTS
+
+// On linux platform, we have sys/socket.h, so HAVE_SO_BINDTODEVICE should be set to 1
+#define HAVE_SO_BINDTODEVICE 1
diff --git a/src/platform/webos/KeyValueStoreManagerImpl.cpp b/src/platform/webos/KeyValueStoreManagerImpl.cpp
new file mode 100644
index 000000000..bcc1c0177
--- /dev/null
+++ b/src/platform/webos/KeyValueStoreManagerImpl.cpp
@@ -0,0 +1,114 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Platform-specific implementatiuon of KVS for linux.
+ */
+
+#include <platform/KeyValueStoreManager.h>
+
+#include <algorithm>
+#include <string.h>
+
+#include <lib/support/CodeUtils.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <platform/webos/CHIPLinuxStorage.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace PersistedStorage {
+
+KeyValueStoreManagerImpl KeyValueStoreManagerImpl::sInstance;
+
+CHIP_ERROR KeyValueStoreManagerImpl::_Get(const char * key, void * value, size_t value_size, size_t * read_bytes_size,
+                                          size_t offset_bytes)
+{
+    size_t read_size;
+
+    // Copy data into value buffer
+    VerifyOrReturnError(value != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
+
+    // On linux read first without a buffer which returns the size, and then
+    // use a local buffer to read the entire object, which allows partial and
+    // offset reads.
+    CHIP_ERROR err = mStorage.ReadValueBin(key, nullptr, 0, read_size);
+    if (err == CHIP_ERROR_KEY_NOT_FOUND)
+    {
+        return CHIP_ERROR_PERSISTED_STORAGE_VALUE_NOT_FOUND;
+    }
+    else if ((err != CHIP_NO_ERROR) && (err != CHIP_ERROR_BUFFER_TOO_SMALL))
+    {
+        return err;
+    }
+    else if (offset_bytes > read_size)
+    {
+        return CHIP_ERROR_INVALID_ARGUMENT;
+    }
+
+    Platform::ScopedMemoryBuffer<uint8_t> buf;
+    VerifyOrReturnError(buf.Alloc(read_size), CHIP_ERROR_NO_MEMORY);
+    ReturnErrorOnFailure(mStorage.ReadValueBin(key, buf.Get(), read_size, read_size));
+
+    size_t copy_size = std::min(value_size, read_size - offset_bytes);
+    if (read_bytes_size != nullptr)
+    {
+        *read_bytes_size = copy_size;
+    }
+    ::memcpy(value, buf.Get() + offset_bytes, copy_size);
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR KeyValueStoreManagerImpl::_Put(const char * key, const void * value, size_t value_size)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    err = mStorage.WriteValueBin(key, reinterpret_cast<const uint8_t *>(value), value_size);
+    SuccessOrExit(err);
+
+    // Commit the value to the persistent store.
+    err = mStorage.Commit();
+    SuccessOrExit(err);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR KeyValueStoreManagerImpl::_Delete(const char * key)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    err            = mStorage.ClearValue(key);
+
+    if (err == CHIP_ERROR_KEY_NOT_FOUND)
+    {
+        ExitNow(err = CHIP_ERROR_PERSISTED_STORAGE_VALUE_NOT_FOUND);
+    }
+    SuccessOrExit(err);
+
+    // Commit the value to the persistent store.
+    err = mStorage.Commit();
+    SuccessOrExit(err);
+
+exit:
+    return err;
+}
+
+} // namespace PersistedStorage
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/KeyValueStoreManagerImpl.h b/src/platform/webos/KeyValueStoreManagerImpl.h
new file mode 100644
index 000000000..62cc0dc83
--- /dev/null
+++ b/src/platform/webos/KeyValueStoreManagerImpl.h
@@ -0,0 +1,79 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Platform-specific implementation of KVS for linux.
+ */
+
+#pragma once
+
+#include <platform/webos/CHIPLinuxStorage.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace PersistedStorage {
+
+class KeyValueStoreManagerImpl : public KeyValueStoreManager
+{
+public:
+    /**
+     * @brief
+     * Initalize the KVS, must be called before using.
+     */
+    void Init(const char * file) { mStorage.Init(file); }
+
+    CHIP_ERROR _Get(const char * key, void * value, size_t value_size, size_t * read_bytes_size = nullptr, size_t offset = 0);
+    CHIP_ERROR _Delete(const char * key);
+    CHIP_ERROR _Put(const char * key, const void * value, size_t value_size);
+
+private:
+    DeviceLayer::Internal::ChipLinuxStorage mStorage;
+
+    // ===== Members for internal use by the following friends.
+    friend KeyValueStoreManager & KeyValueStoreMgr();
+    friend KeyValueStoreManagerImpl & KeyValueStoreMgrImpl();
+
+    static KeyValueStoreManagerImpl sInstance;
+};
+
+/**
+ * Returns the public interface of the KeyValueStoreManager singleton object.
+ *
+ * Chip applications should use this to access features of the KeyValueStoreManager object
+ * that are common to all platforms.
+ */
+inline KeyValueStoreManager & KeyValueStoreMgr(void)
+{
+    return KeyValueStoreManagerImpl::sInstance;
+}
+
+/**
+ * Returns the platform-specific implementation of the KeyValueStoreManager singleton object.
+ *
+ * Chip applications can use this to gain access to features of the KeyValueStoreManager
+ * that are specific to the ESP32 platform.
+ */
+inline KeyValueStoreManagerImpl & KeyValueStoreMgrImpl(void)
+{
+    return KeyValueStoreManagerImpl::sInstance;
+}
+
+} // namespace PersistedStorage
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/Logging.cpp b/src/platform/webos/Logging.cpp
new file mode 100644
index 000000000..923c03b11
--- /dev/null
+++ b/src/platform/webos/Logging.cpp
@@ -0,0 +1,58 @@
+/* See Project CHIP LICENSE file for licensing information. */
+
+#include <platform/logging/LogV.h>
+
+#include <cinttypes>
+#include <cstdio>
+#include <sys/syscall.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+#ifdef USE_SYSLOG
+#include <syslog.h>
+#endif
+
+namespace chip {
+namespace DeviceLayer {
+
+/**
+ * Called whenever a log message is emitted by chip or LwIP.
+ *
+ * This function is intended be overridden by the application to, e.g.,
+ * schedule output of queued log entries.
+ */
+void __attribute__((weak)) OnLogOutput() {}
+
+} // namespace DeviceLayer
+
+namespace Logging {
+namespace Platform {
+
+/**
+ * CHIP log output functions.
+ */
+void LogV(const char * module, uint8_t category, const char * msg, va_list v)
+{
+    struct timeval tv;
+
+    // Should not fail per man page of gettimeofday(), but failed to get time is not a fatal error in log. The bad time value will
+    // indicate the error occurred during getting time.
+    gettimeofday(&tv, nullptr);
+
+#ifdef USE_SYSLOG
+    vsyslog(category, msg, v);
+#else
+    printf("[%" PRIu64 ".%06" PRIu64 "][%lld:%lld] CHIP:%s: ", static_cast<uint64_t>(tv.tv_sec), static_cast<uint64_t>(tv.tv_usec),
+           static_cast<long long>(syscall(SYS_getpid)), static_cast<long long>(syscall(SYS_gettid)), module);
+    vprintf(msg, v);
+    printf("\n");
+    fflush(stdout);
+#endif
+
+    // Let the application know that a log message has been emitted.
+    DeviceLayer::OnLogOutput();
+}
+
+} // namespace Platform
+} // namespace Logging
+} // namespace chip
diff --git a/src/platform/webos/OTAImageProcessorImpl.cpp b/src/platform/webos/OTAImageProcessorImpl.cpp
new file mode 100644
index 000000000..14a061484
--- /dev/null
+++ b/src/platform/webos/OTAImageProcessorImpl.cpp
@@ -0,0 +1,203 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#include <app/clusters/ota-requestor/OTADownloader.h>
+
+#include "OTAImageProcessorImpl.h"
+
+namespace chip {
+
+CHIP_ERROR OTAImageProcessorImpl::PrepareDownload()
+{
+    if (mParams.imageFile.empty())
+    {
+        ChipLogError(SoftwareUpdate, "Invalid output image file supplied");
+        return CHIP_ERROR_INTERNAL;
+    }
+
+    DeviceLayer::PlatformMgr().ScheduleWork(HandlePrepareDownload, reinterpret_cast<intptr_t>(this));
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR OTAImageProcessorImpl::Finalize()
+{
+    DeviceLayer::PlatformMgr().ScheduleWork(HandleFinalize, reinterpret_cast<intptr_t>(this));
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR OTAImageProcessorImpl::Apply()
+{
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR OTAImageProcessorImpl::Abort()
+{
+    if (mParams.imageFile.empty())
+    {
+        ChipLogError(SoftwareUpdate, "Invalid output image file supplied");
+        return CHIP_ERROR_INTERNAL;
+    }
+
+    DeviceLayer::PlatformMgr().ScheduleWork(HandleAbort, reinterpret_cast<intptr_t>(this));
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR OTAImageProcessorImpl::ProcessBlock(ByteSpan & block)
+{
+    if (!mOfs.is_open() || !mOfs.good())
+    {
+        return CHIP_ERROR_INTERNAL;
+    }
+
+    if ((block.data() == nullptr) || block.empty())
+    {
+        return CHIP_ERROR_INVALID_ARGUMENT;
+    }
+
+    // Store block data for HandleProcessBlock to access
+    CHIP_ERROR err = SetBlock(block);
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(SoftwareUpdate, "Cannot set block data: %" CHIP_ERROR_FORMAT, err.Format());
+    }
+
+    DeviceLayer::PlatformMgr().ScheduleWork(HandleProcessBlock, reinterpret_cast<intptr_t>(this));
+    return CHIP_NO_ERROR;
+}
+
+void OTAImageProcessorImpl::HandlePrepareDownload(intptr_t context)
+{
+    auto * imageProcessor = reinterpret_cast<OTAImageProcessorImpl *>(context);
+    if (imageProcessor == nullptr)
+    {
+        ChipLogError(SoftwareUpdate, "ImageProcessor context is null");
+        return;
+    }
+    else if (imageProcessor->mDownloader == nullptr)
+    {
+        ChipLogError(SoftwareUpdate, "mDownloader is null");
+        return;
+    }
+
+    imageProcessor->mOfs.open(imageProcessor->mParams.imageFile.data(),
+                              std::ofstream::out | std::ofstream::ate | std::ofstream::app);
+    if (!imageProcessor->mOfs.good())
+    {
+        imageProcessor->mDownloader->OnPreparedForDownload(CHIP_ERROR_OPEN_FAILED);
+        return;
+    }
+
+    // TODO: if file already exists and is not empty, erase previous contents
+
+    imageProcessor->mDownloader->OnPreparedForDownload(CHIP_NO_ERROR);
+}
+
+void OTAImageProcessorImpl::HandleFinalize(intptr_t context)
+{
+    auto * imageProcessor = reinterpret_cast<OTAImageProcessorImpl *>(context);
+    if (imageProcessor == nullptr)
+    {
+        return;
+    }
+
+    imageProcessor->mOfs.close();
+    imageProcessor->ReleaseBlock();
+
+    ChipLogProgress(SoftwareUpdate, "OTA image downloaded to %s", imageProcessor->mParams.imageFile.data());
+}
+
+void OTAImageProcessorImpl::HandleAbort(intptr_t context)
+{
+    auto * imageProcessor = reinterpret_cast<OTAImageProcessorImpl *>(context);
+    if (imageProcessor == nullptr)
+    {
+        return;
+    }
+
+    imageProcessor->mOfs.close();
+    remove(imageProcessor->mParams.imageFile.data());
+    imageProcessor->ReleaseBlock();
+}
+
+void OTAImageProcessorImpl::HandleProcessBlock(intptr_t context)
+{
+    auto * imageProcessor = reinterpret_cast<OTAImageProcessorImpl *>(context);
+    if (imageProcessor == nullptr)
+    {
+        ChipLogError(SoftwareUpdate, "ImageProcessor context is null");
+        return;
+    }
+    else if (imageProcessor->mDownloader == nullptr)
+    {
+        ChipLogError(SoftwareUpdate, "mDownloader is null");
+        return;
+    }
+
+    // TODO: Process block header if any
+
+    if (!imageProcessor->mOfs.write(reinterpret_cast<const char *>(imageProcessor->mBlock.data()),
+                                    static_cast<std::streamsize>(imageProcessor->mBlock.size())))
+    {
+        imageProcessor->mDownloader->EndDownload(CHIP_ERROR_WRITE_FAILED);
+        return;
+    }
+
+    imageProcessor->mParams.downloadedBytes += imageProcessor->mBlock.size();
+    imageProcessor->mDownloader->FetchNextData();
+}
+
+CHIP_ERROR OTAImageProcessorImpl::SetBlock(ByteSpan & block)
+{
+    if ((block.data() == nullptr) || block.empty())
+    {
+        return CHIP_NO_ERROR;
+    }
+
+    // Allocate memory for block data if it has not been done yet
+    if (mBlock.empty())
+    {
+        mBlock = MutableByteSpan(static_cast<uint8_t *>(chip::Platform::MemoryAlloc(block.size())), block.size());
+        if (mBlock.data() == nullptr)
+        {
+            return CHIP_ERROR_NO_MEMORY;
+        }
+    }
+
+    // Store the actual block data
+    CHIP_ERROR err = CopySpanToMutableSpan(block, mBlock);
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(SoftwareUpdate, "Cannot copy block data: %" CHIP_ERROR_FORMAT, err.Format());
+        return err;
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR OTAImageProcessorImpl::ReleaseBlock()
+{
+    if (mBlock.data() != nullptr)
+    {
+        chip::Platform::MemoryFree(mBlock.data());
+    }
+
+    mBlock = MutableByteSpan();
+    return CHIP_NO_ERROR;
+}
+
+} // namespace chip
diff --git a/src/platform/webos/OTAImageProcessorImpl.h b/src/platform/webos/OTAImageProcessorImpl.h
new file mode 100644
index 000000000..77a13ca36
--- /dev/null
+++ b/src/platform/webos/OTAImageProcessorImpl.h
@@ -0,0 +1,63 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <app/clusters/ota-requestor/OTADownloader.h>
+#include <platform/CHIPDeviceLayer.h>
+#include <platform/OTAImageProcessor.h>
+
+#include <fstream>
+
+namespace chip {
+
+class OTAImageProcessorImpl : public OTAImageProcessorInterface
+{
+public:
+    //////////// OTAImageProcessorInterface Implementation ///////////////
+    CHIP_ERROR PrepareDownload() override;
+    CHIP_ERROR Finalize() override;
+    CHIP_ERROR Apply() override;
+    CHIP_ERROR Abort() override;
+    CHIP_ERROR ProcessBlock(ByteSpan & block) override;
+
+    void SetOTADownloader(OTADownloader * downloader) { mDownloader = downloader; }
+
+private:
+    //////////// Actual handlers for the OTAImageProcessorInterface ///////////////
+    static void HandlePrepareDownload(intptr_t context);
+    static void HandleFinalize(intptr_t context);
+    static void HandleAbort(intptr_t context);
+    static void HandleProcessBlock(intptr_t context);
+
+    /**
+     * Called to allocate memory for mBlock if necessary and set it to block
+     */
+    CHIP_ERROR SetBlock(ByteSpan & block);
+
+    /**
+     * Called to release allocated memory for mBlock
+     */
+    CHIP_ERROR ReleaseBlock();
+
+    std::ofstream mOfs;
+    MutableByteSpan mBlock;
+    OTADownloader * mDownloader;
+};
+
+} // namespace chip
diff --git a/src/platform/webos/OTARequestorDriverImpl.cpp b/src/platform/webos/OTARequestorDriverImpl.cpp
new file mode 100644
index 000000000..5fcd1f68a
--- /dev/null
+++ b/src/platform/webos/OTARequestorDriverImpl.cpp
@@ -0,0 +1,41 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/* This file contains the Linux implementation of the  OTAImageProcessorDriver
+ * interface class
+ */
+
+#include "OTARequestorDriverImpl.h"
+
+using namespace chip;
+
+// A call into the application logic to give it a chance to allow or stop the Requestor
+// from proceeding with actual image download. Returning TRUE will allow the download
+// to proceed, returning FALSE will abort the download process.
+bool OTARequestorDriverImpl::CheckImageDownloadAllowed()
+{
+    return true;
+}
+
+// Notify the application that the download is complete and the image can be applied
+void OTARequestorDriverImpl::ImageDownloadComplete() {}
+
+UserConsentAction OTARequestorDriverImpl::RequestUserConsent()
+{
+    return ImmediateYes;
+}
diff --git a/src/platform/webos/OTARequestorDriverImpl.h b/src/platform/webos/OTARequestorDriverImpl.h
new file mode 100644
index 000000000..43664db1b
--- /dev/null
+++ b/src/platform/webos/OTARequestorDriverImpl.h
@@ -0,0 +1,46 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/* This file contains the decalarions for the Linux implementation of the
+ * the OTARequestorDriver interface class
+ */
+#include <platform/OTARequestorDriver.h>
+
+namespace chip {
+
+class OTARequestorDriverImpl : public OTARequestorDriver
+{
+
+    // Virtual functions from OTARequestorDriver -- start
+
+    // A call into the application logic to give it a chance to allow or stop the Requestor
+    // from proceeding with actual image download. Returning TRUE will allow the download
+    // to proceed, returning FALSE will abort the download process.
+    bool CheckImageDownloadAllowed();
+
+    // Notify the application that the download is complete and the image can be applied
+    void ImageDownloadComplete();
+
+    // Application is directed to complete user consent: either return ImmediateYes/ImmediateNo
+    // without blocking or return Requested and call OTARequestor::OnUserConsent() later.
+    virtual UserConsentAction RequestUserConsent();
+
+    // Virtual functions from OTARequestorDriver -- end
+};
+
+} // namespace chip
diff --git a/src/platform/webos/PlatformManagerImpl.cpp b/src/platform/webos/PlatformManagerImpl.cpp
new file mode 100644
index 000000000..cb9f6bc58
--- /dev/null
+++ b/src/platform/webos/PlatformManagerImpl.cpp
@@ -0,0 +1,538 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    Copyright (c) 2018 Nest Labs, Inc.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the PlatformManager object
+ *          for Linux platforms.
+ */
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+#include <app-common/zap-generated/enums.h>
+#include <lib/support/CHIPMem.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <platform/DeviceControlServer.h>
+#include <platform/webos/DiagnosticDataProviderImpl.h>
+#include <platform/PlatformManager.h>
+#include <platform/internal/GenericPlatformManagerImpl_POSIX.cpp>
+
+#include <thread>
+
+#include <arpa/inet.h>
+#include <dirent.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <signal.h>
+#include <unistd.h>
+
+using namespace ::chip::app::Clusters;
+
+namespace chip {
+namespace DeviceLayer {
+
+PlatformManagerImpl PlatformManagerImpl::sInstance;
+
+namespace {
+
+void SignalHandler(int signum)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    ChipLogDetail(DeviceLayer, "Caught signal %d", signum);
+
+    // The BootReason attribute SHALL indicate the reason for the Nodes most recent boot, the real usecase
+    // for this attribute is embedded system. In Linux simulation, we use different signals to tell the current
+    // running process to terminate with different reasons.
+    switch (signum)
+    {
+    case SIGINT:
+        ConfigurationMgr().StoreBootReason(DiagnosticDataProvider::BootReasonType::SoftwareReset);
+        err = CHIP_ERROR_REBOOT_SIGNAL_RECEIVED;
+        break;
+    case SIGHUP:
+        ConfigurationMgr().StoreBootReason(DiagnosticDataProvider::BootReasonType::BrownOutReset);
+        err = CHIP_ERROR_REBOOT_SIGNAL_RECEIVED;
+        break;
+    case SIGTERM:
+        ConfigurationMgr().StoreBootReason(DiagnosticDataProvider::BootReasonType::PowerOnReboot);
+        err = CHIP_ERROR_REBOOT_SIGNAL_RECEIVED;
+        break;
+    case SIGUSR1:
+        ConfigurationMgr().StoreBootReason(DiagnosticDataProvider::BootReasonType::HardwareWatchdogReset);
+        err = CHIP_ERROR_REBOOT_SIGNAL_RECEIVED;
+        break;
+    case SIGUSR2:
+        ConfigurationMgr().StoreBootReason(DiagnosticDataProvider::BootReasonType::SoftwareWatchdogReset);
+        err = CHIP_ERROR_REBOOT_SIGNAL_RECEIVED;
+        break;
+    case SIGTSTP:
+        ConfigurationMgr().StoreBootReason(DiagnosticDataProvider::BootReasonType::SoftwareUpdateCompleted);
+        err = CHIP_ERROR_REBOOT_SIGNAL_RECEIVED;
+        break;
+    case SIGTRAP:
+        PlatformMgrImpl().HandleSoftwareFault(SoftwareDiagnostics::Events::SoftwareFault::kEventId);
+        break;
+    case SIGILL:
+        PlatformMgrImpl().HandleGeneralFault(GeneralDiagnostics::Events::HardwareFaultChange::kEventId);
+        break;
+    case SIGALRM:
+        PlatformMgrImpl().HandleGeneralFault(GeneralDiagnostics::Events::RadioFaultChange::kEventId);
+        break;
+    case SIGVTALRM:
+        PlatformMgrImpl().HandleGeneralFault(GeneralDiagnostics::Events::NetworkFaultChange::kEventId);
+        break;
+    case SIGIO:
+        PlatformMgrImpl().HandleSwitchEvent(Switch::Events::SwitchLatched::kEventId);
+        break;
+    default:
+        break;
+    }
+
+    if (err == CHIP_ERROR_REBOOT_SIGNAL_RECEIVED)
+    {
+        PlatformMgr().Shutdown();
+        exit(EXIT_FAILURE);
+    }
+}
+
+#if CHIP_WITH_GIO
+void GDBus_Thread()
+{
+    GMainLoop * loop = g_main_loop_new(nullptr, false);
+
+    g_main_loop_run(loop);
+    g_main_loop_unref(loop);
+}
+#endif
+} // namespace
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+void PlatformManagerImpl::WiFIIPChangeListener()
+{
+    int sock;
+    if ((sock = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to init netlink socket for ip addresses.");
+        return;
+    }
+
+    struct sockaddr_nl addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.nl_family = AF_NETLINK;
+    addr.nl_groups = RTMGRP_IPV4_IFADDR;
+
+    if (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) == -1)
+    {
+        ChipLogError(DeviceLayer, "Failed to bind netlink socket for ip addresses.");
+        return;
+    }
+
+    ssize_t len;
+    char buffer[4096];
+    for (struct nlmsghdr * header = reinterpret_cast<struct nlmsghdr *>(buffer); (len = recv(sock, header, sizeof(buffer), 0)) > 0;)
+    {
+        for (struct nlmsghdr * messageHeader = header;
+             (NLMSG_OK(messageHeader, static_cast<uint32_t>(len))) && (messageHeader->nlmsg_type != NLMSG_DONE);
+             messageHeader = NLMSG_NEXT(messageHeader, len))
+        {
+            if (header->nlmsg_type == RTM_NEWADDR)
+            {
+                struct ifaddrmsg * addressMessage = (struct ifaddrmsg *) NLMSG_DATA(header);
+                struct rtattr * routeInfo         = IFA_RTA(addressMessage);
+                size_t rtl                        = IFA_PAYLOAD(header);
+
+                for (; rtl && RTA_OK(routeInfo, rtl); routeInfo = RTA_NEXT(routeInfo, rtl))
+                {
+                    if (routeInfo->rta_type == IFA_LOCAL)
+                    {
+                        char name[IFNAMSIZ];
+                        ChipDeviceEvent event;
+                        if_indextoname(addressMessage->ifa_index, name);
+                        if (strcmp(name, ConnectivityManagerImpl::GetWiFiIfName()) != 0)
+                        {
+                            continue;
+                        }
+
+                        event.Type                            = DeviceEventType::kInternetConnectivityChange;
+                        event.InternetConnectivityChange.IPv4 = kConnectivity_Established;
+                        event.InternetConnectivityChange.IPv6 = kConnectivity_NoChange;
+                        inet_ntop(AF_INET, RTA_DATA(routeInfo), event.InternetConnectivityChange.address,
+                                  sizeof(event.InternetConnectivityChange.address));
+
+                        ChipLogDetail(DeviceLayer, "Got IP address on interface: %s IP: %s", name,
+                                      event.InternetConnectivityChange.address);
+
+                        CHIP_ERROR status = PlatformMgr().PostEvent(&event);
+                        if (status != CHIP_NO_ERROR)
+                        {
+                            ChipLogDetail(DeviceLayer, "Failed to report IP address: %" CHIP_ERROR_FORMAT, status.Format());
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+#endif // #if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+
+CHIP_ERROR PlatformManagerImpl::_InitChipStack()
+{
+    CHIP_ERROR err;
+    struct sigaction action;
+
+    memset(&action, 0, sizeof(action));
+    action.sa_handler = SignalHandler;
+    sigaction(SIGINT, &action, NULL);
+    sigaction(SIGHUP, &action, NULL);
+    sigaction(SIGTERM, &action, NULL);
+    sigaction(SIGUSR1, &action, NULL);
+    sigaction(SIGUSR2, &action, NULL);
+    sigaction(SIGTSTP, &action, NULL);
+
+#if CHIP_WITH_GIO
+    GError * error = nullptr;
+
+    this->mpGDBusConnection = UniqueGDBusConnection(g_bus_get_sync(G_BUS_TYPE_SYSTEM, nullptr, &error));
+
+    std::thread gdbusThread(GDBus_Thread);
+    gdbusThread.detach();
+#endif
+
+#if CHIP_DEVICE_CONFIG_ENABLE_WIFI
+    std::thread wifiIPThread(WiFIIPChangeListener);
+    wifiIPThread.detach();
+#endif
+
+    // Initialize the configuration system.
+    err = Internal::PosixConfig::Init();
+    SuccessOrExit(err);
+    SetConfigurationMgr(&ConfigurationManagerImpl::GetDefaultInstance());
+    SetDiagnosticDataProvider(&DiagnosticDataProviderImpl::GetDefaultInstance());
+
+    // Call _InitChipStack() on the generic implementation base class
+    // to finish the initialization process.
+    err = Internal::GenericPlatformManagerImpl_POSIX<PlatformManagerImpl>::_InitChipStack();
+    SuccessOrExit(err);
+
+    mStartTime = System::SystemClock().GetMonotonicTimestamp();
+
+    ScheduleWork(HandleDeviceRebooted, 0);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PlatformManagerImpl::_Shutdown()
+{
+    PlatformManagerDelegate * platformManagerDelegate = PlatformMgr().GetDelegate();
+    uint64_t upTime                                   = 0;
+
+    // The ShutDown event SHOULD be emitted by a Node prior to any orderly shutdown sequence.
+    if (platformManagerDelegate != nullptr)
+    {
+        platformManagerDelegate->OnShutDown();
+    }
+
+    if (GetDiagnosticDataProvider().GetUpTime(upTime) == CHIP_NO_ERROR)
+    {
+        uint32_t totalOperationalHours = 0;
+
+        if (ConfigurationMgr().GetTotalOperationalHours(totalOperationalHours) == CHIP_NO_ERROR)
+        {
+            ConfigurationMgr().StoreTotalOperationalHours(totalOperationalHours + static_cast<uint32_t>(upTime / 3600));
+        }
+        else
+        {
+            ChipLogError(DeviceLayer, "Failed to get total operational hours of the Node");
+        }
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "Failed to get current uptime since the Nodes last reboot");
+    }
+
+    return Internal::GenericPlatformManagerImpl_POSIX<PlatformManagerImpl>::_Shutdown();
+}
+
+CHIP_ERROR PlatformManagerImpl::_GetFixedLabelList(
+    EndpointId endpoint, LabelList<app::Clusters::FixedLabel::Structs::LabelStruct::Type, kMaxFixedLabels> & labelList)
+{
+    // In Linux simulation, return following hardcoded labelList on all endpoints.
+    FixedLabel::Structs::LabelStruct::Type room;
+    FixedLabel::Structs::LabelStruct::Type orientation;
+    FixedLabel::Structs::LabelStruct::Type floor;
+    FixedLabel::Structs::LabelStruct::Type direction;
+
+    room.label = CharSpan("room", strlen("room"));
+    room.value = CharSpan("bedroom 2", strlen("bedroom 2"));
+
+    orientation.label = CharSpan("orientation", strlen("orientation"));
+    orientation.value = CharSpan("North", strlen("North"));
+
+    floor.label = CharSpan("floor", strlen("floor"));
+    floor.value = CharSpan("2", strlen("2"));
+
+    direction.label = CharSpan("direction", strlen("direction"));
+    direction.value = CharSpan("up", strlen("up"));
+
+    labelList.add(room);
+    labelList.add(orientation);
+    labelList.add(floor);
+    labelList.add(direction);
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR
+PlatformManagerImpl::_SetUserLabelList(EndpointId endpoint,
+                                       LabelList<app::Clusters::UserLabel::Structs::LabelStruct::Type, kMaxUserLabels> & labelList)
+{
+    // TODO:: store the user labelList, and read back stored user labelList if it has been set. Add yaml test to verify this.
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR
+PlatformManagerImpl::_GetUserLabelList(EndpointId endpoint,
+                                       LabelList<app::Clusters::UserLabel::Structs::LabelStruct::Type, kMaxUserLabels> & labelList)
+{
+    // In Linux simulation, return following hardcoded labelList on all endpoints.
+    UserLabel::Structs::LabelStruct::Type room;
+    UserLabel::Structs::LabelStruct::Type orientation;
+    UserLabel::Structs::LabelStruct::Type floor;
+    UserLabel::Structs::LabelStruct::Type direction;
+
+    room.label = CharSpan("room", strlen("room"));
+    room.value = CharSpan("bedroom 2", strlen("bedroom 2"));
+
+    orientation.label = CharSpan("orientation", strlen("orientation"));
+    orientation.value = CharSpan("North", strlen("North"));
+
+    floor.label = CharSpan("floor", strlen("floor"));
+    floor.value = CharSpan("2", strlen("2"));
+
+    direction.label = CharSpan("direction", strlen("direction"));
+    direction.value = CharSpan("up", strlen("up"));
+
+    labelList.add(room);
+    labelList.add(orientation);
+    labelList.add(floor);
+    labelList.add(direction);
+
+    return CHIP_NO_ERROR;
+}
+
+void PlatformManagerImpl::HandleDeviceRebooted(intptr_t arg)
+{
+    PlatformManagerDelegate * platformManagerDelegate       = PlatformMgr().GetDelegate();
+    GeneralDiagnosticsDelegate * generalDiagnosticsDelegate = GetDiagnosticDataProvider().GetGeneralDiagnosticsDelegate();
+
+    if (generalDiagnosticsDelegate != nullptr)
+    {
+        generalDiagnosticsDelegate->OnDeviceRebooted();
+    }
+
+    // The StartUp event SHALL be emitted by a Node after completing a boot or reboot process
+    if (platformManagerDelegate != nullptr)
+    {
+        uint16_t softwareVersion;
+
+        ReturnOnFailure(ConfigurationMgr().GetSoftwareVersion(softwareVersion));
+        platformManagerDelegate->OnStartUp(softwareVersion);
+    }
+}
+
+void PlatformManagerImpl::HandleGeneralFault(uint32_t EventId)
+{
+    GeneralDiagnosticsDelegate * delegate = GetDiagnosticDataProvider().GetGeneralDiagnosticsDelegate();
+
+    if (delegate == nullptr)
+    {
+        ChipLogError(DeviceLayer, "No delegate registered to handle General Diagnostics event");
+        return;
+    }
+
+    if (EventId == GeneralDiagnostics::Events::HardwareFaultChange::kEventId)
+    {
+        GeneralFaults<kMaxHardwareFaults> previous;
+        GeneralFaults<kMaxHardwareFaults> current;
+
+#if CHIP_CONFIG_TEST
+        // On Linux Simulation, set following hardware faults statically.
+        ReturnOnFailure(previous.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_RADIO));
+        ReturnOnFailure(previous.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_POWER_SOURCE));
+
+        ReturnOnFailure(current.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_RADIO));
+        ReturnOnFailure(current.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_SENSOR));
+        ReturnOnFailure(current.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_POWER_SOURCE));
+        ReturnOnFailure(current.add(EMBER_ZCL_HARDWARE_FAULT_TYPE_USER_INTERFACE_FAULT));
+#endif
+        delegate->OnHardwareFaultsDetected(previous, current);
+    }
+    else if (EventId == GeneralDiagnostics::Events::RadioFaultChange::kEventId)
+    {
+        GeneralFaults<kMaxRadioFaults> previous;
+        GeneralFaults<kMaxRadioFaults> current;
+
+#if CHIP_CONFIG_TEST
+        // On Linux Simulation, set following radio faults statically.
+        ReturnOnFailure(previous.add(EMBER_ZCL_RADIO_FAULT_TYPE_WI_FI_FAULT));
+        ReturnOnFailure(previous.add(EMBER_ZCL_RADIO_FAULT_TYPE_THREAD_FAULT));
+
+        ReturnOnFailure(current.add(EMBER_ZCL_RADIO_FAULT_TYPE_WI_FI_FAULT));
+        ReturnOnFailure(current.add(EMBER_ZCL_RADIO_FAULT_TYPE_CELLULAR_FAULT));
+        ReturnOnFailure(current.add(EMBER_ZCL_RADIO_FAULT_TYPE_THREAD_FAULT));
+        ReturnOnFailure(current.add(EMBER_ZCL_RADIO_FAULT_TYPE_NFC_FAULT));
+#endif
+        delegate->OnRadioFaultsDetected(previous, current);
+    }
+    else if (EventId == GeneralDiagnostics::Events::NetworkFaultChange::kEventId)
+    {
+        GeneralFaults<kMaxNetworkFaults> previous;
+        GeneralFaults<kMaxNetworkFaults> current;
+
+#if CHIP_CONFIG_TEST
+        // On Linux Simulation, set following radio faults statically.
+        ReturnOnFailure(previous.add(EMBER_ZCL_NETWORK_FAULT_TYPE_HARDWARE_FAILURE));
+        ReturnOnFailure(previous.add(EMBER_ZCL_NETWORK_FAULT_TYPE_NETWORK_JAMMED));
+
+        ReturnOnFailure(current.add(EMBER_ZCL_NETWORK_FAULT_TYPE_HARDWARE_FAILURE));
+        ReturnOnFailure(current.add(EMBER_ZCL_NETWORK_FAULT_TYPE_NETWORK_JAMMED));
+        ReturnOnFailure(current.add(EMBER_ZCL_NETWORK_FAULT_TYPE_CONNECTION_FAILED));
+#endif
+        delegate->OnNetworkFaultsDetected(previous, current);
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "Unknow event ID:%d", EventId);
+    }
+}
+
+void PlatformManagerImpl::HandleSoftwareFault(uint32_t EventId)
+{
+    SoftwareDiagnosticsDelegate * delegate = GetDiagnosticDataProvider().GetSoftwareDiagnosticsDelegate();
+
+    if (delegate != nullptr)
+    {
+        SoftwareDiagnostics::Structs::SoftwareFault::Type softwareFault;
+        char threadName[kMaxThreadNameLength + 1];
+
+        softwareFault.id = gettid();
+        strncpy(threadName, std::to_string(softwareFault.id).c_str(), kMaxThreadNameLength);
+        threadName[kMaxThreadNameLength] = '\0';
+        softwareFault.name               = CharSpan(threadName, strlen(threadName));
+        softwareFault.faultRecording     = ByteSpan(Uint8::from_const_char("FaultRecording"), strlen("FaultRecording"));
+
+        delegate->OnSoftwareFaultDetected(softwareFault);
+    }
+}
+
+void PlatformManagerImpl::HandleSwitchEvent(uint32_t EventId)
+{
+    SwitchDeviceControlDelegate * delegate = DeviceControlServer::DeviceControlSvr().GetSwitchDelegate();
+
+    if (delegate == nullptr)
+    {
+        ChipLogError(DeviceLayer, "No delegate registered to handle Switch event");
+        return;
+    }
+
+    if (EventId == Switch::Events::SwitchLatched::kEventId)
+    {
+        uint8_t newPosition = 0;
+
+#if CHIP_CONFIG_TEST
+        newPosition = 100;
+#endif
+        delegate->OnSwitchLatched(newPosition);
+    }
+    else if (EventId == Switch::Events::InitialPress::kEventId)
+    {
+        uint8_t newPosition = 0;
+
+#if CHIP_CONFIG_TEST
+        newPosition = 100;
+#endif
+        delegate->OnInitialPressed(newPosition);
+    }
+    else if (EventId == Switch::Events::LongPress::kEventId)
+    {
+        uint8_t newPosition = 0;
+
+#if CHIP_CONFIG_TEST
+        newPosition = 100;
+#endif
+        delegate->OnLongPressed(newPosition);
+    }
+    else if (EventId == Switch::Events::ShortRelease::kEventId)
+    {
+        uint8_t previousPosition = 0;
+
+#if CHIP_CONFIG_TEST
+        previousPosition = 50;
+#endif
+        delegate->OnShortReleased(previousPosition);
+    }
+    else if (EventId == Switch::Events::LongRelease::kEventId)
+    {
+        uint8_t previousPosition = 0;
+
+#if CHIP_CONFIG_TEST
+        previousPosition = 50;
+#endif
+        delegate->OnLongReleased(previousPosition);
+    }
+    else if (EventId == Switch::Events::MultiPressOngoing::kEventId)
+    {
+        uint8_t newPosition                   = 0;
+        uint8_t currentNumberOfPressesCounted = 0;
+
+#if CHIP_CONFIG_TEST
+        newPosition                   = 10;
+        currentNumberOfPressesCounted = 5;
+#endif
+        delegate->OnMultiPressOngoing(newPosition, currentNumberOfPressesCounted);
+    }
+    else if (EventId == Switch::Events::MultiPressComplete::kEventId)
+    {
+        uint8_t newPosition                 = 0;
+        uint8_t totalNumberOfPressesCounted = 0;
+
+#if CHIP_CONFIG_TEST
+        newPosition                 = 10;
+        totalNumberOfPressesCounted = 5;
+#endif
+        delegate->OnMultiPressComplete(newPosition, totalNumberOfPressesCounted);
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "Unknow event ID:%d", EventId);
+    }
+}
+
+#if CHIP_WITH_GIO
+GDBusConnection * PlatformManagerImpl::GetGDBusConnection()
+{
+    return this->mpGDBusConnection.get();
+}
+#endif
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/PlatformManagerImpl.h b/src/platform/webos/PlatformManagerImpl.h
new file mode 100644
index 000000000..6757b9310
--- /dev/null
+++ b/src/platform/webos/PlatformManagerImpl.h
@@ -0,0 +1,123 @@
+/*
+ *
+ *    Copyright (c) 2020-2021 Project CHIP Authors
+ *    Copyright (c) 2018 Nest Labs, Inc.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides an implementation of the PlatformManager object.
+ */
+
+#pragma once
+
+#include <platform/PlatformManager.h>
+#include <platform/internal/GenericPlatformManagerImpl_POSIX.h>
+
+#if CHIP_WITH_GIO
+#include <gio/gio.h>
+#endif
+
+namespace chip {
+namespace DeviceLayer {
+
+/**
+ * Concrete implementation of the PlatformManager singleton object for Linux platforms.
+ */
+class PlatformManagerImpl final : public PlatformManager, public Internal::GenericPlatformManagerImpl_POSIX<PlatformManagerImpl>
+{
+    // Allow the PlatformManager interface class to delegate method calls to
+    // the implementation methods provided by this class.
+    friend PlatformManager;
+
+    // Allow the generic implementation base class to call helper methods on
+    // this class.
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+    friend Internal::GenericPlatformManagerImpl_POSIX<PlatformManagerImpl>;
+#endif
+
+public:
+    // ===== Platform-specific members that may be accessed directly by the application.
+#if CHIP_WITH_GIO
+    GDBusConnection * GetGDBusConnection();
+#endif
+
+    System::Clock::Timestamp GetStartTime() { return mStartTime; }
+
+    void HandleGeneralFault(uint32_t EventId);
+    void HandleSoftwareFault(uint32_t EventId);
+    void HandleSwitchEvent(uint32_t EventId);
+
+private:
+    // ===== Methods that implement the PlatformManager abstract interface.
+
+    CHIP_ERROR _InitChipStack();
+    CHIP_ERROR _Shutdown();
+    CHIP_ERROR _GetFixedLabelList(EndpointId endpoint,
+                                  LabelList<app::Clusters::FixedLabel::Structs::LabelStruct::Type, kMaxFixedLabels> & labelList);
+    CHIP_ERROR _SetUserLabelList(EndpointId endpoint,
+                                 LabelList<app::Clusters::UserLabel::Structs::LabelStruct::Type, kMaxUserLabels> & labelList);
+    CHIP_ERROR _GetUserLabelList(EndpointId endpoint,
+                                 LabelList<app::Clusters::UserLabel::Structs::LabelStruct::Type, kMaxUserLabels> & labelList);
+
+    // ===== Members for internal use by the following friends.
+
+    friend PlatformManager & PlatformMgr();
+    friend PlatformManagerImpl & PlatformMgrImpl();
+    friend class Internal::BLEManagerImpl;
+
+    System::Clock::Timestamp mStartTime = System::Clock::kZero;
+
+    static PlatformManagerImpl sInstance;
+
+    // The temporary hack for getting IP address change on linux for network provisioning in the rendezvous session.
+    // This should be removed or find a better place once we depercate the rendezvous session.
+    static void WiFIIPChangeListener();
+    static void HandleDeviceRebooted(intptr_t arg);
+
+#if CHIP_WITH_GIO
+    struct GDBusConnectionDeleter
+    {
+        void operator()(GDBusConnection * conn) { g_object_unref(conn); }
+    };
+    using UniqueGDBusConnection = std::unique_ptr<GDBusConnection, GDBusConnectionDeleter>;
+    UniqueGDBusConnection mpGDBusConnection;
+#endif
+};
+
+/**
+ * Returns the public interface of the PlatformManager singleton object.
+ *
+ * chip applications should use this to access features of the PlatformManager object
+ * that are common to all platforms.
+ */
+inline PlatformManager & PlatformMgr()
+{
+    return PlatformManagerImpl::sInstance;
+}
+
+/**
+ * Returns the platform-specific implementation of the PlatformManager singleton object.
+ *
+ * chip applications can use this to gain access to features of the PlatformManager
+ * that are specific to the platform.
+ */
+inline PlatformManagerImpl & PlatformMgrImpl()
+{
+    return PlatformManagerImpl::sInstance;
+}
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/PosixConfig.cpp b/src/platform/webos/PosixConfig.cpp
new file mode 100644
index 000000000..82ea1b7ea
--- /dev/null
+++ b/src/platform/webos/PosixConfig.cpp
@@ -0,0 +1,545 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    Copyright (c) 2019-2020 Google LLC.
+ *    Copyright (c) 2018 Nest Labs, Inc.
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Utilities for interacting with multiple file partitions and maps
+ *          key-value config calls to the correct partition.
+ */
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+#include <platform/internal/testing/ConfigUnitTest.h>
+
+#include <lib/core/CHIPEncoding.h>
+#include <lib/support/CodeUtils.h>
+#include <platform/webos/CHIPLinuxStorage.h>
+#include <platform/webos/PosixConfig.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+static ChipLinuxStorage gChipLinuxFactoryStorage;
+static ChipLinuxStorage gChipLinuxConfigStorage;
+static ChipLinuxStorage gChipLinuxCountersStorage;
+
+// *** CAUTION ***: Changing the names or namespaces of these values will *break* existing devices.
+
+// NVS namespaces used to store device configuration information.
+const char PosixConfig::kConfigNamespace_ChipFactory[]  = "chip-factory";
+const char PosixConfig::kConfigNamespace_ChipConfig[]   = "chip-config";
+const char PosixConfig::kConfigNamespace_ChipCounters[] = "chip-counters";
+
+// Keys stored in the Chip-factory namespace
+const PosixConfig::Key PosixConfig::kConfigKey_SerialNum           = { kConfigNamespace_ChipFactory, "serial-num" };
+const PosixConfig::Key PosixConfig::kConfigKey_MfrDeviceId         = { kConfigNamespace_ChipFactory, "device-id" };
+const PosixConfig::Key PosixConfig::kConfigKey_MfrDeviceCert       = { kConfigNamespace_ChipFactory, "device-cert" };
+const PosixConfig::Key PosixConfig::kConfigKey_MfrDeviceICACerts   = { kConfigNamespace_ChipFactory, "device-ca-certs" };
+const PosixConfig::Key PosixConfig::kConfigKey_MfrDevicePrivateKey = { kConfigNamespace_ChipFactory, "device-key" };
+const PosixConfig::Key PosixConfig::kConfigKey_HardwareVersion     = { kConfigNamespace_ChipFactory, "hardware-ver" };
+const PosixConfig::Key PosixConfig::kConfigKey_ManufacturingDate   = { kConfigNamespace_ChipFactory, "mfg-date" };
+const PosixConfig::Key PosixConfig::kConfigKey_SetupPinCode        = { kConfigNamespace_ChipFactory, "pin-code" };
+const PosixConfig::Key PosixConfig::kConfigKey_SetupDiscriminator  = { kConfigNamespace_ChipFactory, "discriminator" };
+
+// Keys stored in the Chip-config namespace
+const PosixConfig::Key PosixConfig::kConfigKey_FabricId           = { kConfigNamespace_ChipConfig, "fabric-id" };
+const PosixConfig::Key PosixConfig::kConfigKey_ServiceConfig      = { kConfigNamespace_ChipConfig, "service-config" };
+const PosixConfig::Key PosixConfig::kConfigKey_PairedAccountId    = { kConfigNamespace_ChipConfig, "account-id" };
+const PosixConfig::Key PosixConfig::kConfigKey_ServiceId          = { kConfigNamespace_ChipConfig, "service-id" };
+const PosixConfig::Key PosixConfig::kConfigKey_FabricSecret       = { kConfigNamespace_ChipConfig, "fabric-secret" };
+const PosixConfig::Key PosixConfig::kConfigKey_GroupKeyIndex      = { kConfigNamespace_ChipConfig, "group-key-index" };
+const PosixConfig::Key PosixConfig::kConfigKey_LastUsedEpochKeyId = { kConfigNamespace_ChipConfig, "last-ek-id" };
+const PosixConfig::Key PosixConfig::kConfigKey_FailSafeArmed      = { kConfigNamespace_ChipConfig, "fail-safe-armed" };
+const PosixConfig::Key PosixConfig::kConfigKey_WiFiStationSecType = { kConfigNamespace_ChipConfig, "sta-sec-type" };
+const PosixConfig::Key PosixConfig::kConfigKey_RegulatoryLocation = { kConfigNamespace_ChipConfig, "regulatory-location" };
+const PosixConfig::Key PosixConfig::kConfigKey_CountryCode        = { kConfigNamespace_ChipConfig, "country-code" };
+const PosixConfig::Key PosixConfig::kConfigKey_Breadcrumb         = { kConfigNamespace_ChipConfig, "breadcrumb" };
+const PosixConfig::Key PosixConfig::kConfigKey_LocationCapability = { kConfigNamespace_ChipConfig, "location-capability" };
+
+// Keys stored in the Chip-counters namespace
+const PosixConfig::Key PosixConfig::kCounterKey_RebootCount           = { kConfigNamespace_ChipCounters, "reboot-count" };
+const PosixConfig::Key PosixConfig::kCounterKey_UpTime                = { kConfigNamespace_ChipCounters, "up-time" };
+const PosixConfig::Key PosixConfig::kCounterKey_TotalOperationalHours = { kConfigNamespace_ChipCounters,
+                                                                          "total-operational-hours" };
+const PosixConfig::Key PosixConfig::kCounterKey_BootReason            = { kConfigNamespace_ChipCounters, "boot-reason" };
+
+// Prefix used for NVS keys that contain Chip group encryption keys.
+const char PosixConfig::kGroupKeyNamePrefix[] = "gk-";
+
+ChipLinuxStorage * PosixConfig::GetStorageForNamespace(Key key)
+{
+    if (strcmp(key.Namespace, kConfigNamespace_ChipFactory) == 0)
+        return &gChipLinuxFactoryStorage;
+
+    if (strcmp(key.Namespace, kConfigNamespace_ChipConfig) == 0)
+        return &gChipLinuxConfigStorage;
+
+    if (strcmp(key.Namespace, kConfigNamespace_ChipCounters) == 0)
+        return &gChipLinuxCountersStorage;
+
+    return nullptr;
+}
+
+CHIP_ERROR PosixConfig::Init()
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    return err;
+}
+
+CHIP_ERROR PosixConfig::ReadConfigValue(Key key, bool & val)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+    uint32_t intVal;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->ReadValue(key.Name, intVal);
+    if (err == CHIP_ERROR_KEY_NOT_FOUND)
+    {
+        err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND;
+    }
+    SuccessOrExit(err);
+
+    val = (intVal != 0);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::ReadConfigValue(Key key, uint32_t & val)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->ReadValue(key.Name, val);
+    if (err == CHIP_ERROR_KEY_NOT_FOUND)
+    {
+        err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND;
+    }
+    SuccessOrExit(err);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::ReadConfigValue(Key key, uint64_t & val)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    // Special case the MfrDeviceId value, optionally allowing it to be read as a blob containing
+    // a 64-bit big-endian integer, instead of a u64 value.
+    if (key == kConfigKey_MfrDeviceId)
+    {
+        uint8_t deviceIdBytes[sizeof(uint64_t)];
+        size_t deviceIdLen = sizeof(deviceIdBytes);
+        size_t deviceIdOutLen;
+        err = storage->ReadValueBin(key.Name, deviceIdBytes, deviceIdLen, deviceIdOutLen);
+        if (err == CHIP_NO_ERROR)
+        {
+            VerifyOrExit(deviceIdOutLen == sizeof(deviceIdBytes), err = CHIP_ERROR_INCORRECT_STATE);
+            val = Encoding::BigEndian::Get64(deviceIdBytes);
+            ExitNow();
+        }
+    }
+
+    err = storage->ReadValue(key.Name, val);
+    if (err == CHIP_ERROR_KEY_NOT_FOUND)
+    {
+        err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND;
+    }
+    SuccessOrExit(err);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::ReadConfigValueStr(Key key, char * buf, size_t bufSize, size_t & outLen)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->ReadValueStr(key.Name, buf, bufSize, outLen);
+    if (err == CHIP_ERROR_KEY_NOT_FOUND)
+    {
+        outLen = 0;
+        err    = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND;
+    }
+    else if (err == CHIP_ERROR_BUFFER_TOO_SMALL)
+    {
+        err = (buf == nullptr) ? CHIP_NO_ERROR : CHIP_ERROR_BUFFER_TOO_SMALL;
+    }
+    SuccessOrExit(err);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::ReadConfigValueBin(Key key, uint8_t * buf, size_t bufSize, size_t & outLen)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->ReadValueBin(key.Name, buf, bufSize, outLen);
+    if (err == CHIP_ERROR_KEY_NOT_FOUND)
+    {
+        outLen = 0;
+        err    = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND;
+    }
+    else if (err == CHIP_ERROR_BUFFER_TOO_SMALL)
+    {
+        err = (buf == nullptr) ? CHIP_NO_ERROR : CHIP_ERROR_BUFFER_TOO_SMALL;
+    }
+    SuccessOrExit(err);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::WriteConfigValue(Key key, bool val)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->WriteValue(key.Name, val);
+    SuccessOrExit(err);
+
+    // Commit the value to the persistent store.
+    err = storage->Commit();
+    SuccessOrExit(err);
+
+    ChipLogProgress(DeviceLayer, "NVS set: %s/%s = %s", key.Namespace, key.Name, val ? "true" : "false");
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::WriteConfigValue(Key key, uint32_t val)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->WriteValue(key.Name, val);
+    SuccessOrExit(err);
+
+    // Commit the value to the persistent store.
+    err = storage->Commit();
+    SuccessOrExit(err);
+
+    ChipLogProgress(DeviceLayer, "NVS set: %s/%s = %" PRIu32 " (0x%" PRIX32 ")", key.Namespace, key.Name, val, val);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::WriteConfigValue(Key key, uint64_t val)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->WriteValue(key.Name, val);
+    SuccessOrExit(err);
+
+    // Commit the value to the persistent store.
+    err = storage->Commit();
+    SuccessOrExit(err);
+
+    ChipLogProgress(DeviceLayer, "NVS set: %s/%s = %" PRIu64 " (0x%" PRIX64 ")", key.Namespace, key.Name, val, val);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::WriteConfigValueStr(Key key, const char * str)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    if (str != nullptr)
+    {
+        storage = GetStorageForNamespace(key);
+        VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+        err = storage->WriteValueStr(key.Name, str);
+        SuccessOrExit(err);
+
+        // Commit the value to the persistent store.
+        err = storage->Commit();
+        SuccessOrExit(err);
+
+        ChipLogProgress(DeviceLayer, "NVS set: %s/%s = \"%s\"", key.Namespace, key.Name, str);
+    }
+
+    else
+    {
+        err = ClearConfigValue(key);
+        SuccessOrExit(err);
+    }
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::WriteConfigValueStr(Key key, const char * str, size_t strLen)
+{
+#if CHIP_CONFIG_MEMORY_MGMT_MALLOC
+    CHIP_ERROR err;
+    char * strCopy = nullptr;
+
+    if (str != nullptr)
+    {
+        strCopy = strndup(str, strLen);
+        VerifyOrExit(strCopy != nullptr, err = CHIP_ERROR_NO_MEMORY);
+    }
+
+    err = PosixConfig::WriteConfigValueStr(key, strCopy);
+
+exit:
+    if (strCopy != nullptr)
+    {
+        free(strCopy);
+    }
+    return err;
+#else
+#error "Unsupported CHIP_CONFIG_MEMORY_MGMT configuration"
+#endif
+}
+
+CHIP_ERROR PosixConfig::WriteConfigValueBin(Key key, const uint8_t * data, size_t dataLen)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    if (data != nullptr)
+    {
+        storage = GetStorageForNamespace(key);
+        VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+        err = storage->WriteValueBin(key.Name, data, dataLen);
+        SuccessOrExit(err);
+
+        // Commit the value to the persistent store.
+        err = storage->Commit();
+        SuccessOrExit(err);
+
+        ChipLogProgress(DeviceLayer, "NVS set: %s/%s = (blob length %zu)", key.Namespace, key.Name, dataLen);
+    }
+    else
+    {
+        err = ClearConfigValue(key);
+        SuccessOrExit(err);
+    }
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::ClearConfigValue(Key key)
+{
+    CHIP_ERROR err;
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->ClearValue(key.Name);
+    if (err == CHIP_ERROR_KEY_NOT_FOUND)
+    {
+        ExitNow(err = CHIP_NO_ERROR);
+    }
+    SuccessOrExit(err);
+
+    // Commit the value to the persistent store.
+    err = storage->Commit();
+    SuccessOrExit(err);
+
+    ChipLogProgress(DeviceLayer, "NVS erase: %s/%s", key.Namespace, key.Name);
+
+exit:
+    return err;
+}
+
+bool PosixConfig::ConfigValueExists(Key key)
+{
+    ChipLinuxStorage * storage;
+
+    storage = GetStorageForNamespace(key);
+    if (storage == nullptr)
+        return false;
+
+    return storage->HasValue(key.Name);
+}
+
+CHIP_ERROR PosixConfig::EnsureNamespace(const char * ns)
+{
+    CHIP_ERROR err             = CHIP_NO_ERROR;
+    ChipLinuxStorage * storage = nullptr;
+
+    if (strcmp(ns, kConfigNamespace_ChipFactory) == 0)
+    {
+        storage = &gChipLinuxFactoryStorage;
+        err     = storage->Init(CHIP_DEFAULT_FACTORY_PATH);
+    }
+    else if (strcmp(ns, kConfigNamespace_ChipConfig) == 0)
+    {
+        storage = &gChipLinuxConfigStorage;
+        err     = storage->Init(CHIP_DEFAULT_CONFIG_PATH);
+    }
+    else if (strcmp(ns, kConfigNamespace_ChipCounters) == 0)
+    {
+        storage = &gChipLinuxCountersStorage;
+        err     = storage->Init(CHIP_DEFAULT_DATA_PATH);
+    }
+
+    SuccessOrExit(err);
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::ClearNamespace(const char * ns)
+{
+    CHIP_ERROR err             = CHIP_NO_ERROR;
+    ChipLinuxStorage * storage = nullptr;
+
+    if (strcmp(ns, kConfigNamespace_ChipConfig) == 0)
+    {
+        storage = &gChipLinuxConfigStorage;
+    }
+    else if (strcmp(ns, kConfigNamespace_ChipCounters) == 0)
+    {
+        storage = &gChipLinuxCountersStorage;
+    }
+
+    VerifyOrExit(storage != nullptr, err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND);
+
+    err = storage->ClearAll();
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Storage ClearAll failed: %s", ErrorStr(err));
+    }
+    SuccessOrExit(err);
+
+    err = storage->Commit();
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Storage Commit failed: %s", ErrorStr(err));
+    }
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::FactoryResetConfig()
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    ChipLinuxStorage * storage;
+
+    ChipLogProgress(DeviceLayer, "Performing factory reset configuration");
+
+    storage = &gChipLinuxConfigStorage;
+    if (storage == nullptr)
+    {
+        ChipLogError(DeviceLayer, "Storage get failed");
+        err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND;
+    }
+    SuccessOrExit(err);
+
+    err = storage->ClearAll();
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Storage ClearAll failed: %s", ErrorStr(err));
+    }
+    SuccessOrExit(err);
+
+    err = storage->Commit();
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Storage Commit failed: %s", ErrorStr(err));
+    }
+
+exit:
+    return err;
+}
+
+CHIP_ERROR PosixConfig::FactoryResetCounters()
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    ChipLinuxStorage * storage;
+
+    ChipLogProgress(DeviceLayer, "Performing factory reset counters");
+
+    storage = &gChipLinuxCountersStorage;
+    if (storage == nullptr)
+    {
+        ChipLogError(DeviceLayer, "Storage get failed");
+        err = CHIP_DEVICE_ERROR_CONFIG_NOT_FOUND;
+    }
+    SuccessOrExit(err);
+
+    err = storage->ClearAll();
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Storage ClearAll failed: %s", ErrorStr(err));
+    }
+    SuccessOrExit(err);
+
+    err = storage->Commit();
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Storage Commit failed: %s", ErrorStr(err));
+    }
+
+exit:
+    return err;
+}
+
+void PosixConfig::RunConfigUnitTest()
+{
+    // Run common unit test.
+    ::chip::DeviceLayer::Internal::RunConfigUnitTest<PosixConfig>();
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/PosixConfig.h b/src/platform/webos/PosixConfig.h
new file mode 100644
index 000000000..97ab64b80
--- /dev/null
+++ b/src/platform/webos/PosixConfig.h
@@ -0,0 +1,130 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Utilities for accessing persisted device configuration on
+ *          Linux platforms.
+ */
+
+#pragma once
+
+#include <functional>
+#include <inttypes.h>
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+class ChipLinuxStorage;
+
+/**
+ * Provides functions and definitions for accessing device configuration information on the Posix.
+ *
+ * This class is designed to be mixed-in to concrete implementation classes as a means to
+ * provide access to configuration information to generic base classes.
+ */
+class PosixConfig
+{
+public:
+    struct Key;
+
+    // Maximum length of an NVS key name.
+    static constexpr size_t kMaxConfigKeyNameLength = 15;
+
+    // NVS namespaces used to store device configuration information.
+    static const char kConfigNamespace_ChipFactory[];
+    static const char kConfigNamespace_ChipConfig[];
+    static const char kConfigNamespace_ChipCounters[];
+
+    // Key definitions for well-known keys.
+    static const Key kConfigKey_SerialNum;
+    static const Key kConfigKey_MfrDeviceId;
+    static const Key kConfigKey_MfrDeviceCert;
+    static const Key kConfigKey_MfrDeviceICACerts;
+    static const Key kConfigKey_MfrDevicePrivateKey;
+    static const Key kConfigKey_HardwareVersion;
+    static const Key kConfigKey_ManufacturingDate;
+    static const Key kConfigKey_SetupPinCode;
+    static const Key kConfigKey_FabricId;
+    static const Key kConfigKey_ServiceConfig;
+    static const Key kConfigKey_PairedAccountId;
+    static const Key kConfigKey_ServiceId;
+    static const Key kConfigKey_FabricSecret;
+    static const Key kConfigKey_GroupKeyIndex;
+    static const Key kConfigKey_LastUsedEpochKeyId;
+    static const Key kConfigKey_FailSafeArmed;
+    static const Key kConfigKey_WiFiStationSecType;
+    static const Key kConfigKey_SetupDiscriminator;
+    static const Key kConfigKey_RegulatoryLocation;
+    static const Key kConfigKey_CountryCode;
+    static const Key kConfigKey_Breadcrumb;
+    static const Key kConfigKey_LocationCapability;
+
+    static const Key kCounterKey_RebootCount;
+    static const Key kCounterKey_UpTime;
+    static const Key kCounterKey_TotalOperationalHours;
+    static const Key kCounterKey_BootReason;
+
+    static const char kGroupKeyNamePrefix[];
+
+    static CHIP_ERROR Init();
+
+    // Config value accessors.
+    static CHIP_ERROR ReadConfigValue(Key key, bool & val);
+    static CHIP_ERROR ReadConfigValue(Key key, uint32_t & val);
+    static CHIP_ERROR ReadConfigValue(Key key, uint64_t & val);
+    static CHIP_ERROR ReadConfigValueStr(Key key, char * buf, size_t bufSize, size_t & outLen);
+    static CHIP_ERROR ReadConfigValueBin(Key key, uint8_t * buf, size_t bufSize, size_t & outLen);
+    static CHIP_ERROR WriteConfigValue(Key key, bool val);
+    static CHIP_ERROR WriteConfigValue(Key key, uint32_t val);
+    static CHIP_ERROR WriteConfigValue(Key key, uint64_t val);
+    static CHIP_ERROR WriteConfigValueStr(Key key, const char * str);
+    static CHIP_ERROR WriteConfigValueStr(Key key, const char * str, size_t strLen);
+    static CHIP_ERROR WriteConfigValueBin(Key key, const uint8_t * data, size_t dataLen);
+    static CHIP_ERROR ClearConfigValue(Key key);
+    static bool ConfigValueExists(Key key);
+    static CHIP_ERROR FactoryResetConfig();
+    static CHIP_ERROR FactoryResetCounters();
+    static void RunConfigUnitTest();
+
+    // NVS Namespace helper functions.
+    static CHIP_ERROR EnsureNamespace(const char * ns);
+    static CHIP_ERROR ClearNamespace(const char * ns);
+
+private:
+    static ChipLinuxStorage * GetStorageForNamespace(Key key);
+};
+
+struct PosixConfig::Key
+{
+    const char * Namespace;
+    const char * Name;
+
+    bool operator==(const Key & other) const;
+};
+
+inline bool PosixConfig::Key::operator==(const Key & other) const
+{
+    return strcmp(Namespace, other.Namespace) == 0 && strcmp(Name, other.Name) == 0;
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/README.md b/src/platform/webos/README.md
new file mode 100644
index 000000000..0fcdb7ec1
--- /dev/null
+++ b/src/platform/webos/README.md
@@ -0,0 +1,59 @@
+# Overview of CHIP Linux Adaption
+
+The following is a quick overview of the Linux adaptation of CHIP. Most of this
+code will have parallels in any new adaptation.
+
+(All file names are relative to `connectedhomeip/src/...`).
+
+`include/platform/Linux/PlatformManagerImpl.h`<br>`Linux/PlatformManagerImpl.cpp`
+
+-   Concrete implementation of PlatformManager interface
+-   Provides initialization of the CHIP stack and core event loop for the chip
+    task
+-   Relies on GenericPlatformManagerImpl_POSIX<> class to provide most of the
+    implementation
+
+`include/platform/Linux/ConfigurationManagerImpl.h`<br>`Linux/ConfigurationManagerImpl.cpp`
+
+-   Concrete implementation of ConfigurationManager interface
+-   Manages storage and retrieval of persistent configuration data
+-   Relies on GenericConfigurationManagerImpl<> classes to implement most API
+    functionality
+-   Delegates low-level reading and writing of persistent values to PosixConfig
+    class
+
+`include/platform/Linux/ConnectivityManagerImpl.h`<br>`Linux/ConnectivityManagerImpl.cpp`
+
+-   Concrete implementation of ConnectivityManager interface
+-   Provides high-level APIs for managing device connectivity
+-   Relies on various generic implementation classes to provide API
+    functionality
+-   Very much a work-in-progress in the Linux branch
+
+`include/platform/Linux/ThreadStackManagerImpl.h`<br>`Linux/ThreadStackManagerImpl.cpp`
+
+-   Concrete implementation of ThreadStackManager interface
+-   Supports Thread stack initialization and core event loop processing
+-   Relies on GenericThreadStackManagerImpl_OpenThread/POSIX<> classes to
+    implement most API functionality
+
+`include/platform/Linux/BLEManagerImpl.h`<br>`Linux/BLEManagerImpl.cpp`
+
+-   Concrete implementation of the BLEManager interface
+-   Maps CHIP's BLE interface abstractions (BleLayer, BlePlatformDelegate,
+    BleApplicationDelegate) onto the platform's native BLE services
+-   Implements chip-compatible BLE advertising.
+
+`platform/Linux/Entropy.cpp`
+
+-   Implements interface to platform entropy source
+
+`platform/Linux/Logging.cpp`
+
+-   Adaption of chip debug logging to platform logging facility.
+
+`platform/Linux/PosixConfig.cpp`
+
+-   Implements low-level read/write of persistent configuration values
+-   Class API specifically designed to work in conjunction with the
+    GenericConfigurationManagerImpl<> class.
diff --git a/src/platform/webos/SystemPlatformConfig.h b/src/platform/webos/SystemPlatformConfig.h
new file mode 100644
index 000000000..2794184ca
--- /dev/null
+++ b/src/platform/webos/SystemPlatformConfig.h
@@ -0,0 +1,49 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Platform-specific configuration overrides for the CHIP System
+ *          Layer on Linux platforms.
+ *
+ */
+
+#pragma once
+
+#include <stdint.h>
+
+namespace chip {
+namespace DeviceLayer {
+struct ChipDeviceEvent;
+} // namespace DeviceLayer
+} // namespace chip
+
+// ==================== Platform Adaptations ====================
+
+#define CHIP_SYSTEM_CONFIG_POSIX_LOCKING 1
+#define CHIP_SYSTEM_CONFIG_FREERTOS_LOCKING 0
+#define CHIP_SYSTEM_CONFIG_NO_LOCKING 0
+#define CHIP_SYSTEM_CONFIG_PLATFORM_PROVIDES_TIME 1
+#define CHIP_SYSTEM_CONFIG_POOL_USE_HEAP 1
+
+// ========== Platform-specific Configuration Overrides =========
+
+#ifndef CHIP_SYSTEM_CONFIG_NUM_TIMERS
+#define CHIP_SYSTEM_CONFIG_NUM_TIMERS 16
+#endif // CHIP_SYSTEM_CONFIG_NUM_TIMERS
+
+#define CHIP_CONFIG_MDNS_CACHE_SIZE 4
diff --git a/src/platform/webos/SystemTimeSupport.cpp b/src/platform/webos/SystemTimeSupport.cpp
new file mode 100644
index 000000000..a4b5ec0b7
--- /dev/null
+++ b/src/platform/webos/SystemTimeSupport.cpp
@@ -0,0 +1,70 @@
+/*
+ *
+ *    Copyright (c) 2018 Nest Labs, Inc.
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          Provides implementations of the CHIP System Layer platform
+ *          time/clock functions that are suitable for use on the Posix platform.
+ */
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+
+#include <lib/support/TimeUtils.h>
+#include <lib/support/logging/CHIPLogging.h>
+
+#include <chrono>
+#include <errno.h>
+#include <inttypes.h>
+#include <sys/time.h>
+
+namespace chip {
+namespace System {
+namespace Clock {
+
+namespace Internal {
+ClockImpl gClockImpl;
+} // namespace Internal
+
+Microseconds64 ClockImpl::GetMonotonicMicroseconds64()
+{
+    return std::chrono::duration_cast<Microseconds64>(std::chrono::steady_clock::now().time_since_epoch());
+}
+
+Milliseconds64 ClockImpl::GetMonotonicMilliseconds64()
+{
+    return std::chrono::duration_cast<Milliseconds64>(std::chrono::steady_clock::now().time_since_epoch());
+}
+
+CHIP_ERROR ClockImpl::GetClock_RealTime(Clock::Microseconds64 & aCurTime)
+{
+    return CHIP_ERROR_UNSUPPORTED_CHIP_FEATURE;
+}
+
+CHIP_ERROR ClockImpl::GetClock_RealTimeMS(Clock::Milliseconds64 & aCurTime)
+{
+    return CHIP_ERROR_UNSUPPORTED_CHIP_FEATURE;
+}
+
+CHIP_ERROR ClockImpl::SetClock_RealTime(Clock::Microseconds64 aNewCurTime)
+{
+    return CHIP_ERROR_UNSUPPORTED_CHIP_FEATURE;
+}
+
+} // namespace Clock
+} // namespace System
+} // namespace chip
diff --git a/src/platform/webos/ThreadStackManagerImpl.cpp b/src/platform/webos/ThreadStackManagerImpl.cpp
new file mode 100644
index 000000000..f51e1cb8d
--- /dev/null
+++ b/src/platform/webos/ThreadStackManagerImpl.cpp
@@ -0,0 +1,512 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+#include <platform/internal/DeviceNetworkInfo.h>
+
+#include <app/AttributeAccessInterface.h>
+#include <lib/support/CodeUtils.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <platform/PlatformManager.h>
+#include <platform/ThreadStackManager.h>
+
+using namespace ::chip::app;
+using namespace ::chip::app::Clusters;
+
+namespace chip {
+namespace DeviceLayer {
+
+ThreadStackManagerImpl ThreadStackManagerImpl::sInstance;
+
+constexpr char ThreadStackManagerImpl::kDBusOpenThreadService[];
+constexpr char ThreadStackManagerImpl::kDBusOpenThreadObjectPath[];
+
+constexpr char ThreadStackManagerImpl::kOpenthreadDeviceRoleDisabled[];
+constexpr char ThreadStackManagerImpl::kOpenthreadDeviceRoleDetached[];
+constexpr char ThreadStackManagerImpl::kOpenthreadDeviceRoleChild[];
+constexpr char ThreadStackManagerImpl::kOpenthreadDeviceRoleRouter[];
+constexpr char ThreadStackManagerImpl::kOpenthreadDeviceRoleLeader[];
+
+constexpr char ThreadStackManagerImpl::kPropertyDeviceRole[];
+
+ThreadStackManagerImpl::ThreadStackManagerImpl() : mAttached(false) {}
+
+CHIP_ERROR ThreadStackManagerImpl::_InitThreadStack()
+{
+    std::unique_ptr<GError, GErrorDeleter> err;
+    mProxy.reset(openthread_io_openthread_border_router_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE,
+                                                                               kDBusOpenThreadService, kDBusOpenThreadObjectPath,
+                                                                               nullptr, &MakeUniquePointerReceiver(err).Get()));
+    if (!mProxy)
+    {
+        ChipLogError(DeviceLayer, "openthread: failed to create openthread dbus proxy %s", err ? err->message : "unknown error");
+        return CHIP_ERROR_INTERNAL;
+    }
+
+    g_signal_connect(mProxy.get(), "g-properties-changed", G_CALLBACK(OnDbusPropertiesChanged), this);
+
+    // If get property is called inside dbus thread (we are going to make it so), XXX_get_XXX can be used instead of XXX_dup_XXX
+    // which is a little bit faster and the returned object doesn't need to be freed. Same for all following get properties.
+    std::unique_ptr<gchar, GFree> role(openthread_io_openthread_border_router_dup_device_role(mProxy.get()));
+    if (role)
+    {
+        ThreadDevcieRoleChangedHandler(role.get());
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+void ThreadStackManagerImpl::OnDbusPropertiesChanged(OpenthreadIoOpenthreadBorderRouter * proxy, GVariant * changed_properties,
+                                                     const gchar * const * invalidated_properties, gpointer user_data)
+{
+    ThreadStackManagerImpl * me = reinterpret_cast<ThreadStackManagerImpl *>(user_data);
+    if (g_variant_n_children(changed_properties) > 0)
+    {
+        const gchar * key;
+        GVariant * value;
+
+        std::unique_ptr<GVariantIter, GVariantIterDeleter> iter;
+        g_variant_get(changed_properties, "a{sv}", &MakeUniquePointerReceiver(iter).Get());
+        if (!iter)
+            return;
+        while (g_variant_iter_loop(iter.get(), "{&sv}", &key, &value))
+        {
+            if (key == nullptr || value == nullptr)
+                continue;
+            // ownership of key and value is still holding by the iter
+            if (strcmp(key, kPropertyDeviceRole) == 0)
+            {
+                const gchar * value_str = g_variant_get_string(value, nullptr);
+                if (value_str == nullptr)
+                    continue;
+                ChipLogProgress(DeviceLayer, "Thread role changed to: %s", value_str);
+                me->ThreadDevcieRoleChangedHandler(value_str);
+            }
+        }
+    }
+}
+
+void ThreadStackManagerImpl::ThreadDevcieRoleChangedHandler(const gchar * role)
+{
+    bool attached = strcmp(role, kOpenthreadDeviceRoleDetached) != 0 && strcmp(role, kOpenthreadDeviceRoleDisabled) != 0;
+
+    ChipDeviceEvent event = ChipDeviceEvent{};
+
+    if (attached != mAttached)
+    {
+        event.Type = DeviceEventType::kThreadConnectivityChange;
+        event.ThreadConnectivityChange.Result =
+            attached ? ConnectivityChange::kConnectivity_Established : ConnectivityChange::kConnectivity_Lost;
+        CHIP_ERROR status = PlatformMgr().PostEvent(&event);
+        if (status != CHIP_NO_ERROR)
+        {
+            ChipLogError(DeviceLayer, "Failed to post thread connectivity change: %" CHIP_ERROR_FORMAT, status.Format());
+        }
+    }
+    mAttached = attached;
+
+    event.Type                          = DeviceEventType::kThreadStateChange;
+    event.ThreadStateChange.RoleChanged = true;
+    CHIP_ERROR status                   = PlatformMgr().PostEvent(&event);
+    if (status != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Failed to post thread state change: %" CHIP_ERROR_FORMAT, status.Format());
+    }
+}
+
+void ThreadStackManagerImpl::_ProcessThreadActivity() {}
+
+bool ThreadStackManagerImpl::_HaveRouteToAddress(const Inet::IPAddress & destAddr)
+{
+    if (!mProxy || !_IsThreadAttached())
+    {
+        return false;
+    }
+    if (destAddr.IsIPv6LinkLocal())
+    {
+        return true;
+    }
+
+    std::unique_ptr<GVariant, GVariantDeleter> routes(openthread_io_openthread_border_router_dup_external_routes(mProxy.get()));
+    if (!routes)
+        return false;
+
+    if (g_variant_n_children(routes.get()) > 0)
+    {
+        std::unique_ptr<GVariantIter, GVariantIterDeleter> iter;
+        g_variant_get(routes.get(), "av", &MakeUniquePointerReceiver(iter).Get());
+        if (!iter)
+            return false;
+
+        GVariant * route;
+        while (g_variant_iter_loop(iter.get(), "&v", &route))
+        {
+            if (route == nullptr)
+                continue;
+            std::unique_ptr<GVariant, GVariantDeleter> prefix;
+            guint16 rloc16;
+            guchar preference;
+            gboolean stable;
+            gboolean nextHopIsThisDevice;
+            g_variant_get(route, "(&vqybb)", &MakeUniquePointerReceiver(prefix).Get(), &rloc16, &preference, &stable,
+                          &nextHopIsThisDevice);
+            if (!prefix)
+                continue;
+
+            std::unique_ptr<GVariant, GVariantDeleter> address;
+            guchar prefixLength;
+            g_variant_get(prefix.get(), "(&vy)", &MakeUniquePointerReceiver(address).Get(), &prefixLength);
+            if (!address)
+                continue;
+
+            GBytes * bytes = g_variant_get_data_as_bytes(address.get()); // the ownership still hold by address
+            if (bytes == nullptr)
+                continue;
+            gsize size;
+            gconstpointer data = g_bytes_get_data(bytes, &size);
+            if (data == nullptr)
+                continue;
+            if (size != sizeof(struct in6_addr))
+                continue;
+
+            Inet::IPPrefix p;
+            p.IPAddr = Inet::IPAddress(*reinterpret_cast<const struct in6_addr *>(data));
+            p.Length = prefixLength;
+
+            if (p.MatchAddress(destAddr))
+            {
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+void ThreadStackManagerImpl::_OnPlatformEvent(const ChipDeviceEvent * event)
+{
+    (void) event;
+    // The otbr-agent processes the Thread state handling by itself so there
+    // isn't much to do in the Chip stack.
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_SetThreadProvision(ByteSpan netInfo)
+{
+    VerifyOrReturnError(mProxy, CHIP_ERROR_INCORRECT_STATE);
+    VerifyOrReturnError(Thread::OperationalDataset::IsValid(netInfo), CHIP_ERROR_INVALID_ARGUMENT);
+
+    {
+        std::unique_ptr<GBytes, GBytesDeleter> bytes(g_bytes_new(netInfo.data(), netInfo.size()));
+        if (!bytes)
+            return CHIP_ERROR_NO_MEMORY;
+        std::unique_ptr<GVariant, GVariantDeleter> value(
+            g_variant_new_from_bytes(G_VARIANT_TYPE_BYTESTRING, bytes.release(), true));
+        if (!value)
+            return CHIP_ERROR_NO_MEMORY;
+        openthread_io_openthread_border_router_set_active_dataset_tlvs(mProxy.get(), value.release());
+    }
+
+    // post an event alerting other subsystems about change in provisioning state
+    ChipDeviceEvent event;
+    event.Type                                           = DeviceEventType::kServiceProvisioningChange;
+    event.ServiceProvisioningChange.IsServiceProvisioned = true;
+    return PlatformMgr().PostEvent(&event);
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_GetThreadProvision(ByteSpan & netInfo)
+{
+    VerifyOrReturnError(mProxy, CHIP_ERROR_INCORRECT_STATE);
+
+    {
+        std::unique_ptr<GVariant, GVariantDeleter> value(
+            openthread_io_openthread_border_router_dup_active_dataset_tlvs(mProxy.get()));
+        GBytes * bytes = g_variant_get_data_as_bytes(value.get());
+        gsize size;
+        const uint8_t * data = reinterpret_cast<const uint8_t *>(g_bytes_get_data(bytes, &size));
+        ReturnErrorOnFailure(mDataset.Init(ByteSpan(data, size)));
+    }
+
+    netInfo = mDataset.AsByteSpan();
+
+    return CHIP_NO_ERROR;
+}
+
+bool ThreadStackManagerImpl::_IsThreadProvisioned()
+{
+    return static_cast<Thread::OperationalDataset &>(mDataset).IsCommissioned();
+}
+
+void ThreadStackManagerImpl::_ErasePersistentInfo()
+{
+    static_cast<Thread::OperationalDataset &>(mDataset).Clear();
+}
+
+bool ThreadStackManagerImpl::_IsThreadEnabled()
+{
+    if (!mProxy)
+    {
+        return false;
+    }
+
+    std::unique_ptr<gchar, GFree> role(openthread_io_openthread_border_router_dup_device_role(mProxy.get()));
+    return (strcmp(role.get(), kOpenthreadDeviceRoleDisabled) != 0);
+}
+
+bool ThreadStackManagerImpl::_IsThreadAttached()
+{
+    return mAttached;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_SetThreadEnabled(bool val)
+{
+    VerifyOrReturnError(mProxy, CHIP_ERROR_INCORRECT_STATE);
+    if (val)
+    {
+        std::unique_ptr<GError, GErrorDeleter> err;
+        gboolean result =
+            openthread_io_openthread_border_router_call_attach_sync(mProxy.get(), nullptr, &MakeUniquePointerReceiver(err).Get());
+        if (err)
+        {
+            ChipLogError(DeviceLayer, "openthread: _SetThreadEnabled calling %s failed: %s", "Attach", err->message);
+            return CHIP_ERROR_INTERNAL;
+        }
+
+        if (!result)
+        {
+            ChipLogError(DeviceLayer, "openthread: _SetThreadEnabled calling %s failed: %s", "Attach", "return false");
+            return CHIP_ERROR_INTERNAL;
+        }
+    }
+    else
+    {
+        std::unique_ptr<GError, GErrorDeleter> err;
+        gboolean result =
+            openthread_io_openthread_border_router_call_reset_sync(mProxy.get(), nullptr, &MakeUniquePointerReceiver(err).Get());
+        if (err)
+        {
+            ChipLogError(DeviceLayer, "openthread: _SetThreadEnabled calling %s failed: %s", "Reset", err->message);
+            return CHIP_ERROR_INTERNAL;
+        }
+
+        if (!result)
+        {
+            ChipLogError(DeviceLayer, "openthread: _SetThreadEnabled calling %s failed: %s", "Reset", "return false");
+            return CHIP_ERROR_INTERNAL;
+        }
+    }
+    return CHIP_NO_ERROR;
+}
+
+ConnectivityManager::ThreadDeviceType ThreadStackManagerImpl::_GetThreadDeviceType()
+{
+    ConnectivityManager::ThreadDeviceType type = ConnectivityManager::ThreadDeviceType::kThreadDeviceType_NotSupported;
+    if (!mProxy)
+    {
+        ChipLogError(DeviceLayer, "Cannot get device role with Thread api client: %s", "");
+        return ConnectivityManager::ThreadDeviceType::kThreadDeviceType_NotSupported;
+    }
+
+    std::unique_ptr<gchar, GFree> role(openthread_io_openthread_border_router_dup_device_role(mProxy.get()));
+    if (!role)
+        return ConnectivityManager::ThreadDeviceType::kThreadDeviceType_NotSupported;
+    if (strcmp(role.get(), kOpenthreadDeviceRoleDetached) == 0 || strcmp(role.get(), kOpenthreadDeviceRoleDisabled) == 0)
+    {
+        return ConnectivityManager::ThreadDeviceType::kThreadDeviceType_NotSupported;
+    }
+    else if (strcmp(role.get(), kOpenthreadDeviceRoleChild) == 0)
+    {
+        std::unique_ptr<GVariant, GVariantDeleter> linkMode(openthread_io_openthread_border_router_dup_link_mode(mProxy.get()));
+        if (!linkMode)
+            return ConnectivityManager::ThreadDeviceType::kThreadDeviceType_NotSupported;
+        gboolean rx_on_when_idle;
+        gboolean device_type;
+        gboolean network_data;
+        g_variant_get(linkMode.get(), "(bbb)", &rx_on_when_idle, &device_type, &network_data);
+        if (!rx_on_when_idle)
+        {
+            type = ConnectivityManager::ThreadDeviceType::kThreadDeviceType_SleepyEndDevice;
+        }
+        else
+        {
+            type = device_type ? ConnectivityManager::ThreadDeviceType::kThreadDeviceType_FullEndDevice
+                               : ConnectivityManager::ThreadDeviceType::kThreadDeviceType_MinimalEndDevice;
+        }
+        return type;
+    }
+    else if (strcmp(role.get(), kOpenthreadDeviceRoleLeader) == 0 || strcmp(role.get(), kOpenthreadDeviceRoleRouter) == 0)
+    {
+        return ConnectivityManager::ThreadDeviceType::kThreadDeviceType_Router;
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "Unknown Thread role: %s", role.get());
+        return ConnectivityManager::ThreadDeviceType::kThreadDeviceType_NotSupported;
+    }
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_SetThreadDeviceType(ConnectivityManager::ThreadDeviceType deviceType)
+{
+    gboolean rx_on_when_idle = true;
+    gboolean device_type     = true;
+    gboolean network_data    = true;
+    VerifyOrReturnError(mProxy, CHIP_ERROR_INCORRECT_STATE);
+    if (deviceType == ConnectivityManager::ThreadDeviceType::kThreadDeviceType_MinimalEndDevice)
+    {
+        network_data = false;
+    }
+    else if (deviceType == ConnectivityManager::ThreadDeviceType::kThreadDeviceType_SleepyEndDevice)
+    {
+        rx_on_when_idle = false;
+        network_data    = false;
+    }
+
+    if (!network_data)
+    {
+        std::unique_ptr<GVariant, GVariantDeleter> linkMode(g_variant_new("(bbb)", rx_on_when_idle, device_type, network_data));
+        if (!linkMode)
+            return CHIP_ERROR_NO_MEMORY;
+        openthread_io_openthread_border_router_set_link_mode(mProxy.get(), linkMode.release());
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+#if CHIP_DEVICE_CONFIG_ENABLE_SED
+CHIP_ERROR ThreadStackManagerImpl::_GetSEDPollingConfig(ConnectivityManager::SEDPollingConfig & pollingConfig)
+{
+    (void) pollingConfig;
+
+    ChipLogError(DeviceLayer, "Polling config is not supported on linux");
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_SetSEDPollingConfig(const ConnectivityManager::SEDPollingConfig & pollingConfig)
+{
+    (void) pollingConfig;
+
+    ChipLogError(DeviceLayer, "Polling config is not supported on linux");
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_RequestSEDFastPollingMode(bool onOff)
+{
+    (void) onOff;
+
+    ChipLogError(DeviceLayer, "Polling config is not supported on linux");
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+#endif
+
+bool ThreadStackManagerImpl::_HaveMeshConnectivity()
+{
+    // TODO: Remove Weave legacy APIs
+    // For a leader with a child, the child is considered to have mesh connectivity
+    // and the leader is not, which is a very confusing definition.
+    // This API is Weave legacy and should be removed.
+
+    ChipLogError(DeviceLayer, "HaveMeshConnectivity has confusing behavior and shouldn't be called");
+    return false;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_GetAndLogThreadStatsCounters()
+{
+    // TODO: Remove Weave legacy APIs
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_GetAndLogThreadTopologyMinimal()
+{
+    // TODO: Remove Weave legacy APIs
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_GetAndLogThreadTopologyFull()
+{
+    // TODO: Remove Weave legacy APIs
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_GetPrimary802154MACAddress(uint8_t * buf)
+{
+    VerifyOrReturnError(mProxy, CHIP_ERROR_INCORRECT_STATE);
+    guint64 extAddr = openthread_io_openthread_border_router_get_extended_address(mProxy.get());
+
+    for (size_t i = 0; i < sizeof(extAddr); i++)
+    {
+        buf[sizeof(uint64_t) - i - 1] = (extAddr & UINT8_MAX);
+        extAddr >>= CHAR_BIT;
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_GetExternalIPv6Address(chip::Inet::IPAddress & addr)
+{
+    // TODO: Remove Weave legacy APIs
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_GetPollPeriod(uint32_t & buf)
+{
+    // TODO: Remove Weave legacy APIs
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+CHIP_ERROR ThreadStackManagerImpl::_JoinerStart()
+{
+    // TODO: Remove Weave legacy APIs
+    return CHIP_ERROR_NOT_IMPLEMENTED;
+}
+
+void ThreadStackManagerImpl::_ResetThreadNetworkDiagnosticsCounts() {}
+
+CHIP_ERROR ThreadStackManagerImpl::_WriteThreadNetworkDiagnosticAttributeToTlv(AttributeId attributeId,
+                                                                               app::AttributeValueEncoder & encoder)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+
+    switch (attributeId)
+    {
+    case ThreadNetworkDiagnostics::Attributes::NeighborTableList::Id:
+    case ThreadNetworkDiagnostics::Attributes::RouteTableList::Id:
+    case ThreadNetworkDiagnostics::Attributes::SecurityPolicy::Id:
+    case ThreadNetworkDiagnostics::Attributes::OperationalDatasetComponents::Id:
+    case ThreadNetworkDiagnostics::Attributes::ActiveNetworkFaultsList::Id: {
+        err = encoder.Encode(DataModel::List<EndpointId>());
+        break;
+    }
+    default: {
+        err = CHIP_ERROR_UNSUPPORTED_CHIP_FEATURE;
+        break;
+    }
+    }
+
+    return err;
+}
+
+ThreadStackManager & ThreadStackMgr()
+{
+    return chip::DeviceLayer::ThreadStackManagerImpl::sInstance;
+}
+
+ThreadStackManagerImpl & ThreadStackMgrImpl()
+{
+    return chip::DeviceLayer::ThreadStackManagerImpl::sInstance;
+}
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/ThreadStackManagerImpl.h b/src/platform/webos/ThreadStackManagerImpl.h
new file mode 100644
index 000000000..3a241509c
--- /dev/null
+++ b/src/platform/webos/ThreadStackManagerImpl.h
@@ -0,0 +1,121 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+
+#include <app/AttributeAccessInterface.h>
+#include <lib/support/ThreadOperationalDataset.h>
+#include <platform/webos/GlibTypeDeleter.h>
+#include <platform/webos/dbus/openthread/introspect.h>
+#include <platform/internal/CHIPDeviceLayerInternal.h>
+#include <platform/internal/DeviceNetworkInfo.h>
+
+namespace chip {
+namespace DeviceLayer {
+
+class ThreadStackManagerImpl : public ThreadStackManager
+{
+public:
+    ThreadStackManagerImpl();
+
+    CHIP_ERROR _InitThreadStack();
+    void _ProcessThreadActivity();
+
+    CHIP_ERROR _StartThreadTask() { return CHIP_NO_ERROR; } // Intentionally left blank
+    void _LockThreadStack() {}                              // Intentionally left blank
+    bool _TryLockThreadStack() { return false; }            // Intentionally left blank
+    void _UnlockThreadStack() {}                            // Intentionally left blank
+
+    bool _HaveRouteToAddress(const Inet::IPAddress & destAddr);
+
+    void _OnPlatformEvent(const ChipDeviceEvent * event);
+
+    CHIP_ERROR _GetThreadProvision(ByteSpan & netInfo);
+
+    CHIP_ERROR _SetThreadProvision(ByteSpan netInfo);
+
+    void _ErasePersistentInfo();
+
+    bool _IsThreadProvisioned();
+
+    bool _IsThreadEnabled();
+
+    bool _IsThreadAttached();
+
+    CHIP_ERROR _SetThreadEnabled(bool val);
+
+    ConnectivityManager::ThreadDeviceType _GetThreadDeviceType();
+
+    CHIP_ERROR _SetThreadDeviceType(ConnectivityManager::ThreadDeviceType deviceType);
+
+#if CHIP_DEVICE_CONFIG_ENABLE_SED
+    CHIP_ERROR _GetSEDPollingConfig(ConnectivityManager::SEDPollingConfig & pollingConfig);
+    CHIP_ERROR _SetSEDPollingConfig(const ConnectivityManager::SEDPollingConfig & pollingConfig);
+    CHIP_ERROR _RequestSEDFastPollingMode(bool onOff);
+#endif
+
+    bool _HaveMeshConnectivity();
+
+    CHIP_ERROR _GetAndLogThreadStatsCounters();
+
+    CHIP_ERROR _GetAndLogThreadTopologyMinimal();
+
+    CHIP_ERROR _GetAndLogThreadTopologyFull();
+
+    CHIP_ERROR _GetPrimary802154MACAddress(uint8_t * buf);
+
+    CHIP_ERROR _GetExternalIPv6Address(chip::Inet::IPAddress & addr);
+
+    CHIP_ERROR _GetPollPeriod(uint32_t & buf);
+
+    CHIP_ERROR _JoinerStart();
+
+    void _ResetThreadNetworkDiagnosticsCounts();
+
+    CHIP_ERROR _WriteThreadNetworkDiagnosticAttributeToTlv(AttributeId attributeId, app::AttributeValueEncoder & encoder);
+
+    ~ThreadStackManagerImpl() = default;
+
+    static ThreadStackManagerImpl sInstance;
+
+private:
+    static constexpr char kDBusOpenThreadService[]    = "io.openthread.BorderRouter.wpan0";
+    static constexpr char kDBusOpenThreadObjectPath[] = "/io/openthread/BorderRouter/wpan0";
+
+    static constexpr char kOpenthreadDeviceRoleDisabled[] = "disabled";
+    static constexpr char kOpenthreadDeviceRoleDetached[] = "detached";
+    static constexpr char kOpenthreadDeviceRoleChild[]    = "child";
+    static constexpr char kOpenthreadDeviceRoleRouter[]   = "router";
+    static constexpr char kOpenthreadDeviceRoleLeader[]   = "leader";
+
+    static constexpr char kPropertyDeviceRole[] = "DeviceRole";
+
+    std::unique_ptr<OpenthreadIoOpenthreadBorderRouter, GObjectDeleter> mProxy;
+
+    static void OnDbusPropertiesChanged(OpenthreadIoOpenthreadBorderRouter * proxy, GVariant * changed_properties,
+                                        const gchar * const * invalidated_properties, gpointer user_data);
+    void ThreadDevcieRoleChangedHandler(const gchar * role);
+
+    Thread::OperationalDataset mDataset = {};
+
+    bool mAttached;
+};
+
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/WirelessDefs.h b/src/platform/webos/WirelessDefs.h
new file mode 100644
index 000000000..d01338fd0
--- /dev/null
+++ b/src/platform/webos/WirelessDefs.h
@@ -0,0 +1,186 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *          IEEE 802.11 Frame type definitions.
+ */
+
+#pragma once
+
+/* Status codes (IEEE Std 802.11-2016, 9.4.1.9, Table 9-46) */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_TDLS_WAKEUP_ALTERNATE 2
+#define WLAN_STATUS_TDLS_WAKEUP_REJECT 3
+#define WLAN_STATUS_SECURITY_DISABLED 5
+#define WLAN_STATUS_UNACCEPTABLE_LIFETIME 6
+#define WLAN_STATUS_NOT_IN_SAME_BSS 7
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
+#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
+#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
+#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
+#define WLAN_STATUS_ASSOC_DENIED_NO_HT 27
+#define WLAN_STATUS_R0KH_UNREACHABLE 28
+#define WLAN_STATUS_ASSOC_DENIED_NO_PCO 29
+#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
+#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
+#define WLAN_STATUS_UNSPECIFIED_QOS_FAILURE 32
+#define WLAN_STATUS_DENIED_INSUFFICIENT_BANDWIDTH 33
+#define WLAN_STATUS_DENIED_POOR_CHANNEL_CONDITIONS 34
+#define WLAN_STATUS_DENIED_QOS_NOT_SUPPORTED 35
+#define WLAN_STATUS_REQUEST_DECLINED 37
+#define WLAN_STATUS_INVALID_PARAMETERS 38
+#define WLAN_STATUS_REJECTED_WITH_SUGGESTED_CHANGES 39
+#define WLAN_STATUS_INVALID_IE 40
+#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
+#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
+#define WLAN_STATUS_AKMP_NOT_VALID 43
+#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
+#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
+#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
+#define WLAN_STATUS_TS_NOT_CREATED 47
+#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
+#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
+#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
+#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
+#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
+#define WLAN_STATUS_INVALID_PMKID 53
+#define WLAN_STATUS_INVALID_MDIE 54
+#define WLAN_STATUS_INVALID_FTIE 55
+#define WLAN_STATUS_REQUESTED_TCLAS_NOT_SUPPORTED 56
+#define WLAN_STATUS_INSUFFICIENT_TCLAS_PROCESSING_RESOURCES 57
+#define WLAN_STATUS_TRY_ANOTHER_BSS 58
+#define WLAN_STATUS_GAS_ADV_PROTO_NOT_SUPPORTED 59
+#define WLAN_STATUS_NO_OUTSTANDING_GAS_REQ 60
+#define WLAN_STATUS_GAS_RESP_NOT_RECEIVED 61
+#define WLAN_STATUS_STA_TIMED_OUT_WAITING_FOR_GAS_RESP 62
+#define WLAN_STATUS_GAS_RESP_LARGER_THAN_LIMIT 63
+#define WLAN_STATUS_REQ_REFUSED_HOME 64
+#define WLAN_STATUS_ADV_SRV_UNREACHABLE 65
+#define WLAN_STATUS_REQ_REFUSED_SSPN 67
+#define WLAN_STATUS_REQ_REFUSED_UNAUTH_ACCESS 68
+#define WLAN_STATUS_INVALID_RSNIE 72
+#define WLAN_STATUS_U_APSD_COEX_NOT_SUPPORTED 73
+#define WLAN_STATUS_U_APSD_COEX_MODE_NOT_SUPPORTED 74
+#define WLAN_STATUS_BAD_INTERVAL_WITH_U_APSD_COEX 75
+#define WLAN_STATUS_ANTI_CLOGGING_TOKEN_REQ 76
+#define WLAN_STATUS_FINITE_CYCLIC_GROUP_NOT_SUPPORTED 77
+#define WLAN_STATUS_CANNOT_FIND_ALT_TBTT 78
+#define WLAN_STATUS_TRANSMISSION_FAILURE 79
+#define WLAN_STATUS_REQ_TCLAS_NOT_SUPPORTED 80
+#define WLAN_STATUS_TCLAS_RESOURCES_EXCHAUSTED 81
+#define WLAN_STATUS_REJECTED_WITH_SUGGESTED_BSS_TRANSITION 82
+#define WLAN_STATUS_REJECT_WITH_SCHEDULE 83
+#define WLAN_STATUS_REJECT_NO_WAKEUP_SPECIFIED 84
+#define WLAN_STATUS_SUCCESS_POWER_SAVE_MODE 85
+#define WLAN_STATUS_PENDING_ADMITTING_FST_SESSION 86
+#define WLAN_STATUS_PERFORMING_FST_NOW 87
+#define WLAN_STATUS_PENDING_GAP_IN_BA_WINDOW 88
+#define WLAN_STATUS_REJECT_U_PID_SETTING 89
+#define WLAN_STATUS_REFUSED_EXTERNAL_REASON 92
+#define WLAN_STATUS_REFUSED_AP_OUT_OF_MEMORY 93
+#define WLAN_STATUS_REJECTED_EMERGENCY_SERVICE_NOT_SUPPORTED 94
+#define WLAN_STATUS_QUERY_RESP_OUTSTANDING 95
+#define WLAN_STATUS_REJECT_DSE_BAND 96
+#define WLAN_STATUS_TCLAS_PROCESSING_TERMINATED 97
+#define WLAN_STATUS_TS_SCHEDULE_CONFLICT 98
+#define WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL 99
+#define WLAN_STATUS_MCCAOP_RESERVATION_CONFLICT 100
+#define WLAN_STATUS_MAF_LIMIT_EXCEEDED 101
+#define WLAN_STATUS_MCCA_TRACK_LIMIT_EXCEEDED 102
+#define WLAN_STATUS_DENIED_DUE_TO_SPECTRUM_MANAGEMENT 103
+#define WLAN_STATUS_ASSOC_DENIED_NO_VHT 104
+#define WLAN_STATUS_ENABLEMENT_DENIED 105
+#define WLAN_STATUS_RESTRICTION_FROM_AUTHORIZED_GDB 106
+#define WLAN_STATUS_AUTHORIZATION_DEENABLED 107
+#define WLAN_STATUS_FILS_AUTHENTICATION_FAILURE 112
+#define WLAN_STATUS_UNKNOWN_AUTHENTICATION_SERVER 113
+#define WLAN_STATUS_UNKNOWN_PASSWORD_IDENTIFIER 123
+
+/* Reason codes (IEEE Std 802.11-2016, 9.4.1.7, Table 9-45) */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
+#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
+#define WLAN_REASON_BSS_TRANSITION_DISASSOC 12
+#define WLAN_REASON_INVALID_IE 13
+#define WLAN_REASON_MICHAEL_MIC_FAILURE 14
+#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
+#define WLAN_REASON_GROUP_KEY_UPDATE_TIMEOUT 16
+#define WLAN_REASON_IE_IN_4WAY_DIFFERS 17
+#define WLAN_REASON_GROUP_CIPHER_NOT_VALID 18
+#define WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID 19
+#define WLAN_REASON_AKMP_NOT_VALID 20
+#define WLAN_REASON_UNSUPPORTED_RSN_IE_VERSION 21
+#define WLAN_REASON_INVALID_RSN_IE_CAPAB 22
+#define WLAN_REASON_IEEE_802_1X_AUTH_FAILED 23
+#define WLAN_REASON_CIPHER_SUITE_REJECTED 24
+#define WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE 25
+#define WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED 26
+#define WLAN_REASON_SSP_REQUESTED_DISASSOC 27
+#define WLAN_REASON_NO_SSP_ROAMING_AGREEMENT 28
+#define WLAN_REASON_BAD_CIPHER_OR_AKM 29
+#define WLAN_REASON_NOT_AUTHORIZED_THIS_LOCATION 30
+#define WLAN_REASON_SERVICE_CHANGE_PRECLUDES_TS 31
+#define WLAN_REASON_UNSPECIFIED_QOS_REASON 32
+#define WLAN_REASON_NOT_ENOUGH_BANDWIDTH 33
+#define WLAN_REASON_DISASSOC_LOW_ACK 34
+#define WLAN_REASON_EXCEEDED_TXOP 35
+#define WLAN_REASON_STA_LEAVING 36
+#define WLAN_REASON_END_TS_BA_DLS 37
+#define WLAN_REASON_UNKNOWN_TS_BA 38
+#define WLAN_REASON_TIMEOUT 39
+#define WLAN_REASON_PEERKEY_MISMATCH 45
+#define WLAN_REASON_AUTHORIZED_ACCESS_LIMIT_REACHED 46
+#define WLAN_REASON_EXTERNAL_SERVICE_REQUIREMENTS 47
+#define WLAN_REASON_INVALID_FT_ACTION_FRAME_COUNT 48
+#define WLAN_REASON_INVALID_PMKID 49
+#define WLAN_REASON_INVALID_MDE 50
+#define WLAN_REASON_INVALID_FTE 51
+#define WLAN_REASON_MESH_PEERING_CANCELLED 52
+#define WLAN_REASON_MESH_MAX_PEERS 53
+#define WLAN_REASON_MESH_CONFIG_POLICY_VIOLATION 54
+#define WLAN_REASON_MESH_CLOSE_RCVD 55
+#define WLAN_REASON_MESH_MAX_RETRIES 56
+#define WLAN_REASON_MESH_CONFIRM_TIMEOUT 57
+#define WLAN_REASON_MESH_INVALID_GTK 58
+#define WLAN_REASON_MESH_INCONSISTENT_PARAMS 59
+#define WLAN_REASON_MESH_INVALID_SECURITY_CAP 60
+#define WLAN_REASON_MESH_PATH_ERROR_NO_PROXY_INFO 61
+#define WLAN_REASON_MESH_PATH_ERROR_NO_FORWARDING_INFO 62
+#define WLAN_REASON_MESH_PATH_ERROR_DEST_UNREACHABLE 63
+#define WLAN_REASON_MAC_ADDRESS_ALREADY_EXISTS_IN_MBSS 64
+#define WLAN_REASON_MESH_CHANNEL_SWITCH_REGULATORY_REQ 65
+#define WLAN_REASON_MESH_CHANNEL_SWITCH_UNSPECIFIED 66
diff --git a/src/platform/webos/args.gni b/src/platform/webos/args.gni
new file mode 100644
index 000000000..f9f97ee30
--- /dev/null
+++ b/src/platform/webos/args.gni
@@ -0,0 +1,15 @@
+# Copyright (c) 2020 Project CHIP Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+chip_device_platform = "linux"
diff --git a/src/platform/webos/bluez/AdapterIterator.cpp b/src/platform/webos/bluez/AdapterIterator.cpp
new file mode 100644
index 000000000..4f9cc0af1
--- /dev/null
+++ b/src/platform/webos/bluez/AdapterIterator.cpp
@@ -0,0 +1,133 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#include "AdapterIterator.h"
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+#include <lib/support/CodeUtils.h>
+#include <lib/support/logging/CHIPLogging.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+AdapterIterator::~AdapterIterator()
+{
+    if (mManager != nullptr)
+    {
+        g_object_unref(mManager);
+    }
+
+    if (mObjectList != nullptr)
+    {
+        g_list_free_full(mObjectList, g_object_unref);
+    }
+
+    if (mCurrent.adapter != nullptr)
+    {
+        g_object_unref(mCurrent.adapter);
+        mCurrent.adapter = nullptr;
+    }
+}
+
+void AdapterIterator::Initialize()
+{
+    GError * error = nullptr;
+
+    mManager = g_dbus_object_manager_client_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,
+                                                             BLUEZ_INTERFACE, "/", bluez_object_manager_client_get_proxy_type,
+                                                             nullptr /* unused user data in the Proxy Type Func */,
+                                                             nullptr /*destroy notify */, nullptr /* cancellable */, &error);
+
+    VerifyOrExit(mManager != nullptr, ChipLogError(DeviceLayer, "Failed to get DBUS object manager for listing adapters."));
+
+    mObjectList      = g_dbus_object_manager_get_objects(mManager);
+    mCurrentListItem = mObjectList;
+
+exit:
+    if (error != nullptr)
+    {
+        ChipLogError(DeviceLayer, "DBus error: %s", error->message);
+        g_error_free(error);
+    }
+}
+
+bool AdapterIterator::Advance()
+{
+    if (mCurrentListItem == nullptr)
+    {
+        return false;
+    }
+
+    while (mCurrentListItem != nullptr)
+    {
+        BluezAdapter1 * adapter = bluez_object_get_adapter1(BLUEZ_OBJECT(mCurrentListItem->data));
+        if (adapter == nullptr)
+        {
+            mCurrentListItem = mCurrentListItem->next;
+            continue;
+        }
+
+        // PATH is of the for  BLUEZ_PATH / hci<nr>, i.e. like
+        // '/org/bluez/hci0'
+        // Index represents the number after hci
+        const char * path = g_dbus_proxy_get_object_path(G_DBUS_PROXY(adapter));
+        unsigned index    = 0;
+
+        if (sscanf(path, BLUEZ_PATH "/hci%u", &index) != 1)
+        {
+            ChipLogError(DeviceLayer, "Failed to extract HCI index from '%s'", path);
+            index = 0;
+        }
+
+        if (mCurrent.adapter != nullptr)
+        {
+            g_object_unref(mCurrent.adapter);
+            mCurrent.adapter = nullptr;
+        }
+
+        mCurrent.index   = index;
+        mCurrent.address = bluez_adapter1_get_address(adapter);
+        mCurrent.alias   = bluez_adapter1_get_alias(adapter);
+        mCurrent.name    = bluez_adapter1_get_name(adapter);
+        mCurrent.powered = bluez_adapter1_get_powered(adapter);
+        mCurrent.adapter = adapter;
+
+        mCurrentListItem = mCurrentListItem->next;
+
+        return true;
+    }
+
+    return false;
+}
+
+bool AdapterIterator::Next()
+{
+    if (mManager == nullptr)
+    {
+        Initialize();
+    }
+
+    return Advance();
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif
diff --git a/src/platform/webos/bluez/AdapterIterator.h b/src/platform/webos/bluez/AdapterIterator.h
new file mode 100644
index 000000000..be5399532
--- /dev/null
+++ b/src/platform/webos/bluez/AdapterIterator.h
@@ -0,0 +1,94 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include "Types.h"
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+/// Iterates over available BlueZ adapters
+///
+/// Usage example:
+///
+///  AdapterIterator iterator;
+///  while (iterator.Next()) {
+///      std::cout << iterator.GetAddress() << std::endl;
+///  }
+///
+/// Data is provided through the bluez dbus interface. You can view
+/// this data in the commandline using commands such as:
+///
+///    busctl introspect org.bluez /org/bluez/hci0
+class AdapterIterator
+{
+public:
+    ~AdapterIterator();
+
+    /// Moves to the next DBUS interface.
+    ///
+    /// MUST be called before any of the 'current value' methods are
+    /// used (iterator gets initialized on the first call of Next).
+    bool Next();
+
+    // Information about the current value. Safe to call only after
+    // "Next" has returned true.
+    uint32_t GetIndex() const { return mCurrent.index; }
+    const char * GetAddress() const { return mCurrent.address.c_str(); }
+    const char * GetAlias() const { return mCurrent.alias.c_str(); }
+    const char * GetName() const { return mCurrent.name.c_str(); }
+    bool IsPowered() const { return mCurrent.powered; }
+    BluezAdapter1 * GetAdapter() const { return mCurrent.adapter; }
+
+private:
+    /// Sets up the DBUS manager and loads the list
+    void Initialize();
+
+    /// Loads the next value in the list.
+    ///
+    /// Returns true if a value could be loaded, false if no more items to
+    /// iterate through.
+    bool Advance();
+
+    static constexpr size_t kMaxAddressLength = 19; // xx:xx:xx:xx:xx:xx
+    static constexpr size_t kMaxNameLength    = 64;
+
+    GDBusObjectManager * mManager = nullptr; // DBus connection
+    GList * mObjectList           = nullptr; // listing of objects on the bus
+    GList * mCurrentListItem      = nullptr; // current item viewed in the list
+
+    // data valid only if Next() returns true
+    struct
+    {
+        uint32_t index;
+        std::string address;
+        std::string alias;
+        std::string name;
+        bool powered;
+        BluezAdapter1 * adapter;
+    } mCurrent = { 0 };
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/bluez/BluezObjectIterator.h b/src/platform/webos/bluez/BluezObjectIterator.h
new file mode 100644
index 000000000..44d2213b0
--- /dev/null
+++ b/src/platform/webos/bluez/BluezObjectIterator.h
@@ -0,0 +1,68 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <glib.h>
+
+#include <platform/CHIPDeviceConfig.h>
+#include <platform/webos/dbus/bluez/DbusBluez.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+/**
+ *  Helper class to iterate over a list of Bluez objects.
+ */
+class BluezObjectIterator
+{
+public:
+    using iterator_category = std::forward_iterator_tag;
+    using difference_type   = std::ptrdiff_t;
+    using value_type        = BluezObject;
+    using pointer           = BluezObject *;
+    using reference         = BluezObject &;
+
+    BluezObjectIterator() = default;
+    explicit BluezObjectIterator(GList * position) : mPosition(position) {}
+
+    reference operator*() const { return *BLUEZ_OBJECT(mPosition->data); }
+    pointer operator->() const { return BLUEZ_OBJECT(mPosition->data); }
+    bool operator==(const BluezObjectIterator & other) const { return mPosition == other.mPosition; }
+    bool operator!=(const BluezObjectIterator & other) const { return mPosition != other.mPosition; }
+
+    BluezObjectIterator & operator++()
+    {
+        mPosition = mPosition->next;
+        return *this;
+    }
+
+    BluezObjectIterator operator++(int)
+    {
+        const auto currentPosition = mPosition;
+        mPosition                  = mPosition->next;
+        return BluezObjectIterator(currentPosition);
+    }
+
+private:
+    GList * mPosition = nullptr;
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/bluez/BluezObjectList.h b/src/platform/webos/bluez/BluezObjectList.h
new file mode 100644
index 000000000..da4dbafa0
--- /dev/null
+++ b/src/platform/webos/bluez/BluezObjectList.h
@@ -0,0 +1,65 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <glib.h>
+
+#include <lib/support/logging/CHIPLogging.h>
+#include <platform/CHIPDeviceConfig.h>
+#include <platform/webos/dbus/bluez/DbusBluez.h>
+
+#include "BluezObjectIterator.h"
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+/**
+ *  C++ wrapper for a Bluez object list based on a object manager
+ */
+class BluezObjectList
+{
+public:
+    explicit BluezObjectList(GDBusObjectManager * manager) { Initialize(manager); }
+
+    ~BluezObjectList() { g_list_free_full(mObjectList, g_object_unref); }
+
+    BluezObjectIterator begin() const { return BluezObjectIterator(mObjectList); }
+    BluezObjectIterator end() const { return BluezObjectIterator(); }
+
+protected:
+    BluezObjectList() {}
+
+    void Initialize(GDBusObjectManager * manager)
+    {
+        if (manager == nullptr)
+        {
+            ChipLogError(DeviceLayer, "Manager is NULL in %s", __func__);
+            return;
+        }
+
+        mObjectList = g_dbus_object_manager_get_objects(manager);
+    }
+
+private:
+    GList * mObjectList = nullptr;
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
diff --git a/src/platform/webos/bluez/ChipDeviceScanner.cpp b/src/platform/webos/bluez/ChipDeviceScanner.cpp
new file mode 100644
index 000000000..0be064878
--- /dev/null
+++ b/src/platform/webos/bluez/ChipDeviceScanner.cpp
@@ -0,0 +1,311 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#include "ChipDeviceScanner.h"
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+#include "BluezObjectList.h"
+#include "MainLoop.h"
+#include "Types.h"
+
+#include <errno.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <pthread.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+namespace {
+
+struct GObjectUnref
+{
+    template <typename T>
+    void operator()(T * value)
+    {
+        g_object_unref(value);
+    }
+};
+
+using GCancellableUniquePtr       = std::unique_ptr<GCancellable, GObjectUnref>;
+using GDBusObjectManagerUniquePtr = std::unique_ptr<GDBusObjectManager, GObjectUnref>;
+
+/// Retrieve CHIP device identification info from the device advertising data
+bool BluezGetChipDeviceInfo(BluezDevice1 & aDevice, chip::Ble::ChipBLEDeviceIdentificationInfo & aDeviceInfo)
+{
+    GVariant * serviceData = bluez_device1_get_service_data(&aDevice);
+    VerifyOrReturnError(serviceData != nullptr, false);
+
+    GVariant * dataValue = g_variant_lookup_value(serviceData, CHIP_BLE_UUID_SERVICE_STRING, nullptr);
+    VerifyOrReturnError(dataValue != nullptr, false);
+
+    size_t dataLen         = 0;
+    const void * dataBytes = g_variant_get_fixed_array(dataValue, &dataLen, sizeof(uint8_t));
+    VerifyOrReturnError(dataBytes != nullptr && dataLen >= sizeof(aDeviceInfo), false);
+
+    memcpy(&aDeviceInfo, dataBytes, sizeof(aDeviceInfo));
+    return true;
+}
+
+} // namespace
+
+ChipDeviceScanner::ChipDeviceScanner(GDBusObjectManager * manager, BluezAdapter1 * adapter, GCancellable * cancellable,
+                                     ChipDeviceScannerDelegate * delegate) :
+    mManager(manager),
+    mAdapter(adapter), mCancellable(cancellable), mDelegate(delegate)
+{
+    g_object_ref(mAdapter);
+    g_object_ref(mCancellable);
+    g_object_ref(mManager);
+}
+
+ChipDeviceScanner::~ChipDeviceScanner()
+{
+    StopScan();
+
+    // In case the timeout timer is still active
+    chip::DeviceLayer::SystemLayer().CancelTimer(TimerExpiredCallback, this);
+
+    g_object_unref(mManager);
+    g_object_unref(mCancellable);
+    g_object_unref(mAdapter);
+
+    mManager     = nullptr;
+    mAdapter     = nullptr;
+    mCancellable = nullptr;
+    mDelegate    = nullptr;
+}
+
+std::unique_ptr<ChipDeviceScanner> ChipDeviceScanner::Create(BluezAdapter1 * adapter, ChipDeviceScannerDelegate * delegate)
+{
+    GError * error = nullptr;
+
+    GCancellableUniquePtr cancellable(g_cancellable_new(), GObjectUnref());
+
+    if (!cancellable)
+    {
+        return std::unique_ptr<ChipDeviceScanner>();
+    }
+
+    GDBusObjectManagerUniquePtr manager(
+        g_dbus_object_manager_client_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE, BLUEZ_INTERFACE,
+                                                      "/", bluez_object_manager_client_get_proxy_type,
+                                                      nullptr /* unused user data in the Proxy Type Func */,
+                                                      nullptr /*destroy notify */, cancellable.get(), &error),
+        GObjectUnref());
+    if (!manager)
+    {
+        ChipLogError(Ble, "Failed to get DBUS object manager for device scanning: %s", error->message);
+        g_error_free(error);
+        return std::unique_ptr<ChipDeviceScanner>();
+    }
+
+    return std::make_unique<ChipDeviceScanner>(manager.get(), adapter, cancellable.get(), delegate);
+}
+
+CHIP_ERROR ChipDeviceScanner::StartScan(System::Clock::Timeout timeout)
+{
+    ReturnErrorCodeIf(mIsScanning, CHIP_ERROR_INCORRECT_STATE);
+
+    ReturnErrorOnFailure(MainLoop::Instance().EnsureStarted());
+
+    mIsScanning = true; // optimistic, to allow all callbacks to check this
+    if (!MainLoop::Instance().Schedule(MainLoopStartScan, this))
+    {
+        ChipLogError(Ble, "Failed to schedule BLE scan start.");
+        mIsScanning = false;
+        return CHIP_ERROR_INTERNAL;
+    }
+
+    CHIP_ERROR err = chip::DeviceLayer::SystemLayer().StartTimer(timeout, TimerExpiredCallback, static_cast<void *>(this));
+
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(Ble, "Failed to schedule scan timeout.");
+        StopScan();
+        return err;
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+void ChipDeviceScanner::TimerExpiredCallback(chip::System::Layer * layer, void * appState)
+{
+    static_cast<ChipDeviceScanner *>(appState)->StopScan();
+}
+
+CHIP_ERROR ChipDeviceScanner::StopScan()
+{
+    ReturnErrorCodeIf(!mIsScanning, CHIP_NO_ERROR);
+    ReturnErrorCodeIf(mIsStopping, CHIP_NO_ERROR);
+    mIsStopping = true;
+    g_cancellable_cancel(mCancellable); // in case we are currently running a scan
+
+    if (mObjectAddedSignal)
+    {
+        g_signal_handler_disconnect(mManager, mObjectAddedSignal);
+        mObjectAddedSignal = 0;
+    }
+
+    if (mInterfaceChangedSignal)
+    {
+        g_signal_handler_disconnect(mManager, mInterfaceChangedSignal);
+        mInterfaceChangedSignal = 0;
+    }
+
+    if (!MainLoop::Instance().ScheduleAndWait(MainLoopStopScan, this))
+    {
+        ChipLogError(Ble, "Failed to schedule BLE scan stop.");
+        return CHIP_ERROR_INTERNAL;
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+int ChipDeviceScanner::MainLoopStopScan(ChipDeviceScanner * self)
+{
+    GError * error = nullptr;
+
+    if (!bluez_adapter1_call_stop_discovery_sync(self->mAdapter, nullptr /* not cancellable */, &error))
+    {
+        ChipLogError(Ble, "Failed to stop discovery %s", error->message);
+        g_error_free(error);
+    }
+    ChipDeviceScannerDelegate * delegate = self->mDelegate;
+    self->mIsScanning                    = false;
+
+    // callback is explicitly allowed to delete the scanner (hence no more
+    // references to 'self' here)
+    delegate->OnScanComplete();
+
+    return 0;
+}
+
+void ChipDeviceScanner::SignalObjectAdded(GDBusObjectManager * manager, GDBusObject * object, ChipDeviceScanner * self)
+{
+    self->ReportDevice(bluez_object_get_device1(BLUEZ_OBJECT(object)));
+}
+
+void ChipDeviceScanner::SignalInterfaceChanged(GDBusObjectManagerClient * manager, GDBusObjectProxy * object,
+                                               GDBusProxy * aInterface, GVariant * aChangedProperties,
+                                               const gchar * const * aInvalidatedProps, ChipDeviceScanner * self)
+{
+    self->ReportDevice(bluez_object_get_device1(BLUEZ_OBJECT(object)));
+}
+
+void ChipDeviceScanner::ReportDevice(BluezDevice1 * device)
+{
+    if (device == nullptr)
+    {
+        return;
+    }
+
+    if (strcmp(bluez_device1_get_adapter(device), g_dbus_proxy_get_object_path(G_DBUS_PROXY(mAdapter))) != 0)
+    {
+        return;
+    }
+
+    chip::Ble::ChipBLEDeviceIdentificationInfo deviceInfo;
+
+    if (!BluezGetChipDeviceInfo(*device, deviceInfo))
+    {
+        ChipLogDetail(Ble, "Device %s does not look like a CHIP device.", bluez_device1_get_address(device));
+        return;
+    }
+
+    mDelegate->OnDeviceScanned(device, deviceInfo);
+}
+
+void ChipDeviceScanner::RemoveDevice(BluezDevice1 * device)
+{
+    if (device == nullptr)
+    {
+        return;
+    }
+
+    if (strcmp(bluez_device1_get_adapter(device), g_dbus_proxy_get_object_path(G_DBUS_PROXY(mAdapter))) != 0)
+    {
+        return;
+    }
+
+    chip::Ble::ChipBLEDeviceIdentificationInfo deviceInfo;
+
+    if (!BluezGetChipDeviceInfo(*device, deviceInfo))
+    {
+        return;
+    }
+
+    const auto devicePath = g_dbus_proxy_get_object_path(G_DBUS_PROXY(device));
+    GError * error        = nullptr;
+
+    if (!bluez_adapter1_call_remove_device_sync(mAdapter, devicePath, nullptr, &error))
+    {
+        ChipLogDetail(Ble, "Failed to remove device %s: %s", devicePath, error->message);
+        g_error_free(error);
+    }
+}
+
+int ChipDeviceScanner::MainLoopStartScan(ChipDeviceScanner * self)
+{
+    GError * error = nullptr;
+
+    self->mObjectAddedSignal = g_signal_connect(self->mManager, "object-added", G_CALLBACK(SignalObjectAdded), self);
+    self->mInterfaceChangedSignal =
+        g_signal_connect(self->mManager, "interface-proxy-properties-changed", G_CALLBACK(SignalInterfaceChanged), self);
+
+    ChipLogProgress(Ble, "BLE removing known devices.");
+    for (BluezObject & object : BluezObjectList(self->mManager))
+    {
+        self->RemoveDevice(bluez_object_get_device1(&object));
+    }
+
+    // Search for LE only.
+    // Do NOT add filtering by UUID as it is done by the following kernel function:
+    // https://github.com/torvalds/linux/blob/bdb575f872175ed0ecf2638369da1cb7a6e86a14/net/bluetooth/mgmt.c#L9258.
+    // The function requires that devices advertise its services' UUIDs in UUID16/32/128 fields
+    // while the Matter specification requires only FLAGS (0x01) and SERVICE_DATA_16 (0x16) fields
+    // in the advertisement packets.
+    GVariantBuilder filterBuilder;
+    g_variant_builder_init(&filterBuilder, G_VARIANT_TYPE("a{sv}"));
+    g_variant_builder_add(&filterBuilder, "{sv}", "Transport", g_variant_new_string("le"));
+    GVariant * filter = g_variant_builder_end(&filterBuilder);
+
+    if (!bluez_adapter1_call_set_discovery_filter_sync(self->mAdapter, filter, self->mCancellable, &error))
+    {
+        // Not critical: ignore if fails
+        ChipLogError(Ble, "Failed to set discovery filters: %s", error->message);
+        g_error_free(error);
+    }
+
+    ChipLogProgress(Ble, "BLE initiating scan.");
+    if (!bluez_adapter1_call_start_discovery_sync(self->mAdapter, self->mCancellable, &error))
+    {
+        ChipLogError(Ble, "Failed to start discovery: %s", error->message);
+        g_error_free(error);
+
+        self->mIsScanning = false;
+        self->mDelegate->OnScanComplete();
+    }
+
+    return 0;
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/bluez/ChipDeviceScanner.h b/src/platform/webos/bluez/ChipDeviceScanner.h
new file mode 100644
index 000000000..68cf65e49
--- /dev/null
+++ b/src/platform/webos/bluez/ChipDeviceScanner.h
@@ -0,0 +1,107 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <platform/CHIPDeviceConfig.h>
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+#include <glib.h>
+#include <memory>
+
+#include <ble/CHIPBleServiceData.h>
+#include <lib/core/CHIPError.h>
+#include <platform/webos/dbus/bluez/DbusBluez.h>
+#include <system/SystemLayer.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+/// Receives callbacks when chip devices are being scanned
+class ChipDeviceScannerDelegate
+{
+public:
+    virtual ~ChipDeviceScannerDelegate() {}
+
+    // Called when a CHIP device was found
+    virtual void OnDeviceScanned(BluezDevice1 * device, const chip::Ble::ChipBLEDeviceIdentificationInfo & info) = 0;
+
+    // Called when a scan was completed (stopped or timed out)
+    virtual void OnScanComplete() = 0;
+};
+
+/// Allows scanning for CHIP devices
+///
+/// Will perform scan operations and call back whenever a device is discovered.
+class ChipDeviceScanner
+{
+public:
+    /// NOTE: prefer to use the  ::Create method instead direct constructor calling.
+    ChipDeviceScanner(GDBusObjectManager * manager, BluezAdapter1 * adapter, GCancellable * cancellable,
+                      ChipDeviceScannerDelegate * delegate);
+
+    ChipDeviceScanner(ChipDeviceScanner &&)      = default;
+    ChipDeviceScanner(const ChipDeviceScanner &) = delete;
+    ChipDeviceScanner & operator=(const ChipDeviceScanner &) = delete;
+
+    ~ChipDeviceScanner();
+
+    /// Initiate a scan for devices, with the given timeout
+    CHIP_ERROR StartScan(System::Clock::Timeout timeout);
+
+    /// Stop any currently running scan
+    CHIP_ERROR StopScan();
+
+    /// Create a new device scanner
+    ///
+    /// Convenience method to allocate any required variables.
+    /// On success, maintains a reference to the provided adapter.
+    static std::unique_ptr<ChipDeviceScanner> Create(BluezAdapter1 * adapter, ChipDeviceScannerDelegate * delegate);
+
+private:
+    static void TimerExpiredCallback(chip::System::Layer * layer, void * appState);
+    static int MainLoopStartScan(ChipDeviceScanner * self);
+    static int MainLoopStopScan(ChipDeviceScanner * self);
+    static void SignalObjectAdded(GDBusObjectManager * manager, GDBusObject * object, ChipDeviceScanner * self);
+    static void SignalInterfaceChanged(GDBusObjectManagerClient * manager, GDBusObjectProxy * object, GDBusProxy * aInterface,
+                                       GVariant * aChangedProperties, const gchar * const * aInvalidatedProps,
+                                       ChipDeviceScanner * self);
+
+    /// Check if a given device is a CHIP device and if yes, report it as discovered
+    void ReportDevice(BluezDevice1 * device);
+
+    /// Check if a given device is a CHIP device and if yes, remove it from the adapter
+    /// so that it can be re-discovered if it's still advertising.
+    void RemoveDevice(BluezDevice1 * device);
+
+    GDBusObjectManager * mManager         = nullptr;
+    BluezAdapter1 * mAdapter              = nullptr;
+    GCancellable * mCancellable           = nullptr;
+    ChipDeviceScannerDelegate * mDelegate = nullptr;
+    gulong mObjectAddedSignal             = 0;
+    gulong mInterfaceChangedSignal        = 0;
+    bool mIsScanning                      = false;
+    bool mIsStopping                      = false;
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/bluez/Helper.cpp b/src/platform/webos/bluez/Helper.cpp
new file mode 100644
index 000000000..20f2691df
--- /dev/null
+++ b/src/platform/webos/bluez/Helper.cpp
@@ -0,0 +1,1790 @@
+/*
+ *
+ *    Copyright (c) 2020-2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/*
+ *  Copyright (c) 2016-2019, The OpenThread Authors.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the
+ *     names of its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *    @file
+ *          Provides Bluez dbus implementatioon for BLE
+ */
+
+#include <ble/BleUUID.h>
+#include <ble/CHIPBleServiceData.h>
+#include <lib/support/BitFlags.h>
+#include <lib/support/CHIPMem.h>
+#include <lib/support/CHIPMemString.h>
+#include <platform/CHIPDeviceLayer.h>
+#include <protocols/Protocols.h>
+#include <setup_payload/AdditionalDataPayloadGenerator.h>
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+#include <cassert>
+#include <errno.h>
+#include <gio/gunixfdlist.h>
+#include <limits>
+#include <stdarg.h>
+#include <strings.h>
+#include <unistd.h>
+#include <utility>
+
+#include <lib/support/CodeUtils.h>
+#include <platform/webos/BLEManagerImpl.h>
+#include <system/TLVPacketBufferBackingStore.h>
+
+#include "BluezObjectIterator.h"
+#include "BluezObjectList.h"
+#include "Helper.h"
+#include "MainLoop.h"
+
+using namespace ::nl;
+using namespace chip::Protocols;
+using chip::Platform::CopyString;
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+static BluezConnection * GetBluezConnectionViaDevice(BluezEndpoint * apEndpoint);
+
+namespace {
+
+class BluezEndpointObjectList : public BluezObjectList
+{
+public:
+    explicit BluezEndpointObjectList(BluezEndpoint * apEndpoint)
+    {
+        VerifyOrReturn(apEndpoint != nullptr, ChipLogError(DeviceLayer, "apEndpoint is NULL in %s", __func__));
+        Initialize(apEndpoint->mpObjMgr);
+    }
+};
+
+} // namespace
+
+static gboolean BluezAdvertisingRelease(BluezLEAdvertisement1 * aAdv, GDBusMethodInvocation * aInvocation, gpointer apClosure)
+{
+    bool isSuccess           = false;
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apClosure);
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+    VerifyOrExit(aAdv != nullptr, ChipLogError(DeviceLayer, "BluezLEAdvertisement1 is NULL in %s", __func__));
+    ChipLogDetail(DeviceLayer, "Release adv object in %s", __func__);
+
+    g_dbus_object_manager_server_unexport(endpoint->mpRoot, endpoint->mpAdvPath);
+    endpoint->mIsAdvertising = false;
+    isSuccess                = true;
+exit:
+
+    return isSuccess ? TRUE : FALSE;
+}
+
+static BluezLEAdvertisement1 * BluezAdvertisingCreate(BluezEndpoint * apEndpoint)
+{
+    BluezLEAdvertisement1 * adv = nullptr;
+    BluezObjectSkeleton * object;
+    GVariant * serviceData;
+    GVariant * serviceUUID;
+    gchar * localName;
+    GVariantBuilder serviceDataBuilder;
+    GVariantBuilder serviceUUIDsBuilder;
+    char * debugStr;
+
+    VerifyOrExit(apEndpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+    if (apEndpoint->mpAdvPath == nullptr)
+        apEndpoint->mpAdvPath = g_strdup_printf("%s/advertising", apEndpoint->mpRootPath);
+
+    ChipLogDetail(DeviceLayer, "Create adv object at %s", apEndpoint->mpAdvPath);
+    object = bluez_object_skeleton_new(apEndpoint->mpAdvPath);
+
+    adv = bluez_leadvertisement1_skeleton_new();
+
+    g_variant_builder_init(&serviceDataBuilder, G_VARIANT_TYPE("a{sv}"));
+    g_variant_builder_init(&serviceUUIDsBuilder, G_VARIANT_TYPE("as"));
+
+    g_variant_builder_add(&serviceDataBuilder, "{sv}", apEndpoint->mpAdvertisingUUID,
+                          g_variant_new_fixed_array(G_VARIANT_TYPE_BYTE, &apEndpoint->mDeviceIdInfo,
+                                                    sizeof(apEndpoint->mDeviceIdInfo), sizeof(uint8_t)));
+    g_variant_builder_add(&serviceUUIDsBuilder, "s", apEndpoint->mpAdvertisingUUID);
+
+    if (apEndpoint->mpAdapterName != nullptr)
+        localName = g_strdup_printf("%s", apEndpoint->mpAdapterName);
+    else
+        localName = g_strdup_printf("%s%04x", CHIP_DEVICE_CONFIG_BLE_DEVICE_NAME_PREFIX, getpid() & 0xffff);
+
+    serviceData = g_variant_builder_end(&serviceDataBuilder);
+    serviceUUID = g_variant_builder_end(&serviceUUIDsBuilder);
+
+    debugStr = g_variant_print(serviceData, TRUE);
+    ChipLogDetail(DeviceLayer, "SET service data to %s", debugStr);
+    g_free(debugStr);
+
+    bluez_leadvertisement1_set_type_(adv, (apEndpoint->mType & BLUEZ_ADV_TYPE_CONNECTABLE) ? "peripheral" : "broadcast");
+    // empty manufacturer data
+    // empty solicit UUIDs
+    bluez_leadvertisement1_set_service_data(adv, serviceData);
+    // empty data
+
+    // Setting "Discoverable" to False on the adapter and to True on the advertisement convinces
+    // Bluez to set "BR/EDR Not Supported" flag. Bluez doesn't provide API to do that explicitly
+    // and the flag is necessary to force using LE transport.
+    bluez_leadvertisement1_set_discoverable(adv, (apEndpoint->mType & BLUEZ_ADV_TYPE_SCANNABLE) ? TRUE : FALSE);
+    if (apEndpoint->mType & BLUEZ_ADV_TYPE_SCANNABLE)
+        bluez_leadvertisement1_set_discoverable_timeout(adv, UINT16_MAX);
+
+    // advertising name corresponding to the PID and object path, for debug purposes
+    bluez_leadvertisement1_set_local_name(adv, localName);
+    bluez_leadvertisement1_set_service_uuids(adv, serviceUUID);
+
+    // 0xffff means no appearance
+    bluez_leadvertisement1_set_appearance(adv, 0xffff);
+
+    bluez_leadvertisement1_set_duration(adv, apEndpoint->mDuration);
+    // empty duration, we don't have a clear notion what it would mean to timeslice between toble and anyone else
+    bluez_leadvertisement1_set_timeout(adv, 0);
+    // empty secondary channel for now
+
+    bluez_object_skeleton_set_leadvertisement1(object, adv);
+    g_signal_connect(adv, "handle-release", G_CALLBACK(BluezAdvertisingRelease), apEndpoint);
+
+    g_dbus_object_manager_server_export(apEndpoint->mpRoot, G_DBUS_OBJECT_SKELETON(object));
+    g_object_unref(object);
+
+    BLEManagerImpl::NotifyBLEPeripheralAdvConfiguredComplete(true, nullptr);
+
+exit:
+    return adv;
+}
+
+static void BluezAdvStartDone(GObject * aObject, GAsyncResult * aResult, gpointer apClosure)
+{
+    BluezLEAdvertisingManager1 * advMgr = BLUEZ_LEADVERTISING_MANAGER1(aObject);
+    GError * error                      = nullptr;
+    BluezEndpoint * endpoint            = static_cast<BluezEndpoint *>(apClosure);
+    gboolean success                    = FALSE;
+
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    success = bluez_leadvertising_manager1_call_register_advertisement_finish(advMgr, aResult, &error);
+    if (success == FALSE)
+    {
+        g_dbus_object_manager_server_unexport(endpoint->mpRoot, endpoint->mpAdvPath);
+    }
+    VerifyOrExit(success == TRUE, ChipLogError(DeviceLayer, "FAIL: RegisterAdvertisement : %s", error->message));
+
+    endpoint->mIsAdvertising = true;
+
+    ChipLogDetail(DeviceLayer, "RegisterAdvertisement complete");
+
+exit:
+    BLEManagerImpl::NotifyBLEPeripheralAdvStartComplete(success == TRUE, nullptr);
+    if (error != nullptr)
+        g_error_free(error);
+}
+
+static void BluezAdvStopDone(GObject * aObject, GAsyncResult * aResult, gpointer apClosure)
+{
+    BluezLEAdvertisingManager1 * advMgr = BLUEZ_LEADVERTISING_MANAGER1(aObject);
+    BluezEndpoint * endpoint            = static_cast<BluezEndpoint *>(apClosure);
+    GError * error                      = nullptr;
+    gboolean success                    = FALSE;
+
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    success = bluez_leadvertising_manager1_call_unregister_advertisement_finish(advMgr, aResult, &error);
+
+    if (success == FALSE)
+    {
+        g_dbus_object_manager_server_unexport(endpoint->mpRoot, endpoint->mpAdvPath);
+    }
+    else
+    {
+        endpoint->mIsAdvertising = false;
+    }
+
+    VerifyOrExit(success == TRUE, ChipLogError(DeviceLayer, "FAIL: UnregisterAdvertisement : %s", error->message));
+
+    ChipLogDetail(DeviceLayer, "UnregisterAdvertisement complete");
+
+exit:
+    BLEManagerImpl::NotifyBLEPeripheralAdvStopComplete(success == TRUE, nullptr);
+    if (error != nullptr)
+        g_error_free(error);
+}
+
+static gboolean BluezAdvSetup(BluezEndpoint * endpoint)
+{
+    BluezLEAdvertisement1 * adv;
+
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+    VerifyOrExit(endpoint->mIsAdvertising == FALSE, ChipLogError(DeviceLayer, "FAIL: Advertising already enabled in %s", __func__));
+    VerifyOrExit(endpoint->mpAdapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL endpoint->mpAdapter in %s", __func__));
+
+    adv = BluezAdvertisingCreate(endpoint);
+    VerifyOrExit(adv != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL adv in %s", __func__));
+
+exit:
+    return G_SOURCE_REMOVE;
+}
+
+static gboolean BluezAdvStart(BluezEndpoint * endpoint)
+{
+    GDBusObject * adapter;
+    BluezLEAdvertisingManager1 * advMgr = nullptr;
+    GVariantBuilder optionsBuilder;
+    GVariant * options;
+
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+    VerifyOrExit(!endpoint->mIsAdvertising,
+                 ChipLogError(DeviceLayer, "FAIL: Advertising has already been enabled in %s", __func__));
+    VerifyOrExit(endpoint->mpAdapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL endpoint->mpAdapter in %s", __func__));
+
+    adapter = g_dbus_interface_get_object(G_DBUS_INTERFACE(endpoint->mpAdapter));
+    VerifyOrExit(adapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL adapter in %s", __func__));
+
+    advMgr = bluez_object_get_leadvertising_manager1(BLUEZ_OBJECT(adapter));
+    VerifyOrExit(advMgr != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL advMgr in %s", __func__));
+
+    g_variant_builder_init(&optionsBuilder, G_VARIANT_TYPE("a{sv}"));
+    options = g_variant_builder_end(&optionsBuilder);
+
+    bluez_leadvertising_manager1_call_register_advertisement(advMgr, endpoint->mpAdvPath, options, nullptr, BluezAdvStartDone,
+                                                             endpoint);
+
+exit:
+    return G_SOURCE_REMOVE;
+}
+
+static gboolean BluezAdvStop(BluezEndpoint * endpoint)
+{
+    GDBusObject * adapter;
+    BluezLEAdvertisingManager1 * advMgr = nullptr;
+
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+    VerifyOrExit(endpoint->mIsAdvertising,
+                 ChipLogError(DeviceLayer, "FAIL: Advertising has already been disabled in %s", __func__));
+    VerifyOrExit(endpoint->mpAdapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL endpoint->mpAdapter in %s", __func__));
+
+    adapter = g_dbus_interface_get_object(G_DBUS_INTERFACE(endpoint->mpAdapter));
+    VerifyOrExit(adapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL adapter in %s", __func__));
+
+    advMgr = bluez_object_get_leadvertising_manager1(BLUEZ_OBJECT(adapter));
+    VerifyOrExit(advMgr != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL advMgr in %s", __func__));
+
+    bluez_leadvertising_manager1_call_unregister_advertisement(advMgr, endpoint->mpAdvPath, nullptr, BluezAdvStopDone, endpoint);
+
+exit:
+    return G_SOURCE_REMOVE;
+}
+
+static gboolean BluezCharacteristicReadValue(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                             GVariant * aOptions)
+{
+    GVariant * val;
+    ChipLogDetail(DeviceLayer, "Received BluezCharacteristicReadValue");
+    val = bluez_gatt_characteristic1_get_value(aChar);
+    bluez_gatt_characteristic1_complete_read_value(aChar, aInvocation, val);
+    return TRUE;
+}
+
+#if CHIP_BLUEZ_CHAR_WRITE_VALUE
+static gboolean BluezCharacteristicWriteValue(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                              GVariant * aValue, GVariant * aOptions, gpointer apEndpoint)
+{
+    const uint8_t * tmpBuf;
+    uint8_t * buf;
+    size_t len;
+    bool isSuccess         = false;
+    BluezConnection * conn = NULL;
+
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apEndpoint);
+    VerifyOrExit(endpoint != NULL, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    VerifyOrExit(aValue != NULL, ChipLogError(DeviceLayer, "aValue is NULL in %s", __func__));
+
+    conn = GetBluezConnectionViaDevice(endpoint);
+    VerifyOrExit(conn != NULL,
+                 g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "No CHIP Bluez connection"));
+
+    bluez_gatt_characteristic1_set_value(aChar, g_variant_ref(aValue));
+
+    tmpBuf = (uint8_t *) (g_variant_get_fixed_array(aValue, &len, sizeof(uint8_t)));
+    buf    = (uint8_t *) (g_memdup(tmpBuf, len));
+
+    BLEManagerImpl::HandleRXCharWrite(conn, buf, len);
+    bluez_gatt_characteristic1_complete_write_value(aChar, aInvocation);
+    isSuccess = true;
+
+exit:
+    return isSuccess ? TRUE : FALSE;
+}
+#endif
+
+static gboolean BluezCharacteristicWriteValueError(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                                   GVariant * aValue, GVariant * aOptions, gpointer apClosure)
+{
+    ChipLogDetail(DeviceLayer, "BluezCharacteristicWriteValueError");
+    g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.NotSupported",
+                                               "Write for characteristic is unsupported");
+    return TRUE;
+}
+
+static gboolean BluezCharacteristicWriteFD(GIOChannel * aChannel, GIOCondition aCond, gpointer apEndpoint)
+{
+    GVariant * newVal;
+    gchar * buf;
+    ssize_t len;
+    int fd;
+    bool isSuccess = false;
+
+    BluezConnection * conn = static_cast<BluezConnection *>(apEndpoint);
+
+    VerifyOrExit(conn != nullptr, ChipLogError(DeviceLayer, "No CHIP Bluez connection in %s", __func__));
+
+    VerifyOrExit(!(aCond & G_IO_HUP), ChipLogError(DeviceLayer, "INFO: socket disconnected in %s", __func__));
+    VerifyOrExit(!(aCond & (G_IO_ERR | G_IO_NVAL)), ChipLogError(DeviceLayer, "INFO: socket error in %s", __func__));
+    VerifyOrExit(aCond == G_IO_IN, ChipLogError(DeviceLayer, "FAIL: error in %s", __func__));
+
+    ChipLogDetail(DeviceLayer, "c1 %s mtu, %d", __func__, conn->mMtu);
+
+    buf = static_cast<gchar *>(g_malloc(conn->mMtu));
+    fd  = g_io_channel_unix_get_fd(aChannel);
+
+    len = read(fd, buf, conn->mMtu);
+
+    VerifyOrExit(len > 0, ChipLogError(DeviceLayer, "FAIL: short read in %s (%zd)", __func__, len));
+
+    // Casting len to size_t is safe, since we ensured that it's not negative.
+    newVal = g_variant_new_fixed_array(G_VARIANT_TYPE_BYTE, buf, static_cast<size_t>(len), sizeof(uint8_t));
+
+    bluez_gatt_characteristic1_set_value(conn->mpC1, newVal);
+    BLEManagerImpl::HandleRXCharWrite(conn, reinterpret_cast<uint8_t *>(buf), static_cast<size_t>(len));
+    isSuccess = true;
+
+exit:
+    return isSuccess ? TRUE : FALSE;
+}
+
+static void Bluez_gatt_characteristic1_complete_acquire_write_with_fd(GDBusMethodInvocation * invocation, int fd, guint16 mtu)
+{
+    GUnixFDList * fd_list = g_unix_fd_list_new();
+    int index;
+
+    index = g_unix_fd_list_append(fd_list, fd, nullptr);
+
+    g_dbus_method_invocation_return_value_with_unix_fd_list(invocation, g_variant_new("(@hq)", g_variant_new_handle(index), mtu),
+                                                            fd_list);
+}
+
+static gboolean bluezCharacteristicDestroyFD(GIOChannel * aChannel, GIOCondition aCond, gpointer apClosure)
+{
+    return G_SOURCE_REMOVE;
+}
+
+static gboolean BluezCharacteristicAcquireWrite(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                                GVariant * aOptions, gpointer apEndpoint)
+{
+    int fds[2] = { -1, -1 };
+    GIOChannel * channel;
+    char * errStr;
+    GVariantDict options;
+    bool isSuccess         = false;
+    BluezConnection * conn = nullptr;
+
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apEndpoint);
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    conn = GetBluezConnectionViaDevice(endpoint);
+    VerifyOrExit(conn != nullptr,
+                 g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "No Chipoble connection"));
+
+    ChipLogDetail(DeviceLayer, "BluezCharacteristicAcquireWrite is called, conn: %p", conn);
+
+    if (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds) < 0)
+    {
+        errStr = strerror(errno);
+        ChipLogError(DeviceLayer, "FAIL: socketpair: %s in %s", errStr, __func__);
+        g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "FD creation failed");
+        goto exit;
+    }
+
+    g_variant_dict_init(&options, aOptions);
+    if (g_variant_dict_contains(&options, "mtu") == TRUE)
+    {
+        GVariant * v = g_variant_dict_lookup_value(&options, "mtu", G_VARIANT_TYPE_UINT16);
+        conn->mMtu   = g_variant_get_uint16(v);
+    }
+    else
+    {
+        ChipLogError(DeviceLayer, "FAIL: no MTU in options in %s", __func__);
+        g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.InvalidArguments", "MTU negotiation failed");
+        goto exit;
+    }
+
+    channel = g_io_channel_unix_new(fds[0]);
+    g_io_channel_set_encoding(channel, nullptr, nullptr);
+    g_io_channel_set_close_on_unref(channel, TRUE);
+    g_io_channel_set_buffered(channel, FALSE);
+
+    conn->mC1Channel.mpChannel = channel;
+    conn->mC1Channel.mWatch    = g_io_add_watch(channel, static_cast<GIOCondition>(G_IO_HUP | G_IO_IN | G_IO_ERR | G_IO_NVAL),
+                                             BluezCharacteristicWriteFD, conn);
+
+    bluez_gatt_characteristic1_set_write_acquired(aChar, TRUE);
+
+    Bluez_gatt_characteristic1_complete_acquire_write_with_fd(aInvocation, fds[1], conn->mMtu);
+    close(fds[1]);
+    isSuccess = true;
+
+exit:
+    return isSuccess ? TRUE : FALSE;
+}
+
+static gboolean BluezCharacteristicAcquireWriteError(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                                     GVariant * aOptions)
+{
+    ChipLogDetail(DeviceLayer, "BluezCharacteristicAcquireWriteError is called");
+    g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.NotSupported",
+                                               "AcquireWrite for characteristic is unsupported");
+    return TRUE;
+}
+
+static gboolean BluezCharacteristicAcquireNotify(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                                 GVariant * aOptions, gpointer apEndpoint)
+{
+    int fds[2] = { -1, -1 };
+    GIOChannel * channel;
+    char * errStr;
+    GVariantDict options;
+    BluezConnection * conn = nullptr;
+    bool isSuccess         = false;
+
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apEndpoint);
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    conn = GetBluezConnectionViaDevice(endpoint);
+    VerifyOrExit(conn != nullptr,
+                 g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "No Chipoble connection"));
+
+    g_variant_dict_init(&options, aOptions);
+    if ((g_variant_dict_contains(&options, "mtu") == TRUE))
+    {
+        GVariant * v = g_variant_dict_lookup_value(&options, "mtu", G_VARIANT_TYPE_UINT16);
+        conn->mMtu   = g_variant_get_uint16(v);
+    }
+
+    if (bluez_gatt_characteristic1_get_notifying(aChar))
+    {
+        g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.NotPermitted", "Already notifying");
+    }
+    if (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds) < 0)
+    {
+        errStr = strerror(errno);
+        ChipLogError(DeviceLayer, "FAIL: socketpair: %s in %s", errStr, __func__);
+        g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "FD creation failed");
+        goto exit;
+    }
+    channel = g_io_channel_unix_new(fds[0]);
+    g_io_channel_set_encoding(channel, nullptr, nullptr);
+    g_io_channel_set_close_on_unref(channel, TRUE);
+    g_io_channel_set_buffered(channel, FALSE);
+    conn->mC2Channel.mpChannel = channel;
+    conn->mC2Channel.mWatch =
+        g_io_add_watch_full(channel, G_PRIORITY_DEFAULT_IDLE, static_cast<GIOCondition>(G_IO_HUP | G_IO_ERR | G_IO_NVAL),
+                            bluezCharacteristicDestroyFD, conn, nullptr);
+
+    bluez_gatt_characteristic1_set_notify_acquired(aChar, TRUE);
+
+    // same reply as for AcquireWrite
+    Bluez_gatt_characteristic1_complete_acquire_write_with_fd(aInvocation, fds[1], conn->mMtu);
+    close(fds[1]);
+
+    conn->mIsNotify = true;
+    BLEManagerImpl::HandleTXCharCCCDWrite(conn);
+    isSuccess = true;
+
+exit:
+    return isSuccess ? TRUE : FALSE;
+}
+
+static gboolean BluezCharacteristicAcquireNotifyError(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                                      GVariant * aOptions)
+{
+    ChipLogDetail(DeviceLayer, "TRACE: AcquireNotify is called");
+    g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.NotSupported",
+                                               "AcquireNotify for characteristic is unsupported");
+    return TRUE;
+}
+
+static gboolean BluezCharacteristicStartNotify(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                               gpointer apEndpoint)
+{
+    bool isSuccess         = false;
+    BluezConnection * conn = nullptr;
+
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apEndpoint);
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    conn = GetBluezConnectionViaDevice(endpoint);
+    VerifyOrExit(conn != nullptr,
+                 g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "No Chipoble connection"));
+
+    if (bluez_gatt_characteristic1_get_notifying(aChar) == TRUE)
+    {
+        g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "Characteristic is already subscribed");
+    }
+    else
+    {
+        bluez_gatt_characteristic1_complete_start_notify(aChar, aInvocation);
+        bluez_gatt_characteristic1_set_notifying(aChar, TRUE);
+        conn->mIsNotify = true;
+        BLEManagerImpl::HandleTXCharCCCDWrite(conn);
+    }
+    isSuccess = true;
+
+exit:
+    return isSuccess ? TRUE : FALSE;
+}
+
+static gboolean BluezCharacteristicStartNotifyError(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation)
+{
+    g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.NotSupported",
+                                               "Subscribing to characteristic is unsupported");
+    return TRUE;
+}
+
+static gboolean BluezCharacteristicStopNotify(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                              gpointer apEndpoint)
+{
+    bool isSuccess         = false;
+    BluezConnection * conn = nullptr;
+
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apEndpoint);
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    conn = GetBluezConnectionViaDevice(endpoint);
+    VerifyOrExit(conn != nullptr,
+                 g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "No Chipoble connection"));
+
+    if (bluez_gatt_characteristic1_get_notifying(aChar) == FALSE)
+    {
+        g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "Characteristic is already unsubscribed");
+    }
+    else
+    {
+        bluez_gatt_characteristic1_complete_start_notify(aChar, aInvocation);
+        bluez_gatt_characteristic1_set_notifying(aChar, FALSE);
+    }
+    conn->mIsNotify = false;
+
+    isSuccess = true;
+
+exit:
+    return isSuccess ? TRUE : FALSE;
+}
+
+static gboolean BluezCharacteristicConfirm(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation,
+                                           gpointer apClosure)
+{
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apClosure);
+    BluezConnection * conn   = GetBluezConnectionViaDevice(endpoint);
+
+    ChipLogDetail(Ble, "Indication confirmation, %p", conn);
+    BLEManagerImpl::HandleTXComplete(conn);
+
+    return TRUE;
+}
+
+static gboolean BluezCharacteristicStopNotifyError(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation)
+{
+    g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed",
+                                               "Unsubscribing from characteristic is unsupported");
+    return TRUE;
+}
+
+static gboolean BluezCharacteristicConfirmError(BluezGattCharacteristic1 * aChar, GDBusMethodInvocation * aInvocation)
+{
+    g_dbus_method_invocation_return_dbus_error(aInvocation, "org.bluez.Error.Failed", "Confirm from characteristic is unsupported");
+    return TRUE;
+}
+
+static gboolean BluezIsDeviceOnAdapter(BluezDevice1 * aDevice, BluezAdapter1 * aAdapter)
+{
+    return strcmp(bluez_device1_get_adapter(aDevice), g_dbus_proxy_get_object_path(G_DBUS_PROXY(aAdapter))) == 0 ? TRUE : FALSE;
+}
+
+static gboolean BluezIsServiceOnDevice(BluezGattService1 * aService, BluezDevice1 * aDevice)
+{
+    return strcmp(bluez_gatt_service1_get_device(aService), g_dbus_proxy_get_object_path(G_DBUS_PROXY(aDevice))) == 0 ? TRUE
+                                                                                                                      : FALSE;
+}
+
+static gboolean BluezIsCharOnService(BluezGattCharacteristic1 * aChar, BluezGattService1 * aService)
+{
+    ChipLogDetail(DeviceLayer, "Char1 %s", bluez_gatt_characteristic1_get_service(aChar));
+    ChipLogDetail(DeviceLayer, "Char1 %s", g_dbus_proxy_get_object_path(G_DBUS_PROXY(aService)));
+    return strcmp(bluez_gatt_characteristic1_get_service(aChar), g_dbus_proxy_get_object_path(G_DBUS_PROXY(aService))) == 0 ? TRUE
+                                                                                                                            : FALSE;
+}
+
+static void BluezConnectionInit(BluezConnection * apConn)
+{
+    // populate the service and the characteristics
+    GList * objects = nullptr;
+    GList * l;
+    BluezEndpoint * endpoint = nullptr;
+
+    VerifyOrExit(apConn != nullptr, ChipLogError(DeviceLayer, "Bluez connection is NULL in %s", __func__));
+
+    endpoint = apConn->mpEndpoint;
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    if (!endpoint->mIsCentral)
+    {
+        apConn->mpService = BLUEZ_GATT_SERVICE1(g_object_ref(apConn->mpEndpoint->mpService));
+        apConn->mpC1      = BLUEZ_GATT_CHARACTERISTIC1(g_object_ref(endpoint->mpC1));
+        apConn->mpC2      = BLUEZ_GATT_CHARACTERISTIC1(g_object_ref(endpoint->mpC2));
+    }
+    else
+    {
+        objects = g_dbus_object_manager_get_objects(endpoint->mpObjMgr);
+
+        for (l = objects; l != nullptr; l = l->next)
+        {
+            BluezObject * object        = BLUEZ_OBJECT(l->data);
+            BluezGattService1 * service = bluez_object_get_gatt_service1(object);
+
+            if (service != nullptr)
+            {
+                if ((BluezIsServiceOnDevice(service, apConn->mpDevice)) == TRUE &&
+                    (strcmp(bluez_gatt_service1_get_uuid(service), CHIP_BLE_UUID_SERVICE_STRING) == 0))
+                {
+                    apConn->mpService = service;
+                    break;
+                }
+                g_object_unref(service);
+            }
+        }
+
+        VerifyOrExit(apConn->mpService != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL service in %s", __func__));
+
+        for (l = objects; l != nullptr; l = l->next)
+        {
+            BluezObject * object             = BLUEZ_OBJECT(l->data);
+            BluezGattCharacteristic1 * char1 = bluez_object_get_gatt_characteristic1(object);
+
+            if (char1 != nullptr)
+            {
+                if ((BluezIsCharOnService(char1, apConn->mpService) == TRUE) &&
+                    (strcmp(bluez_gatt_characteristic1_get_uuid(char1), CHIP_PLAT_BLE_UUID_C1_STRING) == 0))
+                {
+                    apConn->mpC1 = char1;
+                }
+                else if ((BluezIsCharOnService(char1, apConn->mpService) == TRUE) &&
+                         (strcmp(bluez_gatt_characteristic1_get_uuid(char1), CHIP_PLAT_BLE_UUID_C2_STRING) == 0))
+                {
+                    apConn->mpC2 = char1;
+                }
+                else if ((BluezIsCharOnService(char1, apConn->mpService) == TRUE) &&
+                         (strcmp(bluez_gatt_characteristic1_get_uuid(char1), CHIP_PLAT_BLE_UUID_C3_STRING) == 0))
+                {
+                    apConn->mpC3 = char1;
+                }
+                else
+                {
+                    g_object_unref(char1);
+                }
+                if ((apConn->mpC1 != nullptr) && (apConn->mpC2 != nullptr))
+                {
+                    break;
+                }
+            }
+        }
+
+        VerifyOrExit(apConn->mpC1 != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL C1 in %s", __func__));
+        VerifyOrExit(apConn->mpC2 != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL C2 in %s", __func__));
+    }
+
+exit:
+    if (objects != nullptr)
+        g_list_free_full(objects, g_object_unref);
+}
+
+static void BluezOTConnectionDestroy(BluezConnection * aConn)
+{
+    if (aConn)
+    {
+        if (aConn->mpDevice)
+            g_object_unref(aConn->mpDevice);
+        if (aConn->mpService)
+            g_object_unref(aConn->mpService);
+        if (aConn->mpC1)
+            g_object_unref(aConn->mpC1);
+        if (aConn->mpC2)
+            g_object_unref(aConn->mpC2);
+        if (aConn->mpPeerAddress)
+            g_free(aConn->mpPeerAddress);
+        if (aConn->mC1Channel.mWatch > 0)
+            g_source_remove(aConn->mC1Channel.mWatch);
+        if (aConn->mC1Channel.mpChannel)
+            g_io_channel_unref(aConn->mC1Channel.mpChannel);
+        if (aConn->mC2Channel.mWatch > 0)
+            g_source_remove(aConn->mC2Channel.mWatch);
+        if (aConn->mC2Channel.mpChannel)
+            g_io_channel_unref(aConn->mC2Channel.mpChannel);
+
+        g_free(aConn);
+    }
+}
+
+static BluezGattCharacteristic1 * BluezCharacteristicCreate(BluezGattService1 * aService, const char * aCharName,
+                                                            const char * aUUID, GDBusObjectManagerServer * aRoot)
+{
+    char * servicePath = g_strdup(g_dbus_object_get_object_path(g_dbus_interface_get_object(G_DBUS_INTERFACE(aService))));
+    char * charPath    = g_strdup_printf("%s/%s", servicePath, aCharName);
+    BluezObjectSkeleton * object;
+    BluezGattCharacteristic1 * characteristic;
+
+    ChipLogDetail(DeviceLayer, "Create characteristic object at %s", charPath);
+    object = bluez_object_skeleton_new(charPath);
+
+    characteristic = bluez_gatt_characteristic1_skeleton_new();
+    bluez_gatt_characteristic1_set_uuid(characteristic, aUUID);
+    bluez_gatt_characteristic1_set_service(characteristic, servicePath);
+
+    bluez_object_skeleton_set_gatt_characteristic1(object, characteristic);
+    g_dbus_object_manager_server_export(aRoot, G_DBUS_OBJECT_SKELETON(object));
+    g_object_unref(object);
+
+    return characteristic;
+}
+
+static void BluezPeripheralRegisterAppDone(GObject * aObject, GAsyncResult * aResult, gpointer apClosure)
+{
+    GError * error              = nullptr;
+    BluezGattManager1 * gattMgr = BLUEZ_GATT_MANAGER1(aObject);
+
+    gboolean success = bluez_gatt_manager1_call_register_application_finish(gattMgr, aResult, &error);
+
+    VerifyOrExit(success == TRUE, ChipLogError(DeviceLayer, "FAIL: RegisterApplication : %s", error->message));
+
+    BLEManagerImpl::NotifyBLEPeripheralRegisterAppComplete(true, nullptr);
+    ChipLogDetail(DeviceLayer, "BluezPeripheralRegisterAppDone done");
+
+exit:
+    if (error != nullptr)
+    {
+        BLEManagerImpl::NotifyBLEPeripheralRegisterAppComplete(false, nullptr);
+        g_error_free(error);
+    }
+}
+
+gboolean BluezPeripheralRegisterApp(BluezEndpoint * endpoint)
+{
+    GDBusObject * adapter;
+    BluezGattManager1 * gattMgr;
+    GVariantBuilder optionsBuilder;
+    GVariant * options;
+
+    VerifyOrExit(endpoint->mpAdapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL endpoint->mpAdapter in %s", __func__));
+
+    adapter = g_dbus_interface_get_object(G_DBUS_INTERFACE(endpoint->mpAdapter));
+    VerifyOrExit(adapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL adapter in %s", __func__));
+
+    gattMgr = bluez_object_get_gatt_manager1(BLUEZ_OBJECT(adapter));
+    VerifyOrExit(gattMgr != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL gattMgr in %s", __func__));
+
+    g_variant_builder_init(&optionsBuilder, G_VARIANT_TYPE("a{sv}"));
+    options = g_variant_builder_end(&optionsBuilder);
+
+    bluez_gatt_manager1_call_register_application(gattMgr, endpoint->mpRootPath, options, nullptr, BluezPeripheralRegisterAppDone,
+                                                  nullptr);
+
+exit:
+    return G_SOURCE_REMOVE;
+}
+
+/// Update the table of open BLE connections whevener a new device is spotted or its attributes have changed.
+static void UpdateConnectionTable(BluezDevice1 * apDevice, BluezEndpoint & aEndpoint)
+{
+    const gchar * objectPath     = g_dbus_proxy_get_object_path(G_DBUS_PROXY(apDevice));
+    BluezConnection * connection = static_cast<BluezConnection *>(g_hash_table_lookup(aEndpoint.mpConnMap, objectPath));
+
+    if (connection != nullptr && !bluez_device1_get_connected(apDevice))
+    {
+        ChipLogDetail(DeviceLayer, "Bluez disconnected");
+        BLEManagerImpl::CHIPoBluez_ConnectionClosed(connection);
+        // TODO: the connection object should be released after BLEManagerImpl finishes cleaning up its resources
+        // after the disconnection. Releasing it here doesn't cause any issues, but it's error-prone.
+        BluezOTConnectionDestroy(connection);
+        g_hash_table_remove(aEndpoint.mpConnMap, objectPath);
+        return;
+    }
+
+    if (connection == nullptr && !bluez_device1_get_connected(apDevice) && aEndpoint.mIsCentral)
+    {
+        return;
+    }
+
+    if (connection == nullptr && bluez_device1_get_connected(apDevice) &&
+        (!aEndpoint.mIsCentral || bluez_device1_get_services_resolved(apDevice)))
+    {
+        connection                = g_new0(BluezConnection, 1);
+        connection->mpPeerAddress = g_strdup(bluez_device1_get_address(apDevice));
+        connection->mpDevice      = static_cast<BluezDevice1 *>(g_object_ref(apDevice));
+        connection->mpEndpoint    = &aEndpoint;
+        BluezConnectionInit(connection);
+        aEndpoint.mpPeerDevicePath = g_strdup(objectPath);
+        g_hash_table_insert(aEndpoint.mpConnMap, aEndpoint.mpPeerDevicePath, connection);
+
+        ChipLogDetail(DeviceLayer, "New BLE connection %p, device %s, path %s", connection, connection->mpPeerAddress,
+                      aEndpoint.mpPeerDevicePath);
+
+        BLEManagerImpl::HandleNewConnection(connection);
+    }
+}
+
+static void BluezSignalInterfacePropertiesChanged(GDBusObjectManagerClient * aManager, GDBusObjectProxy * aObject,
+                                                  GDBusProxy * aInterface, GVariant * aChangedProperties,
+                                                  const gchar * const * aInvalidatedProps, gpointer apClosure)
+{
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apClosure);
+    VerifyOrReturn(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+    VerifyOrReturn(endpoint->mpAdapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL endpoint->mpAdapter in %s", __func__));
+    VerifyOrReturn(strcmp(g_dbus_proxy_get_interface_name(aInterface), DEVICE_INTERFACE) == 0, );
+
+    BluezDevice1 * device = BLUEZ_DEVICE1(aInterface);
+    VerifyOrReturn(BluezIsDeviceOnAdapter(device, endpoint->mpAdapter));
+
+    UpdateConnectionTable(device, *endpoint);
+}
+
+static void BluezHandleNewDevice(BluezDevice1 * device, BluezEndpoint * apEndpoint)
+{
+    VerifyOrExit(apEndpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+    if (apEndpoint->mIsCentral)
+    {
+        return;
+    }
+
+    // We need to handle device connection both this function and BluezSignalInterfacePropertiesChanged
+    // When a device is connected for first time, this function will be triggerred.
+    // The future connections for the same device will trigger ``Connect'' property change.
+    // TODO: Factor common code in the two function.
+    BluezConnection * conn;
+    VerifyOrExit(bluez_device1_get_connected(device), ChipLogError(DeviceLayer, "FAIL: device is not connected"));
+
+    conn = static_cast<BluezConnection *>(
+        g_hash_table_lookup(apEndpoint->mpConnMap, g_dbus_proxy_get_object_path(G_DBUS_PROXY(device))));
+    VerifyOrExit(conn == nullptr,
+                 ChipLogError(DeviceLayer, "FAIL: connection already tracked: conn: %p new device: %s", conn,
+                              g_dbus_proxy_get_object_path(G_DBUS_PROXY(device))));
+
+    conn                = g_new0(BluezConnection, 1);
+    conn->mpPeerAddress = g_strdup(bluez_device1_get_address(device));
+    conn->mpDevice      = static_cast<BluezDevice1 *>(g_object_ref(device));
+    conn->mpEndpoint    = apEndpoint;
+    BluezConnectionInit(conn);
+    apEndpoint->mpPeerDevicePath = g_strdup(g_dbus_proxy_get_object_path(G_DBUS_PROXY(device)));
+    ChipLogDetail(DeviceLayer, "Device %s (Path: %s) Connected", conn->mpPeerAddress, apEndpoint->mpPeerDevicePath);
+    g_hash_table_insert(apEndpoint->mpConnMap, g_strdup(g_dbus_proxy_get_object_path(G_DBUS_PROXY(device))), conn);
+
+exit:
+    return;
+}
+
+static void BluezSignalOnObjectAdded(GDBusObjectManager * aManager, GDBusObject * aObject, BluezEndpoint * endpoint)
+{
+    // TODO: right now we do not handle addition/removal of adapters
+    // Primary focus here is to handle addition of a device
+    BluezDevice1 * device = bluez_object_get_device1(BLUEZ_OBJECT(aObject));
+    if (device == nullptr)
+    {
+        return;
+    }
+
+    if (BluezIsDeviceOnAdapter(device, endpoint->mpAdapter) == TRUE)
+    {
+        BluezHandleNewDevice(device, endpoint);
+    }
+
+    g_object_unref(device);
+}
+
+static void BluezSignalOnObjectRemoved(GDBusObjectManager * aManager, GDBusObject * aObject, gpointer apClosure)
+{
+    // TODO: for Device1, lookup connection, and call otPlatTobleHandleDisconnected
+    // for Adapter1: unclear, crash if this pertains to our adapter? at least null out the endpoint->mpAdapter.
+    // for Characteristic1, or GattService -- handle here via calling otPlatTobleHandleDisconnected, or ignore.
+}
+
+static BluezGattService1 * BluezServiceCreate(gpointer apClosure)
+{
+    BluezObjectSkeleton * object;
+    BluezGattService1 * service;
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apClosure);
+
+    endpoint->mpServicePath = g_strdup_printf("%s/service", endpoint->mpRootPath);
+    ChipLogDetail(DeviceLayer, "CREATE service object at %s", endpoint->mpServicePath);
+    object = bluez_object_skeleton_new(endpoint->mpServicePath);
+
+    service = bluez_gatt_service1_skeleton_new();
+    bluez_gatt_service1_set_uuid(service, "0xFFF6");
+    // device is only valid for remote services
+    bluez_gatt_service1_set_primary(service, TRUE);
+
+    // includes -- unclear whether required.  Might be filled in later
+    bluez_object_skeleton_set_gatt_service1(object, service);
+    g_dbus_object_manager_server_export(endpoint->mpRoot, G_DBUS_OBJECT_SKELETON(object));
+    g_object_unref(object);
+
+    return service;
+}
+
+static void bluezObjectsSetup(BluezEndpoint * apEndpoint)
+{
+    GList * objects = nullptr;
+    GList * l;
+    char * expectedPath = nullptr;
+
+    VerifyOrExit(apEndpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    expectedPath = g_strdup_printf("%s/hci%d", BLUEZ_PATH, apEndpoint->mAdapterId);
+    objects      = g_dbus_object_manager_get_objects(apEndpoint->mpObjMgr);
+
+    for (l = objects; l != nullptr && apEndpoint->mpAdapter == nullptr; l = l->next)
+    {
+        BluezObject * object = BLUEZ_OBJECT(l->data);
+        GList * interfaces;
+        GList * ll;
+        interfaces = g_dbus_object_get_interfaces(G_DBUS_OBJECT(object));
+
+        for (ll = interfaces; ll != nullptr; ll = ll->next)
+        {
+            if (BLUEZ_IS_ADAPTER1(ll->data))
+            { // we found the adapter
+                BluezAdapter1 * adapter = BLUEZ_ADAPTER1(ll->data);
+                char * addr             = const_cast<char *>(bluez_adapter1_get_address(adapter));
+                if (apEndpoint->mpAdapterAddr == nullptr) // no adapter address provided, bind to the hci indicated by nodeid
+                {
+                    if (strcmp(g_dbus_proxy_get_object_path(G_DBUS_PROXY(adapter)), expectedPath) == 0)
+                    {
+                        apEndpoint->mpAdapter = static_cast<BluezAdapter1 *>(g_object_ref(adapter));
+                    }
+                }
+                else
+                {
+                    if (strcmp(apEndpoint->mpAdapterAddr, addr) == 0)
+                    {
+                        apEndpoint->mpAdapter = static_cast<BluezAdapter1 *>(g_object_ref(adapter));
+                    }
+                }
+            }
+        }
+        g_list_free_full(interfaces, g_object_unref);
+    }
+    VerifyOrExit(apEndpoint->mpAdapter != nullptr, ChipLogError(DeviceLayer, "FAIL: NULL apEndpoint->mpAdapter in %s", __func__));
+    bluez_adapter1_set_powered(apEndpoint->mpAdapter, TRUE);
+
+    // Setting "Discoverable" to False on the adapter and to True on the advertisement convinces
+    // Bluez to set "BR/EDR Not Supported" flag. Bluez doesn't provide API to do that explicitly
+    // and the flag is necessary to force using LE transport.
+    bluez_adapter1_set_discoverable(apEndpoint->mpAdapter, FALSE);
+
+exit:
+    g_list_free_full(objects, g_object_unref);
+    g_free(expectedPath);
+}
+
+static BluezConnection * GetBluezConnectionViaDevice(BluezEndpoint * apEndpoint)
+{
+    BluezConnection * retval =
+        static_cast<BluezConnection *>(g_hash_table_lookup(apEndpoint->mpConnMap, apEndpoint->mpPeerDevicePath));
+    // ChipLogError(DeviceLayer, "acquire connection object %p in (%s)", retval, __func__);
+    return retval;
+}
+
+#if CHIP_BLUEZ_CENTRAL_SUPPORT
+static BluezConnection * BluezCharacteristicGetBluezConnection(BluezGattCharacteristic1 * aChar, GVariant * aOptions,
+                                                               BluezEndpoint * apEndpoint)
+{
+    BluezConnection * retval = NULL;
+    const gchar * path       = NULL;
+    GVariantDict options;
+    GVariant * v;
+
+    VerifyOrExit(apEndpoint != NULL, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+    VerifyOrExit(apEndpoint->mIsCentral, );
+
+    /* TODO Unfortunately StartNotify/StopNotify doesn't provide info about
+     * peer device in call params so we need look this up ourselves.
+     */
+    if (aOptions == NULL)
+    {
+        GList * objects;
+        GList * l;
+        GList * ll;
+
+        objects = g_dbus_object_manager_get_objects(apEndpoint->mpObjMgr);
+        for (l = objects; l != NULL; l = l->next)
+        {
+            BluezDevice1 * device = bluez_object_get_device1(BLUEZ_OBJECT(l->data));
+            if (device != NULL)
+            {
+                if (BluezIsDeviceOnAdapter(device, apEndpoint->mpAdapter))
+                {
+                    for (ll = objects; ll != NULL; ll = ll->next)
+                    {
+                        BluezGattService1 * service = bluez_object_get_gatt_service1(BLUEZ_OBJECT(ll->data));
+                        if (service != NULL)
+                        {
+                            if (BluezIsServiceOnDevice(service, device))
+                            {
+                                if (BluezIsCharOnService(aChar, service))
+                                {
+                                    retval = (BluezConnection *) g_hash_table_lookup(
+                                        apEndpoint->mpConnMap, g_dbus_proxy_get_object_path(G_DBUS_PROXY(device)));
+                                }
+                            }
+                            g_object_unref(service);
+                            if (retval != NULL)
+                                break;
+                        }
+                    }
+                }
+                g_object_unref(device);
+                if (retval != NULL)
+                    break;
+            }
+        }
+
+        g_list_free_full(objects, g_object_unref);
+    }
+    else
+    {
+        g_variant_dict_init(&options, aOptions);
+
+        v = g_variant_dict_lookup_value(&options, "device", G_VARIANT_TYPE_OBJECT_PATH);
+
+        VerifyOrExit(v != NULL, ChipLogError(DeviceLayer, "FAIL: No device option in dictionary (%s)", __func__));
+
+        path = g_variant_get_string(v, NULL);
+
+        retval = (BluezConnection *) g_hash_table_lookup(apEndpoint->mpConnMap, path);
+    }
+
+exit:
+    return retval;
+}
+#endif // CHIP_BLUEZ_CENTRAL_SUPPORT
+
+void EndpointCleanup(BluezEndpoint * apEndpoint)
+{
+    if (apEndpoint != nullptr)
+    {
+        if (apEndpoint->mpOwningName != nullptr)
+        {
+            g_free(apEndpoint->mpOwningName);
+            apEndpoint->mpOwningName = nullptr;
+        }
+        if (apEndpoint->mpAdapterName != nullptr)
+        {
+            g_free(apEndpoint->mpAdapterName);
+            apEndpoint->mpAdapterName = nullptr;
+        }
+        if (apEndpoint->mpAdapterAddr != nullptr)
+        {
+            g_free(apEndpoint->mpAdapterAddr);
+            apEndpoint->mpAdapterAddr = nullptr;
+        }
+        if (apEndpoint->mpRootPath != nullptr)
+        {
+            g_free(apEndpoint->mpRootPath);
+            apEndpoint->mpRootPath = nullptr;
+        }
+        if (apEndpoint->mpAdvPath != nullptr)
+        {
+            g_free(apEndpoint->mpAdvPath);
+            apEndpoint->mpAdvPath = nullptr;
+        }
+        if (apEndpoint->mpServicePath != nullptr)
+        {
+            g_free(apEndpoint->mpServicePath);
+            apEndpoint->mpServicePath = nullptr;
+        }
+        if (apEndpoint->mpConnMap != nullptr)
+        {
+            g_hash_table_destroy(apEndpoint->mpConnMap);
+            apEndpoint->mpConnMap = nullptr;
+        }
+        if (apEndpoint->mpAdvertisingUUID != nullptr)
+        {
+            g_free(apEndpoint->mpAdvertisingUUID);
+            apEndpoint->mpAdvertisingUUID = nullptr;
+        }
+        if (apEndpoint->mpPeerDevicePath != nullptr)
+        {
+            g_free(apEndpoint->mpPeerDevicePath);
+            apEndpoint->mpPeerDevicePath = nullptr;
+        }
+        g_free(apEndpoint->mpConnectCancellable);
+        g_free(apEndpoint);
+    }
+}
+
+int BluezObjectsCleanup(BluezEndpoint * apEndpoint)
+{
+    g_object_unref(apEndpoint->mpAdapter);
+    EndpointCleanup(apEndpoint);
+    return 0;
+}
+
+#if CHIP_ENABLE_ADDITIONAL_DATA_ADVERTISING
+static void UpdateAdditionalDataCharacteristic(BluezGattCharacteristic1 * characteristic)
+{
+    if (characteristic == nullptr)
+    {
+        return;
+    }
+
+    // Construct the TLV for the additional data
+    GVariant * cValue = nullptr;
+    gpointer data;
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    chip::System::PacketBufferHandle bufferHandle;
+
+    char serialNumber[ConfigurationManager::kMaxSerialNumberLength + 1];
+    uint16_t lifetimeCounter = 0;
+    BitFlags<AdditionalDataFields> additionalDataFields;
+
+#if CHIP_ENABLE_ROTATING_DEVICE_ID
+    err = ConfigurationMgr().GetSerialNumber(serialNumber, sizeof(serialNumber));
+    SuccessOrExit(err);
+    err = ConfigurationMgr().GetLifetimeCounter(lifetimeCounter);
+    SuccessOrExit(err);
+
+    additionalDataFields.Set(AdditionalDataFields::RotatingDeviceId);
+#endif
+
+    err = AdditionalDataPayloadGenerator().generateAdditionalDataPayload(lifetimeCounter, serialNumber, strlen(serialNumber),
+                                                                         bufferHandle, additionalDataFields);
+    SuccessOrExit(err);
+
+    data = g_memdup(bufferHandle->Start(), bufferHandle->DataLength());
+
+    cValue = g_variant_new_from_data(G_VARIANT_TYPE("ay"), data, bufferHandle->DataLength(), TRUE, g_free, data);
+    bluez_gatt_characteristic1_set_value(characteristic, cValue);
+
+    return;
+
+exit:
+    if (err != CHIP_NO_ERROR)
+    {
+        ChipLogError(DeviceLayer, "Failed to generate TLV encoded Additional Data (%s)", __func__);
+    }
+    return;
+}
+#endif
+
+static void BluezPeripheralObjectsSetup(gpointer apClosure)
+{
+
+    static const char * const c1_flags[] = { "write", nullptr };
+    static const char * const c2_flags[] = { "read", "indicate", nullptr };
+    static const char * const c3_flags[] = { "read", nullptr };
+
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apClosure);
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    endpoint->mpService = BluezServiceCreate(apClosure);
+    // C1 characteristic
+    endpoint->mpC1 =
+        BluezCharacteristicCreate(endpoint->mpService, g_strdup("c1"), g_strdup(CHIP_PLAT_BLE_UUID_C1_STRING), endpoint->mpRoot);
+    bluez_gatt_characteristic1_set_flags(endpoint->mpC1, c1_flags);
+
+    g_signal_connect(endpoint->mpC1, "handle-read-value", G_CALLBACK(BluezCharacteristicReadValue), apClosure);
+    g_signal_connect(endpoint->mpC1, "handle-write-value", G_CALLBACK(BluezCharacteristicWriteValueError), NULL);
+    g_signal_connect(endpoint->mpC1, "handle-acquire-write", G_CALLBACK(BluezCharacteristicAcquireWrite), apClosure);
+    g_signal_connect(endpoint->mpC1, "handle-acquire-notify", G_CALLBACK(BluezCharacteristicAcquireNotifyError), NULL);
+    g_signal_connect(endpoint->mpC1, "handle-start-notify", G_CALLBACK(BluezCharacteristicStartNotifyError), NULL);
+    g_signal_connect(endpoint->mpC1, "handle-stop-notify", G_CALLBACK(BluezCharacteristicStopNotifyError), NULL);
+    g_signal_connect(endpoint->mpC1, "handle-confirm", G_CALLBACK(BluezCharacteristicConfirmError), NULL);
+
+    endpoint->mpC2 =
+        BluezCharacteristicCreate(endpoint->mpService, g_strdup("c2"), g_strdup(CHIP_PLAT_BLE_UUID_C2_STRING), endpoint->mpRoot);
+    bluez_gatt_characteristic1_set_flags(endpoint->mpC2, c2_flags);
+    g_signal_connect(endpoint->mpC2, "handle-read-value", G_CALLBACK(BluezCharacteristicReadValue), apClosure);
+    g_signal_connect(endpoint->mpC2, "handle-write-value", G_CALLBACK(BluezCharacteristicWriteValueError), NULL);
+    g_signal_connect(endpoint->mpC2, "handle-acquire-write", G_CALLBACK(BluezCharacteristicAcquireWriteError), NULL);
+    g_signal_connect(endpoint->mpC2, "handle-acquire-notify", G_CALLBACK(BluezCharacteristicAcquireNotify), apClosure);
+    g_signal_connect(endpoint->mpC2, "handle-start-notify", G_CALLBACK(BluezCharacteristicStartNotify), apClosure);
+    g_signal_connect(endpoint->mpC2, "handle-stop-notify", G_CALLBACK(BluezCharacteristicStopNotify), apClosure);
+    g_signal_connect(endpoint->mpC2, "handle-confirm", G_CALLBACK(BluezCharacteristicConfirm), apClosure);
+
+    ChipLogDetail(DeviceLayer, "CHIP BTP C1 %s", bluez_gatt_characteristic1_get_service(endpoint->mpC1));
+    ChipLogDetail(DeviceLayer, "CHIP BTP C2 %s", bluez_gatt_characteristic1_get_service(endpoint->mpC2));
+
+#if CHIP_ENABLE_ADDITIONAL_DATA_ADVERTISING
+    ChipLogDetail(DeviceLayer, "CHIP_ENABLE_ADDITIONAL_DATA_ADVERTISING is TRUE");
+    // Additional data characteristics
+    endpoint->mpC3 =
+        BluezCharacteristicCreate(endpoint->mpService, g_strdup("c3"), g_strdup(CHIP_PLAT_BLE_UUID_C3_STRING), endpoint->mpRoot);
+    bluez_gatt_characteristic1_set_flags(endpoint->mpC3, c3_flags);
+    g_signal_connect(endpoint->mpC3, "handle-read-value", G_CALLBACK(BluezCharacteristicReadValue), apClosure);
+    g_signal_connect(endpoint->mpC3, "handle-write-value", G_CALLBACK(BluezCharacteristicWriteValueError), NULL);
+    g_signal_connect(endpoint->mpC3, "handle-acquire-write", G_CALLBACK(BluezCharacteristicAcquireWriteError), NULL);
+    g_signal_connect(endpoint->mpC3, "handle-acquire-notify", G_CALLBACK(BluezCharacteristicAcquireNotify), apClosure);
+    g_signal_connect(endpoint->mpC3, "handle-start-notify", G_CALLBACK(BluezCharacteristicStartNotify), apClosure);
+    g_signal_connect(endpoint->mpC3, "handle-stop-notify", G_CALLBACK(BluezCharacteristicStopNotify), apClosure);
+    g_signal_connect(endpoint->mpC3, "handle-confirm", G_CALLBACK(BluezCharacteristicConfirm), apClosure);
+    // update the characteristic value
+    UpdateAdditionalDataCharacteristic(endpoint->mpC3);
+    ChipLogDetail(DeviceLayer, "CHIP BTP C3 %s", bluez_gatt_characteristic1_get_service(endpoint->mpC3));
+#else
+    ChipLogDetail(DeviceLayer, "CHIP_ENABLE_ADDITIONAL_DATA_ADVERTISING is FALSE");
+    (void) c3_flags;
+#endif
+
+exit:
+    return;
+}
+
+static void BluezOnBusAcquired(GDBusConnection * aConn, const gchar * aName, gpointer apClosure)
+{
+    BluezEndpoint * endpoint = static_cast<BluezEndpoint *>(apClosure);
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    ChipLogDetail(DeviceLayer, "TRACE: Bus acquired for name %s", aName);
+
+    if (!endpoint->mIsCentral)
+    {
+        endpoint->mpRootPath = g_strdup_printf("/chipoble/%04x", getpid() & 0xffff);
+        endpoint->mpRoot     = g_dbus_object_manager_server_new(endpoint->mpRootPath);
+        g_dbus_object_manager_server_set_connection(endpoint->mpRoot, aConn);
+
+        BluezPeripheralObjectsSetup(apClosure);
+    }
+
+exit:
+    return;
+}
+
+#if CHIP_BLUEZ_NAME_MONITOR
+static void BluezOnNameAcquired(GDBusConnection * aConn, const gchar * aName, gpointer apClosure)
+{
+    ChipLogDetail(DeviceLayer, "TRACE: Owning name: Acquired %s", aName);
+}
+
+static void BluezOnNameLost(GDBusConnection * aConn, const gchar * aName, gpointer apClosure)
+{
+    ChipLogDetail(DeviceLayer, "TRACE: Owning name: lost %s", aName);
+}
+#endif
+
+static int StartupEndpointBindings(BluezEndpoint * endpoint)
+{
+    GDBusObjectManager * manager;
+    GError * error         = nullptr;
+    GDBusConnection * conn = nullptr;
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "endpoint is NULL in %s", __func__));
+
+    conn = g_bus_get_sync(G_BUS_TYPE_SYSTEM, nullptr, &error);
+    VerifyOrExit(conn != nullptr, ChipLogError(DeviceLayer, "FAIL: get bus sync in %s, error: %s", __func__, error->message));
+
+    if (endpoint->mpAdapterName != nullptr)
+        endpoint->mpOwningName = g_strdup_printf("%s", endpoint->mpAdapterName);
+    else
+        endpoint->mpOwningName = g_strdup_printf("C-%04x", getpid() & 0xffff);
+
+    BluezOnBusAcquired(conn, endpoint->mpOwningName, endpoint);
+
+    manager = g_dbus_object_manager_client_new_sync(
+        conn, G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE, BLUEZ_INTERFACE, "/", bluez_object_manager_client_get_proxy_type,
+        nullptr /* unused user data in the Proxy Type Func */, nullptr /*destroy notify */, nullptr /* cancellable */, &error);
+
+    VerifyOrExit(manager != nullptr, ChipLogError(DeviceLayer, "FAIL: Error getting object manager client: %s", error->message));
+
+    endpoint->mpObjMgr = manager;
+
+    bluezObjectsSetup(endpoint);
+
+    g_signal_connect(manager, "object-added", G_CALLBACK(BluezSignalOnObjectAdded), endpoint);
+    g_signal_connect(manager, "object-removed", G_CALLBACK(BluezSignalOnObjectRemoved), endpoint);
+    g_signal_connect(manager, "interface-proxy-properties-changed", G_CALLBACK(BluezSignalInterfacePropertiesChanged), endpoint);
+
+    if (!MainLoop::Instance().SetCleanupFunction(BluezObjectsCleanup, endpoint))
+    {
+        ChipLogError(DeviceLayer, "Failed to schedule cleanup function");
+    }
+
+exit:
+    if (error != nullptr)
+        g_error_free(error);
+
+    return 0;
+}
+
+static gboolean BluezC2Indicate(ConnectionDataBundle * closure)
+{
+    BluezConnection * conn = nullptr;
+    GError * error         = nullptr;
+    GIOStatus status;
+    const char * buf;
+    size_t len, written;
+
+    VerifyOrExit(closure != nullptr, ChipLogError(DeviceLayer, "ConnectionDataBundle is NULL in %s", __func__));
+
+    conn = closure->mpConn;
+    VerifyOrExit(conn != nullptr, ChipLogError(DeviceLayer, "BluezConnection is NULL in %s", __func__));
+    VerifyOrExit(conn->mpC2 != nullptr, ChipLogError(DeviceLayer, "FAIL: C2 Indicate: %s", "NULL C2"));
+
+    if (bluez_gatt_characteristic1_get_notify_acquired(conn->mpC2) == TRUE)
+    {
+        buf = (char *) g_variant_get_fixed_array(closure->mpVal, &len, sizeof(uint8_t));
+        VerifyOrExit(len <= static_cast<size_t>(std::numeric_limits<gssize>::max()),
+                     ChipLogError(DeviceLayer, "FAIL: buffer too large in %s", __func__));
+        status = g_io_channel_write_chars(conn->mC2Channel.mpChannel, buf, static_cast<gssize>(len), &written, &error);
+        g_variant_unref(closure->mpVal);
+        closure->mpVal = nullptr;
+
+        VerifyOrExit(status == G_IO_STATUS_NORMAL, ChipLogError(DeviceLayer, "FAIL: C2 Indicate: %s", error->message));
+    }
+    else
+    {
+        bluez_gatt_characteristic1_set_value(conn->mpC2, closure->mpVal);
+        closure->mpVal = nullptr;
+    }
+
+exit:
+    if (closure != nullptr)
+    {
+        if (closure->mpVal)
+        {
+            g_variant_unref(closure->mpVal);
+        }
+        g_free(closure);
+    }
+
+    if (error != nullptr)
+        g_error_free(error);
+    return G_SOURCE_REMOVE;
+}
+
+static ConnectionDataBundle * MakeConnectionDataBundle(BLE_CONNECTION_OBJECT apConn, const chip::System::PacketBufferHandle & apBuf)
+{
+    ConnectionDataBundle * bundle = g_new(ConnectionDataBundle, 1);
+    bundle->mpConn                = static_cast<BluezConnection *>(apConn);
+    bundle->mpVal =
+        g_variant_new_fixed_array(G_VARIANT_TYPE_BYTE, apBuf->Start(), apBuf->DataLength() * sizeof(uint8_t), sizeof(uint8_t));
+    return bundle;
+}
+
+bool SendBluezIndication(BLE_CONNECTION_OBJECT apConn, chip::System::PacketBufferHandle apBuf)
+{
+    bool success = false;
+
+    VerifyOrExit(!apBuf.IsNull(), ChipLogError(DeviceLayer, "apBuf is NULL in %s", __func__));
+
+    success = MainLoop::Instance().Schedule(BluezC2Indicate, MakeConnectionDataBundle(apConn, apBuf));
+
+exit:
+    return success;
+}
+
+static gboolean BluezDisconnect(void * apClosure)
+{
+    BluezConnection * conn = static_cast<BluezConnection *>(apClosure);
+    GError * error         = nullptr;
+    gboolean success;
+
+    VerifyOrExit(conn != nullptr, ChipLogError(DeviceLayer, "conn is NULL in %s", __func__));
+    VerifyOrExit(conn->mpDevice != nullptr, ChipLogError(DeviceLayer, "FAIL: Disconnect: %s", "NULL Device"));
+
+    ChipLogDetail(DeviceLayer, "%s peer=%s", __func__, bluez_device1_get_address(conn->mpDevice));
+
+    success = bluez_device1_call_disconnect_sync(conn->mpDevice, nullptr, &error);
+    VerifyOrExit(success == TRUE, ChipLogError(DeviceLayer, "FAIL: Disconnect: %s", error->message));
+
+exit:
+    if (error != nullptr)
+        g_error_free(error);
+    return G_SOURCE_REMOVE;
+}
+
+static int CloseBleconnectionCB(void * apAppState)
+{
+    BluezDisconnect(apAppState);
+    return G_SOURCE_REMOVE;
+}
+
+bool CloseBluezConnection(BLE_CONNECTION_OBJECT apConn)
+{
+    return MainLoop::Instance().RunOnBluezThread(CloseBleconnectionCB, apConn);
+}
+
+CHIP_ERROR StartBluezAdv(BluezEndpoint * apEndpoint)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    if (!MainLoop::Instance().Schedule(BluezAdvStart, apEndpoint))
+    {
+        err = CHIP_ERROR_INCORRECT_STATE;
+        ChipLogError(Ble, "Failed to schedule BluezAdvStart() on CHIPoBluez thread");
+    }
+    return err;
+}
+
+CHIP_ERROR StopBluezAdv(BluezEndpoint * apEndpoint)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    if (!MainLoop::Instance().Schedule(BluezAdvStop, apEndpoint))
+    {
+        err = CHIP_ERROR_INCORRECT_STATE;
+        ChipLogError(Ble, "Failed to schedule BluezAdvStop() on CHIPoBluez thread");
+    }
+    return err;
+}
+
+CHIP_ERROR BluezAdvertisementSetup(BluezEndpoint * apEndpoint)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    if (!MainLoop::Instance().Schedule(BluezAdvSetup, apEndpoint))
+    {
+        err = CHIP_ERROR_INCORRECT_STATE;
+        ChipLogError(Ble, "Failed to schedule BluezAdvertisementSetup() on CHIPoBluez thread");
+    }
+    return err;
+}
+
+CHIP_ERROR BluezGattsAppRegister(BluezEndpoint * apEndpoint)
+{
+    CHIP_ERROR err = CHIP_NO_ERROR;
+    if (!MainLoop::Instance().Schedule(BluezPeripheralRegisterApp, apEndpoint))
+    {
+        err = CHIP_ERROR_INCORRECT_STATE;
+        ChipLogError(Ble, "Failed to schedule BluezPeripheralRegisterApp() on CHIPoBluez thread");
+    }
+    return err;
+}
+
+CHIP_ERROR ConfigureBluezAdv(BLEAdvConfig & aBleAdvConfig, BluezEndpoint * apEndpoint)
+{
+    const char * msg = nullptr;
+    CHIP_ERROR err   = CHIP_NO_ERROR;
+    VerifyOrExit(aBleAdvConfig.mpBleName != nullptr, msg = "FAIL: BLE name is NULL");
+    VerifyOrExit(aBleAdvConfig.mpAdvertisingUUID != nullptr, msg = "FAIL: BLE mpAdvertisingUUID is NULL in %s");
+
+    apEndpoint->mpAdapterName     = g_strdup(aBleAdvConfig.mpBleName);
+    apEndpoint->mpAdvertisingUUID = g_strdup(aBleAdvConfig.mpAdvertisingUUID);
+    apEndpoint->mAdapterId        = aBleAdvConfig.mAdapterId;
+    apEndpoint->mType             = aBleAdvConfig.mType;
+    apEndpoint->mDuration         = aBleAdvConfig.mDuration;
+    apEndpoint->mDuration         = aBleAdvConfig.mDuration;
+
+    err = ConfigurationMgr().GetBLEDeviceIdentificationInfo(apEndpoint->mDeviceIdInfo);
+    SuccessOrExit(err);
+
+exit:
+    if (nullptr != msg)
+    {
+        ChipLogDetail(DeviceLayer, "%s in %s", msg, __func__);
+        err = CHIP_ERROR_INCORRECT_STATE;
+    }
+    return err;
+}
+
+CHIP_ERROR InitBluezBleLayer(bool aIsCentral, char * apBleAddr, BLEAdvConfig & aBleAdvConfig, BluezEndpoint *& apEndpoint)
+{
+    CHIP_ERROR err           = CHIP_NO_ERROR;
+    bool retval              = false;
+    BluezEndpoint * endpoint = nullptr;
+
+    // initialize server endpoint
+    endpoint = g_new0(BluezEndpoint, 1);
+    VerifyOrExit(endpoint != nullptr, ChipLogError(DeviceLayer, "FAIL: memory allocation in %s", __func__));
+
+    if (apBleAddr != nullptr)
+        endpoint->mpAdapterAddr = g_strdup(apBleAddr);
+    else
+        endpoint->mpAdapterAddr = nullptr;
+
+    endpoint->mpConnMap  = g_hash_table_new(g_str_hash, g_str_equal);
+    endpoint->mIsCentral = aIsCentral;
+
+    if (!aIsCentral)
+    {
+        err = ConfigureBluezAdv(aBleAdvConfig, endpoint);
+        SuccessOrExit(err);
+    }
+    else
+    {
+        endpoint->mAdapterId           = aBleAdvConfig.mAdapterId;
+        endpoint->mpConnectCancellable = g_cancellable_new();
+    }
+
+    err = MainLoop::Instance().EnsureStarted();
+    VerifyOrExit(err == CHIP_NO_ERROR, ChipLogError(DeviceLayer, "Failed to start BLE main loop"));
+
+    if (!MainLoop::Instance().ScheduleAndWait(StartupEndpointBindings, endpoint))
+    {
+        ChipLogError(DeviceLayer, "Failed to schedule endpoint initialization");
+        ExitNow();
+    }
+
+    retval = TRUE;
+
+exit:
+    if (retval)
+    {
+        apEndpoint = endpoint;
+        ChipLogDetail(DeviceLayer, "PlatformBlueZInit init success");
+    }
+    else
+    {
+        EndpointCleanup(endpoint);
+    }
+
+    return err;
+}
+
+// BluezSendWriteRequest callbacks
+
+static void SendWriteRequestDone(GObject * aObject, GAsyncResult * aResult, gpointer apConnection)
+{
+    BluezGattCharacteristic1 * c1 = BLUEZ_GATT_CHARACTERISTIC1(aObject);
+    GError * error                = nullptr;
+    gboolean success              = bluez_gatt_characteristic1_call_write_value_finish(c1, aResult, &error);
+
+    VerifyOrExit(success == TRUE, ChipLogError(DeviceLayer, "FAIL: BluezSendWriteRequest : %s", error->message));
+    BLEManagerImpl::HandleWriteComplete(static_cast<BLE_CONNECTION_OBJECT>(apConnection));
+
+exit:
+    if (error != nullptr)
+        g_error_free(error);
+}
+
+static gboolean SendWriteRequestImpl(void * apConnectionData)
+{
+    ConnectionDataBundle * data = static_cast<ConnectionDataBundle *>(apConnectionData);
+    GVariant * options          = nullptr;
+    GVariantBuilder optionsBuilder;
+
+    VerifyOrExit(data != nullptr, ChipLogError(DeviceLayer, "ConnectionDataBundle is NULL in %s", __func__));
+    VerifyOrExit(data->mpConn != nullptr, ChipLogError(DeviceLayer, "BluezConnection is NULL in %s", __func__));
+    VerifyOrExit(data->mpConn->mpC1 != nullptr, ChipLogError(DeviceLayer, "C1 is NULL in %s", __func__));
+
+    g_variant_builder_init(&optionsBuilder, G_VARIANT_TYPE_ARRAY);
+    g_variant_builder_add(&optionsBuilder, "{sv}", "type", g_variant_new_string("request"));
+    options = g_variant_builder_end(&optionsBuilder);
+
+    bluez_gatt_characteristic1_call_write_value(data->mpConn->mpC1, data->mpVal, options, nullptr, SendWriteRequestDone,
+                                                data->mpConn);
+
+exit:
+    g_free(data);
+    return G_SOURCE_REMOVE;
+}
+
+bool BluezSendWriteRequest(BLE_CONNECTION_OBJECT apConn, chip::System::PacketBufferHandle apBuf)
+{
+    bool success = false;
+
+    VerifyOrExit(!apBuf.IsNull(), ChipLogError(DeviceLayer, "apBuf is NULL in %s", __func__));
+
+    success = MainLoop::Instance().RunOnBluezThread(SendWriteRequestImpl, MakeConnectionDataBundle(apConn, apBuf));
+
+exit:
+    return success;
+}
+
+// BluezSubscribeCharacteristic callbacks
+
+static void OnCharacteristicChanged(GDBusProxy * aInterface, GVariant * aChangedProperties, const gchar * const * aInvalidatedProps,
+                                    gpointer apConnection)
+{
+    BLE_CONNECTION_OBJECT connection = static_cast<BLE_CONNECTION_OBJECT>(apConnection);
+    GVariant * value                 = g_variant_lookup_value(aChangedProperties, "Value", G_VARIANT_TYPE_BYTESTRING);
+    VerifyOrReturn(value != nullptr);
+
+    size_t bufferLen;
+    auto buffer = g_variant_get_fixed_array(value, &bufferLen, sizeof(uint8_t));
+    VerifyOrReturn(value != nullptr, ChipLogError(DeviceLayer, "Characteristic value has unexpected type"));
+
+    BLEManagerImpl::HandleTXCharChanged(connection, static_cast<const uint8_t *>(buffer), bufferLen);
+}
+
+static void SubscribeCharacteristicDone(GObject * aObject, GAsyncResult * aResult, gpointer apConnection)
+{
+    BluezGattCharacteristic1 * c2 = BLUEZ_GATT_CHARACTERISTIC1(aObject);
+    GError * error                = nullptr;
+    gboolean success              = bluez_gatt_characteristic1_call_write_value_finish(c2, aResult, &error);
+
+    VerifyOrExit(success == TRUE, ChipLogError(DeviceLayer, "FAIL: BluezSubscribeCharacteristic : %s", error->message));
+
+    // Get notifications on the TX characteristic change (e.g. indication is received)
+    g_signal_connect(c2, "g-properties-changed", G_CALLBACK(OnCharacteristicChanged), apConnection);
+    BLEManagerImpl::HandleSubscribeOpComplete(static_cast<BLE_CONNECTION_OBJECT>(apConnection), true);
+
+exit:
+    if (error != nullptr)
+        g_error_free(error);
+}
+
+static gboolean SubscribeCharacteristicImpl(BluezConnection * connection)
+{
+    VerifyOrExit(connection != nullptr, ChipLogError(DeviceLayer, "BluezConnection is NULL in %s", __func__));
+    VerifyOrExit(connection->mpC2 != nullptr, ChipLogError(DeviceLayer, "C2 is NULL in %s", __func__));
+
+    bluez_gatt_characteristic1_call_start_notify(connection->mpC2, nullptr, SubscribeCharacteristicDone, connection);
+
+exit:
+    return G_SOURCE_REMOVE;
+}
+
+bool BluezSubscribeCharacteristic(BLE_CONNECTION_OBJECT apConn)
+{
+    return MainLoop::Instance().Schedule(SubscribeCharacteristicImpl, static_cast<BluezConnection *>(apConn));
+}
+
+// BluezUnsubscribeCharacteristic callbacks
+
+static void UnsubscribeCharacteristicDone(GObject * aObject, GAsyncResult * aResult, gpointer apConnection)
+{
+    BluezGattCharacteristic1 * c2 = BLUEZ_GATT_CHARACTERISTIC1(aObject);
+    GError * error                = nullptr;
+    gboolean success              = bluez_gatt_characteristic1_call_write_value_finish(c2, aResult, &error);
+
+    VerifyOrExit(success == TRUE, ChipLogError(DeviceLayer, "FAIL: BluezUnsubscribeCharacteristic : %s", error->message));
+
+    // Stop listening to the TX characteristic changes
+    g_signal_handlers_disconnect_by_data(c2, apConnection);
+    BLEManagerImpl::HandleSubscribeOpComplete(static_cast<BLE_CONNECTION_OBJECT>(apConnection), false);
+
+exit:
+    if (error != nullptr)
+        g_error_free(error);
+}
+
+static gboolean UnsubscribeCharacteristicImpl(BluezConnection * connection)
+{
+    VerifyOrExit(connection != nullptr, ChipLogError(DeviceLayer, "BluezConnection is NULL in %s", __func__));
+    VerifyOrExit(connection->mpC2 != nullptr, ChipLogError(DeviceLayer, "C2 is NULL in %s", __func__));
+
+    bluez_gatt_characteristic1_call_stop_notify(connection->mpC2, nullptr, UnsubscribeCharacteristicDone, connection);
+
+exit:
+    return G_SOURCE_REMOVE;
+}
+
+bool BluezUnsubscribeCharacteristic(BLE_CONNECTION_OBJECT apConn)
+{
+    return MainLoop::Instance().Schedule(UnsubscribeCharacteristicImpl, static_cast<BluezConnection *>(apConn));
+}
+
+// ConnectDevice callbacks
+
+struct ConnectParams
+{
+    ConnectParams(BluezDevice1 * device, BluezEndpoint * endpoint) : mDevice(device), mEndpoint(endpoint) {}
+    BluezDevice1 * mDevice;
+    BluezEndpoint * mEndpoint;
+};
+
+static void ConnectDeviceDone(GObject * aObject, GAsyncResult * aResult, gpointer)
+{
+    BluezDevice1 * device = BLUEZ_DEVICE1(aObject);
+    GError * error        = nullptr;
+    gboolean success      = bluez_device1_call_connect_finish(device, aResult, &error);
+
+    if (!success)
+    {
+        ChipLogError(DeviceLayer, "FAIL: ConnectDevice : %s", error->message);
+        BLEManagerImpl::HandleConnectFailed(CHIP_ERROR_INTERNAL);
+        ExitNow();
+    }
+
+    ChipLogDetail(DeviceLayer, "ConnectDevice complete");
+
+exit:
+    if (error != nullptr)
+        g_error_free(error);
+}
+
+static gboolean ConnectDeviceImpl(ConnectParams * apParams)
+{
+    BluezDevice1 * device    = apParams->mDevice;
+    BluezEndpoint * endpoint = apParams->mEndpoint;
+
+    assert(device != nullptr);
+    assert(endpoint != nullptr);
+
+    g_cancellable_reset(endpoint->mpConnectCancellable);
+    bluez_device1_call_connect(device, endpoint->mpConnectCancellable, ConnectDeviceDone, nullptr);
+    g_object_unref(device);
+    chip::Platform::Delete(apParams);
+
+    return G_SOURCE_REMOVE;
+}
+
+CHIP_ERROR ConnectDevice(BluezDevice1 * apDevice, BluezEndpoint * apEndpoint)
+{
+    auto params = chip::Platform::New<ConnectParams>(apDevice, apEndpoint);
+    g_object_ref(apDevice);
+
+    if (!MainLoop::Instance().Schedule(ConnectDeviceImpl, params))
+    {
+        ChipLogError(Ble, "Failed to schedule ConnectDeviceImpl() on CHIPoBluez thread");
+        g_object_unref(apDevice);
+        chip::Platform::Delete(params);
+        return CHIP_ERROR_INCORRECT_STATE;
+    }
+
+    return CHIP_NO_ERROR;
+}
+
+void CancelConnect(BluezEndpoint * apEndpoint)
+{
+    assert(apEndpoint->mpConnectCancellable != nullptr);
+    g_cancellable_cancel(apEndpoint->mpConnectCancellable);
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/bluez/Helper.h b/src/platform/webos/bluez/Helper.h
new file mode 100644
index 000000000..e77ffc96e
--- /dev/null
+++ b/src/platform/webos/bluez/Helper.h
@@ -0,0 +1,84 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/*
+ *  Copyright (c) 2016-2019, The OpenThread Authors.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the
+ *     names of its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *    @file
+ *          Provides Bluez dbus implementation for BLE
+ */
+
+#pragma once
+
+#include "Types.h"
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+CHIP_ERROR InitBluezBleLayer(bool aIsCentral, char * apBleAddr, BLEAdvConfig & aBleAdvConfig, BluezEndpoint *& apEndpoint);
+bool BluezRunOnBluezThread(int (*aCallback)(void *), void * apClosure);
+bool SendBluezIndication(BLE_CONNECTION_OBJECT apConn, chip::System::PacketBufferHandle apBuf);
+bool CloseBluezConnection(BLE_CONNECTION_OBJECT apConn);
+CHIP_ERROR StartBluezAdv(BluezEndpoint * apEndpoint);
+CHIP_ERROR StopBluezAdv(BluezEndpoint * apEndpoint);
+CHIP_ERROR BluezGattsAppRegister(BluezEndpoint * apEndpoint);
+CHIP_ERROR BluezAdvertisementSetup(BluezEndpoint * apEndpoint);
+
+/// Write to the CHIP RX characteristic on the remote peripheral device
+bool BluezSendWriteRequest(BLE_CONNECTION_OBJECT apConn, chip::System::PacketBufferHandle apBuf);
+/// Subscribe to the CHIP TX characteristic on the remote peripheral device
+bool BluezSubscribeCharacteristic(BLE_CONNECTION_OBJECT apConn);
+/// Unsubscribe from the CHIP TX characteristic on the remote peripheral device
+bool BluezUnsubscribeCharacteristic(BLE_CONNECTION_OBJECT apConn);
+
+CHIP_ERROR ConnectDevice(BluezDevice1 * apDevice, BluezEndpoint * apEndpoint);
+void CancelConnect(BluezEndpoint * apEndpoint);
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/bluez/MainLoop.cpp b/src/platform/webos/bluez/MainLoop.cpp
new file mode 100644
index 000000000..55c58bf38
--- /dev/null
+++ b/src/platform/webos/bluez/MainLoop.cpp
@@ -0,0 +1,185 @@
+/*
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#include "MainLoop.h"
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+#include <errno.h>
+#include <lib/support/CodeUtils.h>
+#include <lib/support/logging/CHIPLogging.h>
+#include <pthread.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+namespace {
+
+class Semaphore
+{
+public:
+    Semaphore()
+    {
+        if (sem_init(&mSemaphore, 0 /* shared */, 0 /*value*/) != 0)
+        {
+            ChipLogError(DeviceLayer, "Failed to initialize semaphore.");
+        }
+    }
+
+    ~Semaphore()
+    {
+        if (sem_destroy(&mSemaphore) != 0)
+        {
+            ChipLogError(DeviceLayer, "Failed to destroy semaphore.");
+        }
+    }
+
+    void Post() { sem_post(&mSemaphore); }
+
+    void Wait() { sem_wait(&mSemaphore); }
+
+private:
+    sem_t mSemaphore;
+};
+
+int PostSemaphore(Semaphore * semaphore)
+{
+    semaphore->Post();
+    return 0;
+}
+
+class CallbackIndirection
+{
+public:
+    CallbackIndirection(GSourceFunc f, void * a) : mCallback(f), mArgument(a) {}
+
+    void Wait() { mDoneSemaphore.Wait(); }
+
+    static int Callback(CallbackIndirection * self)
+    {
+        int result = self->mCallback(self->mArgument);
+        self->mDoneSemaphore.Post();
+        return result;
+    }
+
+private:
+    Semaphore mDoneSemaphore;
+    GSourceFunc mCallback;
+    void * mArgument;
+};
+
+} // namespace
+
+MainLoop & MainLoop::Instance()
+{
+    static MainLoop sMainLoop;
+    return sMainLoop;
+}
+
+void * MainLoop::Thread(void * self)
+{
+    MainLoop * loop = reinterpret_cast<MainLoop *>(self);
+
+    ChipLogDetail(DeviceLayer, "TRACE: Bluez mainloop starting %s", __func__);
+    g_main_loop_run(loop->mBluezMainLoop);
+    ChipLogDetail(DeviceLayer, "TRACE: Bluez mainloop stopping %s", __func__);
+
+    if (loop->mCleanup != nullptr)
+    {
+        ChipLogDetail(DeviceLayer, "TRACE: Executing cleanup %s", __func__);
+        loop->mCleanup(loop->mCleanupArgument);
+    }
+
+    return nullptr;
+}
+
+CHIP_ERROR MainLoop::EnsureStarted()
+{
+    if (mBluezMainLoop != nullptr)
+    {
+        return CHIP_NO_ERROR;
+    }
+
+    mBluezMainLoop = g_main_loop_new(nullptr, TRUE);
+    if (mBluezMainLoop == nullptr)
+    {
+        ChipLogError(DeviceLayer, "FAIL: memory alloc in %s", __func__);
+        return CHIP_ERROR_NO_MEMORY;
+    }
+
+    int pthreadErr = pthread_create(&mThread, nullptr, &MainLoop::Thread, reinterpret_cast<void *>(this));
+    int tmpErrno   = errno;
+    if (pthreadErr != 0)
+    {
+        ChipLogError(DeviceLayer, "FAIL: pthread_create (%s) in %s", strerror(tmpErrno), __func__);
+        g_free(mBluezMainLoop);
+        mBluezMainLoop = nullptr;
+        return CHIP_ERROR_INTERNAL;
+    }
+
+    Semaphore semaphore;
+
+    GMainContext * context = g_main_loop_get_context(mBluezMainLoop);
+    VerifyOrDie(context != nullptr);
+
+    g_main_context_invoke(context, GSourceFunc(PostSemaphore), &semaphore);
+
+    semaphore.Wait();
+
+    return CHIP_NO_ERROR;
+}
+
+bool MainLoop::RunOnBluezThread(GSourceFunc callback, void * argument)
+{
+    GMainContext * context = nullptr;
+    const char * msg       = nullptr;
+
+    VerifyOrExit(mBluezMainLoop != nullptr, msg = "FAIL: NULL sBluezMainLoop");
+    VerifyOrExit(g_main_loop_is_running(mBluezMainLoop), msg = "FAIL: sBluezMainLoop not running");
+
+    context = g_main_loop_get_context(mBluezMainLoop);
+    VerifyOrExit(context != nullptr, msg = "FAIL: NULL main context");
+    g_main_context_invoke(context, callback, argument);
+
+exit:
+    if (msg != nullptr)
+    {
+        ChipLogDetail(DeviceLayer, "%s in %s", msg, __func__);
+    }
+
+    return msg == nullptr;
+}
+
+bool MainLoop::RunOnBluezThreadAndWait(GSourceFunc closure, void * argument)
+{
+    CallbackIndirection indirection(closure, argument);
+
+    if (!Schedule(&CallbackIndirection::Callback, &indirection))
+    {
+        return false;
+    }
+
+    indirection.Wait();
+
+    return true;
+}
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/bluez/MainLoop.h b/src/platform/webos/bluez/MainLoop.h
new file mode 100644
index 000000000..e2a06e131
--- /dev/null
+++ b/src/platform/webos/bluez/MainLoop.h
@@ -0,0 +1,108 @@
+/*
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <lib/core/CHIPError.h>
+#include <platform/CHIPDeviceLayer.h>
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+#include <glib.h>
+#include <semaphore.h>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+/// The main loop provides a thread-based implementation that runs
+/// the GLib main loop.
+///
+/// The main loop is used execute callbacks (e.g. dbus notifications).
+class MainLoop
+{
+public:
+    /// Ensure that a thread with g_main_loop_run is executing.
+    CHIP_ERROR EnsureStarted();
+
+    /// Executes a callback on the underlying main loop.
+    ///
+    /// The main loop MUST have been started already.
+    bool RunOnBluezThread(GSourceFunc closure, void * arg);
+
+    /// Executes a callback on the underlying main loop and waits for
+    /// the method to complete.
+    ///
+    /// The main loop MUST have been started already.
+    bool RunOnBluezThreadAndWait(GSourceFunc closure, void * arg);
+
+    /// Convenience method to require less casts to void*
+    template <class T>
+    bool Schedule(int (*callback)(T *), T * value)
+    {
+        return RunOnBluezThread(G_SOURCE_FUNC(callback), value);
+    }
+
+    /// Convenience method to require less casts to void*
+    template <class T>
+    bool ScheduleAndWait(int (*callback)(T *), T * value)
+    {
+        return RunOnBluezThreadAndWait(G_SOURCE_FUNC(callback), value);
+    }
+
+    /// Schedules a method to be executed after the main loop has finished
+    ///
+    /// A single cleanup method can exist and the main loop has to be running
+    /// to set a cleanup method.
+    template <class T>
+    bool SetCleanupFunction(int (*callback)(T *), T * value)
+    {
+        if (mCleanup != nullptr)
+        {
+            return false;
+        }
+
+        if ((mBluezMainLoop == nullptr) || !g_main_loop_is_running(mBluezMainLoop))
+        {
+            return false;
+        }
+
+        mCleanup         = G_SOURCE_FUNC(callback);
+        mCleanupArgument = static_cast<void *>(value);
+
+        return true;
+    }
+
+    static MainLoop & Instance();
+
+private:
+    MainLoop() {}
+
+    static void * Thread(void * self);
+
+    GMainLoop * mBluezMainLoop = nullptr;
+    pthread_t mThread          = 0;
+
+    // allow a single cleanup method
+    GSourceFunc mCleanup    = nullptr;
+    void * mCleanupArgument = nullptr;
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/bluez/Types.h b/src/platform/webos/bluez/Types.h
new file mode 100644
index 000000000..528d70916
--- /dev/null
+++ b/src/platform/webos/bluez/Types.h
@@ -0,0 +1,197 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/*
+ *  Copyright (c) 2016-2019, The OpenThread Authors.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the
+ *     names of its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+#include <platform/CHIPDeviceConfig.h>
+
+#if CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
+
+#include <ble/CHIPBleServiceData.h>
+#include <platform/webos/dbus/bluez/DbusBluez.h>
+
+#include <cstdint>
+#include <string>
+
+namespace chip {
+namespace DeviceLayer {
+namespace Internal {
+
+enum ChipAdvType
+{
+    BLUEZ_ADV_TYPE_CONNECTABLE = 0x01,
+    BLUEZ_ADV_TYPE_SCANNABLE   = 0x02,
+    BLUEZ_ADV_TYPE_DIRECTED    = 0x04,
+
+    BLUEZ_ADV_TYPE_UNDIRECTED_NONCONNECTABLE_NONSCANNABLE = 0,
+    BLUEZ_ADV_TYPE_UNDIRECTED_CONNECTABLE_NONSCANNABLE    = BLUEZ_ADV_TYPE_CONNECTABLE,
+    BLUEZ_ADV_TYPE_UNDIRECTED_NONCONNECTABLE_SCANNABLE    = BLUEZ_ADV_TYPE_SCANNABLE,
+    BLUEZ_ADV_TYPE_UNDIRECTED_CONNECTABLE_SCANNABLE       = BLUEZ_ADV_TYPE_CONNECTABLE | BLUEZ_ADV_TYPE_SCANNABLE,
+
+    BLUEZ_ADV_TYPE_DIRECTED_NONCONNECTABLE_NONSCANNABLE = BLUEZ_ADV_TYPE_DIRECTED,
+    BLUEZ_ADV_TYPE_DIRECTED_CONNECTABLE_NONSCANNABLE    = BLUEZ_ADV_TYPE_DIRECTED | BLUEZ_ADV_TYPE_CONNECTABLE,
+    BLUEZ_ADV_TYPE_DIRECTED_NONCONNECTABLE_SCANNABLE    = BLUEZ_ADV_TYPE_DIRECTED | BLUEZ_ADV_TYPE_SCANNABLE,
+    BLUEZ_ADV_TYPE_DIRECTED_CONNECTABLE_SCANNABLE = BLUEZ_ADV_TYPE_DIRECTED | BLUEZ_ADV_TYPE_CONNECTABLE | BLUEZ_ADV_TYPE_SCANNABLE,
+};
+
+#define BLUEZ_ADDRESS_SIZE 6 ///< BLE address size (in bytes)
+#define BLUEZ_PATH "/org/bluez"
+#define BLUEZ_INTERFACE "org.bluez"
+#define ADAPTER_INTERFACE BLUEZ_INTERFACE ".Adapter1"
+#define PROFILE_INTERFACE BLUEZ_INTERFACE ".GattManager1"
+#define ADVERTISING_MANAGER_INTERFACE BLUEZ_INTERFACE ".LEAdvertisingManager1"
+#define SERVICE_INTERFACE BLUEZ_INTERFACE ".GattService1"
+#define CHARACTERISTIC_INTERFACE BLUEZ_INTERFACE ".GattCharacteristic1"
+#define ADVERTISING_INTERFACE BLUEZ_INTERFACE ".LEAdvertisement1"
+#define DEVICE_INTERFACE BLUEZ_INTERFACE ".Device1"
+
+#define CHIP_PLAT_BLE_UUID_C1_STRING "18ee2ef5-263d-4559-959f-4f9c429f9d11"
+#define CHIP_PLAT_BLE_UUID_C2_STRING "18ee2ef5-263d-4559-959f-4f9c429f9d12"
+#define CHIP_PLAT_BLE_UUID_C3_STRING "64630238-8772-45F2-B87D-748A83218F04"
+
+#define CHIP_BLE_BASE_SERVICE_UUID_STRING "-0000-1000-8000-00805f9b34fb"
+#define CHIP_BLE_SERVICE_PREFIX_LENGTH 8
+#define CHIP_BLE_BASE_SERVICE_PREFIX "0000"
+#define CHIP_BLE_UUID_SERVICE_SHORT_STRING "fff6"
+
+#define CHIP_BLE_UUID_SERVICE_STRING                                                                                               \
+    CHIP_BLE_BASE_SERVICE_PREFIX CHIP_BLE_UUID_SERVICE_SHORT_STRING CHIP_BLE_BASE_SERVICE_UUID_STRING
+
+#define BLUEZ_ADV_TYPE_FLAGS 0x01
+#define BLUEZ_ADV_TYPE_SERVICE_DATA 0x16
+
+#define BLUEZ_ADV_FLAGS_LE_LIMITED (1 << 0)
+#define BLUEZ_ADV_FLAGS_LE_DISCOVERABLE (1 << 1)
+#define BLUEZ_ADV_FLAGS_EDR_UNSUPPORTED (1 << 2)
+#define BLUEZ_ADV_FLAGS_LE_EDR_CONTROLLER (1 << 3)
+#define BLUEZ_ADV_FLAGS_LE_EDR_HOST (1 << 4)
+
+enum BluezAddressType
+{
+    BLUEZ_ADDRESS_TYPE_PUBLIC                        = 0, ///< Bluetooth public device address.
+    BLUEZ_ADDRESS_TYPE_RANDOM_STATIC                 = 1, ///< Bluetooth random static address.
+    BLUEZ_ADDRESS_TYPE_RANDOM_PRIVATE_RESOLVABLE     = 2, ///< Bluetooth random private resolvable address.
+    BLUEZ_ADDRESS_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE = 3, ///< Bluetooth random private non-resolvable address.
+};
+
+struct BluezAddress
+{
+    BluezAddressType mType;               ///< Bluetooth device address type.
+    uint8_t mAddress[BLUEZ_ADDRESS_SIZE]; ///< A 48-bit address of Bluetooth device in LSB format.
+};
+
+struct IOChannel
+{
+    GIOChannel * mpChannel;
+    guint mWatch;
+};
+
+struct BluezEndpoint
+{
+    char * mpOwningName; // Bus owning name
+
+    // Adapter properties
+    char * mpAdapterName;
+    char * mpAdapterAddr;
+
+    // Paths for objects published by this service
+    char * mpRootPath;
+    char * mpAdvPath;
+    char * mpServicePath;
+
+    // Objects (interfaces) subscibed to by this service
+    GDBusObjectManager * mpObjMgr = nullptr;
+    BluezAdapter1 * mpAdapter     = nullptr;
+    BluezDevice1 * mpDevice       = nullptr;
+
+    // Objects (interfaces) published by this service
+    GDBusObjectManagerServer * mpRoot;
+    BluezGattService1 * mpService;
+    BluezGattCharacteristic1 * mpC1;
+    BluezGattCharacteristic1 * mpC2;
+    // additional data characteristics
+    BluezGattCharacteristic1 * mpC3;
+
+    // map device path to the connection
+    GHashTable * mpConnMap;
+    uint32_t mAdapterId;
+    bool mIsCentral;
+    char * mpAdvertisingUUID;
+    chip::Ble::ChipBLEDeviceIdentificationInfo mDeviceIdInfo;
+    ChipAdvType mType;  ///< Advertisement type.
+    uint16_t mDuration; ///< Advertisement interval (in ms).
+    bool mIsAdvertising;
+    char * mpPeerDevicePath;
+    GCancellable * mpConnectCancellable = nullptr;
+};
+
+struct BluezConnection
+{
+    char * mpPeerAddress;
+    BluezDevice1 * mpDevice;
+    BluezGattService1 * mpService;
+    BluezGattCharacteristic1 * mpC1;
+    BluezGattCharacteristic1 * mpC2;
+    // additional data characteristics
+    BluezGattCharacteristic1 * mpC3;
+
+    bool mIsNotify;
+    uint16_t mMtu;
+    struct IOChannel mC1Channel;
+    struct IOChannel mC2Channel;
+    BluezEndpoint * mpEndpoint;
+};
+
+struct ConnectionDataBundle
+{
+    BluezConnection * mpConn;
+    GVariant * mpVal;
+};
+
+} // namespace Internal
+} // namespace DeviceLayer
+} // namespace chip
+
+#endif // CHIP_DEVICE_CONFIG_ENABLE_CHIPOBLE
diff --git a/src/platform/webos/dbus/bluez/BUILD.gn b/src/platform/webos/dbus/bluez/BUILD.gn
new file mode 100644
index 000000000..308feccb9
--- /dev/null
+++ b/src/platform/webos/dbus/bluez/BUILD.gn
@@ -0,0 +1,26 @@
+# Copyright (c) 2020 Project CHIP Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build_overrides/chip.gni")
+
+import("${chip_root}/build/chip/linux/gdbus_library.gni")
+
+gdbus_library("bluez") {
+  sources = [ "DbusBluez.xml" ]
+
+  c_namespace = "Bluez"
+  interface_prefix = "org.bluez"
+  c_generate_object_manager = true
+  dbus_out_dir = "platform/Linux/dbus/bluez"
+}
diff --git a/src/platform/webos/dbus/bluez/DbusBluez.xml b/src/platform/webos/dbus/bluez/DbusBluez.xml
new file mode 100644
index 000000000..ac0952bcc
--- /dev/null
+++ b/src/platform/webos/dbus/bluez/DbusBluez.xml
@@ -0,0 +1,255 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+# Copyright (c) 2020 Project CHIP Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# This file is constructed using the below method.
+# 1. running bluetoothd
+# 2. running two Bluetooth adapter with LE capability and create ble connection with Gatt servie and Gatt Char.
+#    For the purposes of XML generation we use btvirt emulator with the LE only capability.
+# Assume the LE chip is on hci 0
+# we get the bluez XML via:
+# sudo gdbus introspect -s -d org.bluez -r -o /org/bluez -x
+# sudo gdbus introspect -s -d org.bluez -r -o /org/bluez/hci0 -x
+# sudo gdbus introspect -s -d org.bluez -r -o /org/bluez/hci0/dev_00_AA_01_01_00_24 -x
+# sudo gdbus introspect -s -d org.bluez -r -o /org/bluez/hci0/dev_00_AA_01_01_00_24/service0006 -x
+# sudo gdbus introspect -s -d org.bluez -r -o /org/bluez/hci0/dev_00_AA_01_01_00_24/service0006/char0007 -x
+# sudo gdbus introspect -s -d org.bluez -r -o /org/bluez/hci0/dev_00_AA_01_01_00_24/service0006/char0007/desc0009 -x
+# sudo gdbus introspect -s -d org.bluez -r -o / -x
+-->
+
+<node>
+  <interface name="org.bluez.Adapter1">
+    <method name="StartDiscovery" />
+    <method name="SetDiscoveryFilter">
+      <arg name="properties" type="a{sv}" direction="in" />
+    </method>
+    <method name="StopDiscovery" />
+    <method name="RemoveDevice">
+      <arg name="device" type="o" direction="in" />
+    </method>
+    <method name="GetDiscoveryFilters">
+      <arg name="filters" type="as" direction="out" />
+    </method>
+    <method name="ConnectDevice">
+      <arg name="properties" type="a{sv}" direction="in" />
+    </method>
+
+    <property name="Address" type="s" access="read" />
+    <property name="AddressType" type="s" access="read" />
+    <property name="Name" type="s" access="read" />
+    <property name="Alias" type="s" access="readwrite" />
+    <property name="Class" type="u" access="read" />
+    <property name="Powered" type="b" access="readwrite" />
+    <property name="Discoverable" type="b" access="readwrite" />
+    <property name="DiscoverableTimeout" type="u" access="readwrite" />
+    <property name="Pairable" type="b" access="readwrite" />
+    <property name="PairableTimeout" type="u" access="readwrite" />
+    <property name="Discovering" type="b" access="read" />
+    <property name="UUIDs" type="as" access="read" />
+    <property name="Modalias" type="s" access="read" />
+    <property name="Roles" type="as" access="read" />
+  </interface>
+
+  <interface name="org.bluez.Device1">
+    <method name="Disconnect" />
+    <method name="Connect" />
+    <method name="ConnectProfile">
+      <arg name="UUID" type="s" direction="in" />
+    </method>
+    <method name="DisconnectProfile">
+      <arg name="UUID" type="s" direction="in" />
+    </method>
+    <method name="Pair" />
+    <method name="CancelPairing" />
+    <property name="Address" type="s" access="read" />
+    <property name="AddressType" type="s" access="read" />
+    <property name="Name" type="s" access="read" />
+    <property name="Alias" type="s" access="readwrite" />
+    <property name="Class" type="u" access="read" />
+    <property name="Appearance" type="q" access="read" />
+    <property name="Icon" type="s" access="read" />
+    <property name="Paired" type="b" access="read" />
+    <property name="Trusted" type="b" access="readwrite" />
+    <property name="Blocked" type="b" access="readwrite" />
+    <property name="LegacyPairing" type="b" access="read" />
+    <property name="RSSI" type="n" access="read" />
+    <property name="Connected" type="b" access="read" />
+    <property name="UUIDs" type="as" access="read" />
+    <property name="Modalias" type="s" access="read" />
+    <property name="Adapter" type="o" access="read" />
+    <property name="ManufacturerData" type="a{qv}" access="read" />
+    <property name="ServiceData" type="a{sv}" access="read" />
+    <property name="TxPower" type="n" access="read" />
+    <property name="ServicesResolved" type="b" access="read" />
+    <property name="AdvertisingFlags" type="ay" access="read" />
+    <property name="AdvertisingData" type="a{yv}" access="read" />
+    <property name="WakeAllowed" type="b" access="readwrite" />
+  </interface>
+
+  <interface name="org.bluez.GattManager1">
+    <method name="RegisterApplication">
+      <arg name="application" type="o" direction="in" />
+      <arg name="options" type="a{sv}" direction="in" />
+    </method>
+    <method name="UnregisterApplication">
+      <arg name="application" type="o" direction="in" />
+    </method>
+  </interface>
+
+  <interface name="org.bluez.GattService1">
+    <property name="UUID" type="s" access="read" />
+    <property name="Device" type="o" access="read" />
+    <property name="Primary" type="b" access="read" />
+    <!-- <property name="Includes" type="ao" access="read" /> -->
+  </interface>
+
+  <interface name="org.bluez.GattCharacteristic1">
+    <method name="ReadValue">
+      <arg name="options" type="a{sv}" direction="in"/>
+      <arg name="value" type="ay" direction="out">
+        <annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+      </arg>
+    </method>
+    <method name="WriteValue">
+      <arg name="value" type="ay" direction="in">
+        <annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+      </arg>
+      <arg name="options" type="a{sv}" direction="in"/>
+    </method>
+    <method name="AcquireWrite">
+      <arg name="options" type="a{sv}" direction="in" />
+      <arg name="fd" type="h" direction="out" />
+      <arg name="mtu" type="q" direction="out" />
+    </method>
+    <method name="AcquireNotify">
+      <arg name="options" type="a{sv}" direction="in" />
+      <arg name="fd" type="h" direction="out" />
+      <arg name="mtu" type="q" direction="out" />
+    </method>
+    <method name="StartNotify" />
+    <method name="StopNotify" />
+    <method name="Confirm" />
+    <property name="UUID" type="s" access="read" />
+    <property name="Service" type="o" access="read" />
+    <property name="Value" type="ay" access="read">
+      <annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+    </property>
+    <property name="Notifying" type="b" access="read" />
+    <property name="Flags" type="as" access="read" />
+    <property name="WriteAcquired" type="b" access="read" />
+    <property name="NotifyAcquired" type="b" access="read" />
+  </interface>
+
+  <interface name="org.bluez.GattDescriptor1">
+    <method name="ReadValue">
+      <arg name="options" type="a{sv}" direction="in"/>
+      <arg name="value" type="ay" direction="out">
+        <annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+      </arg>
+    </method>
+    <method name="WriteValue">
+      <arg name="value" type="ay" direction="in">
+        <annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+      </arg>
+      <arg name="options" type="a{sv}" direction="in"/>
+    </method>
+    <property name="UUID" type="s" access="read" />
+    <property name="Characteristic" type="o" access="read" />
+    <property name="Value" type="ay" access="read">
+      <annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+    </property>
+  </interface>
+
+  <interface name="org.bluez.LEAdvertisement1">
+    <method name="Release"/>
+    <property name="Type" type="s" access="read"/>
+    <property name="ServiceUUIDs" type="as" access="read">
+      <annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+    </property>
+    <property name="ManufacturerData" type="a{qv}" access="read"/>
+    <property name="SolicitUUIDs" type="as" access="read"/>
+    <property name="ServiceData" type="a{sv}" access="read"/>
+    <property name="Data" type="a{yay}" access="read"/>
+    <property name="Discoverable" type="b" access="read"/>
+    <property name="DiscoverableTimeout" type="q" access="read"/>
+    <property name="Includes" type="as" access="read"/>
+    <property name="LocalName" type="s" access="read"/>
+    <property name="Appearance" type="q" access="read"/>
+    <property name="Duration" type="q" access="read"/>
+    <property name="Timeout" type="q" access="read"/>
+    <!-- <property name="SecondaryChannel" type="s" access="read"/> -->
+  </interface>
+
+  <interface name="org.bluez.LEAdvertisingManager1">
+    <method name="RegisterAdvertisement">
+      <arg name="advertisement" type="o" direction="in" />
+      <arg name="options" type="a{sv}" direction="in" />
+    </method>
+    <method name="UnregisterAdvertisement">
+      <arg name="service" type="o" direction="in" />
+    </method>
+    <property name="ActiveInstances" type="y" access="read" />
+    <property name="SupportedInstances" type="y" access="read" />
+    <property name="SupportedIncludes" type="as" access="read" />
+    <property name="SupportedSecondaryChannels" type="as" access="read" />
+  </interface>
+
+  <interface name="org.freedesktop.DBus.Properties">
+    <method name="Get">
+      <arg name="interface" type="s" direction="in" />
+      <arg name="name" type="s" direction="in" />
+      <arg name="value" type="v" direction="out" />
+    </method>
+    <method name="Set">
+      <arg name="interface" type="s" direction="in" />
+      <arg name="name" type="s" direction="in" />
+      <arg name="value" type="v" direction="in" />
+    </method>
+    <method name="GetAll">
+      <arg name="interface" type="s" direction="in" />
+      <arg name="properties" type="a{sv}" direction="out" />
+    </method>
+    <signal name="PropertiesChanged">
+      <arg name="interface" type="s" />
+      <arg name="changed_properties" type="a{sv}" />
+      <arg name="invalidated_properties" type="as" />
+    </signal>
+  </interface>
+
+  <interface name="org.bluez.ProfileManager1">
+    <method name="RegisterProfile">
+      <arg name="profile" type="o" direction="in" />
+      <arg name="UUID" type="s" direction="in" />
+      <arg name="options" type="a{sv}" direction="in" />
+    </method>
+    <method name="UnregisterProfile">
+      <arg name="profile" type="o" direction="in" />
+    </method>
+  </interface>
+
+  <interface name="org.freedesktop.DBus.ObjectManager">
+    <method name="GetManagedObjects">
+      <arg name="objects" type="a{oa{sa{sv}}}" direction="out" />
+    </method>
+    <signal name="InterfacesAdded">
+      <arg name="object" type="o" />
+      <arg name="interfaces" type="a{sa{sv}}" />
+    </signal>
+    <signal name="InterfacesRemoved">
+      <arg name="object" type="o" />
+      <arg name="interfaces" type="as" />
+    </signal>
+  </interface>
+</node>
diff --git a/src/platform/webos/dbus/openthread/BUILD.gn b/src/platform/webos/dbus/openthread/BUILD.gn
new file mode 100644
index 000000000..b18b534c2
--- /dev/null
+++ b/src/platform/webos/dbus/openthread/BUILD.gn
@@ -0,0 +1,25 @@
+# Copyright (c) 2020 Project CHIP Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build_overrides/chip.gni")
+
+import("${chip_root}/build/chip/linux/gdbus_library.gni")
+
+gdbus_library("openthread") {
+  sources = [ "introspect.xml" ]
+
+  c_namespace = "Openthread"
+  c_generate_object_manager = false
+  dbus_out_dir = "platform/Linux/dbus/openthread"
+}
diff --git a/src/platform/webos/dbus/openthread/introspect.xml b/src/platform/webos/dbus/openthread/introspect.xml
new file mode 100644
index 000000000..e92b3acf4
--- /dev/null
+++ b/src/platform/webos/dbus/openthread/introspect.xml
@@ -0,0 +1,476 @@
+<?xml version="1.0"?>
+<!--
+Copyright (c) 2021 Project CHIP Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+ "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="io.openthread.BorderRouter">
+    <!-- Scan: Perform a Thread network scan.
+      @scan_result: array of scan results.
+
+      The result struture definition is:
+      <literallayout>
+        struct {
+          uint64 ext_address
+          string network_name
+          uint64 ext_panid
+          uint8[] steering_data
+          uint16 panid
+          uint16 joiner_udp_port
+          uint16 channel
+          uint16 rssi
+          uint8 lqi
+          uint8 version
+          bool is_native
+          bool is_joinable
+        }
+      </literallayout>
+    -->
+    <method name="Scan">
+      <arg name="scan_result" type="a(tstayqqqqyybb)" direction="out"/> 
+    </method>
+
+    <!-- Attach: Attach the current device to the Thread network using the current active network dataset. -->
+    <method name="Attach" />
+
+    <!-- PermitUnsecureJoin: Allow joining the network via unsecure traffic temporarily.
+      @port: The port of the unsecure traffic.
+      @timeout: The timeout for the permission.
+    -->
+    <method name="PermitUnsecureJoin">
+      <arg name="port" type="q"/>
+      <arg name="timeout" type="u"/>
+    </method>
+
+    <!-- JoinerStart: Start Thread joining.
+      @pskd: The pre-shared key for the device.
+      @provision_url: The url for further provision.
+      @vendor vendor_name: The current device vendor name.
+      @vendor vendor_model: The current device model.
+      @vendor vendor_sw_version: The current device software version.
+      @vendor vendor_data: The additional vendor data.
+    -->
+    <method name="JoinerStart">
+      <arg name="pskd" type="s"/>
+      <arg name="provision_url" type="s"/>
+      <arg name="vendor_name" type="s"/>
+      <arg name="vendor_model" type="s"/>
+      <arg name="vendor_sw_version" type="s"/>
+      <arg name="vendor_data" type="s"/>
+    </method>
+
+    <!-- JoinerStop: Stop Thread joining. -->
+    <method name="JoinerStop">
+    </method>
+
+    <!-- FactoryReset: Perform a factory reset, will wipe all Thread persistent data. -->
+    <method name="FactoryReset">
+    </method>
+
+    <!-- Reset: Perform a reset, will try to resume the network after reset. -->
+    <method name="Reset">
+    </method>
+
+    <!-- AddExternalRoute: Add an external border routing rule to the network.
+      @prefix: The prefix for border routing.
+
+      This will make the current device act as the border router for the prefix.
+      The prefix structure is:
+      <literallayout>
+        struct {
+          struct {
+            uint8[] prefix_bytes
+            uint8 prefix_length
+          }
+          uint16 rloc // Not used
+          uint8 preference
+          bool stable
+          bool next_hop_is_self // Not used
+        }
+      </literallayout>
+    -->
+    <method name="AddExternalRoute">
+      <arg name="prefix" type="((ayy)qybb)"/>
+    </method>
+
+    <!-- RemoveExternalRoute: Remove an external border routing rule from the network.
+      @prefix: The prefix for border routing.
+
+      The prefix structure is:
+      <literallayout>
+        struct {
+          uint8[] prefix_bytes
+          uint8 prefix_length
+        }
+      </literallayout>
+    -->
+    <method name="RemoveExternalRoute">
+      <arg name="prefix" type="(ayy)"/>
+    </method>
+
+    <!-- AddOnMeshPrefix: Add an on-mesh prefix to the network.
+      @prefix: The on-mesh prefix.
+
+      The on-mesh prefix structure is:
+      <literallayout>
+        struct {
+          struct {
+            uint8[] prefix_bytes
+            uint8 prefix_length
+          }
+          byte preference
+          struct {
+            boolean preferred
+            boolean slaac 
+            boolean dhcp 
+            boolean configure 
+            boolean default_route   
+            boolean on_mesh
+            boolean stable 
+          }
+        }
+      </literallayout>
+    -->
+    <method name="AddOnMeshPrefix">
+      <arg name="prefix" type="((ayy)y(bbbbbbb))"/>
+    </method>
+    
+    <!-- RemoveOnMeshPrefix: Remove an on-mesh prefix from the network.
+      @prefix: The on-mesh prefix.
+
+      The prefix structure is:
+      <literallayout>
+        struct {
+          uint8[] prefix_bytes
+          uint8 prefix_length
+        }
+      </literallayout>
+    -->
+    <method name="RemoveOnMeshPrefix">
+      <arg name="prefix" type="(ayy)"/>
+    </method>
+
+    <!-- MeshLocalPrefix: The /64 mesh-local prefix.  -->
+    <property name="MeshLocalPrefix" type="ay" access="readwrite">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- LegacyULAPrefix: The /64 legacy prefix.  -->
+    <property name="LegacyULAPrefix" type="ay" access="readwrite">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- LinkMode: The current link mode.
+      <literallayout>
+      struct {
+        bool rx_on_when_idle    //whether the radio receiving is on when idle
+        bool device_type        //ftd or mtd
+        bool network_data       //full or stable
+      }
+      </literallayout>
+    -->
+    <property name="LinkMode" type="(bbb)" access="readwrite">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- DeviceRole: The current device role.
+      Possible values are:
+      <literallayout>
+        0: Disabled
+        1: Detached
+        2: Child
+        3: Router
+        4: Leader
+      </literallayout>
+    -->
+    <property name="DeviceRole" type="s" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
+    </property>
+
+    <!-- NetworkName: The network name. -->
+    <property name="NetworkName" type="s" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- PanId: The pan ID. -->
+    <property name="PanId" type="q" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- ExtPanId: The extended pan ID. -->
+    <property name="ExtPanId" type="t" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- Channel: The current network channel, from 11 to 26 -->
+    <property name="Channel" type="q" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- CcaFailureRate: The Clear Channel Assessment failure rate. -->
+    <property name="CcaFailureRate" type="q" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- MacCounters: The mac layer statistic counters.
+      The counter structure definition:
+      <literallayout>
+        struct {
+          uint32 tx_total;
+          uint32 tx_unicast;
+          uint32 tx_broadcast;
+          uint32 tx_ack_requested;
+          uint32 tx_acked;
+          uint32 tx_no_ack_requested;
+          uint32 tx_data;
+          uint32 tx_data_poll;
+          uint32 tx_beacon;
+          uint32 tx_beacon_request;
+          uint32 tx_other;
+          uint32 tx_retry;
+          uint32 tx_err_cca;
+          uint32 tx_err_abort;
+          uint32 tx_busy_channel;
+          uint32 rx_total;
+          uint32 rx_unicast;
+          uint32 rx_broadcast;
+          uint32 rx_data;
+          uint32 rx_data_poll;
+          uint32 rx_beacon;
+          uint32 rx_beacon_request;
+          uint32 rx_other;
+          uint32 rx_address_filtered;
+          uint32 rx_dest_address_filtered;
+          uint32 rx_duplicated;
+          uint32 rx_err_no_frame;
+          uint32 rx_err_unknown_neighbor;
+          uint32 rx_err_invalid_src_addr;
+          uint32 rx_err_sec;
+          uint32 rx_err_fcs;
+          uint32 rx_err_other;
+        }
+      </literallayout>
+    -->
+    <property name="MacCounters" type="(uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu)" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- LinkCounters: The link statistic counters.
+      The counter structure definition:
+      <literallayout>
+        struct {
+          uint32 ip_tx_success;
+          uint32 ip_rx_success;
+          uint32 ip_tx_failure;
+          uint32 ip_rx_failure;
+        }
+      </literallayout>
+    -->
+    <property name="LinkCounters" type="(uuuu)" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- LinkSupportedChannelMask: The bitwise link supported channel mask -->
+    <property name="LinkSupportedChannelMask" type="u" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- Rloc16: The 16-bit routing locator -->
+    <property name="Rloc16" type="q" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- ExtendedAddress: The 64-bit extended address -->
+    <property name="ExtendedAddress" type="t" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- RouterID: The current router ID -->
+    <property name="RouterID" type="y" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- LeaderData: The network leader data.
+      The structure definition:
+      <literallayout>
+        struct {
+          uint32_t mPartitionId;       // Partition ID
+          uint8_t  mWeighting;         // Leader Weight
+          uint8_t  mDataVersion;       // Full Network Data Version
+          uint8_t  mStableDataVersion; // Stable Network Data Version
+          uint8_t  mLeaderRouterId;    // Leader Router ID
+        }
+      </literallayout>
+    -->
+    <property name="LeaderData" type="(uyyyy)" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- NetworkData: The network data. -->
+    <property name="NetworkData" type="ay" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- StableNetworkData: The stable network data. -->
+    <property name="StableNetworkData" type="ay" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- LocalLeaderWeight: The leader weight of the current node. -->
+    <property name="LocalLeaderWeight" type="y" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- ChannelMonitorSampleCount: The number of the collected samples from the channel monitor -->
+    <property name="ChannelMonitorSampleCount" type="u" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- ChannelMonitorChannelQualityMap: The channel monitor statistics data.
+      The structure definition:
+      <literallayout>
+        struct {
+          uint8_t  mChannel;
+          uint16_t mOccupancy;
+        }
+      </literallayout>
+    -->
+    <property name="ChannelMonitorChannelQualityMap" type="a(yq)" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- ChildTable: The node's child table as an array of child entry structure.
+      The child entry structure definition:
+      <literallayout>
+        struct {
+          uint64_t mExtAddress;         // IEEE 802.15.4 Extended Address
+          uint32_t mTimeout;            // Timeout
+          uint32_t mAge;                // Time last heard
+          uint16_t mRloc16;             // RLOC16
+          uint16_t mChildId;            // Child ID
+          uint8_t  mNetworkDataVersion; // Network Data Version
+          uint8_t  mLinkQualityIn;      // Link Quality In
+          int8_t   mAverageRssi;        // Average RSSI
+          int8_t   mLastRssi;           // Last observed RSSI
+          uint16_t mFrameErrorRate;     // Frame error rate (0xffff->100%). Requires error tracking feature.
+          uint16_t mMessageErrorRate;   // (IPv6) msg error rate (0xffff->100%). Requires error tracking feature.
+          bool     mRxOnWhenIdle;       // rx-on-when-idle
+          bool     mFullThreadDevice;   // Full Thread Device
+          bool     mFullNetworkData;    // Full Network Data
+          bool     mIsStateRestoring;   // Is in restoring state
+        }
+      </literallayout>
+    -->
+    <property name="ChildTable" type="a(tuuqqyyyyqqbbbb)" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- NeighborTable: The node's neighbor table as an array of neighbor entry structure.
+      The neighbor entry structure definition:
+      <literallayout>
+        struct {
+          uint64_t mExtAddress;        // IEEE 802.15.4 Extended Address
+          uint32_t mAge;               // Time last heard
+          uint16_t mRloc16;            // RLOC16
+          uint32_t mLinkFrameCounter;  // Link Frame Counter
+          uint32_t mMleFrameCounter;   // MLE Frame Counter
+          uint8_t  mLinkQualityIn;     // Link Quality In
+          int8_t   mAverageRssi;       // Average RSSI
+          int8_t   mLastRssi;          // Last observed RSSI
+          uint16_t mFrameErrorRate;    // Frame error rate (0xffff->100%). Requires error tracking feature.
+          uint16_t mMessageErrorRate;  // (IPv6) msg error rate (0xffff->100%). Requires error tracking feature.
+          bool     mRxOnWhenIdle;      // rx-on-when-idle
+          bool     mFullThreadDevice;  // Full Thread Device
+          bool     mFullNetworkData;   // Full Network Data
+          bool     mIsChild;           // Is the neighbor a child
+        }
+      </literallayout>
+    -->
+    <property name="NeighborTable" type="a(tuquuyyyqqbbbb)" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- PartitionId: The network partition ID. -->
+    <property name="PartitionId" type="u" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- InstantRssi: The RSSI of the last received packet. -->
+    <property name="InstantRssi" type="y" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- RadioTxPower: The radio transmit power. -->
+    <property name="RadioTxPower" type="y" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- ExternalRoutes: The list of current external route rules.
+      External route rule structure definition:
+      <literallayout>
+        struct {
+          struct {
+            uint8[] prefix_bytes
+            uint8 prefix_length
+          }
+          uint16 rloc
+          uint8 preference
+          bool stable
+          bool next_hop_is_self
+        }
+      </literallayout>
+    -->
+    <property name="ExternalRoutes" type="a((ayy)qybb)" access="read">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- ActiveDatasetTlvs: The Thread active dataset tlv in binary form. -->
+    <property name="ActiveDatasetTlvs" type="ay" access="readwrite">
+      <annotation name="org.gtk.GDBus.C.ForceGVariant" value="true"/>
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+
+    <!-- RadioRegion: The radio region code in ISO 3166-1. -->
+    <property name="RadioRegion" type="s" access="readwrite">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
+    </property>
+  </interface>
+
+  <interface name="org.freedesktop.DBus.Properties">
+    <method name="Get">
+      <arg name="interface" direction="in" type="s"/>
+      <arg name="property" direction="in" type="s"/>
+      <arg name="value" direction="out" type="v"/>
+    </method>
+
+    <method name="GetAll">
+      <arg name="interface" direction="in" type="s"/>
+      <arg name="properties" direction="out" type="a{sv}"/>
+    </method>
+
+    <method name="Set">
+      <arg name="interface" direction="in" type="s"/>
+      <arg name="property" direction="in" type="s"/>
+      <arg name="value" direction="in" type="v"/>
+    </method>
+
+    <signal name="PropertiesChanged">
+      <arg type="s" name="interface"/>
+      <arg type="a{sv}" name="changed_properties"/>
+      <arg type="as" name="invalidated_properties"/>
+    </signal>
+  </interface>
+</node>
diff --git a/src/platform/webos/dbus/wpa/BUILD.gn b/src/platform/webos/dbus/wpa/BUILD.gn
new file mode 100644
index 000000000..508062254
--- /dev/null
+++ b/src/platform/webos/dbus/wpa/BUILD.gn
@@ -0,0 +1,30 @@
+# Copyright (c) 2020 Project CHIP Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build_overrides/chip.gni")
+
+import("${chip_root}/build/chip/linux/gdbus_library.gni")
+
+gdbus_library("wpa") {
+  sources = [
+    "DBusWpa.xml",
+    "DBusWpaBss.xml",
+    "DBusWpaInterface.xml",
+    "DBusWpaNetwork.xml",
+  ]
+
+  c_namespace = "Wpa"
+  c_generate_object_manager = false
+  dbus_out_dir = "platform/Linux/dbus/wpa"
+}
diff --git a/src/platform/webos/dbus/wpa/DBusWpa.xml b/src/platform/webos/dbus/wpa/DBusWpa.xml
new file mode 100644
index 000000000..f43d6916e
--- /dev/null
+++ b/src/platform/webos/dbus/wpa/DBusWpa.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" ?>
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "https://raw.githubusercontent.com/freedesktop/dbus/master/doc/introspect.dtd">
+<node>
+    <interface name="fi.w1.wpa_supplicant1">
+        <method name="CreateInterface">
+            <arg name="args" type="a{sv}" direction="in" />
+            <arg name="path" type="o" direction="out" />
+        </method>
+        <method name="RemoveInterface">
+            <arg name="path" type="o" direction="in" />
+        </method>
+        <method name="GetInterface">
+            <arg name="ifname" type="s" direction="in" />
+            <arg name="path" type="o" direction="out" />
+        </method>
+        <method name="ExpectDisconnect" />
+        <signal name="InterfaceAdded">
+            <arg name="path" type="o" />
+            <arg name="properties" type="a{sv}" />
+        </signal>
+        <signal name="InterfaceRemoved">
+            <arg name="path" type="o" />
+        </signal>
+        <signal name="PropertiesChanged">
+            <arg name="properties" type="a{sv}" />
+        </signal>
+        <property name="DebugLevel" type="s" access="readwrite" />
+        <property name="DebugTimestamp" type="b" access="readwrite" />
+        <property name="DebugShowKeys" type="b" access="readwrite" />
+        <property name="Interfaces" type="ao" access="read" />
+        <property name="EapMethods" type="as" access="read" />
+        <property name="Capabilities" type="as" access="read" />
+        <property name="WFDIEs" type="ay" access="readwrite" />
+    </interface>
+    <node name="Interfaces" />
+</node>
diff --git a/src/platform/webos/dbus/wpa/DBusWpaBss.xml b/src/platform/webos/dbus/wpa/DBusWpaBss.xml
new file mode 100644
index 000000000..b6e8fee46
--- /dev/null
+++ b/src/platform/webos/dbus/wpa/DBusWpaBss.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" ?>
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "https://raw.githubusercontent.com/freedesktop/dbus/master/doc/introspect.dtd">
+<node>
+    <interface name="fi.w1.wpa_supplicant1.BSS">
+        <property name="SSID" type="ay" access="read" />
+        <property name="BSSID" type="ay" access="read" />
+        <property name="Signal" type="n" access="read" />
+        <property name="Frequency" type="q" access="read" />
+    </interface>
+</node>
diff --git a/src/platform/webos/dbus/wpa/DBusWpaInterface.xml b/src/platform/webos/dbus/wpa/DBusWpaInterface.xml
new file mode 100644
index 000000000..61b4f56ba
--- /dev/null
+++ b/src/platform/webos/dbus/wpa/DBusWpaInterface.xml
@@ -0,0 +1,265 @@
+<?xml version="1.0" ?>
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "https://raw.githubusercontent.com/freedesktop/dbus/master/doc/introspect.dtd">
+<node>
+    <interface name="fi.w1.wpa_supplicant1.Interface">
+        <method name="Scan">
+            <arg name="args" type="a{sv}" direction="in" />
+        </method>
+        <method name="SignalPoll">
+            <arg name="args" type="a{sv}" direction="out" />
+        </method>
+        <method name="Disconnect" />
+        <method name="AddNetwork">
+            <arg name="args" type="a{sv}" direction="in" />
+            <arg name="path" type="o" direction="out" />
+        </method>
+        <method name="Reassociate" />
+        <method name="Reattach" />
+        <method name="Reconnect" />
+        <method name="RemoveNetwork">
+            <arg name="path" type="o" direction="in" />
+        </method>
+        <method name="RemoveAllNetworks" />
+        <method name="SelectNetwork">
+            <arg name="path" type="o" direction="in" />
+        </method>
+        <method name="NetworkReply">
+            <arg name="path" type="o" direction="in" />
+            <arg name="field" type="s" direction="in" />
+            <arg name="value" type="s" direction="in" />
+        </method>
+        <method name="AddBlob">
+            <arg name="name" type="s" direction="in" />
+            <arg name="data" type="ay" direction="in" />
+        </method>
+        <method name="GetBlob">
+            <arg name="name" type="s" direction="in" />
+            <arg name="data" type="ay" direction="out" />
+        </method>
+        <method name="RemoveBlob">
+            <arg name="name" type="s" direction="in" />
+        </method>
+        <method name="SetPKCS11EngineAndModulePath">
+            <arg name="pkcs11_engine_path" type="s" direction="in" />
+            <arg name="pkcs11_module_path" type="s" direction="in" />
+        </method>
+        <method name="FlushBSS">
+            <arg name="age" type="u" direction="in" />
+        </method>
+        <method name="SubscribeProbeReq" />
+        <method name="UnsubscribeProbeReq" />
+        <method name="EAPLogoff" />
+        <method name="EAPLogon" />
+        <method name="AutoScan">
+            <arg name="arg" type="s" direction="in" />
+        </method>
+        <method name="TDLSDiscover">
+            <arg name="peer_address" type="s" direction="in" />
+        </method>
+        <method name="TDLSSetup">
+            <arg name="peer_address" type="s" direction="in" />
+        </method>
+        <method name="TDLSStatus">
+            <arg name="peer_address" type="s" direction="in" />
+            <arg name="status" type="s" direction="out" />
+        </method>
+        <method name="TDLSTeardown">
+            <arg name="peer_address" type="s" direction="in" />
+        </method>
+        <method name="TDLSChannelSwitch">
+            <arg name="args" type="a{sv}" direction="in" />
+        </method>
+        <method name="TDLSCancelChannelSwitch">
+            <arg name="peer_address" type="s" direction="in" />
+        </method>
+        <method name="VendorElemAdd">
+            <arg name="frame_id" type="i" direction="in" />
+            <arg name="ielems" type="ay" direction="in" />
+        </method>
+        <method name="VendorElemGet">
+            <arg name="frame_id" type="i" direction="in" />
+            <arg name="ielems" type="ay" direction="out" />
+        </method>
+        <method name="VendorElemRem">
+            <arg name="frame_id" type="i" direction="in" />
+            <arg name="ielems" type="ay" direction="in" />
+        </method>
+        <method name="SaveConfig" />
+        <method name="AbortScan" />
+        <signal name="ScanDone">
+            <arg name="success" type="b" />
+        </signal>
+        <signal name="BSSAdded">
+            <arg name="path" type="o" />
+            <arg name="properties" type="a{sv}" />
+        </signal>
+        <signal name="BSSRemoved">
+            <arg name="path" type="o" />
+        </signal>
+        <signal name="BlobAdded">
+            <arg name="name" type="s" />
+        </signal>
+        <signal name="BlobRemoved">
+            <arg name="name" type="s" />
+        </signal>
+        <signal name="NetworkAdded">
+            <arg name="path" type="o" />
+            <arg name="properties" type="a{sv}" />
+        </signal>
+        <signal name="NetworkRemoved">
+            <arg name="path" type="o" />
+        </signal>
+        <signal name="NetworkSelected">
+            <arg name="path" type="o" />
+        </signal>
+        <signal name="PropertiesChanged">
+            <arg name="properties" type="a{sv}" />
+        </signal>
+        <signal name="ProbeRequest">
+            <arg name="args" type="a{sv}" />
+        </signal>
+        <signal name="Certification">
+            <arg name="certification" type="a{sv}" />
+        </signal>
+        <signal name="EAP">
+            <arg name="status" type="s" />
+            <arg name="parameter" type="s" />
+        </signal>
+        <signal name="StaAuthorized">
+            <arg name="name" type="s" />
+        </signal>
+        <signal name="StaDeauthorized">
+            <arg name="name" type="s" />
+        </signal>
+        <signal name="StationAdded">
+            <arg name="path" type="o" />
+            <arg name="properties" type="a{sv}" />
+        </signal>
+        <signal name="StationRemoved">
+            <arg name="path" type="o" />
+        </signal>
+        <signal name="NetworkRequest">
+            <arg name="path" type="o" />
+            <arg name="field" type="s" />
+            <arg name="text" type="s" />
+        </signal>
+        <property name="Capabilities" type="a{sv}" access="read" />
+        <property name="State" type="s" access="read" />
+        <property name="Scanning" type="b" access="read" />
+        <property name="ApScan" type="u" access="readwrite" />
+        <property name="BSSExpireAge" type="u" access="readwrite" />
+        <property name="BSSExpireCount" type="u" access="readwrite" />
+        <property name="Country" type="s" access="readwrite" />
+        <property name="Ifname" type="s" access="read" />
+        <property name="Driver" type="s" access="read" />
+        <property name="BridgeIfname" type="s" access="read" />
+        <property name="ConfigFile" type="s" access="read" />
+        <property name="CurrentBSS" type="o" access="read" />
+        <property name="CurrentNetwork" type="o" access="read" />
+        <property name="CurrentAuthMode" type="s" access="read" />
+        <property name="Blobs" type="a{say}" access="read" />
+        <property name="BSSs" type="ao" access="read" />
+        <property name="Networks" type="ao" access="read" />
+        <property name="FastReauth" type="b" access="readwrite" />
+        <property name="ScanInterval" type="i" access="readwrite" />
+        <property name="PKCS11EnginePath" type="s" access="read" />
+        <property name="PKCS11ModulePath" type="s" access="read" />
+        <property name="DisconnectReason" type="i" access="read" />
+        <property name="AuthStatusCode" type="i" access="read" />
+        <property name="AssocStatusCode" type="i" access="read" />
+        <property name="RoamTime" type="u" access="read" />
+        <property name="RoamComplete" type="b" access="read" />
+        <property name="SessionLength" type="u" access="read" />
+        <property name="BSSTMStatus" type="u" access="read" />
+        <property name="Stations" type="ao" access="read" />
+        <property name="MACAddressRandomizationMask" type="a{say}" access="readwrite" />
+        <property name="CtrlInterface" type="s" access="readwrite" />
+        <property name="CtrlInterfaceGroup" type="s" access="readwrite" />
+        <property name="EapolVersion" type="s" access="readwrite" />
+        <property name="Bgscan" type="s" access="readwrite" />
+        <property name="DisableScanOffload" type="s" access="readwrite" />
+        <property name="OpenscEnginePath" type="s" access="readwrite" />
+        <property name="OpensslCiphers" type="s" access="readwrite" />
+        <property name="PcscReader" type="s" access="readwrite" />
+        <property name="PcscPin" type="s" access="readwrite" />
+        <property name="ExternalSim" type="s" access="readwrite" />
+        <property name="DriverParam" type="s" access="readwrite" />
+        <property name="Dot11RSNAConfigPMKLifetime" type="s" access="readwrite" />
+        <property name="Dot11RSNAConfigPMKReauthThreshold" type="s" access="readwrite" />
+        <property name="Dot11RSNAConfigSATimeout" type="s" access="readwrite" />
+        <property name="UpdateConfig" type="s" access="readwrite" />
+        <property name="Uuid" type="s" access="readwrite" />
+        <property name="AutoUuid" type="s" access="readwrite" />
+        <property name="DeviceName" type="s" access="readwrite" />
+        <property name="Manufacturer" type="s" access="readwrite" />
+        <property name="ModelName" type="s" access="readwrite" />
+        <property name="ModelNumber" type="s" access="readwrite" />
+        <property name="SerialNumber" type="s" access="readwrite" />
+        <property name="DeviceType" type="s" access="readwrite" />
+        <property name="OsVersion" type="s" access="readwrite" />
+        <property name="ConfigMethods" type="s" access="readwrite" />
+        <property name="SecDeviceType" type="s" access="readwrite" />
+        <property name="IpAddrGo" type="s" access="readwrite" />
+        <property name="IpAddrMask" type="s" access="readwrite" />
+        <property name="IpAddrStart" type="s" access="readwrite" />
+        <property name="IpAddrEnd" type="s" access="readwrite" />
+        <property name="BssMaxCount" type="s" access="readwrite" />
+        <property name="FilterSsids" type="s" access="readwrite" />
+        <property name="FilterRssi" type="s" access="readwrite" />
+        <property name="MaxNumSta" type="s" access="readwrite" />
+        <property name="ApIsolate" type="s" access="readwrite" />
+        <property name="DisassocLowAck" type="s" access="readwrite" />
+        <property name="Hs20" type="s" access="readwrite" />
+        <property name="Interworking" type="s" access="readwrite" />
+        <property name="Hessid" type="s" access="readwrite" />
+        <property name="AccessNetworkType" type="s" access="readwrite" />
+        <property name="GoInterworking" type="s" access="readwrite" />
+        <property name="GoAccessNetworkType" type="s" access="readwrite" />
+        <property name="GoInternet" type="s" access="readwrite" />
+        <property name="GoVenueGroup" type="s" access="readwrite" />
+        <property name="GoVenueType" type="s" access="readwrite" />
+        <property name="PbcInM1" type="s" access="readwrite" />
+        <property name="Autoscan" type="s" access="readwrite" />
+        <property name="ExtPasswordBackend" type="s" access="readwrite" />
+        <property name="AutoInterworking" type="s" access="readwrite" />
+        <property name="Okc" type="s" access="readwrite" />
+        <property name="Pmf" type="s" access="readwrite" />
+        <property name="SaeGroups" type="s" access="readwrite" />
+        <property name="SaePwe" type="s" access="readwrite" />
+        <property name="SaePmkidInAssoc" type="s" access="readwrite" />
+        <property name="DtimPeriod" type="s" access="readwrite" />
+        <property name="BeaconInt" type="s" access="readwrite" />
+        <property name="ApVendorElements" type="s" access="readwrite" />
+        <property name="IgnoreOldScanRes" type="s" access="readwrite" />
+        <property name="FreqList" type="s" access="readwrite" />
+        <property name="ScanCurFreq" type="s" access="readwrite" />
+        <property name="SchedScanInterval" type="s" access="readwrite" />
+        <property name="SchedScanStartDelay" type="s" access="readwrite" />
+        <property name="TdlsExternalControl" type="s" access="readwrite" />
+        <property name="OsuDir" type="s" access="readwrite" />
+        <property name="WowlanTriggers" type="s" access="readwrite" />
+        <property name="MacAddr" type="s" access="readwrite" />
+        <property name="RandAddrLifetime" type="s" access="readwrite" />
+        <property name="PreassocMacAddr" type="s" access="readwrite" />
+        <property name="KeyMgmtOffload" type="s" access="readwrite" />
+        <property name="PassiveScan" type="s" access="readwrite" />
+        <property name="ReassocSameBssOptim" type="s" access="readwrite" />
+        <property name="FstGroupId" type="s" access="readwrite" />
+        <property name="FstPriority" type="s" access="readwrite" />
+        <property name="FstLlt" type="s" access="readwrite" />
+        <property name="CertInCb" type="s" access="readwrite" />
+        <property name="WpaRscRelaxation" type="s" access="readwrite" />
+        <property name="SchedScanPlans" type="s" access="readwrite" />
+        <property name="GasAddress3" type="s" access="readwrite" />
+        <property name="FtmResponder" type="s" access="readwrite" />
+        <property name="FtmInitiator" type="s" access="readwrite" />
+        <property name="GasRandAddrLifetime" type="s" access="readwrite" />
+        <property name="GasRandMacAddr" type="s" access="readwrite" />
+        <property name="DppConfigProcessing" type="s" access="readwrite" />
+        <property name="DppName" type="s" access="readwrite" />
+        <property name="DppMudUrl" type="s" access="readwrite" />
+        <property name="ColocIntfReporting" type="s" access="readwrite" />
+    </interface>
+    <node name="BSSs" />
+    <node name="Networks" />
+</node>
diff --git a/src/platform/webos/dbus/wpa/DBusWpaNetwork.xml b/src/platform/webos/dbus/wpa/DBusWpaNetwork.xml
new file mode 100644
index 000000000..1b0ea70f4
--- /dev/null
+++ b/src/platform/webos/dbus/wpa/DBusWpaNetwork.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" ?>
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "https://raw.githubusercontent.com/freedesktop/dbus/master/doc/introspect.dtd">
+<node>
+    <interface name="fi.w1.wpa_supplicant1.Network">
+        <signal name="PropertiesChanged">
+            <arg name="properties" type="a{sv}" />
+        </signal>
+        <property name="Properties" type="a{sv}" access="readwrite" />
+        <property name="Enabled" type="b" access="readwrite" />
+    </interface>
+</node>
-- 
2.17.1

