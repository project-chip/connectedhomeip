// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
}

struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
}

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
server cluster Identify = 3 {
  enum IdentifyEffectIdentifier : ENUM8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum IdentifyEffectVariant : ENUM8 {
    kDefault = 0;
  }

  enum IdentifyIdentifyType : ENUM8 {
    kNone = 0;
    kVisibleLight = 1;
    kVisibleLED = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute enum8 identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    INT16U identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    IdentifyEffectIdentifier effectIdentifier = 0;
    IdentifyEffectVariant effectVariant = 1;
  }

  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
server cluster Descriptor = 29 {
  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute CLUSTER_ID serverList[] = 1;
  readonly attribute CLUSTER_ID clientList[] = 2;
  readonly attribute ENDPOINT_NO partsList[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
server cluster AccessControl = 31 {
  enum AccessControlEntryAuthModeEnum : ENUM8 {
    kPase = 1;
    kCase = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : ENUM8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum ChangeTypeEnum : ENUM8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  struct Target {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive Target targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
server cluster BasicInformation = 40 {
  enum ColorEnum : ENUM8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : ENUM8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    INT32U softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
server cluster GeneralCommissioning = 48 {
  enum CommissioningError : ENUM8 {
    kOk = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationType : ENUM8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationType regulatoryConfig = 2;
  readonly attribute RegulatoryLocationType locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    INT16U expiryLengthSeconds = 0;
    INT64U breadcrumb = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationType newRegulatoryConfig = 0;
    CHAR_STRING countryCode = 1;
    INT64U breadcrumb = 2;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
server cluster NetworkCommissioning = 49 {
  enum NetworkCommissioningStatus : ENUM8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBand : ENUM8 {
    k2g4 = 0;
    k3g65 = 1;
    k5g = 2;
    k6g = 3;
    k60g = 4;
    k1g = 5;
  }

  bitmap Feature : BITMAP32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
  }

  bitmap WiFiSecurity : BITMAP8 {
    kUnencrypted = 0x1;
    kWep = 0x2;
    kWpaPersonal = 0x4;
    kWpa2Personal = 0x8;
    kWpa3Personal = 0x10;
  }

  struct NetworkInfo {
    octet_string<32> networkID = 0;
    boolean connected = 1;
  }

  struct ThreadInterfaceScanResult {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResult {
    WiFiSecurity security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBand wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfo networks[] = 1;
  readonly attribute int8u scanMaxTimeSeconds = 2;
  readonly attribute int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatus lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable OCTET_STRING<32> ssid = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    OCTET_STRING<254> operationalDataset = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ConnectNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ReorderNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    INT8U networkIndex = 1;
    optional INT64U breadcrumb = 2;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    optional WiFiInterfaceScanResult wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResult threadScanResults[] = 3;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING<512> debugText = 1;
    optional INT8U networkIndex = 2;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    nullable INT32S errorValue = 2;
  }

  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster GeneralDiagnostics = 51 {
  enum BootReasonEnum : ENUM8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : ENUM8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : ENUM8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : ENUM8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : ENUM8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    OCTET_STRING<16> enableKey = 0;
    INT64U eventTrigger = 1;
  }

  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster SoftwareDiagnostics = 52 {
  bitmap Feature : BITMAP32 {
    kWaterMarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    INT64U id = 0;
    optional CHAR_STRING name = 1;
    optional OCTET_STRING faultRecording = 2;
  }

  readonly attribute ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute int64u currentHeapFree = 1;
  readonly attribute int64u currentHeapUsed = 2;
  readonly attribute int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command ResetWatermarks(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
server cluster ThreadNetworkDiagnostics = 53 {
  enum ConnectionStatusEnum : ENUM8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFault : ENUM8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRole : ENUM8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kReed = 4;
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : BITMAP32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTable {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTable {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFault current[] = 0;
    NetworkFault previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRole routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute int64u overrunCount = 6;
  readonly attribute NeighborTable neighborTable[] = 7;
  readonly attribute RouteTable routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int8u weighting = 10;
  readonly attribute nullable int8u dataVersion = 11;
  readonly attribute nullable int8u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute int16u detachedRoleCount = 14;
  readonly attribute int16u childRoleCount = 15;
  readonly attribute int16u routerRoleCount = 16;
  readonly attribute int16u leaderRoleCount = 17;
  readonly attribute int16u attachAttemptCount = 18;
  readonly attribute int16u partitionIdChangeCount = 19;
  readonly attribute int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute int16u parentChangeCount = 21;
  readonly attribute int32u txTotalCount = 22;
  readonly attribute int32u txUnicastCount = 23;
  readonly attribute int32u txBroadcastCount = 24;
  readonly attribute int32u txAckRequestedCount = 25;
  readonly attribute int32u txAckedCount = 26;
  readonly attribute int32u txNoAckRequestedCount = 27;
  readonly attribute int32u txDataCount = 28;
  readonly attribute int32u txDataPollCount = 29;
  readonly attribute int32u txBeaconCount = 30;
  readonly attribute int32u txBeaconRequestCount = 31;
  readonly attribute int32u txOtherCount = 32;
  readonly attribute int32u txRetryCount = 33;
  readonly attribute int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute int32u txErrCcaCount = 36;
  readonly attribute int32u txErrAbortCount = 37;
  readonly attribute int32u txErrBusyChannelCount = 38;
  readonly attribute int32u rxTotalCount = 39;
  readonly attribute int32u rxUnicastCount = 40;
  readonly attribute int32u rxBroadcastCount = 41;
  readonly attribute int32u rxDataCount = 42;
  readonly attribute int32u rxDataPollCount = 43;
  readonly attribute int32u rxBeaconCount = 44;
  readonly attribute int32u rxBeaconRequestCount = 45;
  readonly attribute int32u rxOtherCount = 46;
  readonly attribute int32u rxAddressFilteredCount = 47;
  readonly attribute int32u rxDestAddrFilteredCount = 48;
  readonly attribute int32u rxDuplicatedCount = 49;
  readonly attribute int32u rxErrNoFrameCount = 50;
  readonly attribute int32u rxErrUnknownNeighborCount = 51;
  readonly attribute int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute int32u rxErrSecCount = 53;
  readonly attribute int32u rxErrFcsCount = 54;
  readonly attribute int32u rxErrOtherCount = 55;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFault activeNetworkFaultsList[] = 62;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command ResetCounts(): DefaultSuccess = 0;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
server cluster AdministratorCommissioning = 60 {
  enum CommissioningWindowStatusEnum : ENUM8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : ENUM8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable int16u adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
    OCTET_STRING PAKEPasscodeVerifier = 1;
    INT16U discriminator = 2;
    INT32U iterations = 3;
    OCTET_STRING salt = 4;
  }

  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
server cluster OperationalCredentials = 62 {
  enum CertificateChainTypeEnum : ENUM8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : ENUM8 {
    kOk = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute OCTET_STRING trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    OCTET_STRING attestationNonce = 0;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  request struct CSRRequestRequest {
    OCTET_STRING CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  request struct AddNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
    OCTET_STRING IPKValue = 2;
    Int64u caseAdminSubject = 3;
    VENDOR_ID adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
  }

  request struct UpdateFabricLabelRequest {
    CHAR_STRING<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    OCTET_STRING rootCACertificate = 0;
  }

  response struct AttestationResponse = 1 {
    OCTET_STRING attestationElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  response struct CertificateChainResponse = 3 {
    OCTET_STRING certificate = 0;
  }

  response struct CSRResponse = 5 {
    OCTET_STRING NOCSRElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional CHAR_STRING debugText = 2;
  }

  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
server cluster GroupKeyManagement = 63 {
  enum GroupKeySecurityPolicyEnum : ENUM8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetRemoveRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetReadAllIndicesRequest {
    INT16U groupKeySetIDs[] = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    INT16U groupKeySetIDs[] = 0;
  }

  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  fabric command access(invoke: administer) KeySetReadAllIndices(KeySetReadAllIndicesRequest): KeySetReadAllIndicesResponse = 4;
}

/** An interface to a generic way to secure a door */
server cluster DoorLock = 257 {
  enum AlarmCodeEnum : ENUM8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : ENUM8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : ENUM8 {
    kProgrammingPIN = 0;
    kPin = 1;
    kRfid = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
  }

  enum DataOperationTypeEnum : ENUM8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : ENUM8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : ENUM8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : ENUM8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : ENUM8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : ENUM8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : ENUM8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : ENUM8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : ENUM8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : ENUM8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : ENUM8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPin = 6;
    kRfid = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
  }

  enum LockOperationTypeEnum : ENUM8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : ENUM8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : ENUM8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : ENUM8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRfid = 8;
    kBiometric = 9;
  }

  enum UserStatusEnum : ENUM8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : ENUM8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : BITMAP8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : BITMAP8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : BITMAP8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : BITMAP16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : BITMAP8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : BITMAP16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : BITMAP8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : BITMAP32 {
    kPinCredential = 0x1;
    kRfidCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable INT16U userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable NODE_ID sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable INT16U userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable NODE_ID sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable INT16U userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable NODE_ID sourceNode = 5;
    nullable INT16U dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute int16u numberOfTotalUsersSupported = 17;
  readonly attribute DlCredentialRuleMask credentialRulesSupport = 27;
  attribute access(write: manage) int32u autoRelockTime = 35;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  attribute access(write: administer) int16u expiringUserTimeout = 53;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional OCTET_STRING PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional OCTET_STRING PINCode = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    INT16U userIndex = 1;
    nullable CHAR_STRING userName = 2;
    nullable INT32U userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    INT16U userIndex = 0;
  }

  request struct ClearUserRequest {
    INT16U userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    LONG_OCTET_STRING credentialData = 2;
    nullable INT16U userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  response struct GetUserResponse = 28 {
    INT16U userIndex = 0;
    nullable CHAR_STRING userName = 1;
    nullable INT32U userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable INT16U nextUserIndex = 9;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable INT16U userIndex = 1;
    nullable INT16U nextCredentialIndex = 2;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable INT16U userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable INT16U nextCredentialIndex = 4;
  }

  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
}

endpoint 0 {
  device type rootdevice = 22, version 1;

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    emits event AccessControlExtensionChanged;
    callback attribute acl;
    callback attribute subjectsPerAccessControlEntry default = 4;
    callback attribute targetsPerAccessControlEntry default = 3;
    callback attribute accessControlEntriesPerFabric default = 3;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    callback attribute dataModelRevision default = 10;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location default = "XX";
    callback attribute hardwareVersion default = 0;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion default = 0;
    callback attribute softwareVersionString;
    callback attribute capabilityMinima;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig default = 0;
    callback attribute locationCapability default = 0;
    callback attribute supportsConcurrentConnection default = 1;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    ram      attribute featureMap default = 2;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralDiagnostics {
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount default = 0x0000;
    callback attribute testEventTriggersEnabled default = false;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster SoftwareDiagnostics {
    callback attribute threadMetrics;
    callback attribute currentHeapFree default = 0x0000000000000000;
    callback attribute currentHeapUsed default = 0x0000000000000000;
    callback attribute currentHeapHighWatermark default = 0x0000000000000000;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ThreadNetworkDiagnostics {
    callback attribute channel;
    callback attribute routingRole;
    callback attribute networkName default = "0";
    callback attribute panId default = 0x0000;
    callback attribute extendedPanId default = 0x0000000000000000;
    callback attribute meshLocalPrefix;
    callback attribute overrunCount default = 0x0000000000000000;
    callback attribute neighborTable;
    callback attribute routeTable;
    callback attribute partitionId;
    callback attribute weighting;
    callback attribute dataVersion;
    callback attribute stableDataVersion;
    callback attribute leaderRouterId;
    callback attribute detachedRoleCount default = 0x0000;
    callback attribute childRoleCount default = 0x0000;
    callback attribute routerRoleCount default = 0x0000;
    callback attribute leaderRoleCount default = 0x0000;
    callback attribute attachAttemptCount default = 0x0000;
    callback attribute partitionIdChangeCount default = 0x0000;
    callback attribute betterPartitionAttachAttemptCount default = 0x0000;
    callback attribute parentChangeCount default = 0x0000;
    callback attribute txTotalCount default = 0x0000;
    callback attribute txUnicastCount default = 0x0000;
    callback attribute txBroadcastCount default = 0x0000;
    callback attribute txAckRequestedCount default = 0x0000;
    callback attribute txAckedCount default = 0x0000;
    callback attribute txNoAckRequestedCount default = 0x0000;
    callback attribute txDataCount default = 0x0000;
    callback attribute txDataPollCount default = 0x0000;
    callback attribute txBeaconCount default = 0x0000;
    callback attribute txBeaconRequestCount default = 0x0000;
    callback attribute txOtherCount default = 0x0000;
    callback attribute txRetryCount default = 0x0000;
    callback attribute txDirectMaxRetryExpiryCount default = 0x0000;
    callback attribute txIndirectMaxRetryExpiryCount default = 0x0000;
    callback attribute txErrCcaCount default = 0x0000;
    callback attribute txErrAbortCount default = 0x0000;
    callback attribute txErrBusyChannelCount default = 0x0000;
    callback attribute rxTotalCount default = 0x0000;
    callback attribute rxUnicastCount default = 0x0000;
    callback attribute rxBroadcastCount default = 0x0000;
    callback attribute rxDataCount default = 0x0000;
    callback attribute rxDataPollCount default = 0x0000;
    callback attribute rxBeaconCount default = 0x0000;
    callback attribute rxBeaconRequestCount default = 0x0000;
    callback attribute rxOtherCount default = 0x0000;
    callback attribute rxAddressFilteredCount default = 0x0000;
    callback attribute rxDestAddrFilteredCount default = 0x0000;
    callback attribute rxDuplicatedCount default = 0x0000;
    callback attribute rxErrNoFrameCount default = 0x0000;
    callback attribute rxErrUnknownNeighborCount default = 0x0000;
    callback attribute rxErrInvalidSrcAddrCount default = 0x0000;
    callback attribute rxErrSecCount default = 0x0000;
    callback attribute rxErrFcsCount default = 0x0000;
    callback attribute rxErrOtherCount default = 0x0000;
    callback attribute securityPolicy;
    callback attribute channelPage0Mask default = "0x0000";
    callback attribute operationalDatasetComponents;
    callback attribute activeNetworkFaultsList;
    ram      attribute featureMap default = 0x000F;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus default = 0;
    callback attribute adminFabricIndex default = 1;
    callback attribute adminVendorId default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 1 {
  device type anonymousEndpointType = 10, version 1;

  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster DoorLock {
    emits event DoorLockAlarm;
    emits event LockOperation;
    emits event LockOperationError;
    emits event LockUserChange;
    ram      attribute lockState;
    ram      attribute lockType;
    ram      attribute actuatorEnabled;
    ram      attribute numberOfTotalUsersSupported default = 0;
    ram      attribute credentialRulesSupport default = 1;
    ram      attribute autoRelockTime;
    ram      attribute operatingMode;
    ram      attribute supportedOperatingModes default = 0xFFF6;
    ram      attribute expiringUserTimeout default = 1440;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x1000;
    ram      attribute clusterRevision default = 6;
  }
}


