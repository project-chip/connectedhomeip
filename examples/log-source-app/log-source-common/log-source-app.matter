// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
cluster AccessControl = 31 {
  revision 1; // NOTE: Default/not specifically set

  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1;
    kCASE = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
cluster GeneralCommissioning = 48 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningErrorEnum : enum8 {
    kOK = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string<128> debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string<2> countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  /** Arm the persistent fail-safe timer with an expiry time of now + ExpiryLengthSeconds using device clock */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** Set the regulatory configuration to be used during commissioning */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** Signals the Server that the Client has successfully completed all steps of Commissioning/Recofiguration needed during fail-safe period. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
cluster NetworkCommissioning = 49 {
  revision 1; // NOTE: Default/not specifically set

  enum NetworkCommissioningStatusEnum : enum8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBandEnum : enum8 {
    k2G4 = 0;
    k3G65 = 1;
    k5G = 2;
    k6G = 3;
    k60G = 4;
    k1G = 5;
  }

  bitmap Feature : bitmap32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
    kPerDeviceCredentials = 0x8;
  }

  bitmap ThreadCapabilitiesBitmap : bitmap16 {
    kIsBorderRouterCapable = 0x1;
    kIsRouterCapable = 0x2;
    kIsSleepyEndDeviceCapable = 0x4;
    kIsFullThreadDevice = 0x8;
    kIsSynchronizedSleepyEndDeviceCapable = 0x10;
  }

  bitmap WiFiSecurityBitmap : bitmap8 {
    kUnencrypted = 0x1;
    kWEP = 0x2;
    kWPAPersonal = 0x4;
    kWPA2Personal = 0x8;
    kWPA3Personal = 0x10;
    kWPA3MatterPDC = 0x20;
  }

  struct NetworkInfoStruct {
    octet_string<32> networkID = 0;
    boolean connected = 1;
    optional nullable octet_string<20> networkIdentifier = 2;
    optional nullable octet_string<20> clientIdentifier = 3;
  }

  struct ThreadInterfaceScanResultStruct {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResultStruct {
    WiFiSecurityBitmap security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBandEnum wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfoStruct networks[] = 1;
  readonly attribute optional int8u scanMaxTimeSeconds = 2;
  readonly attribute optional int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatusEnum lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  provisional readonly attribute optional WiFiBandEnum supportedWiFiBands[] = 8;
  provisional readonly attribute optional ThreadCapabilitiesBitmap supportedThreadFeatures = 9;
  provisional readonly attribute optional int16u threadVersion = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable octet_string<32> ssid = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    optional WiFiInterfaceScanResultStruct wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResultStruct threadScanResults[] = 3;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    octet_string<32> ssid = 0;
    octet_string<64> credentials = 1;
    optional int64u breadcrumb = 2;
    optional octet_string<140> networkIdentity = 3;
    optional octet_string<20> clientIdentifier = 4;
    optional octet_string<32> possessionNonce = 5;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    octet_string<254> operationalDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string<512> debugText = 1;
    optional int8u networkIndex = 2;
    optional octet_string<140> clientIdentity = 3;
    optional octet_string<64> possessionSignature = 4;
  }

  request struct ConnectNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    nullable int32s errorValue = 2;
  }

  request struct ReorderNetworkRequest {
    octet_string<32> networkID = 0;
    int8u networkIndex = 1;
    optional int64u breadcrumb = 2;
  }

  request struct QueryIdentityRequest {
    octet_string<20> keyIdentifier = 0;
    optional octet_string<32> possessionNonce = 1;
  }

  response struct QueryIdentityResponse = 10 {
    octet_string<140> identity = 0;
    optional octet_string<64> possessionSignature = 1;
  }

  /** Detemine the set of networks the device sees as available. */
  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  /** Add or update the credentials for a given Wi-Fi network. */
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  /** Add or update the credentials for a given Thread network. */
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  /** Remove the definition of a given network (including its credentials). */
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  /** Connect to the specified network, using previously-defined credentials. */
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  /** Modify the order in which networks will be presented in the Networks attribute. */
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
  /** Retrieve details about and optionally proof of possession of a network client identity. */
  command access(invoke: administer) QueryIdentity(QueryIdentityRequest): QueryIdentityResponse = 9;
}

/** The cluster provides commands for retrieving unstructured diagnostic logs from a Node that may be used to aid in diagnostics. */
cluster DiagnosticLogs = 50 {
  revision 1; // NOTE: Default/not specifically set

  enum IntentEnum : enum8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : enum8 {
    kResponsePayload = 0;
    kBDX = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional char_string<32> transferFileDesignator = 2;
  }

  response struct RetrieveLogsResponse = 1 {
    StatusEnum status = 0;
    long_octet_string logContent = 1;
    optional epoch_us UTCTimeStamp = 2;
    optional systime_us timeSinceBoot = 3;
  }

  /** Retrieving diagnostic logs from a Node */
  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
cluster OperationalCredentials = 62 {
  revision 1; // NOTE: Default/not specifically set

  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string<900> attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string attestationSignature = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string NOCValue = 0;
    optional octet_string ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string rootCACertificate = 0;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** Sender is requesting to update the node operational certificates. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

endpoint 0 {
  device type ma_all_clusters_app = 4293984259, version 1;


  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    emits event AccessControlExtensionChanged;
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry;
    callback attribute targetsPerAccessControlEntry;
    callback attribute accessControlEntriesPerFabric;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute supportsConcurrentConnection;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command ArmFailSafe;
    handle command ArmFailSafeResponse;
    handle command SetRegulatoryConfig;
    handle command SetRegulatoryConfigResponse;
    handle command CommissioningComplete;
    handle command CommissioningCompleteResponse;
  }

  server cluster NetworkCommissioning {
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }

  server cluster DiagnosticLogs {
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command RetrieveLogsRequest;
    handle command RetrieveLogsResponse;
  }

  server cluster OperationalCredentials {
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AttestationRequest;
    handle command AttestationResponse;
    handle command CertificateChainRequest;
    handle command CertificateChainResponse;
    handle command CSRRequest;
    handle command CSRResponse;
    handle command AddNOC;
    handle command NOCResponse;
    handle command UpdateFabricLabel;
    handle command RemoveFabric;
    handle command AddTrustedRootCertificate;
  }
}


