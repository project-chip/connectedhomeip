// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
cluster Identify = 3 {
  revision 4;

  enum EffectIdentifierEnum : enum8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum EffectVariantEnum : enum8 {
    kDefault = 0;
  }

  enum IdentifyTypeEnum : enum8 {
    kNone = 0;
    kLightOutput = 1;
    kVisibleIndicator = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute IdentifyTypeEnum identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    int16u identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    EffectVariantEnum effectVariant = 1;
  }

  /** Command description for Identify */
  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  /** Command description for TriggerEffect */
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** Attributes and commands for group configuration and manipulation. */
cluster Groups = 4 {
  revision 4;

  bitmap Feature : bitmap32 {
    kGroupNames = 0x1;
  }

  bitmap NameSupportBitmap : bitmap8 {
    kGroupNames = 0x80;
  }

  readonly attribute NameSupportBitmap nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  response struct ViewGroupResponse = 1 {
    enum8 status = 0;
    group_id groupID = 1;
    char_string<16> groupName = 2;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable int8u capacity = 0;
    group_id groupList[] = 1;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  response struct RemoveGroupResponse = 3 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  /** Command description for AddGroup */
  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  /** Command description for ViewGroup */
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  /** Command description for GetGroupMembership */
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  /** Command description for RemoveGroup */
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  /** Command description for RemoveAllGroups */
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  /** Command description for AddGroupIfIdentifying */
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
cluster Descriptor = 29 {
  revision 2;

  bitmap Feature : bitmap32 {
    kTagList = 0x1;
  }

  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  struct SemanticTagStruct {
    nullable vendor_id mfgCode = 0;
    enum8 namespaceID = 1;
    enum8 tag = 2;
    optional nullable char_string label = 3;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute cluster_id serverList[] = 1;
  readonly attribute cluster_id clientList[] = 2;
  readonly attribute endpoint_no partsList[] = 3;
  readonly attribute optional SemanticTagStruct tagList[] = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
cluster AccessControl = 31 {
  revision 1; // NOTE: Default/not specifically set

  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1;
    kCASE = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
cluster BasicInformation = 40 {
  revision 3;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  attribute access(write: manage) optional boolean localConfigDisabled = 16;
  readonly attribute optional boolean reachable = 17;
  readonly attribute optional char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute int32u specificationVersion = 21;
  readonly attribute int16u maxPathsPerInvoke = 22;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command MfgSpecificPing(): DefaultSuccess = 0;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
cluster GeneralCommissioning = 48 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningErrorEnum : enum8 {
    kOK = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string<128> debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string<2> countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  /** Arm the persistent fail-safe timer with an expiry time of now + ExpiryLengthSeconds using device clock */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** Set the regulatory configuration to be used during commissioning */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** Signals the Server that the Client has successfully completed all steps of Commissioning/Recofiguration needed during fail-safe period. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
cluster NetworkCommissioning = 49 {
  revision 1; // NOTE: Default/not specifically set

  enum NetworkCommissioningStatusEnum : enum8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBandEnum : enum8 {
    k2G4 = 0;
    k3G65 = 1;
    k5G = 2;
    k6G = 3;
    k60G = 4;
    k1G = 5;
  }

  bitmap Feature : bitmap32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
    kPerDeviceCredentials = 0x8;
  }

  bitmap ThreadCapabilitiesBitmap : bitmap16 {
    kIsBorderRouterCapable = 0x1;
    kIsRouterCapable = 0x2;
    kIsSleepyEndDeviceCapable = 0x4;
    kIsFullThreadDevice = 0x8;
    kIsSynchronizedSleepyEndDeviceCapable = 0x10;
  }

  bitmap WiFiSecurityBitmap : bitmap8 {
    kUnencrypted = 0x1;
    kWEP = 0x2;
    kWPAPersonal = 0x4;
    kWPA2Personal = 0x8;
    kWPA3Personal = 0x10;
    kWPA3MatterPDC = 0x20;
  }

  struct NetworkInfoStruct {
    octet_string<32> networkID = 0;
    boolean connected = 1;
    optional nullable octet_string<20> networkIdentifier = 2;
    optional nullable octet_string<20> clientIdentifier = 3;
  }

  struct ThreadInterfaceScanResultStruct {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResultStruct {
    WiFiSecurityBitmap security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBandEnum wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfoStruct networks[] = 1;
  readonly attribute optional int8u scanMaxTimeSeconds = 2;
  readonly attribute optional int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatusEnum lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute optional WiFiBandEnum supportedWiFiBands[] = 8;
  readonly attribute optional ThreadCapabilitiesBitmap supportedThreadFeatures = 9;
  readonly attribute optional int16u threadVersion = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable octet_string<32> ssid = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    optional WiFiInterfaceScanResultStruct wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResultStruct threadScanResults[] = 3;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    octet_string<32> ssid = 0;
    octet_string<64> credentials = 1;
    optional int64u breadcrumb = 2;
    optional octet_string<140> networkIdentity = 3;
    optional octet_string<20> clientIdentifier = 4;
    optional octet_string<32> possessionNonce = 5;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    octet_string<254> operationalDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string<512> debugText = 1;
    optional int8u networkIndex = 2;
    optional octet_string<140> clientIdentity = 3;
    optional octet_string<64> possessionSignature = 4;
  }

  request struct ConnectNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    nullable int32s errorValue = 2;
  }

  request struct ReorderNetworkRequest {
    octet_string<32> networkID = 0;
    int8u networkIndex = 1;
    optional int64u breadcrumb = 2;
  }

  request struct QueryIdentityRequest {
    octet_string<20> keyIdentifier = 0;
    optional octet_string<32> possessionNonce = 1;
  }

  response struct QueryIdentityResponse = 10 {
    octet_string<140> identity = 0;
    optional octet_string<64> possessionSignature = 1;
  }

  /** Detemine the set of networks the device sees as available. */
  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  /** Add or update the credentials for a given Wi-Fi network. */
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  /** Add or update the credentials for a given Thread network. */
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  /** Remove the definition of a given network (including its credentials). */
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  /** Connect to the specified network, using previously-defined credentials. */
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  /** Modify the order in which networks will be presented in the Networks attribute. */
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
  /** Retrieve details about and optionally proof of possession of a network client identity. */
  command access(invoke: administer) QueryIdentity(QueryIdentityRequest): QueryIdentityResponse = 9;
}

/** The cluster provides commands for retrieving unstructured diagnostic logs from a Node that may be used to aid in diagnostics. */
cluster DiagnosticLogs = 50 {
  revision 1; // NOTE: Default/not specifically set

  enum IntentEnum : enum8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : enum8 {
    kResponsePayload = 0;
    kBDX = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional char_string<32> transferFileDesignator = 2;
  }

  response struct RetrieveLogsResponse = 1 {
    StatusEnum status = 0;
    long_octet_string logContent = 1;
    optional epoch_us UTCTimeStamp = 2;
    optional systime_us timeSinceBoot = 3;
  }

  /** Retrieving diagnostic logs from a Node */
  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster GeneralDiagnostics = 51 {
  revision 2;

  enum BootReasonEnum : enum8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : enum8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : enum8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : enum8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  bitmap Feature : bitmap32 {
    kDataModelTest = 0x1;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute optional int64u upTime = 2;
  readonly attribute optional int32u totalOperationalHours = 3;
  readonly attribute optional BootReasonEnum bootReason = 4;
  readonly attribute optional HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute optional RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute optional NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    octet_string<16> enableKey = 0;
    int64u eventTrigger = 1;
  }

  response struct TimeSnapshotResponse = 2 {
    systime_ms systemTimeMs = 0;
    nullable posix_ms posixTimeMs = 1;
  }

  request struct PayloadTestRequestRequest {
    octet_string<16> enableKey = 0;
    int8u value = 1;
    int16u count = 2;
  }

  response struct PayloadTestResponse = 4 {
    octet_string payload = 0;
  }

  /** Provide a means for certification tests to trigger some test-plan-specific events */
  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
  /** Take a snapshot of system time and epoch time. */
  command TimeSnapshot(): TimeSnapshotResponse = 1;
  /** Request a variable length payload response. */
  command PayloadTestRequest(PayloadTestRequestRequest): PayloadTestResponse = 3;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
cluster AdministratorCommissioning = 60 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningWindowStatusEnum : enum8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : enum8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  bitmap Feature : bitmap32 {
    kBasic = 0x1;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable vendor_id adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
    octet_string PAKEPasscodeVerifier = 1;
    int16u discriminator = 2;
    int32u iterations = 3;
    octet_string<32> salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
  }

  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using enhanced commissioning method. */
  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using basic commissioning method, if the node supports it. */
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  /** This command is used by a current Administrator to instruct a Node to revoke any active Open Commissioning Window or Open Basic Commissioning Window command. */
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
cluster OperationalCredentials = 62 {
  revision 1; // NOTE: Default/not specifically set

  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string<900> attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string attestationSignature = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string NOCValue = 0;
    optional octet_string ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string rootCACertificate = 0;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** Sender is requesting to update the node operational certificates. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
cluster GroupKeyManagement = 63 {
  revision 1; // NOTE: Default/not specifically set

  enum GroupKeySecurityPolicyEnum : enum8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  bitmap Feature : bitmap32 {
    kCacheAndSync = 0x1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetRemoveRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    int16u groupKeySetIDs[] = 0;
  }

  /** Write a new set of keys for the given key set id. */
  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  /** Read the keys for a given key set id. */
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  /** Revoke a Root Key from a Group */
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  /** Return the list of Group Key Sets associated with the accessing fabric */
  fabric command access(invoke: administer) KeySetReadAllIndices(): KeySetReadAllIndicesResponse = 4;
}

/** Attributes for reporting air quality classification */
cluster AirQuality = 91 {
  revision 1; // NOTE: Default/not specifically set

  enum AirQualityEnum : enum8 {
    kUnknown = 0;
    kGood = 1;
    kFair = 2;
    kModerate = 3;
    kPoor = 4;
    kVeryPoor = 5;
    kExtremelyPoor = 6;
  }

  bitmap Feature : bitmap32 {
    kFair = 0x1;
    kModerate = 0x2;
    kVeryPoor = 0x4;
    kExtremelyPoor = 0x8;
  }

  readonly attribute AirQualityEnum airQuality = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for monitoring HEPA filters in a device */
cluster HepaFilterMonitoring = 113 {
  revision 1; // NOTE: Default/not specifically set

  enum ChangeIndicationEnum : enum8 {
    kOK = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum ProductIdentifierTypeEnum : enum8 {
    kUPC = 0;
    kGTIN8 = 1;
    kEAN = 2;
    kGTIN14 = 3;
    kOEM = 4;
  }

  bitmap Feature : bitmap32 {
    kCondition = 0x1;
    kWarning = 0x2;
    kReplacementProductList = 0x4;
  }

  struct ReplacementProductStruct {
    ProductIdentifierTypeEnum productIdentifierType = 0;
    char_string<20> productIdentifierValue = 1;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  attribute optional nullable epoch_s lastChangedTime = 4;
  readonly attribute optional ReplacementProductStruct replacementProductList[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring activated carbon filters in a device */
cluster ActivatedCarbonFilterMonitoring = 114 {
  revision 1; // NOTE: Default/not specifically set

  enum ChangeIndicationEnum : enum8 {
    kOK = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum ProductIdentifierTypeEnum : enum8 {
    kUPC = 0;
    kGTIN8 = 1;
    kEAN = 2;
    kGTIN14 = 3;
    kOEM = 4;
  }

  bitmap Feature : bitmap32 {
    kCondition = 0x1;
    kWarning = 0x2;
    kReplacementProductList = 0x4;
  }

  struct ReplacementProductStruct {
    ProductIdentifierTypeEnum productIdentifierType = 0;
    char_string<20> productIdentifierValue = 1;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  attribute optional nullable epoch_s lastChangedTime = 4;
  readonly attribute optional ReplacementProductStruct replacementProductList[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** An interface for configuring and controlling the functionality of a thermostat. */
cluster Thermostat = 513 {
  revision 6;

  enum ACCapacityFormatEnum : enum8 {
    kBTUh = 0;
  }

  enum ACCompressorTypeEnum : enum8 {
    kUnknown = 0;
    kT1 = 1;
    kT2 = 2;
    kT3 = 3;
  }

  enum ACLouverPositionEnum : enum8 {
    kClosed = 1;
    kOpen = 2;
    kQuarter = 3;
    kHalf = 4;
    kThreeQuarters = 5;
  }

  enum ACRefrigerantTypeEnum : enum8 {
    kUnknown = 0;
    kR22 = 1;
    kR410a = 2;
    kR407c = 3;
  }

  enum ACTypeEnum : enum8 {
    kUnknown = 0;
    kCoolingFixed = 1;
    kHeatPumpFixed = 2;
    kCoolingInverter = 3;
    kHeatPumpInverter = 4;
  }

  enum ControlSequenceOfOperationEnum : enum8 {
    kCoolingOnly = 0;
    kCoolingWithReheat = 1;
    kHeatingOnly = 2;
    kHeatingWithReheat = 3;
    kCoolingAndHeating = 4;
    kCoolingAndHeatingWithReheat = 5;
  }

  enum PresetScenarioEnum : enum8 {
    kUnspecified = 0;
    kOccupied = 1;
    kUnoccupied = 2;
    kSleep = 3;
    kWake = 4;
    kVacation = 5;
    kUserDefined = 6;
  }

  enum SetpointChangeSourceEnum : enum8 {
    kManual = 0;
    kSchedule = 1;
    kExternal = 2;
  }

  enum SetpointRaiseLowerModeEnum : enum8 {
    kHeat = 0;
    kCool = 1;
    kBoth = 2;
  }

  enum StartOfWeekEnum : enum8 {
    kSunday = 0;
    kMonday = 1;
    kTuesday = 2;
    kWednesday = 3;
    kThursday = 4;
    kFriday = 5;
    kSaturday = 6;
  }

  enum SystemModeEnum : enum8 {
    kOff = 0;
    kAuto = 1;
    kCool = 3;
    kHeat = 4;
    kEmergencyHeat = 5;
    kPrecooling = 6;
    kFanOnly = 7;
    kDry = 8;
    kSleep = 9;
  }

  enum TemperatureSetpointHoldEnum : enum8 {
    kSetpointHoldOff = 0;
    kSetpointHoldOn = 1;
  }

  enum ThermostatRunningModeEnum : enum8 {
    kOff = 0;
    kCool = 3;
    kHeat = 4;
  }

  bitmap ACErrorCodeBitmap : bitmap32 {
    kCompressorFail = 0x1;
    kRoomSensorFail = 0x2;
    kOutdoorSensorFail = 0x4;
    kCoilSensorFail = 0x8;
    kFanFail = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHeating = 0x1;
    kCooling = 0x2;
    kOccupancy = 0x4;
    kScheduleConfiguration = 0x8;
    kSetback = 0x10;
    kAutoMode = 0x20;
    kLocalTemperatureNotExposed = 0x40;
    kMatterScheduleConfiguration = 0x80;
    kPresets = 0x100;
    kSetpoints = 0x200;
    kQueuedPresetsSupported = 0x400;
  }

  bitmap HVACSystemTypeBitmap : bitmap8 {
    kCoolingStage = 0x3;
    kHeatingStage = 0xC;
    kHeatingIsHeatPump = 0x10;
    kHeatingUsesFuel = 0x20;
  }

  bitmap PresetTypeFeaturesBitmap : bitmap16 {
    kAutomatic = 0x1;
    kSupportsNames = 0x2;
  }

  bitmap ProgrammingOperationModeBitmap : bitmap8 {
    kScheduleActive = 0x1;
    kAutoRecovery = 0x2;
    kEconomy = 0x4;
  }

  bitmap RelayStateBitmap : bitmap16 {
    kHeat = 0x1;
    kCool = 0x2;
    kFan = 0x4;
    kHeatStage2 = 0x8;
    kCoolStage2 = 0x10;
    kFanStage2 = 0x20;
    kFanStage3 = 0x40;
  }

  bitmap RemoteSensingBitmap : bitmap8 {
    kLocalTemperature = 0x1;
    kOutdoorTemperature = 0x2;
    kOccupancy = 0x4;
  }

  bitmap ScheduleDayOfWeekBitmap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
    kAway = 0x80;
  }

  bitmap ScheduleModeBitmap : bitmap8 {
    kHeatSetpointPresent = 0x1;
    kCoolSetpointPresent = 0x2;
  }

  bitmap ScheduleTypeFeaturesBitmap : bitmap16 {
    kSupportsPresets = 0x1;
    kSupportsSetpoints = 0x2;
    kSupportsNames = 0x4;
    kSupportsOff = 0x8;
  }

  bitmap TemperatureSetpointHoldPolicyBitmap : bitmap8 {
    kHoldDurationElapsed = 0x1;
    kHoldDurationElapsedOrPresetChanged = 0x2;
  }

  struct ScheduleTransitionStruct {
    ScheduleDayOfWeekBitmap dayOfWeek = 0;
    int16u transitionTime = 1;
    optional octet_string<16> presetHandle = 2;
    optional SystemModeEnum systemMode = 3;
    optional temperature coolingSetpoint = 4;
    optional temperature heatingSetpoint = 5;
  }

  struct ScheduleStruct {
    nullable octet_string<16> scheduleHandle = 0;
    SystemModeEnum systemMode = 1;
    optional char_string<64> name = 2;
    optional octet_string<16> presetHandle = 3;
    ScheduleTransitionStruct transitions[] = 4;
    optional nullable boolean builtIn = 5;
  }

  struct PresetStruct {
    nullable octet_string<16> presetHandle = 0;
    PresetScenarioEnum presetScenario = 1;
    optional nullable char_string<64> name = 2;
    optional temperature coolingSetpoint = 3;
    optional temperature heatingSetpoint = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetTypeStruct {
    PresetScenarioEnum presetScenario = 0;
    int8u numberOfPresets = 1;
    PresetTypeFeaturesBitmap presetTypeFeatures = 2;
  }

  struct QueuedPresetStruct {
    nullable octet_string<16> presetHandle = 0;
    nullable epoch_s transitionTimestamp = 1;
  }

  struct ScheduleTypeStruct {
    SystemModeEnum systemMode = 0;
    int8u numberOfSchedules = 1;
    ScheduleTypeFeaturesBitmap scheduleTypeFeatures = 2;
  }

  struct WeeklyScheduleTransitionStruct {
    int16u transitionTime = 0;
    nullable temperature heatSetpoint = 1;
    nullable temperature coolSetpoint = 2;
  }

  readonly attribute nullable temperature localTemperature = 0;
  readonly attribute optional nullable temperature outdoorTemperature = 1;
  readonly attribute optional bitmap8 occupancy = 2;
  readonly attribute optional temperature absMinHeatSetpointLimit = 3;
  readonly attribute optional temperature absMaxHeatSetpointLimit = 4;
  readonly attribute optional temperature absMinCoolSetpointLimit = 5;
  readonly attribute optional temperature absMaxCoolSetpointLimit = 6;
  readonly attribute optional int8u PICoolingDemand = 7;
  readonly attribute optional int8u PIHeatingDemand = 8;
  attribute access(write: manage) optional bitmap8 HVACSystemTypeConfiguration = 9;
  attribute access(write: manage) optional int8s localTemperatureCalibration = 16;
  attribute optional int16s occupiedCoolingSetpoint = 17;
  attribute optional int16s occupiedHeatingSetpoint = 18;
  attribute optional int16s unoccupiedCoolingSetpoint = 19;
  attribute optional int16s unoccupiedHeatingSetpoint = 20;
  attribute access(write: manage) optional int16s minHeatSetpointLimit = 21;
  attribute access(write: manage) optional int16s maxHeatSetpointLimit = 22;
  attribute access(write: manage) optional int16s minCoolSetpointLimit = 23;
  attribute access(write: manage) optional int16s maxCoolSetpointLimit = 24;
  attribute access(write: manage) optional int8s minSetpointDeadBand = 25;
  attribute access(write: manage) optional RemoteSensingBitmap remoteSensing = 26;
  attribute access(write: manage) ControlSequenceOfOperationEnum controlSequenceOfOperation = 27;
  attribute access(write: manage) SystemModeEnum systemMode = 28;
  readonly attribute optional ThermostatRunningModeEnum thermostatRunningMode = 30;
  readonly attribute optional StartOfWeekEnum startOfWeek = 32;
  readonly attribute optional int8u numberOfWeeklyTransitions = 33;
  readonly attribute optional int8u numberOfDailyTransitions = 34;
  attribute access(write: manage) optional TemperatureSetpointHoldEnum temperatureSetpointHold = 35;
  attribute access(write: manage) optional nullable int16u temperatureSetpointHoldDuration = 36;
  attribute access(write: manage) optional ProgrammingOperationModeBitmap thermostatProgrammingOperationMode = 37;
  readonly attribute optional RelayStateBitmap thermostatRunningState = 41;
  readonly attribute optional SetpointChangeSourceEnum setpointChangeSource = 48;
  readonly attribute optional nullable int16s setpointChangeAmount = 49;
  readonly attribute optional epoch_s setpointChangeSourceTimestamp = 50;
  attribute access(write: manage) optional nullable int8u occupiedSetback = 52;
  readonly attribute optional nullable int8u occupiedSetbackMin = 53;
  readonly attribute optional nullable int8u occupiedSetbackMax = 54;
  attribute access(write: manage) optional nullable int8u unoccupiedSetback = 55;
  readonly attribute optional nullable int8u unoccupiedSetbackMin = 56;
  readonly attribute optional nullable int8u unoccupiedSetbackMax = 57;
  attribute access(write: manage) optional int8u emergencyHeatDelta = 58;
  attribute access(write: manage) optional ACTypeEnum ACType = 64;
  attribute access(write: manage) optional int16u ACCapacity = 65;
  attribute access(write: manage) optional ACRefrigerantTypeEnum ACRefrigerantType = 66;
  attribute access(write: manage) optional ACCompressorTypeEnum ACCompressorType = 67;
  attribute access(write: manage) optional ACErrorCodeBitmap ACErrorCode = 68;
  attribute access(write: manage) optional ACLouverPositionEnum ACLouverPosition = 69;
  readonly attribute optional nullable temperature ACCoilTemperature = 70;
  attribute access(write: manage) optional ACCapacityFormatEnum ACCapacityformat = 71;
  readonly attribute optional PresetTypeStruct presetTypes[] = 72;
  readonly attribute optional ScheduleTypeStruct scheduleTypes[] = 73;
  readonly attribute optional int8u numberOfPresets = 74;
  readonly attribute optional int8u numberOfSchedules = 75;
  readonly attribute optional int8u numberOfScheduleTransitions = 76;
  readonly attribute optional nullable int8u numberOfScheduleTransitionPerDay = 77;
  readonly attribute optional nullable octet_string<16> activePresetHandle = 78;
  readonly attribute optional nullable octet_string<16> activeScheduleHandle = 79;
  attribute access(write: manage) optional PresetStruct presets[] = 80;
  attribute access(write: manage) optional ScheduleStruct schedules[] = 81;
  readonly attribute optional boolean presetsSchedulesEditable = 82;
  readonly attribute optional TemperatureSetpointHoldPolicyBitmap temperatureSetpointHoldPolicy = 83;
  readonly attribute optional nullable epoch_s setpointHoldExpiryTimestamp = 84;
  readonly attribute optional nullable QueuedPresetStruct queuedPreset = 85;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetpointRaiseLowerRequest {
    SetpointRaiseLowerModeEnum mode = 0;
    int8s amount = 1;
  }

  response struct GetWeeklyScheduleResponse = 0 {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct SetWeeklyScheduleRequest {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct GetWeeklyScheduleRequest {
    ScheduleDayOfWeekBitmap daysToReturn = 0;
    ScheduleModeBitmap modeToReturn = 1;
  }

  request struct SetActiveScheduleRequestRequest {
    octet_string<16> scheduleHandle = 0;
  }

  request struct SetActivePresetRequestRequest {
    octet_string<16> presetHandle = 0;
    optional int16u delayMinutes = 1;
  }

  request struct StartPresetsSchedulesEditRequestRequest {
    int16u timeoutSeconds = 0;
  }

  request struct SetTemperatureSetpointHoldPolicyRequest {
    TemperatureSetpointHoldPolicyBitmap temperatureSetpointHoldPolicy = 0;
  }

  /** Command description for SetpointRaiseLower */
  command SetpointRaiseLower(SetpointRaiseLowerRequest): DefaultSuccess = 0;
  /** Command description for SetWeeklySchedule */
  command access(invoke: manage) SetWeeklySchedule(SetWeeklyScheduleRequest): DefaultSuccess = 1;
  /** Command description for GetWeeklySchedule */
  command GetWeeklySchedule(GetWeeklyScheduleRequest): GetWeeklyScheduleResponse = 2;
  /** This command is used to clear the weekly schedule. The ClearWeeklySchedule command has no payload. */
  command access(invoke: manage) ClearWeeklySchedule(): DefaultSuccess = 3;
  /** This command is used to set the active schedule. */
  command SetActiveScheduleRequest(SetActiveScheduleRequestRequest): DefaultSuccess = 5;
  /** This command is used to set the active preset. */
  command SetActivePresetRequest(SetActivePresetRequestRequest): DefaultSuccess = 6;
  /** This command is used to start editing the presets and schedules. */
  command access(invoke: manage) StartPresetsSchedulesEditRequest(StartPresetsSchedulesEditRequestRequest): DefaultSuccess = 7;
  /** This command is used to cancel editing presets and schedules. */
  command access(invoke: manage) CancelPresetsSchedulesEditRequest(): DefaultSuccess = 8;
  /** This command is used to notify the server that all edits are done and should be committed. */
  command access(invoke: manage) CommitPresetsSchedulesRequest(): DefaultSuccess = 9;
  /** This command is sent to cancel a queued preset. */
  command access(invoke: manage) CancelSetActivePresetRequest(): DefaultSuccess = 10;
  /** This command sets the set point hold policy. */
  command SetTemperatureSetpointHoldPolicy(SetTemperatureSetpointHoldPolicyRequest): DefaultSuccess = 11;
}

/** An interface for controlling a fan in a heating/cooling system. */
provisional cluster FanControl = 514 {
  revision 4;

  enum AirflowDirectionEnum : enum8 {
    kForward = 0;
    kReverse = 1;
  }

  enum FanModeEnum : enum8 {
    kOff = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kOn = 4;
    kAuto = 5;
    kSmart = 6;
  }

  enum FanModeSequenceEnum : enum8 {
    kOffLowMedHigh = 0;
    kOffLowHigh = 1;
    kOffLowMedHighAuto = 2;
    kOffLowHighAuto = 3;
    kOffHighAuto = 4;
    kOffHigh = 5;
  }

  enum StepDirectionEnum : enum8 {
    kIncrease = 0;
    kDecrease = 1;
  }

  bitmap Feature : bitmap32 {
    kMultiSpeed = 0x1;
    kAuto = 0x2;
    kRocking = 0x4;
    kWind = 0x8;
    kStep = 0x10;
    kAirflowDirection = 0x20;
  }

  bitmap RockBitmap : bitmap8 {
    kRockLeftRight = 0x1;
    kRockUpDown = 0x2;
    kRockRound = 0x4;
  }

  bitmap WindBitmap : bitmap8 {
    kSleepWind = 0x1;
    kNaturalWind = 0x2;
  }

  attribute FanModeEnum fanMode = 0;
  readonly attribute FanModeSequenceEnum fanModeSequence = 1;
  attribute nullable percent percentSetting = 2;
  readonly attribute percent percentCurrent = 3;
  readonly attribute optional int8u speedMax = 4;
  attribute optional nullable int8u speedSetting = 5;
  readonly attribute optional int8u speedCurrent = 6;
  readonly attribute optional RockBitmap rockSupport = 7;
  attribute optional RockBitmap rockSetting = 8;
  readonly attribute optional WindBitmap windSupport = 9;
  attribute optional WindBitmap windSetting = 10;
  attribute optional AirflowDirectionEnum airflowDirection = 11;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct StepRequest {
    StepDirectionEnum direction = 0;
    optional boolean wrap = 1;
    optional boolean lowestOff = 2;
  }

  /** The Step command speeds up or slows down the fan, in steps. */
  command Step(StepRequest): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the measurement of temperature, and reporting temperature measurements. */
cluster TemperatureMeasurement = 1026 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute nullable temperature measuredValue = 0;
  readonly attribute nullable temperature minMeasuredValue = 1;
  readonly attribute nullable temperature maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of relative humidity, and reporting relative humidity measurements. */
cluster RelativeHumidityMeasurement = 1029 {
  revision 3;

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting carbon monoxide concentration measurements */
cluster CarbonMonoxideConcentrationMeasurement = 1036 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting carbon dioxide concentration measurements */
cluster CarbonDioxideConcentrationMeasurement = 1037 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting nitrogen dioxide concentration measurements */
cluster NitrogenDioxideConcentrationMeasurement = 1043 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting ozone concentration measurements */
cluster OzoneConcentrationMeasurement = 1045 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM2.5 concentration measurements */
cluster Pm25ConcentrationMeasurement = 1066 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting formaldehyde concentration measurements */
cluster FormaldehydeConcentrationMeasurement = 1067 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM1 concentration measurements */
cluster Pm1ConcentrationMeasurement = 1068 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM10 concentration measurements */
cluster Pm10ConcentrationMeasurement = 1069 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting total volatile organic compounds concentration measurements */
cluster TotalVolatileOrganicCompoundsConcentrationMeasurement = 1070 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting radon concentration measurements */
cluster RadonConcentrationMeasurement = 1071 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

endpoint 0 {
  device type ma_rootdevice = 22, version 1;


  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    emits event AccessControlExtensionChanged;
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry;
    callback attribute targetsPerAccessControlEntry;
    callback attribute accessControlEntriesPerFabric;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    callback attribute dataModelRevision;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location;
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate;
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    persist  attribute localConfigDisabled default = 0;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    callback attribute specificationVersion;
    callback attribute maxPathsPerInvoke;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig;
    callback attribute locationCapability;
    callback attribute supportsConcurrentConnection;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 0x0001;

    handle command ArmFailSafe;
    handle command ArmFailSafeResponse;
    handle command SetRegulatoryConfig;
    handle command SetRegulatoryConfigResponse;
    handle command CommissioningComplete;
    handle command CommissioningCompleteResponse;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 0x0001;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }

  server cluster DiagnosticLogs {
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command RetrieveLogsRequest;
  }

  server cluster GeneralDiagnostics {
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount;
    callback attribute upTime;
    callback attribute totalOperationalHours;
    callback attribute bootReason;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    callback attribute testEventTriggersEnabled default = false;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command TestEventTrigger;
    handle command TimeSnapshot;
    handle command TimeSnapshotResponse;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus;
    callback attribute adminFabricIndex;
    callback attribute adminVendorId;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 0x0001;

    handle command OpenCommissioningWindow;
    handle command OpenBasicCommissioningWindow;
    handle command RevokeCommissioning;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 0x0001;

    handle command AttestationRequest;
    handle command AttestationResponse;
    handle command CertificateChainRequest;
    handle command CertificateChainResponse;
    handle command CSRRequest;
    handle command CSRResponse;
    handle command AddNOC;
    handle command UpdateNOC;
    handle command NOCResponse;
    handle command UpdateFabricLabel;
    handle command RemoveFabric;
    handle command AddTrustedRootCertificate;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command KeySetWrite;
    handle command KeySetRead;
    handle command KeySetReadResponse;
    handle command KeySetRemove;
    handle command KeySetReadAllIndices;
    handle command KeySetReadAllIndicesResponse;
  }
}
endpoint 1 {
  device type ma_air_purifier = 45, version 1;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Groups {
    ram      attribute nameSupport;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;

    handle command AddGroup;
    handle command AddGroupResponse;
    handle command ViewGroup;
    handle command ViewGroupResponse;
    handle command GetGroupMembership;
    handle command GetGroupMembershipResponse;
    handle command RemoveGroup;
    handle command RemoveGroupResponse;
    handle command RemoveAllGroups;
    handle command AddGroupIfIdentifying;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster HepaFilterMonitoring {
    callback attribute condition;
    callback attribute degradationDirection;
    callback attribute changeIndication;
    callback attribute inPlaceIndicator;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ActivatedCarbonFilterMonitoring {
    callback attribute condition;
    callback attribute degradationDirection;
    callback attribute changeIndication;
    callback attribute inPlaceIndicator;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster FanControl {
    ram      attribute fanMode default = 0;
    ram      attribute fanModeSequence default = 2;
    ram      attribute percentSetting default = 0;
    ram      attribute percentCurrent default = 0;
    ram      attribute speedMax default = 10;
    ram      attribute speedSetting default = 0;
    ram      attribute speedCurrent default = 0;
    ram      attribute rockSupport default = 0x01;
    ram      attribute rockSetting default = 0x00;
    ram      attribute windSupport default = 0x03;
    ram      attribute windSetting default = 0x00;
    ram      attribute airflowDirection default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;
  }
}
endpoint 2 {
  device type ma_air_quality_sensor = 44, version 1;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command Identify;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster AirQuality {
    callback attribute airQuality;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster CarbonMonoxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster CarbonDioxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster NitrogenDioxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster OzoneConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Pm25ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster FormaldehydeConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Pm1ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Pm10ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster TotalVolatileOrganicCompoundsConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster RadonConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }
}
endpoint 3 {
  device type ma_tempsensor = 770, version 1;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster TemperatureMeasurement {
    ram      attribute measuredValue;
    ram      attribute minMeasuredValue default = 0x8000;
    ram      attribute maxMeasuredValue default = 0x8000;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 4 {
  device type ma_humiditysensor = 775, version 1;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster RelativeHumidityMeasurement {
    ram      attribute measuredValue;
    ram      attribute minMeasuredValue;
    ram      attribute maxMeasuredValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 3;
  }
}
endpoint 5 {
  device type ma_thermostat = 769, version 1;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster Thermostat {
    ram      attribute localTemperature;
    ram      attribute occupiedHeatingSetpoint default = 2000;
    ram      attribute minHeatSetpointLimit default = 1700;
    ram      attribute maxHeatSetpointLimit default = 3000;
    ram      attribute controlSequenceOfOperation default = 0x02;
    ram      attribute systemMode default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 6;

    handle command SetpointRaiseLower;
  }
}


