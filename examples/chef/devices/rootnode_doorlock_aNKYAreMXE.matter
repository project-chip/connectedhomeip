// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

server cluster Identify = 3 {
  enum IdentifyEffectIdentifier : ENUM8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum IdentifyEffectVariant : ENUM8 {
    kDefault = 0;
  }

  enum IdentifyIdentifyType : ENUM8 {
    kNone = 0;
    kVisibleLight = 1;
    kVisibleLED = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute enum8 identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    INT16U identifyTime = 0;
  }

  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
}

server cluster Groups = 4 {
  bitmap GroupClusterFeature : BITMAP32 {
    kGroupNames = 0x1;
  }

  readonly attribute bitmap8 nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    CHAR_STRING groupName = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    CHAR_STRING groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    ENUM8 status = 0;
    group_id groupID = 1;
  }

  response struct ViewGroupResponse = 1 {
    ENUM8 status = 0;
    group_id groupID = 1;
    CHAR_STRING groupName = 2;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable INT8U capacity = 0;
    group_id groupList[] = 1;
  }

  response struct RemoveGroupResponse = 3 {
    ENUM8 status = 0;
    group_id groupID = 1;
  }

  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

server cluster Descriptor = 29 {
  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute CLUSTER_ID serverList[] = 1;
  readonly attribute CLUSTER_ID clientList[] = 2;
  readonly attribute ENDPOINT_NO partsList[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

client cluster Binding = 30 {
  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster AccessControl = 31 {
  enum AccessControlEntryAuthModeEnum : ENUM8 {
    kPase = 1;
    kCase = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : ENUM8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum ChangeTypeEnum : ENUM8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive Target targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  struct Target {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) AccessControlExtensionStruct extension[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster BasicInformation = 40 {
  critical event StartUp = 0 {
    INT32U softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute char_string<16> manufacturingDate = 11;
  readonly attribute char_string<32> partNumber = 12;
  readonly attribute long_char_string<256> productURL = 13;
  readonly attribute char_string<64> productLabel = 14;
  readonly attribute char_string<32> serialNumber = 15;
  attribute access(write: manage) boolean localConfigDisabled = 16;
  readonly attribute boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

client cluster OtaSoftwareUpdateProvider = 41 {
  enum OTAApplyUpdateAction : ENUM8 {
    kProceed = 0;
    kAwaitNextAction = 1;
    kDiscontinue = 2;
  }

  enum OTADownloadProtocol : ENUM8 {
    kBDXSynchronous = 0;
    kBDXAsynchronous = 1;
    kHttps = 2;
    kVendorSpecific = 3;
  }

  enum OTAQueryStatus : ENUM8 {
    kUpdateAvailable = 0;
    kBusy = 1;
    kNotAvailable = 2;
    kDownloadProtocolNotSupported = 3;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct QueryImageRequest {
    vendor_id vendorID = 0;
    INT16U productID = 1;
    INT32U softwareVersion = 2;
    OTADownloadProtocol protocolsSupported[] = 3;
    optional INT16U hardwareVersion = 4;
    optional CHAR_STRING<2> location = 5;
    optional BOOLEAN requestorCanConsent = 6;
    optional OCTET_STRING<512> metadataForProvider = 7;
  }

  response struct QueryImageResponse = 1 {
    OTAQueryStatus status = 0;
    optional INT32U delayedActionTime = 1;
    optional CHAR_STRING<256> imageURI = 2;
    optional INT32U softwareVersion = 3;
    optional CHAR_STRING<64> softwareVersionString = 4;
    optional OCTET_STRING<32> updateToken = 5;
    optional BOOLEAN userConsentNeeded = 6;
    optional OCTET_STRING<512> metadataForRequestor = 7;
  }

  request struct ApplyUpdateRequestRequest {
    OCTET_STRING<32> updateToken = 0;
    INT32U newVersion = 1;
  }

  response struct ApplyUpdateResponse = 3 {
    OTAApplyUpdateAction action = 0;
    INT32U delayedActionTime = 1;
  }

  request struct NotifyUpdateAppliedRequest {
    OCTET_STRING<32> updateToken = 0;
    INT32U softwareVersion = 1;
  }

  command QueryImage(QueryImageRequest): QueryImageResponse = 0;
  command ApplyUpdateRequest(ApplyUpdateRequestRequest): ApplyUpdateResponse = 2;
  command NotifyUpdateApplied(NotifyUpdateAppliedRequest): DefaultSuccess = 4;
}

server cluster OtaSoftwareUpdateRequestor = 42 {
  enum OTAAnnouncementReason : ENUM8 {
    kSimpleAnnouncement = 0;
    kUpdateAvailable = 1;
    kUrgentUpdateAvailable = 2;
  }

  enum OTAChangeReasonEnum : ENUM8 {
    kUnknown = 0;
    kSuccess = 1;
    kFailure = 2;
    kTimeOut = 3;
    kDelayByProvider = 4;
  }

  enum OTAUpdateStateEnum : ENUM8 {
    kUnknown = 0;
    kIdle = 1;
    kQuerying = 2;
    kDelayedOnQuery = 3;
    kDownloading = 4;
    kApplying = 5;
    kDelayedOnApply = 6;
    kRollingBack = 7;
    kDelayedOnUserConsent = 8;
  }

  fabric_scoped struct ProviderLocation {
    node_id providerNodeID = 1;
    endpoint_no endpoint = 2;
    fabric_idx fabricIndex = 254;
  }

  info event StateTransition = 0 {
    OTAUpdateStateEnum previousState = 0;
    OTAUpdateStateEnum newState = 1;
    OTAChangeReasonEnum reason = 2;
    nullable INT32U targetSoftwareVersion = 3;
  }

  critical event VersionApplied = 1 {
    INT32U softwareVersion = 0;
    INT16U productID = 1;
  }

  info event DownloadError = 2 {
    INT32U softwareVersion = 0;
    INT64U bytesDownloaded = 1;
    nullable INT8U progressPercent = 2;
    nullable INT64S platformCode = 3;
  }

  attribute ProviderLocation defaultOTAProviders[] = 0;
  readonly attribute boolean updatePossible = 1;
  readonly attribute OTAUpdateStateEnum updateState = 2;
  readonly attribute nullable int8u updateStateProgress = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AnnounceOTAProviderRequest {
    node_id providerNodeID = 0;
    vendor_id vendorID = 1;
    OTAAnnouncementReason announcementReason = 2;
    optional OCTET_STRING<512> metadataForNode = 3;
    endpoint_no endpoint = 4;
  }

  command AnnounceOTAProvider(AnnounceOTAProviderRequest): DefaultSuccess = 0;
}

server cluster LocalizationConfiguration = 43 {
  readonly attribute CHAR_STRING supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster TimeFormatLocalization = 44 {
  enum CalendarTypeEnum : ENUM8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
  }

  enum HourFormatEnum : ENUM8 {
    k12hr = 0;
    k24hr = 1;
  }

  attribute HourFormatEnum hourFormat = 0;
  attribute CalendarTypeEnum activeCalendarType = 1;
  readonly attribute CalendarTypeEnum supportedCalendarTypes[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster GeneralCommissioning = 48 {
  enum CommissioningError : ENUM8 {
    kOk = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationType : ENUM8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationType regulatoryConfig = 2;
  readonly attribute RegulatoryLocationType locationCapability = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    INT16U expiryLengthSeconds = 0;
    INT64U breadcrumb = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationType newRegulatoryConfig = 0;
    CHAR_STRING countryCode = 1;
    INT64U breadcrumb = 2;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

server cluster NetworkCommissioning = 49 {
  enum NetworkCommissioningStatus : ENUM8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBand : ENUM8 {
    k2g4 = 0;
    k3g65 = 1;
    k5g = 2;
    k6g = 3;
    k60g = 4;
  }

  bitmap NetworkCommissioningFeature : BITMAP32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
  }

  bitmap WiFiSecurity : BITMAP8 {
    kUnencrypted = 0x1;
    kWep = 0x2;
    kWpaPersonal = 0x4;
    kWpa2Personal = 0x8;
    kWpa3Personal = 0x10;
  }

  struct NetworkInfo {
    octet_string<32> networkID = 0;
    boolean connected = 1;
  }

  struct WiFiInterfaceScanResult {
    WiFiSecurity security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBand wiFiBand = 4;
    int8s rssi = 5;
  }

  struct ThreadInterfaceScanResult {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfo networks[] = 1;
  readonly attribute int8u scanMaxTimeSeconds = 2;
  readonly attribute int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatus lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable OCTET_STRING<32> ssid = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    OCTET_STRING<32> ssid = 0;
    OCTET_STRING<64> credentials = 1;
    optional INT64U breadcrumb = 2;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    OCTET_STRING<254> operationalDataset = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ConnectNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct ReorderNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    INT8U networkIndex = 1;
    optional INT64U breadcrumb = 2;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    optional WiFiInterfaceScanResult wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResult threadScanResults[] = 3;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING<512> debugText = 1;
    optional INT8U networkIndex = 2;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    nullable INT32S errorValue = 2;
  }

  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
}

server cluster DiagnosticLogs = 50 {
  enum IntentEnum : ENUM8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : ENUM8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : ENUM8 {
    kResponsePayload = 0;
    kBdx = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional CHAR_STRING<32> transferFileDesignator = 2;
  }

  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

server cluster GeneralDiagnostics = 51 {
  enum BootReasonEnum : ENUM8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : ENUM8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : ENUM8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : ENUM8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : ENUM8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute int64u upTime = 2;
  readonly attribute int32u totalOperationalHours = 3;
  readonly attribute BootReasonEnum bootReason = 4;
  readonly attribute HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    OCTET_STRING<16> enableKey = 0;
    INT64U eventTrigger = 1;
  }

  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
}

server cluster SoftwareDiagnostics = 52 {
  bitmap SoftwareDiagnosticsFeature : BITMAP32 {
    kWaterMarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    INT64U id = 0;
    optional CHAR_STRING name = 1;
    optional OCTET_STRING faultRecording = 2;
  }

  readonly attribute ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute int64u currentHeapFree = 1;
  readonly attribute int64u currentHeapUsed = 2;
  readonly attribute int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command ResetWatermarks(): DefaultSuccess = 0;
}

server cluster Switch = 59 {
  bitmap SwitchFeature : BITMAP32 {
    kLatchingSwitch = 0x1;
    kMomentarySwitch = 0x2;
    kMomentarySwitchRelease = 0x4;
    kMomentarySwitchLongPress = 0x8;
    kMomentarySwitchMultiPress = 0x10;
  }

  info event SwitchLatched = 0 {
    INT8U newPosition = 0;
  }

  info event InitialPress = 1 {
    INT8U newPosition = 0;
  }

  info event LongPress = 2 {
    INT8U newPosition = 0;
  }

  info event ShortRelease = 3 {
    INT8U previousPosition = 0;
  }

  info event LongRelease = 4 {
    INT8U previousPosition = 0;
  }

  info event MultiPressOngoing = 5 {
    INT8U newPosition = 0;
    INT8U currentNumberOfPressesCounted = 1;
  }

  info event MultiPressComplete = 6 {
    INT8U previousPosition = 0;
    INT8U totalNumberOfPressesCounted = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster AdministratorCommissioning = 60 {
  enum CommissioningWindowStatusEnum : ENUM8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : ENUM8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable int16u adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
    OCTET_STRING PAKEPasscodeVerifier = 1;
    INT16U discriminator = 2;
    INT32U iterations = 3;
    OCTET_STRING salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
  }

  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

server cluster OperationalCredentials = 62 {
  enum CertificateChainTypeEnum : ENUM8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : ENUM8 {
    kOk = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute OCTET_STRING trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    OCTET_STRING attestationNonce = 0;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  request struct CSRRequestRequest {
    OCTET_STRING CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  request struct AddNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
    OCTET_STRING IPKValue = 2;
    Int64u caseAdminSubject = 3;
    VENDOR_ID adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
  }

  request struct UpdateFabricLabelRequest {
    CHAR_STRING<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    OCTET_STRING rootCACertificate = 0;
  }

  response struct AttestationResponse = 1 {
    OCTET_STRING attestationElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  response struct CertificateChainResponse = 3 {
    OCTET_STRING certificate = 0;
  }

  response struct CSRResponse = 5 {
    OCTET_STRING NOCSRElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional CHAR_STRING debugText = 2;
  }

  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

server cluster GroupKeyManagement = 63 {
  enum GroupKeySecurityPolicyEnum : ENUM8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetRemoveRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetReadAllIndicesRequest {
    INT16U groupKeySetIDs[] = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    INT16U groupKeySetIDs[] = 0;
  }

  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  fabric command access(invoke: administer) KeySetReadAllIndices(KeySetReadAllIndicesRequest): KeySetReadAllIndicesResponse = 4;
}

server cluster FixedLabel = 64 {
  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

server cluster DoorLock = 257 {
  enum AlarmCodeEnum : ENUM8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : ENUM8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : ENUM8 {
    kProgrammingPIN = 0;
    kPin = 1;
    kRfid = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
  }

  enum DataOperationTypeEnum : ENUM8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : ENUM8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
  }

  enum DlLockType : ENUM8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
  }

  enum DlStatus : ENUM8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : ENUM8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : ENUM8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : ENUM8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : ENUM8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : ENUM8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : ENUM8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : ENUM8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPin = 6;
    kRfid = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
  }

  enum LockOperationTypeEnum : ENUM8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
  }

  enum OperatingModeEnum : ENUM8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : ENUM8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : ENUM8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRfid = 8;
    kBiometric = 9;
  }

  enum UserStatusEnum : ENUM8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : ENUM8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : BITMAP8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : BITMAP8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : BITMAP8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : BITMAP16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : BITMAP8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : BITMAP16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : BITMAP8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DoorLockFeature : BITMAP32 {
    kPinCredential = 0x1;
    kRfidCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable INT16U userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable NODE_ID sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable INT16U userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable NODE_ID sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable INT16U userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable NODE_ID sourceNode = 5;
    nullable INT16U dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute int16u numberOfTotalUsersSupported = 17;
  readonly attribute int16u numberOfPINUsersSupported = 18;
  readonly attribute int8u maxPINCodeLength = 23;
  readonly attribute int8u minPINCodeLength = 24;
  readonly attribute int8u numberOfCredentialsSupportedPerUser = 28;
  attribute access(write: manage) int32u autoRelockTime = 35;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  attribute access(write: administer) int8u wrongCodeEntryLimit = 48;
  attribute access(write: administer) int8u userCodeTemporaryDisableTime = 49;
  attribute access(write: administer) boolean sendPINOverTheAir = 50;
  attribute access(write: administer) boolean requirePINforRemoteOperation = 51;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional OCTET_STRING PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional OCTET_STRING PINCode = 0;
  }

  request struct UnlockWithTimeoutRequest {
    INT16U timeout = 0;
    optional OCTET_STRING PINCode = 1;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    INT16U userIndex = 1;
    nullable CHAR_STRING userName = 2;
    nullable INT32U userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    INT16U userIndex = 0;
  }

  request struct ClearUserRequest {
    INT16U userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    LONG_OCTET_STRING credentialData = 2;
    nullable INT16U userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  response struct GetUserResponse = 28 {
    INT16U userIndex = 0;
    nullable CHAR_STRING userName = 1;
    nullable INT32U userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable INT16U nextUserIndex = 9;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable INT16U userIndex = 1;
    nullable INT16U nextCredentialIndex = 2;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable INT16U userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable INT16U nextCredentialIndex = 4;
  }

  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  timed command UnlockWithTimeout(UnlockWithTimeoutRequest): DefaultSuccess = 3;
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
}

endpoint 0 {
  device type rootdevice = 22, version 1;
  binding cluster OtaSoftwareUpdateProvider;

  server cluster Groups {
    ram      attribute nameSupport;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    ram      attribute featureMap;
    callback attribute clusterRevision default = 1;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    emits event AccessControlExtensionChanged;
    callback attribute acl;
    callback attribute extension;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    callback attribute dataModelRevision default = 10;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location default = "XX";
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate default = "20210614123456ZZ";
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    persist  attribute localConfigDisabled;
    ram      attribute reachable default = 1;
    callback attribute uniqueID;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OtaSoftwareUpdateRequestor {
    emits event StateTransition;
    emits event VersionApplied;
    emits event DownloadError;
    callback attribute defaultOTAProviders;
    ram      attribute updatePossible default = 1;
    ram      attribute updateState;
    ram      attribute updateStateProgress;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster LocalizationConfiguration {
    callback attribute supportedLocales;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TimeFormatLocalization {
    persist  attribute hourFormat;
    persist  attribute activeCalendarType;
    callback attribute supportedCalendarTypes;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig;
    callback attribute locationCapability;
    ram      attribute featureMap default = 6;
    ram      attribute clusterRevision default = 0x0001;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 0x0001;
  }

  server cluster DiagnosticLogs {
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralDiagnostics {
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount;
    callback attribute upTime;
    callback attribute totalOperationalHours;
    callback attribute bootReason;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    callback attribute testEventTriggersEnabled;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 0x0001;
  }

  server cluster SoftwareDiagnostics {
    callback attribute threadMetrics;
    callback attribute currentHeapFree;
    callback attribute currentHeapUsed;
    callback attribute currentHeapHighWatermark;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 0x0001;
  }

  server cluster Switch {
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus;
    callback attribute adminFabricIndex default = 1;
    callback attribute adminVendorId;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 0x0001;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 0x0001;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster FixedLabel {
    callback attribute labelList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 1 {
  device type anonymousEndpointType = 10, version 1;
  binding cluster Binding;

  server cluster Identify {
    ram      attribute identifyTime;
    ram      attribute identifyType;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 2;
  }

  server cluster Groups {
    ram      attribute nameSupport;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 3;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster DoorLock {
    emits event DoorLockAlarm;
    emits event LockOperation;
    emits event LockOperationError;
    ram      attribute lockState default = 1;
    ram      attribute lockType;
    ram      attribute actuatorEnabled;
    ram      attribute numberOfTotalUsersSupported default = 2;
    ram      attribute numberOfPINUsersSupported default = 2;
    ram      attribute maxPINCodeLength default = 10;
    ram      attribute minPINCodeLength default = 5;
    ram      attribute numberOfCredentialsSupportedPerUser default = 5;
    ram      attribute autoRelockTime;
    ram      attribute operatingMode;
    ram      attribute supportedOperatingModes default = 0xFFF6;
    ram      attribute wrongCodeEntryLimit default = 3;
    ram      attribute userCodeTemporaryDisableTime default = 10;
    ram      attribute sendPINOverTheAir;
    ram      attribute requirePINforRemoteOperation default = 1;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x0181;
    ram      attribute clusterRevision default = 6;
  }
}


