// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

enum AreaTypeTag : enum8 {
  kAisle = 0;
  kAttic = 1;
  kBackDoor = 2;
  kBackYard = 3;
  kBalcony = 4;
  kBallroom = 5;
  kBathroom = 6;
  kBedroom = 7;
  kBorder = 8;
  kBoxroom = 9;
  kBreakfastRoom = 10;
  kCarport = 11;
  kCellar = 12;
  kCloakroom = 13;
  kCloset = 14;
  kConservatory = 15;
  kCorridor = 16;
  kCraftRoom = 17;
  kCupboard = 18;
  kDeck = 19;
  kDen = 20;
  kDining = 21;
  kDrawingRoom = 22;
  kDressingRoom = 23;
  kDriveway = 24;
  kElevator = 25;
  kEnsuite = 26;
  kEntrance = 27;
  kEntryway = 28;
  kFamilyRoom = 29;
  kFoyer = 30;
  kFrontDoor = 31;
  kFrontYard = 32;
  kGameRoom = 33;
  kGarage = 34;
  kGarageDoor = 35;
  kGarden = 36;
  kGardenDoor = 37;
  kGuestBathroom = 38;
  kGuestBedroom = 39;
  kGuestRoom = 41;
  kGym = 42;
  kHallway = 43;
  kHearthRoom = 44;
  kKidsRoom = 45;
  kKidsBedroom = 46;
  kKitchen = 47;
  kLaundryRoom = 49;
  kLawn = 50;
  kLibrary = 51;
  kLivingRoom = 52;
  kLounge = 53;
  kMediaTVRoom = 54 [spec_name = "Media/TV Room"];
  kMudRoom = 55;
  kMusicRoom = 56;
  kNursery = 57;
  kOffice = 58;
  kOutdoorKitchen = 59;
  kOutside = 60;
  kPantry = 61;
  kParkingLot = 62;
  kParlor = 63;
  kPatio = 64;
  kPlayRoom = 65;
  kPoolRoom = 66;
  kPorch = 67;
  kPrimaryBathroom = 68;
  kPrimaryBedroom = 69;
  kRamp = 70;
  kReceptionRoom = 71;
  kRecreationRoom = 72;
  kRoof = 74;
  kSauna = 75;
  kScullery = 76;
  kSewingRoom = 77;
  kShed = 78;
  kSideDoor = 79;
  kSideYard = 80;
  kSittingRoom = 81;
  kSnug = 82;
  kSpa = 83;
  kStaircase = 84;
  kSteamRoom = 85;
  kStorageRoom = 86;
  kStudio = 87;
  kStudy = 88;
  kSunRoom = 89;
  kSwimmingPool = 90;
  kTerrace = 91;
  kUtilityRoom = 92;
  kWard = 93;
  kWorkshop = 94;
  kToilet = 95;
}

enum AtomicRequestTypeEnum : enum8 {
  kBeginWrite = 0;
  kCommitWrite = 1;
  kRollbackWrite = 2;
}

enum LandmarkTag : enum8 {
  kAirConditioner = 0;
  kAirPurifier = 1;
  kBackDoor = 2;
  kBarStool = 3;
  kBathMat = 4;
  kBathtub = 5;
  kBed = 6;
  kBookshelf = 7;
  kChair = 8;
  kChristmasTree = 9;
  kCoatRack = 10;
  kCoffeeTable = 11;
  kCookingRange = 12;
  kCouch = 13;
  kCountertop = 14;
  kCradle = 15;
  kCrib = 16;
  kDesk = 17;
  kDiningTable = 18;
  kDishwasher = 19;
  kDoor = 20;
  kDresser = 21;
  kLaundryDryer = 22;
  kFan = 23;
  kFireplace = 24;
  kFreezer = 25;
  kFrontDoor = 26;
  kHighChair = 27;
  kKitchenIsland = 28;
  kLamp = 29;
  kLitterBox = 30;
  kMirror = 31;
  kNightstand = 32;
  kOven = 33;
  kPetBed = 34;
  kPetBowl = 35;
  kPetCrate = 36;
  kRefrigerator = 37;
  kScratchingPost = 38;
  kShoeRack = 39;
  kShower = 40;
  kSideDoor = 41;
  kSink = 42;
  kSofa = 43;
  kStove = 44;
  kTable = 45;
  kToilet = 46;
  kTrashCan = 47;
  kLaundryWasher = 48;
  kWindow = 49;
  kWineCooler = 50;
}

enum LocationTag : enum8 {
  kIndoor = 0;
  kOutdoor = 1;
  kInside = 2;
  kOutside = 3;
}

enum MeasurementTypeEnum : enum16 {
  kUnspecified = 0;
  kVoltage = 1;
  kActiveCurrent = 2;
  kReactiveCurrent = 3;
  kApparentCurrent = 4;
  kActivePower = 5;
  kReactivePower = 6;
  kApparentPower = 7;
  kRMSVoltage = 8;
  kRMSCurrent = 9;
  kRMSPower = 10;
  kFrequency = 11;
  kPowerFactor = 12;
  kNeutralCurrent = 13;
  kElectricalEnergy = 14;
  kReactiveEnergy = 15;
  kApparentEnergy = 16;
  kSoilMoisture = 17;
}

enum PositionTag : enum8 {
  kLeft = 0;
  kRight = 1;
  kTop = 2;
  kBottom = 3;
  kMiddle = 4;
  kRow = 5;
  kColumn = 6;
}

enum PowerThresholdSourceEnum : enum8 {
  kContract = 0;
  kRegulator = 1;
  kEquipment = 2;
}

enum RelativePositionTag : enum8 {
  kUnder = 0;
  kNextTo = 1;
  kAround = 2;
  kOn = 3;
  kAbove = 4;
  kFrontOf = 5;
  kBehind = 6;
}

enum StreamUsageEnum : enum8 {
  kInternal = 0;
  kRecording = 1;
  kAnalysis = 2;
  kLiveView = 3;
}

enum TariffPriceTypeEnum : enum8 {
  kStandard = 0;
  kCritical = 1;
  kVirtual = 2;
  kIncentive = 3;
  kIncentiveSignal = 4;
}

enum TariffUnitEnum : enum8 {
  kKWh = 0;
  kKVAh = 1;
}

enum TestGlobalEnum : enum8 {
  kSomeValue = 0;
  kSomeOtherValue = 1;
  kFinalValue = 2;
}

enum ThreeLevelAutoEnum : enum8 {
  kAuto = 0;
  kLow = 1;
  kMedium = 2;
  kHigh = 3;
}

enum WebRTCEndReasonEnum : enum8 {
  kICEFailed = 0;
  kICETimeout = 1;
  kUserHangup = 2;
  kUserBusy = 3;
  kReplaced = 4;
  kNoUserMedia = 5;
  kInviteTimeout = 6;
  kAnsweredElsewhere = 7;
  kOutOfResources = 8;
  kMediaTimeout = 9;
  kLowPower = 10;
  kPrivacyMode = 11;
  kUnknownReason = 12;
}

bitmap TestGlobalBitmap : bitmap32 {
  kFirstBit = 0x1;
  kSecondBit = 0x2;
}

struct CurrencyStruct {
  int16u currency = 0;
  int8u decimalPoints = 1;
}

struct PriceStruct {
  money amount = 0;
  CurrencyStruct currency = 1;
}

struct MeasurementAccuracyRangeStruct {
  int64s rangeMin = 0;
  int64s rangeMax = 1;
  optional percent100ths percentMax = 2;
  optional percent100ths percentMin = 3;
  optional percent100ths percentTypical = 4;
  optional int64u fixedMax = 5;
  optional int64u fixedMin = 6;
  optional int64u fixedTypical = 7;
}

struct MeasurementAccuracyStruct {
  MeasurementTypeEnum measurementType = 0;
  boolean measured = 1;
  int64s minMeasuredValue = 2;
  int64s maxMeasuredValue = 3;
  MeasurementAccuracyRangeStruct accuracyRanges[] = 4;
}

struct AtomicAttributeStatusStruct {
  attrib_id attributeID = 0;
  status statusCode = 1;
}

struct ICECandidateStruct {
  char_string candidate = 0;
  nullable char_string SDPMid = 1;
  nullable int16u SDPMLineIndex = 2;
}

struct ICEServerStruct {
  char_string URLs[] = 0;
  optional long_char_string<508> username = 1;
  optional long_char_string<512> credential = 2;
  optional int16u caid = 3;
}

struct LocationDescriptorStruct {
  char_string<128> locationName = 0;
  nullable int16s floorNumber = 1;
  nullable AreaTypeTag areaType = 2;
}

struct PowerThresholdStruct {
  optional power_mw powerThreshold = 0;
  optional power_mva apparentPowerThreshold = 1;
  nullable PowerThresholdSourceEnum powerThresholdSource = 2;
}

struct TestGlobalStruct {
  char_string<128> name = 0;
  nullable TestGlobalBitmap myBitmap = 1;
  optional nullable TestGlobalEnum myEnum = 2;
}

struct ViewportStruct {
  int16u x1 = 0;
  int16u y1 = 1;
  int16u x2 = 2;
  int16u y2 = 3;
}

fabric_scoped struct WebRTCSessionStruct {
  int16u id = 0;
  node_id peerNodeID = 1;
  endpoint_no peerEndpointID = 2;
  StreamUsageEnum streamUsage = 3;
  nullable int16u videoStreamID = 4;
  nullable int16u audioStreamID = 5;
  boolean metadataEnabled = 6;
  fabric_idx fabricIndex = 254;
}

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
cluster Identify = 3 {
  revision 5;

  enum EffectIdentifierEnum : enum8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum EffectVariantEnum : enum8 {
    kDefault = 0;
  }

  enum IdentifyTypeEnum : enum8 {
    kNone = 0;
    kLightOutput = 1;
    kVisibleIndicator = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute IdentifyTypeEnum identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    int16u identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    EffectVariantEnum effectVariant = 1;
  }

  /** This command starts or stops the receiving device identifying itself. */
  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  /** This command allows the support of feedback to the user, such as a certain light effect. */
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
cluster Descriptor = 29 {
  revision 3;

  bitmap Feature : bitmap32 {
    kTagList = 0x1;
  }

  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  struct SemanticTagStruct {
    nullable vendor_id mfgCode = 0;
    enum8 namespaceID = 1;
    enum8 tag = 2;
    optional nullable char_string<64> label = 3;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute cluster_id serverList[] = 1;
  readonly attribute cluster_id clientList[] = 2;
  readonly attribute endpoint_no partsList[] = 3;
  readonly attribute optional SemanticTagStruct tagList[] = 4;
  readonly attribute optional char_string<32> endpointUniqueID = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Binding Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table. */
cluster Binding = 30 {
  revision 1;

  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(write: manage) TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
cluster AccessControl = 31 {
  revision 2;

  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1 [spec_name = "PASE"];
    kCASE = 2 [spec_name = "CASE"];
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum AccessRestrictionTypeEnum : enum8 {
    kAttributeAccessForbidden = 0;
    kAttributeWriteForbidden = 1;
    kCommandForbidden = 2;
    kEventForbidden = 3;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  bitmap Feature : bitmap32 {
    kExtension = 0x1;
    kManagedDevice = 0x2;
  }

  struct AccessRestrictionStruct {
    AccessRestrictionTypeEnum type = 0;
    nullable int32u id = 1;
  }

  struct CommissioningAccessRestrictionEntryStruct {
    endpoint_no endpoint = 0;
    cluster_id cluster = 1;
    AccessRestrictionStruct restrictions[] = 2;
  }

  fabric_scoped struct AccessRestrictionEntryStruct {
    fabric_sensitive endpoint_no endpoint = 0;
    fabric_sensitive cluster_id cluster = 1;
    fabric_sensitive AccessRestrictionStruct restrictions[] = 2;
    fabric_idx fabricIndex = 254;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) FabricRestrictionReviewUpdate = 2 {
    int64u token = 0;
    optional long_char_string instruction = 1;
    optional long_char_string ARLRequestFlowUrl = 2;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute optional CommissioningAccessRestrictionEntryStruct commissioningARL[] = 5;
  readonly attribute optional AccessRestrictionEntryStruct arl[] = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ReviewFabricRestrictionsRequest {
    CommissioningAccessRestrictionEntryStruct arl[] = 0;
  }

  response struct ReviewFabricRestrictionsResponse = 1 {
    int64u token = 0;
  }

  /** This command signals to the service associated with the device vendor that the fabric administrator would like a review of the current restrictions on the accessing fabric. */
  fabric command access(invoke: administer) ReviewFabricRestrictions(ReviewFabricRestrictionsRequest): ReviewFabricRestrictionsResponse = 0;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
cluster BasicInformation = 40 {
  revision 5;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  attribute access(write: manage) optional boolean localConfigDisabled = 16;
  readonly attribute optional boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute int32u specificationVersion = 21;
  readonly attribute int16u maxPathsPerInvoke = 22;
  readonly attribute int32u configurationVersion = 24;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command MfgSpecificPing(): DefaultSuccess = 0;
}

/** Provides an interface for providing OTA software updates */
cluster OtaSoftwareUpdateProvider = 41 {
  revision 1; // NOTE: Default/not specifically set

  enum ApplyUpdateActionEnum : enum8 {
    kProceed = 0;
    kAwaitNextAction = 1;
    kDiscontinue = 2;
  }

  enum DownloadProtocolEnum : enum8 {
    kBDXSynchronous = 0;
    kBDXAsynchronous = 1;
    kHTTPS = 2 [spec_name = "HTTPS"];
    kVendorSpecific = 3;
  }

  enum StatusEnum : enum8 {
    kUpdateAvailable = 0;
    kBusy = 1;
    kNotAvailable = 2;
    kDownloadProtocolNotSupported = 3;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct QueryImageRequest {
    vendor_id vendorID = 0;
    int16u productID = 1;
    int32u softwareVersion = 2;
    DownloadProtocolEnum protocolsSupported[] = 3;
    optional int16u hardwareVersion = 4;
    optional char_string<2> location = 5;
    optional boolean requestorCanConsent = 6;
    optional octet_string<512> metadataForProvider = 7;
  }

  response struct QueryImageResponse = 1 {
    StatusEnum status = 0;
    optional int32u delayedActionTime = 1;
    optional char_string<256> imageURI = 2;
    optional int32u softwareVersion = 3;
    optional char_string<64> softwareVersionString = 4;
    optional octet_string<32> updateToken = 5;
    optional boolean userConsentNeeded = 6;
    optional octet_string<512> metadataForRequestor = 7;
  }

  request struct ApplyUpdateRequestRequest {
    octet_string<32> updateToken = 0;
    int32u newVersion = 1;
  }

  response struct ApplyUpdateResponse = 3 {
    ApplyUpdateActionEnum action = 0;
    int32u delayedActionTime = 1;
  }

  request struct NotifyUpdateAppliedRequest {
    octet_string<32> updateToken = 0;
    int32u softwareVersion = 1;
  }

  /** Determine availability of a new Software Image */
  command QueryImage(QueryImageRequest): QueryImageResponse = 0;
  /** Determine next action to take for a downloaded Software Image */
  command ApplyUpdateRequest(ApplyUpdateRequestRequest): ApplyUpdateResponse = 2;
  /** Notify OTA Provider that an update was applied */
  command NotifyUpdateApplied(NotifyUpdateAppliedRequest): DefaultSuccess = 4;
}

/** Provides an interface for downloading and applying OTA software updates */
cluster OtaSoftwareUpdateRequestor = 42 {
  revision 1; // NOTE: Default/not specifically set

  enum AnnouncementReasonEnum : enum8 {
    kSimpleAnnouncement = 0;
    kUpdateAvailable = 1;
    kUrgentUpdateAvailable = 2;
  }

  enum ChangeReasonEnum : enum8 {
    kUnknown = 0;
    kSuccess = 1;
    kFailure = 2;
    kTimeOut = 3;
    kDelayByProvider = 4;
  }

  enum UpdateStateEnum : enum8 {
    kUnknown = 0;
    kIdle = 1;
    kQuerying = 2;
    kDelayedOnQuery = 3;
    kDownloading = 4;
    kApplying = 5;
    kDelayedOnApply = 6;
    kRollingBack = 7;
    kDelayedOnUserConsent = 8;
  }

  fabric_scoped struct ProviderLocation {
    node_id providerNodeID = 1;
    endpoint_no endpoint = 2;
    fabric_idx fabricIndex = 254;
  }

  info event StateTransition = 0 {
    UpdateStateEnum previousState = 0;
    UpdateStateEnum newState = 1;
    ChangeReasonEnum reason = 2;
    nullable int32u targetSoftwareVersion = 3;
  }

  critical event VersionApplied = 1 {
    int32u softwareVersion = 0;
    int16u productID = 1;
  }

  info event DownloadError = 2 {
    int32u softwareVersion = 0;
    int64u bytesDownloaded = 1;
    nullable int8u progressPercent = 2;
    nullable int64s platformCode = 3;
  }

  attribute access(write: administer) ProviderLocation defaultOTAProviders[] = 0;
  readonly attribute boolean updatePossible = 1;
  readonly attribute UpdateStateEnum updateState = 2;
  readonly attribute nullable int8u updateStateProgress = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AnnounceOTAProviderRequest {
    node_id providerNodeID = 0;
    vendor_id vendorID = 1;
    AnnouncementReasonEnum announcementReason = 2;
    optional octet_string<512> metadataForNode = 3;
    endpoint_no endpoint = 4;
  }

  /** Announce the presence of an OTA Provider */
  command access(invoke: administer) AnnounceOTAProvider(AnnounceOTAProviderRequest): DefaultSuccess = 0;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
cluster LocalizationConfiguration = 43 {
  revision 1;

  attribute access(write: manage) char_string<35> activeLocale = 0;
  readonly attribute char_string supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for the units in which values are conveyed in communication to a
      user. As such, Nodes that visually or audibly convey measurable values to the user need a
      mechanism by which they can be configured to use a user’s preferred unit. */
cluster UnitLocalization = 45 {
  revision 2;

  enum TempUnitEnum : enum8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap Feature : bitmap32 {
    kTemperatureUnit = 0x1;
  }

  attribute access(write: manage) optional TempUnitEnum temperatureUnit = 0;
  provisional readonly attribute optional TempUnitEnum supportedTemperatureUnits[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
cluster GeneralCommissioning = 48 {
  revision 2;

  enum CommissioningErrorEnum : enum8 {
    kOK = 0 [spec_name = "OK"];
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
    kRequiredTCNotAccepted = 5;
    kTCAcknowledgementsNotReceived = 6;
    kTCMinVersionNotMet = 7;
  }

  enum NetworkRecoveryReasonEnum : enum8 {
    kUnspecified = 0;
    kAuth = 1;
    kVisibility = 2;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  bitmap Feature : bitmap32 {
    kTermsAndConditions = 0x1;
    kNetworkRecovery = 0x2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  provisional readonly attribute access(read: administer) optional int16u TCAcceptedVersion = 5;
  provisional readonly attribute access(read: administer) optional int16u TCMinRequiredVersion = 6;
  provisional readonly attribute access(read: administer) optional bitmap16 TCAcknowledgements = 7;
  provisional readonly attribute access(read: administer) optional boolean TCAcknowledgementsRequired = 8;
  provisional readonly attribute access(read: administer) optional nullable int32u TCUpdateDeadline = 9;
  provisional readonly attribute access(read: manage) optional octet_string<8> recoveryIdentifier = 10;
  provisional readonly attribute access(read: manage) optional nullable NetworkRecoveryReasonEnum networkRecoveryReason = 11;
  provisional readonly attribute optional boolean isCommissioningWithoutPower = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string<128> debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string<2> countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  request struct SetTCAcknowledgementsRequest {
    int16u TCVersion = 0;
    bitmap16 TCUserResponse = 1;
  }

  response struct SetTCAcknowledgementsResponse = 7 {
    CommissioningErrorEnum errorCode = 0;
  }

  /** This command is used to arm or disarm the fail-safe timer. */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** This command is used to set the regulatory configuration for the device. */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** This command is used to indicate that the commissioning process is complete. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
  /** This command is used to set the user acknowledgements received in the Enhanced Setup Flow Terms & Conditions into the node. */
  command access(invoke: administer) SetTCAcknowledgements(SetTCAcknowledgementsRequest): SetTCAcknowledgementsResponse = 6;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
cluster NetworkCommissioning = 49 {
  revision 2;

  enum NetworkCommissioningStatusEnum : enum8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBandEnum : enum8 {
    k2G4 = 0 [spec_name = "2G4"];
    k3G65 = 1 [spec_name = "3G65"];
    k5G = 2 [spec_name = "5G"];
    k6G = 3 [spec_name = "6G"];
    k60G = 4 [spec_name = "60G"];
    k1G = 5 [spec_name = "1G"];
  }

  bitmap Feature : bitmap32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
    kPerDeviceCredentials = 0x8;
  }

  bitmap ThreadCapabilitiesBitmap : bitmap16 {
    kIsBorderRouterCapable = 0x1;
    kIsRouterCapable = 0x2;
    kIsSleepyEndDeviceCapable = 0x4;
    kIsFullThreadDevice = 0x8;
    kIsSynchronizedSleepyEndDeviceCapable = 0x10;
  }

  bitmap WiFiSecurityBitmap : bitmap8 {
    kUnencrypted = 0x1;
    kWEP = 0x2 [spec_name = "WEP"];
    kWPAPersonal = 0x4 [spec_name = "WPA-PERSONAL"];
    kWPA2Personal = 0x8 [spec_name = "WPA2-PERSONAL"];
    kWPA3Personal = 0x10 [spec_name = "WPA3-PERSONAL"];
    kWPA3MatterPDC = 0x20 [spec_name = "WPA3-Matter-PDC"];
  }

  struct NetworkInfoStruct {
    octet_string<32> networkID = 0;
    boolean connected = 1;
    optional nullable octet_string<20> networkIdentifier = 2;
    optional nullable octet_string<20> clientIdentifier = 3;
  }

  struct ThreadInterfaceScanResultStruct {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResultStruct {
    WiFiSecurityBitmap security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBandEnum wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfoStruct networks[] = 1;
  readonly attribute optional int8u scanMaxTimeSeconds = 2;
  readonly attribute optional int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatusEnum lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  provisional readonly attribute optional WiFiBandEnum supportedWiFiBands[] = 8;
  provisional readonly attribute optional ThreadCapabilitiesBitmap supportedThreadFeatures = 9;
  provisional readonly attribute optional int16u threadVersion = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable octet_string<32> ssid = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    optional WiFiInterfaceScanResultStruct wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResultStruct threadScanResults[] = 3;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    octet_string<32> ssid = 0;
    octet_string<64> credentials = 1;
    optional int64u breadcrumb = 2;
    optional octet_string<140> networkIdentity = 3;
    optional octet_string<20> clientIdentifier = 4;
    optional octet_string<32> possessionNonce = 5;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    octet_string<254> operationalDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string<512> debugText = 1;
    optional int8u networkIndex = 2;
    optional octet_string<140> clientIdentity = 3;
    optional octet_string<64> possessionSignature = 4;
  }

  request struct ConnectNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    nullable int32s errorValue = 2;
  }

  request struct ReorderNetworkRequest {
    octet_string<32> networkID = 0;
    int8u networkIndex = 1;
    optional int64u breadcrumb = 2;
  }

  request struct QueryIdentityRequest {
    octet_string<20> keyIdentifier = 0;
    optional octet_string<32> possessionNonce = 1;
  }

  response struct QueryIdentityResponse = 10 {
    octet_string<140> identity = 0;
    optional octet_string<64> possessionSignature = 1;
  }

  /** Detemine the set of networks the device sees as available. */
  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  /** Add or update the credentials for a given Wi-Fi network. */
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  /** Add or update the credentials for a given Thread network. */
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  /** Remove the definition of a given network (including its credentials). */
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  /** Connect to the specified network, using previously-defined credentials. */
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  /** Modify the order in which networks will be presented in the Networks attribute. */
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
  /** Retrieve details about and optionally proof of possession of a network client identity. */
  command access(invoke: administer) QueryIdentity(QueryIdentityRequest): QueryIdentityResponse = 9;
}

/** The cluster provides commands for retrieving unstructured diagnostic logs from a Node that may be used to aid in diagnostics. */
cluster DiagnosticLogs = 50 {
  revision 1;

  enum IntentEnum : enum8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : enum8 {
    kResponsePayload = 0;
    kBDX = 1 [spec_name = "BDX"];
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional char_string<32> transferFileDesignator = 2;
  }

  response struct RetrieveLogsResponse = 1 {
    StatusEnum status = 0;
    long_octet_string<1024> logContent = 1;
    optional epoch_us UTCTimeStamp = 2;
    optional systime_us timeSinceBoot = 3;
  }

  /** Reception of this command starts the process of retrieving diagnostic logs from a Node. */
  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster GeneralDiagnostics = 51 {
  revision 2;

  enum BootReasonEnum : enum8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : enum8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : enum8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : enum8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  bitmap Feature : bitmap32 {
    kDataModelTest = 0x1;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute optional int64u upTime = 2;
  readonly attribute optional int32u totalOperationalHours = 3;
  readonly attribute optional BootReasonEnum bootReason = 4;
  readonly attribute optional HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute optional RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute optional NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    octet_string<16> enableKey = 0;
    int64u eventTrigger = 1;
  }

  response struct TimeSnapshotResponse = 2 {
    systime_ms systemTimeMs = 0;
    nullable posix_ms posixTimeMs = 1;
  }

  request struct PayloadTestRequestRequest {
    octet_string<16> enableKey = 0;
    int8u value = 1;
    int16u count = 2;
  }

  response struct PayloadTestResponse = 4 {
    octet_string payload = 0;
  }

  /** Provide a means for certification tests to trigger some test-plan-specific events */
  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
  /** Take a snapshot of system time and epoch time. */
  command TimeSnapshot(): TimeSnapshotResponse = 1;
  /** Request a variable length payload response. */
  command access(invoke: manage) PayloadTestRequest(PayloadTestRequestRequest): PayloadTestResponse = 3;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster SoftwareDiagnostics = 52 {
  revision 1;

  bitmap Feature : bitmap32 {
    kWatermarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    int64u id = 0;
    optional char_string name = 1;
    optional long_octet_string faultRecording = 2;
  }

  readonly attribute optional ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute optional int64u currentHeapFree = 1;
  readonly attribute optional int64u currentHeapUsed = 2;
  readonly attribute optional int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command is used to reset the high watermarks for heap and stack memory. */
  command access(invoke: manage) ResetWatermarks(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
cluster ThreadNetworkDiagnostics = 53 {
  revision 3;

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRoleEnum : enum8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kREED = 4 [spec_name = "REED"];
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTableStruct {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTableStruct {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRoleEnum routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute NeighborTableStruct neighborTable[] = 7;
  readonly attribute RouteTableStruct routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int16u weighting = 10;
  readonly attribute nullable int16u dataVersion = 11;
  readonly attribute nullable int16u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute optional int16u detachedRoleCount = 14;
  readonly attribute optional int16u childRoleCount = 15;
  readonly attribute optional int16u routerRoleCount = 16;
  readonly attribute optional int16u leaderRoleCount = 17;
  readonly attribute optional int16u attachAttemptCount = 18;
  readonly attribute optional int16u partitionIdChangeCount = 19;
  readonly attribute optional int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute optional int16u parentChangeCount = 21;
  readonly attribute optional int32u txTotalCount = 22;
  readonly attribute optional int32u txUnicastCount = 23;
  readonly attribute optional int32u txBroadcastCount = 24;
  readonly attribute optional int32u txAckRequestedCount = 25;
  readonly attribute optional int32u txAckedCount = 26;
  readonly attribute optional int32u txNoAckRequestedCount = 27;
  readonly attribute optional int32u txDataCount = 28;
  readonly attribute optional int32u txDataPollCount = 29;
  readonly attribute optional int32u txBeaconCount = 30;
  readonly attribute optional int32u txBeaconRequestCount = 31;
  readonly attribute optional int32u txOtherCount = 32;
  readonly attribute optional int32u txRetryCount = 33;
  readonly attribute optional int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute optional int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute optional int32u txErrCcaCount = 36;
  readonly attribute optional int32u txErrAbortCount = 37;
  readonly attribute optional int32u txErrBusyChannelCount = 38;
  readonly attribute optional int32u rxTotalCount = 39;
  readonly attribute optional int32u rxUnicastCount = 40;
  readonly attribute optional int32u rxBroadcastCount = 41;
  readonly attribute optional int32u rxDataCount = 42;
  readonly attribute optional int32u rxDataPollCount = 43;
  readonly attribute optional int32u rxBeaconCount = 44;
  readonly attribute optional int32u rxBeaconRequestCount = 45;
  readonly attribute optional int32u rxOtherCount = 46;
  readonly attribute optional int32u rxAddressFilteredCount = 47;
  readonly attribute optional int32u rxDestAddrFilteredCount = 48;
  readonly attribute optional int32u rxDuplicatedCount = 49;
  readonly attribute optional int32u rxErrNoFrameCount = 50;
  readonly attribute optional int32u rxErrUnknownNeighborCount = 51;
  readonly attribute optional int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute optional int32u rxErrSecCount = 53;
  readonly attribute optional int32u rxErrFcsCount = 54;
  readonly attribute optional int32u rxErrOtherCount = 55;
  readonly attribute optional nullable int64u activeTimestamp = 56;
  readonly attribute optional nullable int64u pendingTimestamp = 57;
  readonly attribute optional nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFaultEnum activeNetworkFaultsList[] = 62;
  provisional readonly attribute nullable int64u extAddress = 63;
  provisional readonly attribute nullable int16u rloc16 = 64;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the following attributes to 0: */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
cluster AdministratorCommissioning = 60 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningWindowStatusEnum : enum8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : enum8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  bitmap Feature : bitmap32 {
    kBasic = 0x1;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable vendor_id adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
    octet_string PAKEPasscodeVerifier = 1;
    int16u discriminator = 2;
    int32u iterations = 3;
    octet_string<32> salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
  }

  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using enhanced commissioning method. */
  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using basic commissioning method, if the node supports it. */
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  /** This command is used by a current Administrator to instruct a Node to revoke any active Open Commissioning Window or Open Basic Commissioning Window command. */
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
cluster OperationalCredentials = 62 {
  revision 2;

  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0 [spec_name = "OK"];
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    optional octet_string<85> VIDVerificationStatement = 6;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    octet_string<400> noc = 1;
    nullable octet_string<400> icac = 2;
    optional octet_string<400> vvsc = 3;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string<400> rootCACertificate = 0;
  }

  request struct SetVIDVerificationStatementRequest {
    optional vendor_id vendorID = 0;
    optional octet_string<85> VIDVerificationStatement = 1;
    optional octet_string<400> vvsc = 2;
  }

  request struct SignVIDVerificationRequestRequest {
    fabric_idx fabricIndex = 0;
    octet_string<32> clientChallenge = 1;
  }

  response struct SignVIDVerificationResponse = 14 {
    fabric_idx fabricIndex = 0;
    int8u fabricBindingVersion = 1;
    octet_string signature = 2;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** This command SHALL replace the NOC and optional associated ICAC (if present) scoped under the accessing fabric upon successful validation of all arguments and preconditions. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
  /** This command SHALL be used to update any of the accessing fabric's associated VendorID, VidVerificatioNStatement or VVSC (Vendor Verification Signing Certificate). */
  fabric command access(invoke: administer) SetVIDVerificationStatement(SetVIDVerificationStatementRequest): DefaultSuccess = 12;
  /** This command SHALL be used to request that the server authenticate the fabric associated with the FabricIndex given. */
  command access(invoke: administer) SignVIDVerificationRequest(SignVIDVerificationRequestRequest): SignVIDVerificationResponse = 13;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
cluster GroupKeyManagement = 63 {
  revision 1; // NOTE: Default/not specifically set

  enum GroupKeySecurityPolicyEnum : enum8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  bitmap Feature : bitmap32 {
    kCacheAndSync = 0x1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetRemoveRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    int16u groupKeySetIDs[] = 0;
  }

  /** Write a new set of keys for the given key set id. */
  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  /** Read the keys for a given key set id. */
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  /** Revoke a Root Key from a Group */
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  /** Return the list of Group Key Sets associated with the accessing fabric */
  fabric command access(invoke: administer) KeySetReadAllIndices(): KeySetReadAllIndicesResponse = 4;
}

/** The User Label Cluster provides a feature to tag an endpoint with zero or more labels. */
cluster UserLabel = 65 {
  revision 1; // NOTE: Default/not specifically set

  shared struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  attribute access(write: manage) LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster supports remotely monitoring and, where supported, changing the operational state of any device where a state machine is a part of the operation. */
cluster OperationalState = 96 {
  revision 1;

  enum ErrorStateEnum : enum8 {
    kNoError = 0;
    kUnableToStartOrResume = 1;
    kUnableToCompleteOperation = 2;
    kCommandInvalidInState = 3;
  }

  enum OperationalStateEnum : enum8 {
    kStopped = 0;
    kRunning = 1;
    kPaused = 2;
    kError = 3;
  }

  shared struct ErrorStateStruct {
    enum8 errorStateID = 0;
    optional char_string<64> errorStateLabel = 1;
    optional char_string<64> errorStateDetails = 2;
  }

  shared struct OperationalStateStruct {
    enum8 operationalStateID = 0;
    optional char_string<64> operationalStateLabel = 1;
  }

  critical event OperationalError = 0 {
    ErrorStateStruct errorState = 0;
  }

  info event OperationCompletion = 1 {
    enum8 completionErrorCode = 0;
    optional nullable elapsed_s totalOperationalTime = 1;
    optional nullable elapsed_s pausedTime = 2;
  }

  readonly attribute nullable char_string phaseList[] = 0;
  readonly attribute nullable int8u currentPhase = 1;
  readonly attribute optional nullable elapsed_s countdownTime = 2;
  readonly attribute OperationalStateStruct operationalStateList[] = 3;
  readonly attribute OperationalStateEnum operationalState = 4;
  readonly attribute ErrorStateStruct operationalError = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct OperationalCommandResponse = 4 {
    ErrorStateStruct commandResponseState = 0;
  }

  /** Upon receipt, the device SHALL pause its operation if it is possible based on the current function of the server. */
  command Pause(): OperationalCommandResponse = 0;
  /** Upon receipt, the device SHALL stop its operation if it is at a position where it is safe to do so and/or permitted. */
  command Stop(): OperationalCommandResponse = 1;
  /** Upon receipt, the device SHALL start its operation if it is safe to do so and the device is in an operational state from which it can be started. */
  command Start(): OperationalCommandResponse = 2;
  /** Upon receipt, the device SHALL resume its operation from the point it was at when it received the Pause command, or from the point when it was paused by means outside of this cluster (for example by manual button press). */
  command Resume(): OperationalCommandResponse = 3;
}

/** This cluster provides a mechanism for querying data about electrical power as measured by the server. */
cluster ElectricalPowerMeasurement = 144 {
  revision 3;

  shared enum MeasurementTypeEnum : enum16 {
    kUnspecified = 0;
    kVoltage = 1;
    kActiveCurrent = 2;
    kReactiveCurrent = 3;
    kApparentCurrent = 4;
    kActivePower = 5;
    kReactivePower = 6;
    kApparentPower = 7;
    kRMSVoltage = 8;
    kRMSCurrent = 9;
    kRMSPower = 10;
    kFrequency = 11;
    kPowerFactor = 12;
    kNeutralCurrent = 13;
    kElectricalEnergy = 14;
    kReactiveEnergy = 15;
    kApparentEnergy = 16;
  }

  enum PowerModeEnum : enum8 {
    kUnknown = 0;
    kDC = 1 [spec_name = "DC"];
    kAC = 2 [spec_name = "AC"];
  }

  bitmap Feature : bitmap32 {
    kDirectCurrent = 0x1;
    kAlternatingCurrent = 0x2;
    kPolyphasePower = 0x4;
    kHarmonics = 0x8;
    kPowerQuality = 0x10;
  }

  shared struct MeasurementAccuracyRangeStruct {
    int64s rangeMin = 0;
    int64s rangeMax = 1;
    optional percent100ths percentMax = 2;
    optional percent100ths percentMin = 3;
    optional percent100ths percentTypical = 4;
    optional int64u fixedMax = 5;
    optional int64u fixedMin = 6;
    optional int64u fixedTypical = 7;
  }

  shared struct MeasurementAccuracyStruct {
    MeasurementTypeEnum measurementType = 0;
    boolean measured = 1;
    int64s minMeasuredValue = 2;
    int64s maxMeasuredValue = 3;
    MeasurementAccuracyRangeStruct accuracyRanges[] = 4;
  }

  struct HarmonicMeasurementStruct {
    int8u order = 0;
    nullable int64s measurement = 1;
  }

  struct MeasurementRangeStruct {
    MeasurementTypeEnum measurementType = 0;
    int64s min = 1;
    int64s max = 2;
    optional epoch_s startTimestamp = 3;
    optional epoch_s endTimestamp = 4;
    optional epoch_s minTimestamp = 5;
    optional epoch_s maxTimestamp = 6;
    optional systime_ms startSystime = 7;
    optional systime_ms endSystime = 8;
    optional systime_ms minSystime = 9;
    optional systime_ms maxSystime = 10;
  }

  info event MeasurementPeriodRanges = 0 {
    MeasurementRangeStruct ranges[] = 0;
  }

  readonly attribute PowerModeEnum powerMode = 0;
  readonly attribute int8u numberOfMeasurementTypes = 1;
  readonly attribute MeasurementAccuracyStruct accuracy[] = 2;
  readonly attribute optional MeasurementRangeStruct ranges[] = 3;
  readonly attribute optional nullable voltage_mv voltage = 4;
  readonly attribute optional nullable amperage_ma activeCurrent = 5;
  readonly attribute optional nullable amperage_ma reactiveCurrent = 6;
  readonly attribute optional nullable amperage_ma apparentCurrent = 7;
  readonly attribute nullable power_mw activePower = 8;
  readonly attribute optional nullable power_mvar reactivePower = 9;
  readonly attribute optional nullable power_mva apparentPower = 10;
  readonly attribute optional nullable voltage_mv RMSVoltage = 11;
  readonly attribute optional nullable amperage_ma RMSCurrent = 12;
  readonly attribute optional nullable power_mw RMSPower = 13;
  readonly attribute optional nullable int64s frequency = 14;
  readonly attribute optional nullable HarmonicMeasurementStruct harmonicCurrents[] = 15;
  readonly attribute optional nullable HarmonicMeasurementStruct harmonicPhases[] = 16;
  readonly attribute optional nullable int64s powerFactor = 17;
  readonly attribute optional nullable amperage_ma neutralCurrent = 18;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides a mechanism for querying data about the electrical energy imported or provided by the server. */
cluster ElectricalEnergyMeasurement = 145 {
  revision 2;

  shared enum MeasurementTypeEnum : enum16 {
    kUnspecified = 0;
    kVoltage = 1;
    kActiveCurrent = 2;
    kReactiveCurrent = 3;
    kApparentCurrent = 4;
    kActivePower = 5;
    kReactivePower = 6;
    kApparentPower = 7;
    kRMSVoltage = 8;
    kRMSCurrent = 9;
    kRMSPower = 10;
    kFrequency = 11;
    kPowerFactor = 12;
    kNeutralCurrent = 13;
    kElectricalEnergy = 14;
    kReactiveEnergy = 15;
    kApparentEnergy = 16;
  }

  bitmap Feature : bitmap32 {
    kImportedEnergy = 0x1;
    kExportedEnergy = 0x2;
    kCumulativeEnergy = 0x4;
    kPeriodicEnergy = 0x8;
    kApparentEnergy = 0x10;
    kReactiveEnergy = 0x20;
  }

  shared struct MeasurementAccuracyRangeStruct {
    int64s rangeMin = 0;
    int64s rangeMax = 1;
    optional percent100ths percentMax = 2;
    optional percent100ths percentMin = 3;
    optional percent100ths percentTypical = 4;
    optional int64u fixedMax = 5;
    optional int64u fixedMin = 6;
    optional int64u fixedTypical = 7;
  }

  shared struct MeasurementAccuracyStruct {
    MeasurementTypeEnum measurementType = 0;
    boolean measured = 1;
    int64s minMeasuredValue = 2;
    int64s maxMeasuredValue = 3;
    MeasurementAccuracyRangeStruct accuracyRanges[] = 4;
  }

  struct CumulativeEnergyResetStruct {
    optional nullable epoch_s importedResetTimestamp = 0;
    optional nullable epoch_s exportedResetTimestamp = 1;
    optional nullable systime_ms importedResetSystime = 2;
    optional nullable systime_ms exportedResetSystime = 3;
  }

  struct EnergyMeasurementStruct {
    energy_mwh energy = 0;
    optional epoch_s startTimestamp = 1;
    optional epoch_s endTimestamp = 2;
    optional systime_ms startSystime = 3;
    optional systime_ms endSystime = 4;
    optional energy_mvah apparentEnergy = 5;
    optional energy_mvarh reactiveEnergy = 6;
  }

  info event CumulativeEnergyMeasured = 0 {
    optional EnergyMeasurementStruct energyImported = 0;
    optional EnergyMeasurementStruct energyExported = 1;
  }

  info event PeriodicEnergyMeasured = 1 {
    optional EnergyMeasurementStruct energyImported = 0;
    optional EnergyMeasurementStruct energyExported = 1;
  }

  readonly attribute MeasurementAccuracyStruct accuracy = 0;
  readonly attribute optional nullable EnergyMeasurementStruct cumulativeEnergyImported = 1;
  readonly attribute optional nullable EnergyMeasurementStruct cumulativeEnergyExported = 2;
  readonly attribute optional nullable EnergyMeasurementStruct periodicEnergyImported = 3;
  readonly attribute optional nullable EnergyMeasurementStruct periodicEnergyExported = 4;
  readonly attribute optional nullable CumulativeEnergyResetStruct cumulativeEnergyReset = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster allows a client to manage the power draw of a device. An example of such a client could be an Energy Management System (EMS) which controls an Energy Smart Appliance (ESA). */
provisional cluster DeviceEnergyManagement = 152 {
  revision 4;

  enum AdjustmentCauseEnum : enum8 {
    kLocalOptimization = 0;
    kGridOptimization = 1;
  }

  enum CauseEnum : enum8 {
    kNormalCompletion = 0;
    kOffline = 1;
    kFault = 2;
    kUserOptOut = 3;
    kCancelled = 4;
  }

  enum CostTypeEnum : enum8 {
    kFinancial = 0;
    kGHGEmissions = 1;
    kComfort = 2;
    kTemperature = 3;
  }

  enum ESAStateEnum : enum8 {
    kOffline = 0;
    kOnline = 1;
    kFault = 2;
    kPowerAdjustActive = 3;
    kPaused = 4;
  }

  enum ESATypeEnum : enum8 {
    kEVSE = 0 [spec_name = "EVSE"];
    kSpaceHeating = 1;
    kWaterHeating = 2;
    kSpaceCooling = 3;
    kSpaceHeatingCooling = 4;
    kBatteryStorage = 5;
    kSolarPV = 6;
    kFridgeFreezer = 7;
    kWashingMachine = 8;
    kDishwasher = 9;
    kCooking = 10;
    kHomeWaterPump = 11;
    kIrrigationWaterPump = 12;
    kPoolPump = 13;
    kOther = 255;
  }

  enum ForecastUpdateReasonEnum : enum8 {
    kInternalOptimization = 0;
    kLocalOptimization = 1;
    kGridOptimization = 2;
  }

  enum OptOutStateEnum : enum8 {
    kNoOptOut = 0;
    kLocalOptOut = 1;
    kGridOptOut = 2;
    kOptOut = 3;
  }

  enum PowerAdjustReasonEnum : enum8 {
    kNoAdjustment = 0;
    kLocalOptimizationAdjustment = 1;
    kGridOptimizationAdjustment = 2;
  }

  bitmap Feature : bitmap32 {
    kPowerAdjustment = 0x1;
    kPowerForecastReporting = 0x2;
    kStateForecastReporting = 0x4;
    kStartTimeAdjustment = 0x8;
    kPausable = 0x10;
    kForecastAdjustment = 0x20;
    kConstraintBasedAdjustment = 0x40;
  }

  struct CostStruct {
    CostTypeEnum costType = 0;
    int32s value = 1;
    int8u decimalPoints = 2;
    optional int16u currency = 3;
  }

  struct PowerAdjustStruct {
    power_mw minPower = 0;
    power_mw maxPower = 1;
    elapsed_s minDuration = 2;
    elapsed_s maxDuration = 3;
  }

  struct PowerAdjustCapabilityStruct {
    nullable PowerAdjustStruct powerAdjustCapability[] = 0;
    PowerAdjustReasonEnum cause = 1;
  }

  struct SlotStruct {
    elapsed_s minDuration = 0;
    elapsed_s maxDuration = 1;
    elapsed_s defaultDuration = 2;
    elapsed_s elapsedSlotTime = 3;
    elapsed_s remainingSlotTime = 4;
    optional boolean slotIsPausable = 5;
    optional elapsed_s minPauseDuration = 6;
    optional elapsed_s maxPauseDuration = 7;
    optional int16u manufacturerESAState = 8;
    optional power_mw nominalPower = 9;
    optional power_mw minPower = 10;
    optional power_mw maxPower = 11;
    optional energy_mwh nominalEnergy = 12;
    optional CostStruct costs[] = 13;
    optional power_mw minPowerAdjustment = 14;
    optional power_mw maxPowerAdjustment = 15;
    optional elapsed_s minDurationAdjustment = 16;
    optional elapsed_s maxDurationAdjustment = 17;
  }

  struct ForecastStruct {
    int32u forecastID = 0;
    nullable int16u activeSlotNumber = 1;
    epoch_s startTime = 2;
    epoch_s endTime = 3;
    optional nullable epoch_s earliestStartTime = 4;
    optional epoch_s latestEndTime = 5;
    boolean isPausable = 6;
    SlotStruct slots[] = 7;
    ForecastUpdateReasonEnum forecastUpdateReason = 8;
  }

  struct ConstraintsStruct {
    epoch_s startTime = 0;
    elapsed_s duration = 1;
    optional power_mw nominalPower = 2;
    optional energy_mwh maximumEnergy = 3;
    optional int8s loadControl = 4;
  }

  struct SlotAdjustmentStruct {
    int8u slotIndex = 0;
    optional power_mw nominalPower = 1;
    elapsed_s duration = 2;
  }

  info event PowerAdjustStart = 0 {
  }

  info event PowerAdjustEnd = 1 {
    CauseEnum cause = 0;
    elapsed_s duration = 1;
    energy_mwh energyUse = 2;
  }

  info event Paused = 2 {
  }

  info event Resumed = 3 {
    CauseEnum cause = 0;
  }

  readonly attribute ESATypeEnum ESAType = 0;
  readonly attribute boolean ESACanGenerate = 1;
  readonly attribute ESAStateEnum ESAState = 2;
  readonly attribute power_mw absMinPower = 3;
  readonly attribute power_mw absMaxPower = 4;
  readonly attribute optional nullable PowerAdjustCapabilityStruct powerAdjustmentCapability = 5;
  readonly attribute optional nullable ForecastStruct forecast = 6;
  readonly attribute optional OptOutStateEnum optOutState = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct PowerAdjustRequestRequest {
    power_mw power = 0;
    elapsed_s duration = 1;
    AdjustmentCauseEnum cause = 2;
  }

  request struct StartTimeAdjustRequestRequest {
    epoch_s requestedStartTime = 0;
    AdjustmentCauseEnum cause = 1;
  }

  request struct PauseRequestRequest {
    elapsed_s duration = 0;
    AdjustmentCauseEnum cause = 1;
  }

  request struct ModifyForecastRequestRequest {
    int32u forecastID = 0;
    SlotAdjustmentStruct slotAdjustments[] = 1;
    AdjustmentCauseEnum cause = 2;
  }

  request struct RequestConstraintBasedForecastRequest {
    ConstraintsStruct constraints[] = 0;
    AdjustmentCauseEnum cause = 1;
  }

  /** Allows a client to request an adjustment in the power consumption of an ESA for a specified duration. */
  command PowerAdjustRequest(PowerAdjustRequestRequest): DefaultSuccess = 0;
  /** Allows a client to cancel an ongoing PowerAdjustmentRequest operation. */
  command CancelPowerAdjustRequest(): DefaultSuccess = 1;
  /** Allows a client to adjust the start time of a Forecast sequence that has not yet started operation (i.e. where the current Forecast StartTime is in the future). */
  command StartTimeAdjustRequest(StartTimeAdjustRequestRequest): DefaultSuccess = 2;
  /** Allows a client to temporarily pause an operation and reduce the ESAs energy demand. */
  command PauseRequest(PauseRequestRequest): DefaultSuccess = 3;
  /** Allows a client to cancel the PauseRequest command and enable earlier resumption of operation. */
  command ResumeRequest(): DefaultSuccess = 4;
  /** Allows a client to modify a Forecast within the limits allowed by the ESA. */
  command ModifyForecastRequest(ModifyForecastRequestRequest): DefaultSuccess = 5;
  /** Allows a client to ask the ESA to recompute its Forecast based on power and time constraints. */
  command RequestConstraintBasedForecast(RequestConstraintBasedForecastRequest): DefaultSuccess = 6;
  /** Allows a client to request cancellation of a previous adjustment request in a StartTimeAdjustRequest, ModifyForecastRequest or RequestConstraintBasedForecast command. */
  command CancelRequest(): DefaultSuccess = 7;
}

/** The Power Topology Cluster provides a mechanism for expressing how power is flowing between endpoints. */
cluster PowerTopology = 156 {
  revision 1;

  bitmap Feature : bitmap32 {
    kNodeTopology = 0x1;
    kTreeTopology = 0x2;
    kSetTopology = 0x4;
    kDynamicPowerFlow = 0x8;
  }

  readonly attribute optional endpoint_no availableEndpoints[] = 0;
  readonly attribute optional endpoint_no activeEndpoints[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
provisional cluster DeviceEnergyManagementMode = 159 {
  revision 2;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kNoOptimization = 16384;
    kDeviceOptimization = 16385;
    kLocalOptimization = 16386;
    kGridOptimization = 16387;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  shared struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  shared struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string<64> statusText = 1;
  }

  /** This command is used to change device modes. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

endpoint 0 {
  device type ma_rootdevice = 22, version 3;

  binding cluster OtaSoftwareUpdateProvider;

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    emits event AccessControlExtensionChanged;
    callback attribute acl;
    callback attribute subjectsPerAccessControlEntry;
    callback attribute targetsPerAccessControlEntry;
    callback attribute accessControlEntriesPerFabric;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster BasicInformation {
    callback attribute dataModelRevision;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    callback attribute nodeLabel;
    callback attribute location;
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate;
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    callback attribute localConfigDisabled;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    callback attribute specificationVersion;
    callback attribute maxPathsPerInvoke;
    callback attribute configurationVersion;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster OtaSoftwareUpdateRequestor {
    callback attribute defaultOTAProviders;
    ram      attribute updatePossible default = 1;
    ram      attribute updateState default = 0;
    ram      attribute updateStateProgress default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AnnounceOTAProvider;
  }

  server cluster LocalizationConfiguration {
    persist  attribute activeLocale default = "en-US";
    callback attribute supportedLocales;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UnitLocalization {
    callback attribute temperatureUnit;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig;
    callback attribute locationCapability;
    callback attribute supportsConcurrentConnection;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 2;

    handle command ArmFailSafe;
    handle command ArmFailSafeResponse;
    handle command SetRegulatoryConfig;
    handle command SetRegulatoryConfigResponse;
    handle command CommissioningComplete;
    handle command CommissioningCompleteResponse;
  }

  server cluster NetworkCommissioning {
    callback attribute maxNetworks;
    callback attribute networks;
    callback attribute scanMaxTimeSeconds;
    callback attribute connectMaxTimeSeconds;
    callback attribute interfaceEnabled;
    callback attribute lastNetworkingStatus;
    callback attribute lastNetworkID;
    callback attribute lastConnectErrorValue;
    callback attribute supportedThreadFeatures;
    callback attribute threadVersion;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }

  server cluster DiagnosticLogs {
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command RetrieveLogsRequest;
  }

  server cluster GeneralDiagnostics {
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount;
    callback attribute upTime;
    callback attribute totalOperationalHours;
    callback attribute bootReason;
    callback attribute testEventTriggersEnabled default = false;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command TestEventTrigger;
    handle command TimeSnapshot;
    handle command TimeSnapshotResponse;
  }

  server cluster SoftwareDiagnostics {
    emits event SoftwareFault;
    callback attribute threadMetrics;
    callback attribute currentHeapFree;
    callback attribute currentHeapUsed;
    callback attribute currentHeapHighWatermark;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command ResetWatermarks;
  }

  server cluster ThreadNetworkDiagnostics {
    callback attribute channel;
    callback attribute routingRole;
    callback attribute networkName;
    callback attribute panId;
    callback attribute extendedPanId;
    callback attribute meshLocalPrefix;
    callback attribute overrunCount;
    callback attribute neighborTable;
    callback attribute routeTable;
    callback attribute partitionId;
    callback attribute weighting;
    callback attribute dataVersion;
    callback attribute stableDataVersion;
    callback attribute leaderRouterId;
    callback attribute detachedRoleCount;
    callback attribute childRoleCount;
    callback attribute routerRoleCount;
    callback attribute leaderRoleCount;
    callback attribute attachAttemptCount;
    callback attribute partitionIdChangeCount;
    callback attribute betterPartitionAttachAttemptCount;
    callback attribute parentChangeCount;
    callback attribute txTotalCount;
    callback attribute txUnicastCount;
    callback attribute txBroadcastCount;
    callback attribute txAckRequestedCount;
    callback attribute txAckedCount;
    callback attribute txNoAckRequestedCount;
    callback attribute txDataCount;
    callback attribute txDataPollCount;
    callback attribute txBeaconCount;
    callback attribute txBeaconRequestCount;
    callback attribute txOtherCount;
    callback attribute txRetryCount;
    callback attribute txDirectMaxRetryExpiryCount;
    callback attribute txIndirectMaxRetryExpiryCount;
    callback attribute txErrCcaCount;
    callback attribute txErrAbortCount;
    callback attribute txErrBusyChannelCount;
    callback attribute rxTotalCount;
    callback attribute rxUnicastCount;
    callback attribute rxBroadcastCount;
    callback attribute rxDataCount;
    callback attribute rxDataPollCount;
    callback attribute rxBeaconCount;
    callback attribute rxBeaconRequestCount;
    callback attribute rxOtherCount;
    callback attribute rxAddressFilteredCount;
    callback attribute rxDestAddrFilteredCount;
    callback attribute rxDuplicatedCount;
    callback attribute rxErrNoFrameCount;
    callback attribute rxErrUnknownNeighborCount;
    callback attribute rxErrInvalidSrcAddrCount;
    callback attribute rxErrSecCount;
    callback attribute rxErrFcsCount;
    callback attribute rxErrOtherCount;
    callback attribute activeTimestamp;
    callback attribute pendingTimestamp;
    callback attribute delay;
    callback attribute securityPolicy;
    callback attribute channelPage0Mask;
    callback attribute operationalDatasetComponents;
    callback attribute activeNetworkFaultsList;
    ram      attribute featureMap default = 0x000F;
    ram      attribute clusterRevision default = 2;

    handle command ResetCounts;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus;
    callback attribute adminFabricIndex;
    callback attribute adminVendorId;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision;

    handle command OpenCommissioningWindow;
    handle command OpenBasicCommissioningWindow;
    handle command RevokeCommissioning;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AttestationRequest;
    handle command AttestationResponse;
    handle command CertificateChainRequest;
    handle command CertificateChainResponse;
    handle command CSRRequest;
    handle command CSRResponse;
    handle command AddNOC;
    handle command UpdateNOC;
    handle command NOCResponse;
    handle command UpdateFabricLabel;
    handle command RemoveFabric;
    handle command AddTrustedRootCertificate;
    handle command SetVIDVerificationStatement;
    handle command SignVIDVerificationRequest;
    handle command SignVIDVerificationResponse;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command KeySetWrite;
    handle command KeySetRead;
    handle command KeySetReadResponse;
    handle command KeySetRemove;
    handle command KeySetReadAllIndices;
    handle command KeySetReadAllIndicesResponse;
  }

  server cluster UserLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 1 {
  device type ma_dishwasher = 117, version 2;


  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 0x0005;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster Binding {
    callback attribute binding;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OperationalState {
    callback attribute phaseList;
    callback attribute currentPhase;
    callback attribute operationalStateList;
    callback attribute operationalState;
    callback attribute operationalError;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command Pause;
    handle command Stop;
    handle command Start;
    handle command Resume;
    handle command OperationalCommandResponse;
  }
}
endpoint 2 {
  device type ma_electricalsensor = 1296, version 1;


  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster ElectricalPowerMeasurement {
    emits event MeasurementPeriodRanges;
    callback attribute powerMode;
    callback attribute numberOfMeasurementTypes;
    callback attribute accuracy;
    callback attribute ranges;
    callback attribute voltage;
    callback attribute activeCurrent;
    callback attribute reactiveCurrent;
    callback attribute apparentCurrent;
    callback attribute activePower;
    callback attribute reactivePower;
    callback attribute apparentPower;
    callback attribute RMSVoltage;
    callback attribute RMSCurrent;
    callback attribute RMSPower;
    callback attribute frequency;
    callback attribute harmonicCurrents;
    callback attribute harmonicPhases;
    callback attribute powerFactor;
    callback attribute neutralCurrent;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ElectricalEnergyMeasurement {
    emits event CumulativeEnergyMeasured;
    callback attribute accuracy;
    callback attribute cumulativeEnergyImported;
    callback attribute cumulativeEnergyReset;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster PowerTopology {
    callback attribute availableEndpoints;
    callback attribute activeEndpoints;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 3 {
  device type device_energy_management = 1293, version 1;


  server cluster DeviceEnergyManagement {
    emits event PowerAdjustStart;
    emits event PowerAdjustEnd;
    emits event Paused;
    emits event Resumed;
    callback attribute ESAType;
    callback attribute ESACanGenerate;
    callback attribute ESAState;
    callback attribute absMinPower;
    callback attribute absMaxPower;
    callback attribute powerAdjustmentCapability;
    callback attribute forecast;
    callback attribute optOutState;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 3;

    handle command PowerAdjustRequest;
    handle command CancelPowerAdjustRequest;
    handle command StartTimeAdjustRequest;
    handle command PauseRequest;
    handle command ResumeRequest;
    handle command ModifyForecastRequest;
    handle command RequestConstraintBasedForecast;
    handle command CancelRequest;
  }

  server cluster DeviceEnergyManagementMode {
    callback attribute supportedModes;
    callback attribute currentMode;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;

    handle command ChangeToMode;
    handle command ChangeToModeResponse;
  }
}


