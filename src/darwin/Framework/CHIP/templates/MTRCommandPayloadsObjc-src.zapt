{{> header excludeZapComment=true}}

{{> command_payload_impl_imports privateOrInternal="Internal"}}

NS_ASSUME_NONNULL_BEGIN

static void LogAndConvertDecodingError(CHIP_ERROR err, NSError * __autoreleasing * error) {
  NSString * errorStr = [NSString stringWithFormat:@"Command payload decoding failed: %s", err.AsString()];
  MTR_LOG_ERROR("%s", errorStr.UTF8String);
  if (error != nil) {
    NSDictionary * userInfo = @ { NSLocalizedFailureReasonErrorKey : NSLocalizedString(errorStr, nil) };
    *error = [NSError errorWithDomain:MTRErrorDomain code:MTRErrorCodeSchemaMismatch userInfo:userInfo];
  }
}

{{#zcl_clusters}}
{{#zcl_commands}}
{{#*inline "completeImpl"}}
{{#if (isSupported cluster command=command isForCommandPayload=true)}}
@implementation MTR{{cluster}}Cluster{{command}}Params
{{> command_params_init_impl}}

{{> command_params_copy_impl cluster=cluster command=command}}

{{> command_params_description_impl}}
{{#zcl_command_arguments}}
{{#if (and includeRenamedProperties
           (hasOldName ../cluster command=../command commandField=(asStructPropertyName label)))}}

{{> renamed_struct_field_impl cluster=parent.parent.name type=type newName=label oldName=(oldName ../cluster command=../command commandField=(asStructPropertyName label))}}
{{/if}}
{{/zcl_command_arguments}}

{{#if (isStrEqual source "server")}}
- (nullable instancetype)initWithResponseValue:(NSDictionary<NSString *, id> *)responseValue
                                         error:(NSError * __autoreleasing *)error
{
  if (!(self = [super init])) {
    return nil;
  }

  using DecodableType = chip::app::Clusters::{{asUpperCamelCase parent.name}}::Commands::{{asUpperCamelCase name}}::DecodableType;
  chip::System::PacketBufferHandle buffer = [MTRBaseDevice _responseDataForCommand:responseValue
                                                                         clusterID:DecodableType::GetClusterId()
                                                                         commandID:DecodableType::GetCommandId()
                                                                             error:error];
  if (buffer.IsNull()) {
    return nil;
  }

  chip::TLV::TLVReader reader;
  reader.Init(buffer->Start(), buffer->DataLength());

  CHIP_ERROR err = reader.Next(chip::TLV::AnonymousTag());
  if (err == CHIP_NO_ERROR) {
    DecodableType decodedStruct;
    err = chip::app::DataModel::Decode(reader, decodedStruct);
    if (err == CHIP_NO_ERROR) {
      err = [self _setFieldsFromDecodableStruct:decodedStruct];
      {{#if (and (isStrEqual (asUpperCamelCase parent.name preserveAcronyms=true) "OperationalCredentials")
                 (isStrEqual (asUpperCamelCase name preserveAcronyms=true) "AttestationResponse"))}}
      if (err == CHIP_NO_ERROR) {
        do {
          // AttestationResponse has an extra attestationChallenge field.  Once we
          // have some sort of more direct decoding from the responseValue, we can
          // probably make this less hardcoded.
          //
          // It might be simpler to look for the right profile tag in the TLV, but let's stick to examining
          // the responseValue we were handed.
          id data = responseValue[MTRDataKey];
          if (![data isKindOfClass:NSDictionary.class]) {
            err = CHIP_ERROR_INVALID_ARGUMENT;
            break;
          }

          NSDictionary * dataDictionary = data;
          if (dataDictionary[MTRTypeKey] == nil ||
              ![dataDictionary[MTRTypeKey] isKindOfClass:NSString.class] ||
              ![dataDictionary[MTRTypeKey] isEqualToString:MTRStructureValueType]) {
            err = CHIP_ERROR_INVALID_ARGUMENT;
            break;
          }

          id value = dataDictionary[MTRValueKey];
          if (value == nil || ![value isKindOfClass:NSArray.class]) {
            err = CHIP_ERROR_INVALID_ARGUMENT;
            break;
          }

          NSArray * valueArray = value;
          for (id item in valueArray) {
            if (![item isKindOfClass:NSDictionary.class]) {
                err = CHIP_ERROR_INVALID_ARGUMENT;
                break;
            }

            NSDictionary * itemDictionary = item;
            id contextTag = itemDictionary[MTRContextTagKey];
            if (contextTag == nil || ![contextTag isKindOfClass:NSNumber.class]) {
              err = CHIP_ERROR_INVALID_ARGUMENT;
              break;
            }

            NSNumber * contextTagNumber = contextTag;
            if (![contextTagNumber isEqualToNumber:@(kAttestationChallengeTagValue)]) {
              // Not the right field; keep going.
              continue;
            }

            id data = itemDictionary[MTRDataKey];
            if (data == nil || ![data isKindOfClass:NSDictionary.class]) {
              err = CHIP_ERROR_INVALID_ARGUMENT;
              break;
            }

            NSDictionary * dataDictionary = data;
            id dataType = dataDictionary[MTRTypeKey];
            id dataValue = dataDictionary[MTRValueKey];
            if (dataType == nil || dataValue == nil ||
                ![dataType isKindOfClass:NSString.class] ||
                ![dataValue isKindOfClass:NSData.class]) {
              err = CHIP_ERROR_INVALID_ARGUMENT;
              break;
            }

            NSString * dataTypeString = dataType;
            if (![dataTypeString isEqualToString:MTROctetStringValueType]) {
              err = CHIP_ERROR_INVALID_ARGUMENT;
              break;
            }

            self.attestationChallenge = dataValue;
            break;
          }

          // Do not add code here without first checking whether err is success.
        } while (0);
      }
      {{/if}}
      if (err == CHIP_NO_ERROR) {
        return self;
      }
    }
  }

  LogAndConvertDecodingError(err, error);
  return nil;
}
{{/if}}

@end
{{/if}}
{{/inline}}
{{#*inline "oldNameImpl"}}
{{#if (isSupported cluster command=command isForCommandPayload=true)}}

@implementation MTR{{cluster}}Cluster{{command}}Params
{{#zcl_command_arguments}}
{{#if (isSupported ../cluster command=../command commandField=(asStructPropertyName label))}}
@dynamic {{asStructPropertyName label}};
{{/if}}
{{/zcl_command_arguments}}

{{#if (isStrEqual source "client")}}
@dynamic timedInvokeTimeoutMs;
@dynamic serverSideProcessingTimeout;
{{else if (wasIntroducedBeforeRelease "267F4B03-3256-4056-A62D-5237640FDCFE" cluster command=command)}}
@dynamic timedInvokeTimeoutMs;
{{/if}}
@end
{{/if}}
{{/inline}}
{{#if (isSupported (asUpperCamelCase parent.name preserveAcronyms=true) command=(asUpperCamelCase name preserveAcronyms=true) isForCommandPayload=true)}}
{{#unless (isInConfigList (asUpperCamelCase parent.name preserveAcronyms=true) "DarwinPrivateClusters")}}
{{> completeImpl cluster=(asUpperCamelCase parent.name preserveAcronyms=true)
                 command=(asUpperCamelCase name preserveAcronyms=true)
                 includeRenamedProperties=false}}

{{> command_params_internal_methods cluster=(asUpperCamelCase parent.name preserveAcronyms=true) command=(asUpperCamelCase name preserveAcronyms=true) categoryName="InternalMethods"}}

{{> command_old_name_impl}}
{{> command_deprecated_fields_impl cluster=(asUpperCamelCase parent.name preserveAcronyms=true) command=(asUpperCamelCase name preserveAcronyms=true)}}
{{/unless}}
{{else}}
{{> completeImpl cluster=(compatClusterNameRemapping parent.name)
                 command=(compatCommandNameRemapping parent.name name)
                 includeRenamedProperties=true}}
{{/if}}
{{/zcl_commands}}
{{/zcl_clusters}}

// MTRBasicClusterMfgSpecificPingParams doesn't need to actually work.
@implementation MTRBasicClusterMfgSpecificPingParams (InternalMethods)
- (NSDictionary<NSString *, id> * _Nullable)_encodeAsDataValue:(NSError * __autoreleasing *)error
{
    if (error) {
        *error = [MTRError errorForCHIPErrorCode:CHIP_ERROR_INCORRECT_STATE];
    }
    return nil;
}
@end


NS_ASSUME_NONNULL_END
