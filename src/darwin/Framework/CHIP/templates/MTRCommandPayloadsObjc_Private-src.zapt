{{> header excludeZapComment=true}}

#import "MTRCommandPayloadsObjc.h"
#import "MTRCommandPayloads_Private.h"
#import "MTRCommandPayloadExtensions_Internal.h"
#import "MTRBaseDevice_Internal.h"
#import "MTRDefines_Internal.h"
#import "MTRError_Internal.h"
#import "MTRLogging_Internal.h"
#import "NSStringSpanConversion.h"
#import "NSDataSpanConversion.h"
#import "MTRBackwardsCompatShims.h"

#include <app/data-model/Decode.h>
#include <lib/core/TLV.h>
#include <app/data-model/ListLargeSystemExtensions.h>
#include <lib/support/CodeUtils.h>
#include <system/TLVPacketBufferBackingStore.h>

NS_ASSUME_NONNULL_BEGIN

static void LogAndConvertDecodingError(CHIP_ERROR err, NSError * __autoreleasing * error) __attribute__((unused));
static void LogAndConvertDecodingError(CHIP_ERROR err, NSError * __autoreleasing * error) {
  NSString * errorStr = [NSString stringWithFormat:@"Command payload decoding failed: %s", err.AsString()];
  MTR_LOG_ERROR("%s", errorStr.UTF8String);
  if (error != nil) {
    NSDictionary * userInfo = @ { NSLocalizedFailureReasonErrorKey : NSLocalizedString(errorStr, nil) };
    *error = [NSError errorWithDomain:MTRErrorDomain code:MTRErrorCodeSchemaMismatch userInfo:userInfo];
  }
}

{{#zcl_clusters}}
{{#if (isInConfigList (asUpperCamelCase name preserveAcronyms=true) "DarwinPrivateClusters")}}
{{#zcl_commands}}
{{#if (isSupported (asUpperCamelCase parent.name preserveAcronyms=true) command=(asUpperCamelCase name preserveAcronyms=true) isForCommandPayload=true)}}

@implementation MTR{{asUpperCamelCase parent.name preserveAcronyms=true}}Cluster{{asUpperCamelCase name preserveAcronyms=true}}Params
- (instancetype)init
{
  if (self = [super init]) {
{{#zcl_command_arguments}}

    {{>init_struct_member label=label type=type cluster=parent.parent.name}}
{{/zcl_command_arguments}}
{{#if (or (isStrEqual source "client")
          (wasIntroducedBeforeRelease "267F4B03-3256-4056-A62D-5237640FDCFE" (compatClusterNameRemapping parent.name) command=(compatCommandNameRemapping parent.name name)))}}
    _timedInvokeTimeoutMs = nil;
{{/if}}
{{#if (isStrEqual source "client")}}
    _serverSideProcessingTimeout = nil;
{{/if}}
  }
  return self;
}

- (id)copyWithZone:(NSZone * _Nullable)zone;
{
  auto other = [[MTR{{asUpperCamelCase parent.name preserveAcronyms=true}}Cluster{{asUpperCamelCase name preserveAcronyms=true}}Params alloc] init];

  {{#zcl_command_arguments}}
  other.{{asStructPropertyName label}} = self.{{asStructPropertyName label}};
  {{/zcl_command_arguments}}
{{#if (or (isStrEqual source "client")
          (wasIntroducedBeforeRelease "267F4B03-3256-4056-A62D-5237640FDCFE" (compatClusterNameRemapping parent.name) command=(compatCommandNameRemapping parent.name name)))}}
  other.timedInvokeTimeoutMs = self.timedInvokeTimeoutMs;
{{/if}}
{{#if (isStrEqual source "client")}}
  other.serverSideProcessingTimeout = self.serverSideProcessingTimeout;
{{/if}}

  return other;
}

- (NSString *)description
{
  NSString *descriptionString = [NSString stringWithFormat:@"<%@: {{#zcl_command_arguments}}{{asStructPropertyName label}}:%@; {{/zcl_command_arguments}}>", NSStringFromClass([self class]) {{#zcl_command_arguments}},{{#if isArray}}_{{asStructPropertyName label}}{{else if (isOctetString type)}}[_{{asStructPropertyName label}} base64EncodedStringWithOptions:0]{{else}}_{{asStructPropertyName label}}{{/if}}{{/zcl_command_arguments}}];
  return descriptionString;
}

{{#if (isStrEqual source "server")}}
- (nullable instancetype)initWithResponseValue:(NSDictionary<NSString *, id> *)responseValue
                                         error:(NSError * __autoreleasing *)error
{
  if (!(self = [super init])) {
    return nil;
  }

  using DecodableType = chip::app::Clusters::{{asUpperCamelCase parent.name}}::Commands::{{asUpperCamelCase name}}::DecodableType;
  chip::System::PacketBufferHandle buffer = [MTRBaseDevice _responseDataForCommand:responseValue
                                                                         clusterID:DecodableType::GetClusterId()
                                                                         commandID:DecodableType::GetCommandId()
                                                                             error:error];
  if (buffer.IsNull()) {
    return nil;
  }

  chip::TLV::TLVReader reader;
  reader.Init(buffer->Start(), buffer->DataLength());

  CHIP_ERROR err = reader.Next(chip::TLV::AnonymousTag());
  if (err == CHIP_NO_ERROR) {
    DecodableType decodedStruct;
    err = chip::app::DataModel::Decode(reader, decodedStruct);
    if (err == CHIP_NO_ERROR) {
      err = [self _setFieldsFromDecodableStruct:decodedStruct];
      if (err == CHIP_NO_ERROR) {
        return self;
      }
    }
  }

  LogAndConvertDecodingError(err, error);
  return nil;
}
{{/if}}

@end

{{/if}}
@implementation MTR{{asUpperCamelCase parent.name preserveAcronyms=true}}Cluster{{asUpperCamelCase name preserveAcronyms=true}}Params (PrivateMethods)

{{#if (isStrEqual source "server")}}
- (nullable instancetype)initWithDecodableStruct:(const chip::app::Clusters::{{asUpperCamelCase parent.name}}::Commands::{{asUpperCamelCase name}}::DecodableType &)decodableStruct
{
  if (!(self = [super init])) {
    return nil;
  }

  CHIP_ERROR err = [self _setFieldsFromDecodableStruct:decodableStruct];
  if (err == CHIP_NO_ERROR) {
    return self;
  }

  LogAndConvertDecodingError(err, nil);
  return nil;
}

- (CHIP_ERROR)_setFieldsFromDecodableStruct:(const chip::app::Clusters::{{asUpperCamelCase parent.name}}::Commands::{{asUpperCamelCase name}}::DecodableType &)decodableStruct
{
  {{#zcl_command_arguments}}
  {
    {{>decode_value target=(concat "self." (asStructPropertyName label)) source=(concat "decodableStruct." (asLowerCamelCase label)) cluster=parent.parent.name errorCode="return err;" depth=0}}
  }
  {{/zcl_command_arguments}}
  return CHIP_NO_ERROR;
}
{{/if}}

{{#if (isStrEqual source "client")}}
- (CHIP_ERROR)_encodeToTLVReader:(chip::System::PacketBufferTLVReader &)reader
{
  chip::app::Clusters::{{asUpperCamelCase parent.name}}::Commands::{{asUpperCamelCase name}}::Type encodableStruct;
  ListFreer listFreer;
  {{#zcl_command_arguments}}
  {
    {{>encode_value target=(concat "encodableStruct." (asLowerCamelCase label)) source=(concat "self." (asStructPropertyName label)) cluster=parent.parent.name errorCode="return CHIP_ERROR_INVALID_ARGUMENT;" depth=0}}
  }
  {{/zcl_command_arguments}}

  auto buffer = chip::System::PacketBufferHandle::New(chip::System::PacketBuffer::kMaxSizeWithoutReserve, 0);
  if (buffer.IsNull()) {
    return CHIP_ERROR_NO_MEMORY;
  }

  chip::System::PacketBufferTLVWriter writer;
  // Commands never need chained buffers, since they cannot be chunked.
  writer.Init(std::move(buffer), /* useChainedBuffers = */ false);

  ReturnErrorOnFailure(chip::app::DataModel::Encode(writer, chip::TLV::AnonymousTag(), encodableStruct));

  ReturnErrorOnFailure(writer.Finalize(&buffer));

  reader.Init(std::move(buffer));
  return reader.Next(chip::TLV::kTLVType_Structure, chip::TLV::AnonymousTag());
}

- (NSDictionary<NSString *, id> * _Nullable)_encodeAsDataValue:(NSError * __autoreleasing *)error
{
  chip::System::PacketBufferTLVReader reader;
  CHIP_ERROR err = [self _encodeToTLVReader:reader];
  if (err != CHIP_NO_ERROR) {
    if (error) {
      *error = [MTRError errorForCHIPErrorCode:err];
    }
    return nil;
  }

  auto decodedObj = MTRDecodeDataValueDictionaryFromCHIPTLV(&reader);
  if (decodedObj == nil) {
    if (error) {
      *error = [MTRError errorForCHIPErrorCode:CHIP_ERROR_INCORRECT_STATE];
    }
  }
  return decodedObj;
}
{{/if}}
@end

{{/zcl_commands}}
{{/if}}
{{/zcl_clusters}}

NS_ASSUME_NONNULL_END
