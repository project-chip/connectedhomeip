{{> header}}

#import <Foundation/Foundation.h>

#import "MTRAttributeCacheContainer_Internal.h"
#import "MTRBaseDevice_internal.h"
#import "MTRClusterConstants.h"
#import "MTRClusters_internal.h"
#import "MTRDevice.h"
#import "MTRDevice_Internal.h"
#import "MTRCallbackBridge_internal.h"
#import "MTRCluster_internal.h"
#import "MTRStructsObjc.h"
#import "MTRCommandPayloadsObjc.h"

#include <lib/support/CHIPListUtils.h>
#include <platform/CHIPDeviceLayer.h>
#include <type_traits>

using chip::Callback::Callback;
using chip::Callback::Cancelable;
using namespace chip::app::Clusters;
// NOLINTBEGIN(clang-analyzer-cplusplus.NewDeleteLeaks): Linter is unable to locate the delete on these objects.
{{#chip_client_clusters includeAll=true}}
@implementation MTRCluster{{asUpperCamelCase name}}

- (instancetype)initWithDevice:(MTRDevice *)device endpoint:(uint16_t)endpoint queue:(dispatch_queue_t)queue
{
    if (self = [super initWithQueue:queue]) {
        if (device == nil) {
            return nil;
        }

        _endpoint = endpoint;
        _device = device;
    }
    return self;
}

- (void)connectAndPerformAsync:(void (^)(chip::Controller::{{asUpperCamelCase name}}Cluster * cppCluster))asyncBlock
{
    [self.device connectAndPerformAsync:^(MTRBaseDevice * baseDevice) {
        chip::DeviceProxy * internalDevice = [baseDevice internalDevice];
        chip::Controller::{{asUpperCamelCase name}}Cluster *cppCluster = new chip::Controller::{{asUpperCamelCase name}}Cluster(* internalDevice->GetExchangeManager(), internalDevice->GetSecureSession().Value(), self.endpoint);
        asyncBlock(cppCluster);
    }];
}

{{#chip_cluster_commands}}
{{#*inline "callbackName"}}{{#if hasSpecificResponse}}{{asUpperCamelCase parent.name}}Cluster{{asUpperCamelCase responseName}}{{else}}CommandSuccess{{/if}}{{/inline}}
{{#unless (hasArguments)}}
- (void){{asLowerCamelCase name}}WithExpectedValues:(NSArray<NSDictionary<NSString *, id> *> *)expectedValues expectedValueInterval:(NSNumber *)expectedValueIntervalMs completionHandler:({{>command_completion_type command=.}})completionHandler
{
  [self {{asLowerCamelCase name}}WithParams:nil expectedValues:expectedValues expectedValueInterval:expectedValueIntervalMs completionHandler:completionHandler];
}
{{/unless}}
- (void){{asLowerCamelCase name}}WithParams: (MTR{{asUpperCamelCase parent.name}}Cluster{{asUpperCamelCase name}}Params * {{#unless (commandHasRequiredField .)}}_Nullable{{/unless}})params expectedValues:(NSArray<NSDictionary<NSString *, id> *> *)expectedValues expectedValueInterval:(NSNumber *)expectedValueIntervalMs completionHandler:({{>command_completion_type command=.}})completionHandler
{
    NSDate *waitStartTime = [NSDate date];
    [self connectAndPerformAsync:^(chip::Controller::{{asUpperCamelCase parent.name}}Cluster * cppCluster) {
        ListFreer listFreer;
        {{asUpperCamelCase parent.name}}::Commands::{{asUpperCamelCase name}}::Type request;
        {{#chip_cluster_command_arguments}}
          {{#first}}
            {{#unless (commandHasRequiredField parent)}}
            if (params != nil) {
            {{/unless}}
          {{/first}}
          {{>encode_value target=(concat "request." (asLowerCamelCase label)) source=(concat "params." (asStructPropertyName label)) cluster=parent.parent.name errorCode="return;" depth=0}}
          {{#last}}
            {{#unless (commandHasRequiredField parent)}}
            }
           {{/unless}}
          {{/last}}
        {{/chip_cluster_command_arguments}}

        new MTR{{>callbackName}}CallbackBridge(self.callbackQueue,
          {{#if hasSpecificResponse}}
            {{! This treats completionHandler as taking an id for the data.  This is
                not great from a type-safety perspective, of course. }}
            completionHandler,
          {{else}}
            {{! For now, don't change the bridge API; instead just use an adapter
                to invoke our completion handler. This is not great from a
                type-safety perspective, of course. }}
            ^(id _Nullable value, NSError * _Nullable error) {
              completionHandler(error);
            },
          {{/if}}
          ^(Cancelable * success, Cancelable * failure) {
            {{! convert seconds to ms and calculate how much timeout is left for work }}
            NSNumber *waitTimeInMs = params.timedInvokeTimeoutMs;
            {{#if mustUseTimedInvoke}}
            if (!waitTimeInMs) {
                waitTimeInMs = @(10000);
            }
            {{/if}}
            NSTimeInterval timeSinceWaitStartInMs = [[NSDate date] timeIntervalSinceDate:waitStartTime] * 1000;
            if (waitTimeInMs && waitTimeInMs.unsignedShortValue < timeSinceWaitStartInMs) {
                return CHIP_ERROR_TIMEOUT;
            }

            unsigned short newWaitTimeInMs = waitTimeInMs.unsignedShortValue - timeSinceWaitStartInMs;

            chip::Optional<uint16_t> timedInvokeTimeoutMs;
            if (waitTimeInMs) {
                timedInvokeTimeoutMs.SetValue(newWaitTimeInMs);
            }

            auto successFn = Callback<{{>callbackName}}CallbackType>::FromCancelable(success);
            auto failureFn = Callback<DefaultFailureCallbackType>::FromCancelable(failure);
            return cppCluster->InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, timedInvokeTimeoutMs);
        });

        [self.device setExpectedValues:expectedValues expectedValueInterval:expectedValueIntervalMs];
    }];
}
{{/chip_cluster_commands}}

{{#chip_server_cluster_attributes}}
{{#*inline "attribute"}}Attribute{{asUpperCamelCase name}}{{/inline}}
- (NSDictionary<NSString *, id> *)read{{>attribute}}WithParams:(MTRReadParams * _Nullable)params {
    return [self.device readAttributeWithEndpointId:@(_endpoint) clusterId:@(MTRCluster{{asUpperCamelCase parent.name}}ID) attributeId:@(MTRCluster{{asUpperCamelCase parent.name}}Attribute{{asUpperCamelCase name}}ID) params:params];
}

{{#if isWritableAttribute}}
{{#*inline "callbackName"}}DefaultSuccess{{/inline}}
- (void)write{{>attribute}}WithValue:(NSDictionary<NSString *, id> *)dataValueDictionary expectedValueInterval:(NSNumber *)expectedValueIntervalMs
{
  [self write{{>attribute}}WithValue:dataValueDictionary expectedValueInterval:expectedValueIntervalMs params:nil];
}
- (void)write{{>attribute}}WithValue:(NSDictionary<NSString *, id> *)dataValueDictionary expectedValueInterval:(NSNumber *)expectedValueIntervalMs params:(MTRWriteParams * _Nullable)params
{
    NSNumber *waitTimeInMs = params.timedWriteTimeout;
    {{#if mustUseTimedInvoke}}
    if (!waitTimeInMs) {
        waitTimeInMs = @(10000);
    }
    {{/if}}

    [self.device writeAttributeWithEndpointId:@(_endpoint) clusterId:@(MTRCluster{{asUpperCamelCase parent.name}}ID) attributeId:@(MTRCluster{{asUpperCamelCase parent.name}}Attribute{{asUpperCamelCase name}}ID) value:dataValueDictionary expectedValueInterval:expectedValueIntervalMs timedWriteTimeout:waitTimeInMs];
}

{{/if}}

{{/chip_server_cluster_attributes}}

@end

{{/chip_client_clusters}}
// NOLINTEND(clang-analyzer-cplusplus.NewDeleteLeaks)
