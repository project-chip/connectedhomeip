/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#import "CHIPCallbackBridge_internal.h"
#import "CHIPCommandPayloadsObjc.h"
#import "CHIPStructsObjc.h"

#include <lib/support/TypeTraits.h>

void CHIPDefaultSuccessCallbackBridge::OnSuccessFn(void * context) { DispatchSuccess(context, nil); };

void CHIPCommandSuccessCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::NullObjectType &)
{
    DispatchSuccess(context, nil);
};

void CHIPOctetStringAttributeCallbackBridge::OnSuccessFn(void * context, chip::ByteSpan value)
{
    NSData * _Nonnull objCValue;
    objCValue = [NSData dataWithBytes:value.data() length:value.size()];
    DispatchSuccess(context, objCValue);
};

void CHIPOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOctetStringAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOctetStringAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & value)
{
    NSData * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSData dataWithBytes:value.Value().data() length:value.Value().size()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableOctetStringAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPCharStringAttributeCallbackBridge::OnSuccessFn(void * context, chip::CharSpan value)
{
    NSString * _Nonnull objCValue;
    objCValue = [[NSString alloc] initWithBytes:value.data() length:value.size() encoding:NSUTF8StringEncoding];
    DispatchSuccess(context, objCValue);
};

void CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPCharStringAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableCharStringAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & value)
{
    NSString * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [[NSString alloc] initWithBytes:value.Value().data() length:value.Value().size() encoding:NSUTF8StringEncoding];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableCharStringAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBooleanAttributeCallbackBridge::OnSuccessFn(void * context, bool value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithBool:value];
    DispatchSuccess(context, objCValue);
};

void CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBooleanAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableBooleanAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<bool> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithBool:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableBooleanAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPInt8uAttributeCallbackBridge::OnSuccessFn(void * context, uint8_t value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:value];
    DispatchSuccess(context, objCValue);
};

void CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPInt8uAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableInt8uAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<uint8_t> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableInt8uAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPInt8sAttributeCallbackBridge::OnSuccessFn(void * context, int8_t value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithChar:value];
    DispatchSuccess(context, objCValue);
};

void CHIPInt8sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPInt8sAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableInt8sAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<int8_t> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithChar:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableInt8sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableInt8sAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPInt16uAttributeCallbackBridge::OnSuccessFn(void * context, uint16_t value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedShort:value];
    DispatchSuccess(context, objCValue);
};

void CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPInt16uAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableInt16uAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<uint16_t> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedShort:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableInt16uAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPInt16sAttributeCallbackBridge::OnSuccessFn(void * context, int16_t value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithShort:value];
    DispatchSuccess(context, objCValue);
};

void CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPInt16sAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableInt16sAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<int16_t> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithShort:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableInt16sAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPInt32uAttributeCallbackBridge::OnSuccessFn(void * context, uint32_t value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedInt:value];
    DispatchSuccess(context, objCValue);
};

void CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPInt32uAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableInt32uAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<uint32_t> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedInt:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableInt32uAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPInt32sAttributeCallbackBridge::OnSuccessFn(void * context, int32_t value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithInt:value];
    DispatchSuccess(context, objCValue);
};

void CHIPInt32sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPInt32sAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableInt32sAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<int32_t> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithInt:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableInt32sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableInt32sAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPInt64uAttributeCallbackBridge::OnSuccessFn(void * context, uint64_t value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedLongLong:value];
    DispatchSuccess(context, objCValue);
};

void CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPInt64uAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableInt64uAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<uint64_t> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedLongLong:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableInt64uAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPInt64sAttributeCallbackBridge::OnSuccessFn(void * context, int64_t value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithLongLong:value];
    DispatchSuccess(context, objCValue);
};

void CHIPInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPInt64sAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableInt64sAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<int64_t> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithLongLong:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableInt64sAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPFloatAttributeCallbackBridge::OnSuccessFn(void * context, float value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithFloat:value];
    DispatchSuccess(context, objCValue);
};

void CHIPFloatAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPFloatAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableFloatAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<float> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithFloat:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableFloatAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableFloatAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoubleAttributeCallbackBridge::OnSuccessFn(void * context, double value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithDouble:value];
    DispatchSuccess(context, objCValue);
};

void CHIPDoubleAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoubleAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoubleAttributeCallbackBridge::OnSuccessFn(void * context, const chip::app::DataModel::Nullable<double> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithDouble:value.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoubleAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoubleAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPVendorIdAttributeCallbackBridge::OnSuccessFn(void * context, chip::VendorId value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedShort:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPVendorIdAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPVendorIdAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableVendorIdAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::VendorId> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedShort:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableVendorIdAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableVendorIdAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccessControlAclListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPAccessControlClusterAccessControlEntry * newElement_0;
        newElement_0 = [CHIPAccessControlClusterAccessControlEntry new];
        newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
        newElement_0.privilege = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.privilege)];
        newElement_0.authMode = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.authMode)];
        if (entry_0.subjects.IsNull()) {
            newElement_0.subjects = nil;
        } else {
            auto * array_3 = [NSMutableArray new];
            auto iter_3 = entry_0.subjects.Value().begin();
            while (iter_3.Next()) {
                auto & entry_3 = iter_3.GetValue();
                NSNumber * newElement_3;
                newElement_3 = [NSNumber numberWithUnsignedLongLong:entry_3];
                [array_3 addObject:newElement_3];
            }
            { // Scope for the error so we will know what it's named
                CHIP_ERROR err = iter_3.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    OnFailureFn(context, err);
                    return;
                }
            }
            newElement_0.subjects = array_3;
        }
        if (entry_0.targets.IsNull()) {
            newElement_0.targets = nil;
        } else {
            auto * array_3 = [NSMutableArray new];
            auto iter_3 = entry_0.targets.Value().begin();
            while (iter_3.Next()) {
                auto & entry_3 = iter_3.GetValue();
                CHIPAccessControlClusterTarget * newElement_3;
                newElement_3 = [CHIPAccessControlClusterTarget new];
                if (entry_3.cluster.IsNull()) {
                    newElement_3.cluster = nil;
                } else {
                    newElement_3.cluster = [NSNumber numberWithUnsignedInt:entry_3.cluster.Value()];
                }
                if (entry_3.endpoint.IsNull()) {
                    newElement_3.endpoint = nil;
                } else {
                    newElement_3.endpoint = [NSNumber numberWithUnsignedShort:entry_3.endpoint.Value()];
                }
                if (entry_3.deviceType.IsNull()) {
                    newElement_3.deviceType = nil;
                } else {
                    newElement_3.deviceType = [NSNumber numberWithUnsignedInt:entry_3.deviceType.Value()];
                }
                [array_3 addObject:newElement_3];
            }
            { // Scope for the error so we will know what it's named
                CHIP_ERROR err = iter_3.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    OnFailureFn(context, err);
                    return;
                }
            }
            newElement_0.targets = array_3;
        }
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAccessControlAclListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccessControlAclListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccessControlExtensionListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPAccessControlClusterExtensionEntry * newElement_0;
        newElement_0 = [CHIPAccessControlClusterExtensionEntry new];
        newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
        newElement_0.data = [NSData dataWithBytes:entry_0.data.data() length:entry_0.data.size()];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAccessControlExtensionListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccessControlExtensionListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccessControlServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAccessControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccessControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccessControlClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAccessControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccessControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccessControlAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAccessControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccessControlAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccountLoginServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAccountLoginServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccountLoginServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccountLoginClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAccountLoginClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccountLoginClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccountLoginAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAccountLoginAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccountLoginAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAdministratorCommissioningServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAdministratorCommissioningServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPAdministratorCommissioningServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAdministratorCommissioningClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAdministratorCommissioningClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPAdministratorCommissioningClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAdministratorCommissioningAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAdministratorCommissioningAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAdministratorCommissioningAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationBasicApplicationAppStructAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApplication::DecodableType & value)
{
    CHIPApplicationBasicClusterApplicationBasicApplication * _Nonnull objCValue;
    objCValue = [CHIPApplicationBasicClusterApplicationBasicApplication new];
    objCValue.catalogVendorId = [NSNumber numberWithUnsignedShort:value.catalogVendorId];
    objCValue.applicationId = [[NSString alloc] initWithBytes:value.applicationId.data()
                                                       length:value.applicationId.size()
                                                     encoding:NSUTF8StringEncoding];
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationBasicApplicationAppStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplicationBasicApplicationAppStructAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationBasicAllowedVendorListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::VendorId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedShort:chip::to_underlying(entry_0)];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationBasicAllowedVendorListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplicationBasicAllowedVendorListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationBasicServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationBasicServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPApplicationBasicServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationBasicClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationBasicClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPApplicationBasicClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationBasicAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationBasicAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplicationBasicAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationLauncherApplicationLauncherListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<uint16_t> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedShort:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationLauncherApplicationLauncherListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPApplicationLauncherApplicationLauncherListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationLauncherApplicationLauncherAppStructAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEP::DecodableType> & value)
{
    CHIPApplicationLauncherClusterApplicationEP * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [CHIPApplicationLauncherClusterApplicationEP new];
        objCValue.application = [CHIPApplicationLauncherClusterApplication new];
        objCValue.application.catalogVendorId = [NSNumber numberWithUnsignedShort:value.Value().application.catalogVendorId];
        objCValue.application.applicationId = [[NSString alloc] initWithBytes:value.Value().application.applicationId.data()
                                                                       length:value.Value().application.applicationId.size()
                                                                     encoding:NSUTF8StringEncoding];
        if (value.Value().endpoint.HasValue()) {
            objCValue.endpoint = [NSNumber numberWithUnsignedShort:value.Value().endpoint.Value()];
        } else {
            objCValue.endpoint = nil;
        }
    }
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationLauncherApplicationLauncherAppStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPApplicationLauncherApplicationLauncherAppStructAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationLauncherServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationLauncherServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPApplicationLauncherServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationLauncherClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationLauncherClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPApplicationLauncherClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationLauncherAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationLauncherAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplicationLauncherAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAudioOutputAudioOutputListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPAudioOutputClusterOutputInfo * newElement_0;
        newElement_0 = [CHIPAudioOutputClusterOutputInfo new];
        newElement_0.index = [NSNumber numberWithUnsignedChar:entry_0.index];
        newElement_0.outputType = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.outputType)];
        newElement_0.name = [[NSString alloc] initWithBytes:entry_0.name.data()
                                                     length:entry_0.name.size()
                                                   encoding:NSUTF8StringEncoding];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAudioOutputAudioOutputListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAudioOutputAudioOutputListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAudioOutputServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAudioOutputServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAudioOutputServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAudioOutputClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAudioOutputClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAudioOutputClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAudioOutputAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPAudioOutputAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAudioOutputAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBarrierControlServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBarrierControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBarrierControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBarrierControlClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBarrierControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBarrierControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBarrierControlAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBarrierControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBarrierControlAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBasicServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBasicServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBasicServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBasicClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBasicClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBasicClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBasicAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBasicAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBasicAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBinaryInputBasicServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBinaryInputBasicServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPBinaryInputBasicServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBinaryInputBasicClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBinaryInputBasicClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPBinaryInputBasicClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBinaryInputBasicAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBinaryInputBasicAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBinaryInputBasicAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBindingServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBindingServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBindingServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBindingClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBindingClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBindingClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBindingAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBindingAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBindingAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBooleanStateServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBooleanStateServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBooleanStateServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBooleanStateClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBooleanStateClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBooleanStateClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBooleanStateAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBooleanStateAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBooleanStateAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsActionListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPBridgedActionsClusterActionStruct * newElement_0;
        newElement_0 = [CHIPBridgedActionsClusterActionStruct new];
        newElement_0.actionID = [NSNumber numberWithUnsignedShort:entry_0.actionID];
        newElement_0.name = [[NSString alloc] initWithBytes:entry_0.name.data()
                                                     length:entry_0.name.size()
                                                   encoding:NSUTF8StringEncoding];
        newElement_0.type = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.type)];
        newElement_0.endpointListID = [NSNumber numberWithUnsignedShort:entry_0.endpointListID];
        newElement_0.supportedCommands = [NSNumber numberWithUnsignedShort:entry_0.supportedCommands];
        newElement_0.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.status)];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsActionListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsActionListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsEndpointListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPBridgedActionsClusterEndpointListStruct * newElement_0;
        newElement_0 = [CHIPBridgedActionsClusterEndpointListStruct new];
        newElement_0.endpointListID = [NSNumber numberWithUnsignedShort:entry_0.endpointListID];
        newElement_0.name = [[NSString alloc] initWithBytes:entry_0.name.data()
                                                     length:entry_0.name.size()
                                                   encoding:NSUTF8StringEncoding];
        newElement_0.type = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.type)];
        auto * array_2 = [NSMutableArray new];
        auto iter_2 = entry_0.endpoints.begin();
        while (iter_2.Next()) {
            auto & entry_2 = iter_2.GetValue();
            NSNumber * newElement_2;
            newElement_2 = [NSNumber numberWithUnsignedShort:entry_2];
            [array_2 addObject:newElement_2];
        }
        { // Scope for the error so we will know what it's named
            CHIP_ERROR err = iter_2.GetStatus();
            if (err != CHIP_NO_ERROR) {
                OnFailureFn(context, err);
                return;
            }
        }
        newElement_0.endpoints = array_2;
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsEndpointListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsEndpointListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedDeviceBasicServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedDeviceBasicServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPBridgedDeviceBasicServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedDeviceBasicClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedDeviceBasicClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPBridgedDeviceBasicClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedDeviceBasicAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedDeviceBasicAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedDeviceBasicAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPChannelChannelListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPChannelClusterChannelInfo * newElement_0;
        newElement_0 = [CHIPChannelClusterChannelInfo new];
        newElement_0.majorNumber = [NSNumber numberWithUnsignedShort:entry_0.majorNumber];
        newElement_0.minorNumber = [NSNumber numberWithUnsignedShort:entry_0.minorNumber];
        if (entry_0.name.HasValue()) {
            newElement_0.name = [[NSString alloc] initWithBytes:entry_0.name.Value().data()
                                                         length:entry_0.name.Value().size()
                                                       encoding:NSUTF8StringEncoding];
        } else {
            newElement_0.name = nil;
        }
        if (entry_0.callSign.HasValue()) {
            newElement_0.callSign = [[NSString alloc] initWithBytes:entry_0.callSign.Value().data()
                                                             length:entry_0.callSign.Value().size()
                                                           encoding:NSUTF8StringEncoding];
        } else {
            newElement_0.callSign = nil;
        }
        if (entry_0.affiliateCallSign.HasValue()) {
            newElement_0.affiliateCallSign = [[NSString alloc] initWithBytes:entry_0.affiliateCallSign.Value().data()
                                                                      length:entry_0.affiliateCallSign.Value().size()
                                                                    encoding:NSUTF8StringEncoding];
        } else {
            newElement_0.affiliateCallSign = nil;
        }
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPChannelChannelListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPChannelChannelListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPChannelChannelLineupStructAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfo::DecodableType> & value)
{
    CHIPChannelClusterLineupInfo * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [CHIPChannelClusterLineupInfo new];
        objCValue.operatorName = [[NSString alloc] initWithBytes:value.Value().operatorName.data()
                                                          length:value.Value().operatorName.size()
                                                        encoding:NSUTF8StringEncoding];
        if (value.Value().lineupName.HasValue()) {
            objCValue.lineupName = [[NSString alloc] initWithBytes:value.Value().lineupName.Value().data()
                                                            length:value.Value().lineupName.Value().size()
                                                          encoding:NSUTF8StringEncoding];
        } else {
            objCValue.lineupName = nil;
        }
        if (value.Value().postalCode.HasValue()) {
            objCValue.postalCode = [[NSString alloc] initWithBytes:value.Value().postalCode.Value().data()
                                                            length:value.Value().postalCode.Value().size()
                                                          encoding:NSUTF8StringEncoding];
        } else {
            objCValue.postalCode = nil;
        }
        objCValue.lineupInfoType = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value().lineupInfoType)];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPChannelChannelLineupStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPChannelChannelLineupStructAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPChannelCurrentChannelStructAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> & value)
{
    CHIPChannelClusterChannelInfo * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [CHIPChannelClusterChannelInfo new];
        objCValue.majorNumber = [NSNumber numberWithUnsignedShort:value.Value().majorNumber];
        objCValue.minorNumber = [NSNumber numberWithUnsignedShort:value.Value().minorNumber];
        if (value.Value().name.HasValue()) {
            objCValue.name = [[NSString alloc] initWithBytes:value.Value().name.Value().data()
                                                      length:value.Value().name.Value().size()
                                                    encoding:NSUTF8StringEncoding];
        } else {
            objCValue.name = nil;
        }
        if (value.Value().callSign.HasValue()) {
            objCValue.callSign = [[NSString alloc] initWithBytes:value.Value().callSign.Value().data()
                                                          length:value.Value().callSign.Value().size()
                                                        encoding:NSUTF8StringEncoding];
        } else {
            objCValue.callSign = nil;
        }
        if (value.Value().affiliateCallSign.HasValue()) {
            objCValue.affiliateCallSign = [[NSString alloc] initWithBytes:value.Value().affiliateCallSign.Value().data()
                                                                   length:value.Value().affiliateCallSign.Value().size()
                                                                 encoding:NSUTF8StringEncoding];
        } else {
            objCValue.affiliateCallSign = nil;
        }
    }
    DispatchSuccess(context, objCValue);
};

void CHIPChannelCurrentChannelStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPChannelCurrentChannelStructAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPChannelServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPChannelServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPChannelServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPChannelClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPChannelClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPChannelClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPChannelAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPChannelAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPChannelAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPContentLauncherAcceptHeaderListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CharSpan> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSString * newElement_0;
        newElement_0 = [[NSString alloc] initWithBytes:entry_0.data() length:entry_0.size() encoding:NSUTF8StringEncoding];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPContentLauncherAcceptHeaderListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPContentLauncherAcceptHeaderListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPContentLauncherServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPContentLauncherServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPContentLauncherServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPContentLauncherClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPContentLauncherClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPContentLauncherClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPContentLauncherAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPContentLauncherAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPContentLauncherAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDescriptorDeviceListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPDescriptorClusterDeviceType * newElement_0;
        newElement_0 = [CHIPDescriptorClusterDeviceType new];
        newElement_0.type = [NSNumber numberWithUnsignedInt:entry_0.type];
        newElement_0.revision = [NSNumber numberWithUnsignedShort:entry_0.revision];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDescriptorDeviceListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDescriptorDeviceListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDescriptorServerListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDescriptorServerListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDescriptorServerListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDescriptorClientListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDescriptorClientListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDescriptorClientListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDescriptorPartsListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::EndpointId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedShort:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDescriptorPartsListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDescriptorPartsListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDescriptorServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDescriptorServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDescriptorServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDescriptorClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDescriptorClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDescriptorClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDescriptorAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDescriptorAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDescriptorAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDiagnosticLogsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDiagnosticLogsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDiagnosticLogsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDiagnosticLogsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDiagnosticLogsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDiagnosticLogsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDiagnosticLogsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDiagnosticLogsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDiagnosticLogsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPElectricalMeasurementServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPElectricalMeasurementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPElectricalMeasurementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPElectricalMeasurementClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPElectricalMeasurementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPElectricalMeasurementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPElectricalMeasurementAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPElectricalMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPElectricalMeasurementAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPEthernetNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPEthernetNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPEthernetNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPEthernetNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPEthernetNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPEthernetNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPEthernetNetworkDiagnosticsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPEthernetNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPEthernetNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPFixedLabelLabelListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPFixedLabelClusterLabelStruct * newElement_0;
        newElement_0 = [CHIPFixedLabelClusterLabelStruct new];
        newElement_0.label = [[NSString alloc] initWithBytes:entry_0.label.data()
                                                      length:entry_0.label.size()
                                                    encoding:NSUTF8StringEncoding];
        newElement_0.value = [[NSString alloc] initWithBytes:entry_0.value.data()
                                                      length:entry_0.value.size()
                                                    encoding:NSUTF8StringEncoding];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPFixedLabelLabelListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPFixedLabelLabelListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPFixedLabelServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPFixedLabelServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPFixedLabelServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPFixedLabelClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPFixedLabelClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPFixedLabelClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPFixedLabelAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPFixedLabelAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPFixedLabelAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPFlowMeasurementServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPFlowMeasurementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPFlowMeasurementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPFlowMeasurementClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPFlowMeasurementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPFlowMeasurementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPFlowMeasurementAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPFlowMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPFlowMeasurementAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralCommissioningBasicCommissioningInfoStructAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfo::DecodableType & value)
{
    CHIPGeneralCommissioningClusterBasicCommissioningInfo * _Nonnull objCValue;
    objCValue = [CHIPGeneralCommissioningClusterBasicCommissioningInfo new];
    objCValue.failSafeExpiryLengthSeconds = [NSNumber numberWithUnsignedShort:value.failSafeExpiryLengthSeconds];
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralCommissioningBasicCommissioningInfoStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGeneralCommissioningBasicCommissioningInfoStructAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralCommissioningServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralCommissioningServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGeneralCommissioningServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralCommissioningClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralCommissioningClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGeneralCommissioningClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralCommissioningAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralCommissioningAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralCommissioningAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsNetworkInterfacesListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPGeneralDiagnosticsClusterNetworkInterfaceType * newElement_0;
        newElement_0 = [CHIPGeneralDiagnosticsClusterNetworkInterfaceType new];
        newElement_0.name = [[NSString alloc] initWithBytes:entry_0.name.data()
                                                     length:entry_0.name.size()
                                                   encoding:NSUTF8StringEncoding];
        newElement_0.fabricConnected = [NSNumber numberWithBool:entry_0.fabricConnected];
        if (entry_0.offPremiseServicesReachableIPv4.IsNull()) {
            newElement_0.offPremiseServicesReachableIPv4 = nil;
        } else {
            newElement_0.offPremiseServicesReachableIPv4 =
                [NSNumber numberWithBool:entry_0.offPremiseServicesReachableIPv4.Value()];
        }
        if (entry_0.offPremiseServicesReachableIPv6.IsNull()) {
            newElement_0.offPremiseServicesReachableIPv6 = nil;
        } else {
            newElement_0.offPremiseServicesReachableIPv6 =
                [NSNumber numberWithBool:entry_0.offPremiseServicesReachableIPv6.Value()];
        }
        newElement_0.hardwareAddress = [NSData dataWithBytes:entry_0.hardwareAddress.data() length:entry_0.hardwareAddress.size()];
        newElement_0.type = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.type)];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsNetworkInterfacesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsNetworkInterfacesListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsActiveHardwareFaultsListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<uint8_t> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsActiveHardwareFaultsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsActiveHardwareFaultsListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsActiveRadioFaultsListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<uint8_t> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsActiveRadioFaultsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsActiveRadioFaultsListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsActiveNetworkFaultsListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<uint8_t> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsActiveNetworkFaultsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsActiveNetworkFaultsListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupKeyManagementGroupKeyMapListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPGroupKeyManagementClusterGroupKeyMapStruct * newElement_0;
        newElement_0 = [CHIPGroupKeyManagementClusterGroupKeyMapStruct new];
        newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
        newElement_0.groupId = [NSNumber numberWithUnsignedShort:entry_0.groupId];
        newElement_0.groupKeySetID = [NSNumber numberWithUnsignedShort:entry_0.groupKeySetID];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGroupKeyManagementGroupKeyMapListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGroupKeyManagementGroupKeyMapListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupKeyManagementGroupTableListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPGroupKeyManagementClusterGroupInfoMapStruct * newElement_0;
        newElement_0 = [CHIPGroupKeyManagementClusterGroupInfoMapStruct new];
        newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
        newElement_0.groupId = [NSNumber numberWithUnsignedShort:entry_0.groupId];
        auto * array_2 = [NSMutableArray new];
        auto iter_2 = entry_0.endpoints.begin();
        while (iter_2.Next()) {
            auto & entry_2 = iter_2.GetValue();
            NSNumber * newElement_2;
            newElement_2 = [NSNumber numberWithUnsignedShort:entry_2];
            [array_2 addObject:newElement_2];
        }
        { // Scope for the error so we will know what it's named
            CHIP_ERROR err = iter_2.GetStatus();
            if (err != CHIP_NO_ERROR) {
                OnFailureFn(context, err);
                return;
            }
        }
        newElement_0.endpoints = array_2;
        if (entry_0.groupName.HasValue()) {
            newElement_0.groupName = [[NSString alloc] initWithBytes:entry_0.groupName.Value().data()
                                                              length:entry_0.groupName.Value().size()
                                                            encoding:NSUTF8StringEncoding];
        } else {
            newElement_0.groupName = nil;
        }
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGroupKeyManagementGroupTableListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGroupKeyManagementGroupTableListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupKeyManagementServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGroupKeyManagementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGroupKeyManagementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupKeyManagementClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGroupKeyManagementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGroupKeyManagementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupKeyManagementAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGroupKeyManagementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGroupKeyManagementAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGroupsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGroupsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGroupsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGroupsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPGroupsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGroupsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIdentifyServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPIdentifyServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIdentifyServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIdentifyClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPIdentifyClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIdentifyClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIdentifyAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPIdentifyAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIdentifyAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIlluminanceMeasurementServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPIlluminanceMeasurementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPIlluminanceMeasurementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIlluminanceMeasurementClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPIlluminanceMeasurementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPIlluminanceMeasurementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIlluminanceMeasurementAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPIlluminanceMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIlluminanceMeasurementAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPKeypadInputServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPKeypadInputServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPKeypadInputServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPKeypadInputClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPKeypadInputClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPKeypadInputClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPKeypadInputAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPKeypadInputAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPKeypadInputAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLevelControlServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLevelControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLevelControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLevelControlClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLevelControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLevelControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLevelControlAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLevelControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLevelControlAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLocalizationConfigurationSupportedLocalesListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CharSpan> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSString * newElement_0;
        newElement_0 = [[NSString alloc] initWithBytes:entry_0.data() length:entry_0.size() encoding:NSUTF8StringEncoding];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLocalizationConfigurationSupportedLocalesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLocalizationConfigurationSupportedLocalesListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLocalizationConfigurationServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLocalizationConfigurationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPLocalizationConfigurationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLocalizationConfigurationClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLocalizationConfigurationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPLocalizationConfigurationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLowPowerServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLowPowerServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLowPowerServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLowPowerClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLowPowerClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLowPowerClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLowPowerAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPLowPowerAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLowPowerAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaInputMediaInputListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPMediaInputClusterInputInfo * newElement_0;
        newElement_0 = [CHIPMediaInputClusterInputInfo new];
        newElement_0.index = [NSNumber numberWithUnsignedChar:entry_0.index];
        newElement_0.inputType = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.inputType)];
        newElement_0.name = [[NSString alloc] initWithBytes:entry_0.name.data()
                                                     length:entry_0.name.size()
                                                   encoding:NSUTF8StringEncoding];
        newElement_0.descriptionString = [[NSString alloc] initWithBytes:entry_0.description.data()
                                                                  length:entry_0.description.size()
                                                                encoding:NSUTF8StringEncoding];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPMediaInputMediaInputListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaInputMediaInputListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaInputServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPMediaInputServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaInputServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaInputClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPMediaInputClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaInputClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaInputAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPMediaInputAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaInputAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaPlaybackPositionStructAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType & value)
{
    CHIPMediaPlaybackClusterPlaybackPosition * _Nonnull objCValue;
    objCValue = [CHIPMediaPlaybackClusterPlaybackPosition new];
    objCValue.updatedAt = [NSNumber numberWithUnsignedLongLong:value.updatedAt];
    if (value.position.IsNull()) {
        objCValue.position = nil;
    } else {
        objCValue.position = [NSNumber numberWithUnsignedLongLong:value.position.Value()];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPMediaPlaybackPositionStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaPlaybackPositionStructAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaPlaybackServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPMediaPlaybackServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaPlaybackServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaPlaybackClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPMediaPlaybackClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaPlaybackClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaPlaybackAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPMediaPlaybackAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaPlaybackAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPModeSelectSupportedModesListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPModeSelectClusterModeOptionStruct * newElement_0;
        newElement_0 = [CHIPModeSelectClusterModeOptionStruct new];
        newElement_0.label = [[NSString alloc] initWithBytes:entry_0.label.data()
                                                      length:entry_0.label.size()
                                                    encoding:NSUTF8StringEncoding];
        newElement_0.mode = [NSNumber numberWithUnsignedChar:entry_0.mode];
        newElement_0.semanticTag = [NSNumber numberWithUnsignedInt:entry_0.semanticTag];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPModeSelectSupportedModesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPModeSelectSupportedModesListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPModeSelectServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPModeSelectServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPModeSelectServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPModeSelectClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPModeSelectClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPModeSelectClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPModeSelectAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPModeSelectAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPModeSelectAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNetworkCommissioningNetworksListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPNetworkCommissioningClusterNetworkInfo * newElement_0;
        newElement_0 = [CHIPNetworkCommissioningClusterNetworkInfo new];
        newElement_0.networkID = [NSData dataWithBytes:entry_0.networkID.data() length:entry_0.networkID.size()];
        newElement_0.connected = [NSNumber numberWithBool:entry_0.connected];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPNetworkCommissioningNetworksListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNetworkCommissioningNetworksListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNetworkCommissioningServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPNetworkCommissioningServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNetworkCommissioningServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNetworkCommissioningClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPNetworkCommissioningClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNetworkCommissioningClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateProviderAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateProviderAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOtaSoftwareUpdateProviderAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPOtaSoftwareUpdateRequestorClusterProviderLocation * newElement_0;
        newElement_0 = [CHIPOtaSoftwareUpdateRequestorClusterProviderLocation new];
        newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
        newElement_0.providerNodeID = [NSNumber numberWithUnsignedLongLong:entry_0.providerNodeID];
        newElement_0.endpoint = [NSNumber numberWithUnsignedShort:entry_0.endpoint];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPOtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateRequestorAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateRequestorAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOtaSoftwareUpdateRequestorAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOccupancySensingServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOccupancySensingServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPOccupancySensingServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOccupancySensingClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOccupancySensingClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPOccupancySensingClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOccupancySensingAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOccupancySensingAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOccupancySensingAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOnOffServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOnOffClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOnOffAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffSwitchConfigurationServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffSwitchConfigurationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOnOffSwitchConfigurationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffSwitchConfigurationClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffSwitchConfigurationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOnOffSwitchConfigurationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffSwitchConfigurationAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffSwitchConfigurationAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOnOffSwitchConfigurationAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOperationalCredentialsNOCsListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPOperationalCredentialsClusterNOCStruct * newElement_0;
        newElement_0 = [CHIPOperationalCredentialsClusterNOCStruct new];
        newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
        newElement_0.noc = [NSData dataWithBytes:entry_0.noc.data() length:entry_0.noc.size()];
        if (entry_0.icac.IsNull()) {
            newElement_0.icac = nil;
        } else {
            newElement_0.icac = [NSData dataWithBytes:entry_0.icac.Value().data() length:entry_0.icac.Value().size()];
        }
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOperationalCredentialsNOCsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOperationalCredentialsNOCsListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOperationalCredentialsFabricsListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPOperationalCredentialsClusterFabricDescriptor * newElement_0;
        newElement_0 = [CHIPOperationalCredentialsClusterFabricDescriptor new];
        newElement_0.fabricIndex = [NSNumber numberWithUnsignedChar:entry_0.fabricIndex];
        newElement_0.rootPublicKey = [NSData dataWithBytes:entry_0.rootPublicKey.data() length:entry_0.rootPublicKey.size()];
        newElement_0.vendorId = [NSNumber numberWithUnsignedShort:entry_0.vendorId];
        newElement_0.fabricId = [NSNumber numberWithUnsignedLongLong:entry_0.fabricId];
        newElement_0.nodeId = [NSNumber numberWithUnsignedLongLong:entry_0.nodeId];
        newElement_0.label = [[NSString alloc] initWithBytes:entry_0.label.data()
                                                      length:entry_0.label.size()
                                                    encoding:NSUTF8StringEncoding];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOperationalCredentialsFabricsListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOperationalCredentialsFabricsListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOperationalCredentialsTrustedRootCertificatesListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSData * newElement_0;
        newElement_0 = [NSData dataWithBytes:entry_0.data() length:entry_0.size()];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOperationalCredentialsTrustedRootCertificatesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPOperationalCredentialsTrustedRootCertificatesListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOperationalCredentialsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOperationalCredentialsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOperationalCredentialsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOperationalCredentialsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOperationalCredentialsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOperationalCredentialsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOperationalCredentialsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPOperationalCredentialsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOperationalCredentialsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceActiveBatteryFaultsListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<uint8_t> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceActiveBatteryFaultsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceActiveBatteryFaultsListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceConfigurationSourcesListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<uint8_t> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceConfigurationSourcesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceConfigurationSourcesListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceConfigurationServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceConfigurationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPPowerSourceConfigurationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceConfigurationClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceConfigurationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPPowerSourceConfigurationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceConfigurationAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceConfigurationAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceConfigurationAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPressureMeasurementAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPressureMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPressureMeasurementAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPumpConfigurationAndControlServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPumpConfigurationAndControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPPumpConfigurationAndControlServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPumpConfigurationAndControlClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPumpConfigurationAndControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPPumpConfigurationAndControlClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPumpConfigurationAndControlAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPPumpConfigurationAndControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPumpConfigurationAndControlAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPRelativeHumidityMeasurementServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPRelativeHumidityMeasurementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPRelativeHumidityMeasurementServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPRelativeHumidityMeasurementClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPRelativeHumidityMeasurementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPRelativeHumidityMeasurementClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPRelativeHumidityMeasurementAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPRelativeHumidityMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPRelativeHumidityMeasurementAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPScenesServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPScenesServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPScenesServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPScenesClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPScenesClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPScenesClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPScenesAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPScenesAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPScenesAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPSoftwareDiagnosticsThreadMetricsListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPSoftwareDiagnosticsClusterThreadMetrics * newElement_0;
        newElement_0 = [CHIPSoftwareDiagnosticsClusterThreadMetrics new];
        newElement_0.id = [NSNumber numberWithUnsignedLongLong:entry_0.id];
        newElement_0.name = [[NSString alloc] initWithBytes:entry_0.name.data()
                                                     length:entry_0.name.size()
                                                   encoding:NSUTF8StringEncoding];
        newElement_0.stackFreeCurrent = [NSNumber numberWithUnsignedInt:entry_0.stackFreeCurrent];
        newElement_0.stackFreeMinimum = [NSNumber numberWithUnsignedInt:entry_0.stackFreeMinimum];
        newElement_0.stackSize = [NSNumber numberWithUnsignedInt:entry_0.stackSize];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPSoftwareDiagnosticsThreadMetricsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPSoftwareDiagnosticsThreadMetricsListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPSoftwareDiagnosticsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPSoftwareDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPSoftwareDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPSoftwareDiagnosticsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPSoftwareDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPSoftwareDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPSoftwareDiagnosticsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPSoftwareDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPSoftwareDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPSwitchServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPSwitchServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPSwitchServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPSwitchClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPSwitchClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPSwitchClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPSwitchAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPSwitchAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPSwitchAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTargetNavigatorTargetNavigatorListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPTargetNavigatorClusterTargetInfo * newElement_0;
        newElement_0 = [CHIPTargetNavigatorClusterTargetInfo new];
        newElement_0.identifier = [NSNumber numberWithUnsignedChar:entry_0.identifier];
        newElement_0.name = [[NSString alloc] initWithBytes:entry_0.name.data()
                                                     length:entry_0.name.size()
                                                   encoding:NSUTF8StringEncoding];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTargetNavigatorTargetNavigatorListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTargetNavigatorTargetNavigatorListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTargetNavigatorServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTargetNavigatorServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTargetNavigatorServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTargetNavigatorClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTargetNavigatorClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTargetNavigatorClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTargetNavigatorAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTargetNavigatorAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTargetNavigatorAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTemperatureMeasurementAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTemperatureMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTemperatureMeasurementAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterListInt8uListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<uint8_t> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterListInt8uListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterListInt8uListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterListOctetStringListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSData * newElement_0;
        newElement_0 = [NSData dataWithBytes:entry_0.data() length:entry_0.size()];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterListOctetStringListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterListOctetStringListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterListStructOctetStringListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPTestClusterClusterTestListStructOctet * newElement_0;
        newElement_0 = [CHIPTestClusterClusterTestListStructOctet new];
        newElement_0.fabricIndex = [NSNumber numberWithUnsignedLongLong:entry_0.fabricIndex];
        newElement_0.operationalCert = [NSData dataWithBytes:entry_0.operationalCert.data() length:entry_0.operationalCert.size()];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterListStructOctetStringListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterListStructOctetStringListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterListNullablesAndOptionalsStructListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPTestClusterClusterNullablesAndOptionalsStruct * newElement_0;
        newElement_0 = [CHIPTestClusterClusterNullablesAndOptionalsStruct new];
        if (entry_0.nullableInt.IsNull()) {
            newElement_0.nullableInt = nil;
        } else {
            newElement_0.nullableInt = [NSNumber numberWithUnsignedShort:entry_0.nullableInt.Value()];
        }
        if (entry_0.optionalInt.HasValue()) {
            newElement_0.optionalInt = [NSNumber numberWithUnsignedShort:entry_0.optionalInt.Value()];
        } else {
            newElement_0.optionalInt = nil;
        }
        if (entry_0.nullableOptionalInt.HasValue()) {
            if (entry_0.nullableOptionalInt.Value().IsNull()) {
                newElement_0.nullableOptionalInt = nil;
            } else {
                newElement_0.nullableOptionalInt = [NSNumber numberWithUnsignedShort:entry_0.nullableOptionalInt.Value().Value()];
            }
        } else {
            newElement_0.nullableOptionalInt = nil;
        }
        if (entry_0.nullableString.IsNull()) {
            newElement_0.nullableString = nil;
        } else {
            newElement_0.nullableString = [[NSString alloc] initWithBytes:entry_0.nullableString.Value().data()
                                                                   length:entry_0.nullableString.Value().size()
                                                                 encoding:NSUTF8StringEncoding];
        }
        if (entry_0.optionalString.HasValue()) {
            newElement_0.optionalString = [[NSString alloc] initWithBytes:entry_0.optionalString.Value().data()
                                                                   length:entry_0.optionalString.Value().size()
                                                                 encoding:NSUTF8StringEncoding];
        } else {
            newElement_0.optionalString = nil;
        }
        if (entry_0.nullableOptionalString.HasValue()) {
            if (entry_0.nullableOptionalString.Value().IsNull()) {
                newElement_0.nullableOptionalString = nil;
            } else {
                newElement_0.nullableOptionalString =
                    [[NSString alloc] initWithBytes:entry_0.nullableOptionalString.Value().Value().data()
                                             length:entry_0.nullableOptionalString.Value().Value().size()
                                           encoding:NSUTF8StringEncoding];
            }
        } else {
            newElement_0.nullableOptionalString = nil;
        }
        if (entry_0.nullableStruct.IsNull()) {
            newElement_0.nullableStruct = nil;
        } else {
            newElement_0.nullableStruct = [CHIPTestClusterClusterSimpleStruct new];
            newElement_0.nullableStruct.a = [NSNumber numberWithUnsignedChar:entry_0.nullableStruct.Value().a];
            newElement_0.nullableStruct.b = [NSNumber numberWithBool:entry_0.nullableStruct.Value().b];
            newElement_0.nullableStruct.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.nullableStruct.Value().c)];
            newElement_0.nullableStruct.d = [NSData dataWithBytes:entry_0.nullableStruct.Value().d.data()
                                                           length:entry_0.nullableStruct.Value().d.size()];
            newElement_0.nullableStruct.e = [[NSString alloc] initWithBytes:entry_0.nullableStruct.Value().e.data()
                                                                     length:entry_0.nullableStruct.Value().e.size()
                                                                   encoding:NSUTF8StringEncoding];
            newElement_0.nullableStruct.f = [NSNumber numberWithUnsignedChar:entry_0.nullableStruct.Value().f.Raw()];
            newElement_0.nullableStruct.g = [NSNumber numberWithFloat:entry_0.nullableStruct.Value().g];
            newElement_0.nullableStruct.h = [NSNumber numberWithDouble:entry_0.nullableStruct.Value().h];
        }
        if (entry_0.optionalStruct.HasValue()) {
            newElement_0.optionalStruct = [CHIPTestClusterClusterSimpleStruct new];
            newElement_0.optionalStruct.a = [NSNumber numberWithUnsignedChar:entry_0.optionalStruct.Value().a];
            newElement_0.optionalStruct.b = [NSNumber numberWithBool:entry_0.optionalStruct.Value().b];
            newElement_0.optionalStruct.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.optionalStruct.Value().c)];
            newElement_0.optionalStruct.d = [NSData dataWithBytes:entry_0.optionalStruct.Value().d.data()
                                                           length:entry_0.optionalStruct.Value().d.size()];
            newElement_0.optionalStruct.e = [[NSString alloc] initWithBytes:entry_0.optionalStruct.Value().e.data()
                                                                     length:entry_0.optionalStruct.Value().e.size()
                                                                   encoding:NSUTF8StringEncoding];
            newElement_0.optionalStruct.f = [NSNumber numberWithUnsignedChar:entry_0.optionalStruct.Value().f.Raw()];
            newElement_0.optionalStruct.g = [NSNumber numberWithFloat:entry_0.optionalStruct.Value().g];
            newElement_0.optionalStruct.h = [NSNumber numberWithDouble:entry_0.optionalStruct.Value().h];
        } else {
            newElement_0.optionalStruct = nil;
        }
        if (entry_0.nullableOptionalStruct.HasValue()) {
            if (entry_0.nullableOptionalStruct.Value().IsNull()) {
                newElement_0.nullableOptionalStruct = nil;
            } else {
                newElement_0.nullableOptionalStruct = [CHIPTestClusterClusterSimpleStruct new];
                newElement_0.nullableOptionalStruct.a =
                    [NSNumber numberWithUnsignedChar:entry_0.nullableOptionalStruct.Value().Value().a];
                newElement_0.nullableOptionalStruct.b = [NSNumber numberWithBool:entry_0.nullableOptionalStruct.Value().Value().b];
                newElement_0.nullableOptionalStruct.c =
                    [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0.nullableOptionalStruct.Value().Value().c)];
                newElement_0.nullableOptionalStruct.d =
                    [NSData dataWithBytes:entry_0.nullableOptionalStruct.Value().Value().d.data()
                                   length:entry_0.nullableOptionalStruct.Value().Value().d.size()];
                newElement_0.nullableOptionalStruct.e =
                    [[NSString alloc] initWithBytes:entry_0.nullableOptionalStruct.Value().Value().e.data()
                                             length:entry_0.nullableOptionalStruct.Value().Value().e.size()
                                           encoding:NSUTF8StringEncoding];
                newElement_0.nullableOptionalStruct.f =
                    [NSNumber numberWithUnsignedChar:entry_0.nullableOptionalStruct.Value().Value().f.Raw()];
                newElement_0.nullableOptionalStruct.g = [NSNumber numberWithFloat:entry_0.nullableOptionalStruct.Value().Value().g];
                newElement_0.nullableOptionalStruct.h =
                    [NSNumber numberWithDouble:entry_0.nullableOptionalStruct.Value().Value().h];
            }
        } else {
            newElement_0.nullableOptionalStruct = nil;
        }
        if (entry_0.nullableList.IsNull()) {
            newElement_0.nullableList = nil;
        } else {
            auto * array_3 = [NSMutableArray new];
            auto iter_3 = entry_0.nullableList.Value().begin();
            while (iter_3.Next()) {
                auto & entry_3 = iter_3.GetValue();
                NSNumber * newElement_3;
                newElement_3 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_3)];
                [array_3 addObject:newElement_3];
            }
            { // Scope for the error so we will know what it's named
                CHIP_ERROR err = iter_3.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    OnFailureFn(context, err);
                    return;
                }
            }
            newElement_0.nullableList = array_3;
        }
        if (entry_0.optionalList.HasValue()) {
            auto * array_3 = [NSMutableArray new];
            auto iter_3 = entry_0.optionalList.Value().begin();
            while (iter_3.Next()) {
                auto & entry_3 = iter_3.GetValue();
                NSNumber * newElement_3;
                newElement_3 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_3)];
                [array_3 addObject:newElement_3];
            }
            { // Scope for the error so we will know what it's named
                CHIP_ERROR err = iter_3.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    OnFailureFn(context, err);
                    return;
                }
            }
            newElement_0.optionalList = array_3;
        } else {
            newElement_0.optionalList = nil;
        }
        if (entry_0.nullableOptionalList.HasValue()) {
            if (entry_0.nullableOptionalList.Value().IsNull()) {
                newElement_0.nullableOptionalList = nil;
            } else {
                auto * array_4 = [NSMutableArray new];
                auto iter_4 = entry_0.nullableOptionalList.Value().Value().begin();
                while (iter_4.Next()) {
                    auto & entry_4 = iter_4.GetValue();
                    NSNumber * newElement_4;
                    newElement_4 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_4)];
                    [array_4 addObject:newElement_4];
                }
                { // Scope for the error so we will know what it's named
                    CHIP_ERROR err = iter_4.GetStatus();
                    if (err != CHIP_NO_ERROR) {
                        OnFailureFn(context, err);
                        return;
                    }
                }
                newElement_0.nullableOptionalList = array_4;
            }
        } else {
            newElement_0.nullableOptionalList = nil;
        }
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterListNullablesAndOptionalsStructListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPTestClusterListNullablesAndOptionalsStructListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterStructAttrStructAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & value)
{
    CHIPTestClusterClusterSimpleStruct * _Nonnull objCValue;
    objCValue = [CHIPTestClusterClusterSimpleStruct new];
    objCValue.a = [NSNumber numberWithUnsignedChar:value.a];
    objCValue.b = [NSNumber numberWithBool:value.b];
    objCValue.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.c)];
    objCValue.d = [NSData dataWithBytes:value.d.data() length:value.d.size()];
    objCValue.e = [[NSString alloc] initWithBytes:value.e.data() length:value.e.size() encoding:NSUTF8StringEncoding];
    objCValue.f = [NSNumber numberWithUnsignedChar:value.f.Raw()];
    objCValue.g = [NSNumber numberWithFloat:value.g];
    objCValue.h = [NSNumber numberWithDouble:value.h];
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterStructAttrStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterStructAttrStructAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterListLongOctetStringListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSData * newElement_0;
        newElement_0 = [NSData dataWithBytes:entry_0.data() length:entry_0.size()];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterListLongOctetStringListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterListLongOctetStringListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterNullableStructStructAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType> & value)
{
    CHIPTestClusterClusterSimpleStruct * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [CHIPTestClusterClusterSimpleStruct new];
        objCValue.a = [NSNumber numberWithUnsignedChar:value.Value().a];
        objCValue.b = [NSNumber numberWithBool:value.Value().b];
        objCValue.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value().c)];
        objCValue.d = [NSData dataWithBytes:value.Value().d.data() length:value.Value().d.size()];
        objCValue.e = [[NSString alloc] initWithBytes:value.Value().e.data()
                                               length:value.Value().e.size()
                                             encoding:NSUTF8StringEncoding];
        objCValue.f = [NSNumber numberWithUnsignedChar:value.Value().f.Raw()];
        objCValue.g = [NSNumber numberWithFloat:value.Value().g];
        objCValue.h = [NSNumber numberWithDouble:value.Value().h];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterNullableStructStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterNullableStructStructAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThermostatAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThermostatAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPThermostatAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThermostatUserInterfaceConfigurationServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThermostatUserInterfaceConfigurationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::
    OnSubscriptionEstablished(void * context)
{
    auto * self
        = static_cast<CHIPThermostatUserInterfaceConfigurationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThermostatUserInterfaceConfigurationClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThermostatUserInterfaceConfigurationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::
    OnSubscriptionEstablished(void * context)
{
    auto * self
        = static_cast<CHIPThermostatUserInterfaceConfigurationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThermostatUserInterfaceConfigurationAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThermostatUserInterfaceConfigurationAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPThermostatUserInterfaceConfigurationAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsNeighborTableListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPThreadNetworkDiagnosticsClusterNeighborTable * newElement_0;
        newElement_0 = [CHIPThreadNetworkDiagnosticsClusterNeighborTable new];
        newElement_0.extAddress = [NSNumber numberWithUnsignedLongLong:entry_0.extAddress];
        newElement_0.age = [NSNumber numberWithUnsignedInt:entry_0.age];
        newElement_0.rloc16 = [NSNumber numberWithUnsignedShort:entry_0.rloc16];
        newElement_0.linkFrameCounter = [NSNumber numberWithUnsignedInt:entry_0.linkFrameCounter];
        newElement_0.mleFrameCounter = [NSNumber numberWithUnsignedInt:entry_0.mleFrameCounter];
        newElement_0.lqi = [NSNumber numberWithUnsignedChar:entry_0.lqi];
        newElement_0.averageRssi = [NSNumber numberWithChar:entry_0.averageRssi];
        newElement_0.lastRssi = [NSNumber numberWithChar:entry_0.lastRssi];
        newElement_0.frameErrorRate = [NSNumber numberWithUnsignedChar:entry_0.frameErrorRate];
        newElement_0.messageErrorRate = [NSNumber numberWithUnsignedChar:entry_0.messageErrorRate];
        newElement_0.rxOnWhenIdle = [NSNumber numberWithBool:entry_0.rxOnWhenIdle];
        newElement_0.fullThreadDevice = [NSNumber numberWithBool:entry_0.fullThreadDevice];
        newElement_0.fullNetworkData = [NSNumber numberWithBool:entry_0.fullNetworkData];
        newElement_0.isChild = [NSNumber numberWithBool:entry_0.isChild];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsNeighborTableListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPThreadNetworkDiagnosticsNeighborTableListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsRouteTableListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType> &
        value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPThreadNetworkDiagnosticsClusterRouteTable * newElement_0;
        newElement_0 = [CHIPThreadNetworkDiagnosticsClusterRouteTable new];
        newElement_0.extAddress = [NSNumber numberWithUnsignedLongLong:entry_0.extAddress];
        newElement_0.rloc16 = [NSNumber numberWithUnsignedShort:entry_0.rloc16];
        newElement_0.routerId = [NSNumber numberWithUnsignedChar:entry_0.routerId];
        newElement_0.nextHop = [NSNumber numberWithUnsignedChar:entry_0.nextHop];
        newElement_0.pathCost = [NSNumber numberWithUnsignedChar:entry_0.pathCost];
        newElement_0.lqiIn = [NSNumber numberWithUnsignedChar:entry_0.LQIIn];
        newElement_0.lqiOut = [NSNumber numberWithUnsignedChar:entry_0.LQIOut];
        newElement_0.age = [NSNumber numberWithUnsignedChar:entry_0.age];
        newElement_0.allocated = [NSNumber numberWithBool:entry_0.allocated];
        newElement_0.linkEstablished = [NSNumber numberWithBool:entry_0.linkEstablished];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsRouteTableListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPThreadNetworkDiagnosticsRouteTableListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsSecurityPolicyListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPThreadNetworkDiagnosticsClusterSecurityPolicy * newElement_0;
        newElement_0 = [CHIPThreadNetworkDiagnosticsClusterSecurityPolicy new];
        newElement_0.rotationTime = [NSNumber numberWithUnsignedShort:entry_0.rotationTime];
        newElement_0.flags = [NSNumber numberWithUnsignedShort:entry_0.flags];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsSecurityPolicyListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPThreadNetworkDiagnosticsSecurityPolicyListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPThreadNetworkDiagnosticsClusterOperationalDatasetComponents * newElement_0;
        newElement_0 = [CHIPThreadNetworkDiagnosticsClusterOperationalDatasetComponents new];
        newElement_0.activeTimestampPresent = [NSNumber numberWithBool:entry_0.activeTimestampPresent];
        newElement_0.pendingTimestampPresent = [NSNumber numberWithBool:entry_0.pendingTimestampPresent];
        newElement_0.masterKeyPresent = [NSNumber numberWithBool:entry_0.masterKeyPresent];
        newElement_0.networkNamePresent = [NSNumber numberWithBool:entry_0.networkNamePresent];
        newElement_0.extendedPanIdPresent = [NSNumber numberWithBool:entry_0.extendedPanIdPresent];
        newElement_0.meshLocalPrefixPresent = [NSNumber numberWithBool:entry_0.meshLocalPrefixPresent];
        newElement_0.delayPresent = [NSNumber numberWithBool:entry_0.delayPresent];
        newElement_0.panIdPresent = [NSNumber numberWithBool:entry_0.panIdPresent];
        newElement_0.channelPresent = [NSNumber numberWithBool:entry_0.channelPresent];
        newElement_0.pskcPresent = [NSNumber numberWithBool:entry_0.pskcPresent];
        newElement_0.securityPolicyPresent = [NSNumber numberWithBool:entry_0.securityPolicyPresent];
        newElement_0.channelMaskPresent = [NSNumber numberWithBool:entry_0.channelMaskPresent];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0)];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPThreadNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPThreadNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPThreadNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTimeFormatLocalizationSupportedCalendarTypesListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::app::Clusters::TimeFormatLocalization::CalendarType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_0)];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTimeFormatLocalizationSupportedCalendarTypesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPTimeFormatLocalizationSupportedCalendarTypesListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTimeFormatLocalizationServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTimeFormatLocalizationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPTimeFormatLocalizationServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTimeFormatLocalizationClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPTimeFormatLocalizationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPTimeFormatLocalizationClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPUnitLocalizationAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPUnitLocalizationAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPUnitLocalizationAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPUserLabelLabelListListAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        CHIPUserLabelClusterLabelStruct * newElement_0;
        newElement_0 = [CHIPUserLabelClusterLabelStruct new];
        newElement_0.label = [[NSString alloc] initWithBytes:entry_0.label.data()
                                                      length:entry_0.label.size()
                                                    encoding:NSUTF8StringEncoding];
        newElement_0.value = [[NSString alloc] initWithBytes:entry_0.value.data()
                                                      length:entry_0.value.size()
                                                    encoding:NSUTF8StringEncoding];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPUserLabelLabelListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPUserLabelLabelListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPUserLabelServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPUserLabelServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPUserLabelServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPUserLabelClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPUserLabelClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPUserLabelClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWakeOnLanServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWakeOnLanServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWakeOnLanServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWakeOnLanClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWakeOnLanClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWakeOnLanClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWakeOnLanAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWakeOnLanAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWakeOnLanAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWiFiNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWiFiNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPWiFiNetworkDiagnosticsServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWiFiNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWiFiNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPWiFiNetworkDiagnosticsClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWiFiNetworkDiagnosticsAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWiFiNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWiFiNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWindowCoveringServerGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWindowCoveringServerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWindowCoveringServerGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWindowCoveringClientGeneratedCommandListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::CommandId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWindowCoveringClientGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWindowCoveringClientGeneratedCommandListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWindowCoveringAttributeListListAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::DecodableList<chip::AttributeId> & value)
{
    NSArray * _Nonnull objCValue;
    auto * array_0 = [NSMutableArray new];
    auto iter_0 = value.begin();
    while (iter_0.Next()) {
        auto & entry_0 = iter_0.GetValue();
        NSNumber * newElement_0;
        newElement_0 = [NSNumber numberWithUnsignedInt:entry_0];
        [array_0 addObject:newElement_0];
    }
    { // Scope for the error so we will know what it's named
        CHIP_ERROR err = iter_0.GetStatus();
        if (err != CHIP_NO_ERROR) {
            OnFailureFn(context, err);
            return;
        }
    }
    objCValue = array_0;
    DispatchSuccess(context, objCValue);
};

void CHIPWindowCoveringAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWindowCoveringAttributeListListAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccountLoginClusterGetSetupPINResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType & data)
{
    auto * response = [CHIPAccountLoginClusterGetSetupPINResponseParams new];
    {
        response.setupPIN = [[NSString alloc] initWithBytes:data.setupPIN.data()
                                                     length:data.setupPIN.size()
                                                   encoding:NSUTF8StringEncoding];
    }
    DispatchSuccess(context, response);
};

void CHIPApplicationLauncherClusterLauncherResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType & data)
{
    auto * response = [CHIPApplicationLauncherClusterLauncherResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    {
        response.data = [NSData dataWithBytes:data.data.data() length:data.data.size()];
    }
    DispatchSuccess(context, response);
};

void CHIPChannelClusterChangeChannelResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Channel::Commands::ChangeChannelResponse::DecodableType & data)
{
    auto * response = [CHIPChannelClusterChangeChannelResponseParams new];
    {
        response.channelMatch = [CHIPChannelClusterChannelInfo new];
        response.channelMatch.majorNumber = [NSNumber numberWithUnsignedShort:data.channelMatch.majorNumber];
        response.channelMatch.minorNumber = [NSNumber numberWithUnsignedShort:data.channelMatch.minorNumber];
        if (data.channelMatch.name.HasValue()) {
            response.channelMatch.name = [[NSString alloc] initWithBytes:data.channelMatch.name.Value().data()
                                                                  length:data.channelMatch.name.Value().size()
                                                                encoding:NSUTF8StringEncoding];
        } else {
            response.channelMatch.name = nil;
        }
        if (data.channelMatch.callSign.HasValue()) {
            response.channelMatch.callSign = [[NSString alloc] initWithBytes:data.channelMatch.callSign.Value().data()
                                                                      length:data.channelMatch.callSign.Value().size()
                                                                    encoding:NSUTF8StringEncoding];
        } else {
            response.channelMatch.callSign = nil;
        }
        if (data.channelMatch.affiliateCallSign.HasValue()) {
            response.channelMatch.affiliateCallSign =
                [[NSString alloc] initWithBytes:data.channelMatch.affiliateCallSign.Value().data()
                                         length:data.channelMatch.affiliateCallSign.Value().size()
                                       encoding:NSUTF8StringEncoding];
        } else {
            response.channelMatch.affiliateCallSign = nil;
        }
    }
    {
        response.errorType = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.errorType)];
    }
    DispatchSuccess(context, response);
};

void CHIPContentLauncherClusterLaunchResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::ContentLauncher::Commands::LaunchResponse::DecodableType & data)
{
    auto * response = [CHIPContentLauncherClusterLaunchResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    {
        if (data.data.HasValue()) {
            response.data = [[NSString alloc] initWithBytes:data.data.Value().data()
                                                     length:data.data.Value().size()
                                                   encoding:NSUTF8StringEncoding];
        } else {
            response.data = nil;
        }
    }
    DispatchSuccess(context, response);
};

void CHIPDiagnosticLogsClusterRetrieveLogsResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::DiagnosticLogs::Commands::RetrieveLogsResponse::DecodableType & data)
{
    auto * response = [CHIPDiagnosticLogsClusterRetrieveLogsResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    {
        response.content = [NSData dataWithBytes:data.content.data() length:data.content.size()];
    }
    {
        response.timeStamp = [NSNumber numberWithUnsignedInt:data.timeStamp];
    }
    {
        response.timeSinceBoot = [NSNumber numberWithUnsignedInt:data.timeSinceBoot];
    }
    DispatchSuccess(context, response);
};

void CHIPDoorLockClusterGetCredentialStatusResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType & data)
{
    auto * response = [CHIPDoorLockClusterGetCredentialStatusResponseParams new];
    {
        response.credentialExists = [NSNumber numberWithBool:data.credentialExists];
    }
    {
        if (data.userIndex.IsNull()) {
            response.userIndex = nil;
        } else {
            response.userIndex = [NSNumber numberWithUnsignedShort:data.userIndex.Value()];
        }
    }
    {
        if (data.nextCredentialIndex.IsNull()) {
            response.nextCredentialIndex = nil;
        } else {
            response.nextCredentialIndex = [NSNumber numberWithUnsignedShort:data.nextCredentialIndex.Value()];
        }
    }
    DispatchSuccess(context, response);
};

void CHIPDoorLockClusterGetUserResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType & data)
{
    auto * response = [CHIPDoorLockClusterGetUserResponseParams new];
    {
        response.userIndex = [NSNumber numberWithUnsignedShort:data.userIndex];
    }
    {
        if (data.userName.IsNull()) {
            response.userName = nil;
        } else {
            response.userName = [[NSString alloc] initWithBytes:data.userName.Value().data()
                                                         length:data.userName.Value().size()
                                                       encoding:NSUTF8StringEncoding];
        }
    }
    {
        if (data.userUniqueId.IsNull()) {
            response.userUniqueId = nil;
        } else {
            response.userUniqueId = [NSNumber numberWithUnsignedInt:data.userUniqueId.Value()];
        }
    }
    {
        if (data.userStatus.IsNull()) {
            response.userStatus = nil;
        } else {
            response.userStatus = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.userStatus.Value())];
        }
    }
    {
        if (data.userType.IsNull()) {
            response.userType = nil;
        } else {
            response.userType = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.userType.Value())];
        }
    }
    {
        if (data.credentialRule.IsNull()) {
            response.credentialRule = nil;
        } else {
            response.credentialRule = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.credentialRule.Value())];
        }
    }
    {
        if (data.credentials.IsNull()) {
            response.credentials = nil;
        } else {
            auto * array_1 = [NSMutableArray new];
            auto iter_1 = data.credentials.Value().begin();
            while (iter_1.Next()) {
                auto & entry_1 = iter_1.GetValue();
                CHIPDoorLockClusterDlCredential * newElement_1;
                newElement_1 = [CHIPDoorLockClusterDlCredential new];
                newElement_1.credentialType = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_1.credentialType)];
                newElement_1.credentialIndex = [NSNumber numberWithUnsignedShort:entry_1.credentialIndex];
                [array_1 addObject:newElement_1];
            }
            { // Scope for the error so we will know what it's named
                CHIP_ERROR err = iter_1.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    OnFailureFn(context, err);
                    return;
                }
            }
            response.credentials = array_1;
        }
    }
    {
        if (data.creatorFabricIndex.IsNull()) {
            response.creatorFabricIndex = nil;
        } else {
            response.creatorFabricIndex = [NSNumber numberWithUnsignedChar:data.creatorFabricIndex.Value()];
        }
    }
    {
        if (data.lastModifiedFabricIndex.IsNull()) {
            response.lastModifiedFabricIndex = nil;
        } else {
            response.lastModifiedFabricIndex = [NSNumber numberWithUnsignedChar:data.lastModifiedFabricIndex.Value()];
        }
    }
    {
        if (data.nextUserIndex.IsNull()) {
            response.nextUserIndex = nil;
        } else {
            response.nextUserIndex = [NSNumber numberWithUnsignedShort:data.nextUserIndex.Value()];
        }
    }
    DispatchSuccess(context, response);
};

void CHIPDoorLockClusterGetWeekDayScheduleResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType & data)
{
    auto * response = [CHIPDoorLockClusterGetWeekDayScheduleResponseParams new];
    {
        response.weekDayIndex = [NSNumber numberWithUnsignedChar:data.weekDayIndex];
    }
    {
        response.userIndex = [NSNumber numberWithUnsignedShort:data.userIndex];
    }
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    {
        if (data.daysMask.HasValue()) {
            response.daysMask = [NSNumber numberWithUnsignedChar:data.daysMask.Value().Raw()];
        } else {
            response.daysMask = nil;
        }
    }
    {
        if (data.startHour.HasValue()) {
            response.startHour = [NSNumber numberWithUnsignedChar:data.startHour.Value()];
        } else {
            response.startHour = nil;
        }
    }
    {
        if (data.startMinute.HasValue()) {
            response.startMinute = [NSNumber numberWithUnsignedChar:data.startMinute.Value()];
        } else {
            response.startMinute = nil;
        }
    }
    {
        if (data.endHour.HasValue()) {
            response.endHour = [NSNumber numberWithUnsignedChar:data.endHour.Value()];
        } else {
            response.endHour = nil;
        }
    }
    {
        if (data.endMinute.HasValue()) {
            response.endMinute = [NSNumber numberWithUnsignedChar:data.endMinute.Value()];
        } else {
            response.endMinute = nil;
        }
    }
    DispatchSuccess(context, response);
};

void CHIPDoorLockClusterGetYearDayScheduleResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType & data)
{
    auto * response = [CHIPDoorLockClusterGetYearDayScheduleResponseParams new];
    {
        response.yearDayIndex = [NSNumber numberWithUnsignedChar:data.yearDayIndex];
    }
    {
        response.userIndex = [NSNumber numberWithUnsignedShort:data.userIndex];
    }
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    {
        if (data.localStartTime.HasValue()) {
            response.localStartTime = [NSNumber numberWithUnsignedInt:data.localStartTime.Value()];
        } else {
            response.localStartTime = nil;
        }
    }
    {
        if (data.localEndTime.HasValue()) {
            response.localEndTime = [NSNumber numberWithUnsignedInt:data.localEndTime.Value()];
        } else {
            response.localEndTime = nil;
        }
    }
    DispatchSuccess(context, response);
};

void CHIPDoorLockClusterSetCredentialResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType & data)
{
    auto * response = [CHIPDoorLockClusterSetCredentialResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    {
        if (data.userIndex.IsNull()) {
            response.userIndex = nil;
        } else {
            response.userIndex = [NSNumber numberWithUnsignedShort:data.userIndex.Value()];
        }
    }
    {
        if (data.nextCredentialIndex.IsNull()) {
            response.nextCredentialIndex = nil;
        } else {
            response.nextCredentialIndex = [NSNumber numberWithUnsignedShort:data.nextCredentialIndex.Value()];
        }
    }
    DispatchSuccess(context, response);
};

void CHIPGeneralCommissioningClusterArmFailSafeResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType & data)
{
    auto * response = [CHIPGeneralCommissioningClusterArmFailSafeResponseParams new];
    {
        response.errorCode = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.errorCode)];
    }
    {
        response.debugText = [[NSString alloc] initWithBytes:data.debugText.data()
                                                      length:data.debugText.size()
                                                    encoding:NSUTF8StringEncoding];
    }
    DispatchSuccess(context, response);
};

void CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType & data)
{
    auto * response = [CHIPGeneralCommissioningClusterCommissioningCompleteResponseParams new];
    {
        response.errorCode = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.errorCode)];
    }
    {
        response.debugText = [[NSString alloc] initWithBytes:data.debugText.data()
                                                      length:data.debugText.size()
                                                    encoding:NSUTF8StringEncoding];
    }
    DispatchSuccess(context, response);
};

void CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::GeneralCommissioning::Commands::SetRegulatoryConfigResponse::DecodableType & data)
{
    auto * response = [CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseParams new];
    {
        response.errorCode = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.errorCode)];
    }
    {
        response.debugText = [[NSString alloc] initWithBytes:data.debugText.data()
                                                      length:data.debugText.size()
                                                    encoding:NSUTF8StringEncoding];
    }
    DispatchSuccess(context, response);
};

void CHIPGroupKeyManagementClusterKeySetReadAllIndicesResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadAllIndicesResponse::DecodableType & data)
{
    auto * response = [CHIPGroupKeyManagementClusterKeySetReadAllIndicesResponseParams new];
    {
        auto * array_0 = [NSMutableArray new];
        auto iter_0 = data.groupKeySetIDs.begin();
        while (iter_0.Next()) {
            auto & entry_0 = iter_0.GetValue();
            NSNumber * newElement_0;
            newElement_0 = [NSNumber numberWithUnsignedShort:entry_0];
            [array_0 addObject:newElement_0];
        }
        { // Scope for the error so we will know what it's named
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                OnFailureFn(context, err);
                return;
            }
        }
        response.groupKeySetIDs = array_0;
    }
    DispatchSuccess(context, response);
};

void CHIPGroupKeyManagementClusterKeySetReadResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType & data)
{
    auto * response = [CHIPGroupKeyManagementClusterKeySetReadResponseParams new];
    {
        response.groupKeySet = [CHIPGroupKeyManagementClusterGroupKeySetStruct new];
        response.groupKeySet.groupKeySetID = [NSNumber numberWithUnsignedShort:data.groupKeySet.groupKeySetID];
        response.groupKeySet.groupKeySecurityPolicy =
            [NSNumber numberWithUnsignedChar:chip::to_underlying(data.groupKeySet.groupKeySecurityPolicy)];
        if (data.groupKeySet.epochKey0.IsNull()) {
            response.groupKeySet.epochKey0 = nil;
        } else {
            response.groupKeySet.epochKey0 = [NSData dataWithBytes:data.groupKeySet.epochKey0.Value().data()
                                                            length:data.groupKeySet.epochKey0.Value().size()];
        }
        if (data.groupKeySet.epochStartTime0.IsNull()) {
            response.groupKeySet.epochStartTime0 = nil;
        } else {
            response.groupKeySet.epochStartTime0 = [NSNumber numberWithUnsignedLongLong:data.groupKeySet.epochStartTime0.Value()];
        }
        if (data.groupKeySet.epochKey1.IsNull()) {
            response.groupKeySet.epochKey1 = nil;
        } else {
            response.groupKeySet.epochKey1 = [NSData dataWithBytes:data.groupKeySet.epochKey1.Value().data()
                                                            length:data.groupKeySet.epochKey1.Value().size()];
        }
        if (data.groupKeySet.epochStartTime1.IsNull()) {
            response.groupKeySet.epochStartTime1 = nil;
        } else {
            response.groupKeySet.epochStartTime1 = [NSNumber numberWithUnsignedLongLong:data.groupKeySet.epochStartTime1.Value()];
        }
        if (data.groupKeySet.epochKey2.IsNull()) {
            response.groupKeySet.epochKey2 = nil;
        } else {
            response.groupKeySet.epochKey2 = [NSData dataWithBytes:data.groupKeySet.epochKey2.Value().data()
                                                            length:data.groupKeySet.epochKey2.Value().size()];
        }
        if (data.groupKeySet.epochStartTime2.IsNull()) {
            response.groupKeySet.epochStartTime2 = nil;
        } else {
            response.groupKeySet.epochStartTime2 = [NSNumber numberWithUnsignedLongLong:data.groupKeySet.epochStartTime2.Value()];
        }
    }
    DispatchSuccess(context, response);
};

void CHIPGroupsClusterAddGroupResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType & data)
{
    auto * response = [CHIPGroupsClusterAddGroupResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    DispatchSuccess(context, response);
};

void CHIPGroupsClusterGetGroupMembershipResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType & data)
{
    auto * response = [CHIPGroupsClusterGetGroupMembershipResponseParams new];
    {
        response.capacity = [NSNumber numberWithUnsignedChar:data.capacity];
    }
    {
        auto * array_0 = [NSMutableArray new];
        auto iter_0 = data.groupList.begin();
        while (iter_0.Next()) {
            auto & entry_0 = iter_0.GetValue();
            NSNumber * newElement_0;
            newElement_0 = [NSNumber numberWithUnsignedShort:entry_0];
            [array_0 addObject:newElement_0];
        }
        { // Scope for the error so we will know what it's named
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                OnFailureFn(context, err);
                return;
            }
        }
        response.groupList = array_0;
    }
    DispatchSuccess(context, response);
};

void CHIPGroupsClusterRemoveGroupResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Groups::Commands::RemoveGroupResponse::DecodableType & data)
{
    auto * response = [CHIPGroupsClusterRemoveGroupResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    DispatchSuccess(context, response);
};

void CHIPGroupsClusterViewGroupResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType & data)
{
    auto * response = [CHIPGroupsClusterViewGroupResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    {
        response.groupName = [[NSString alloc] initWithBytes:data.groupName.data()
                                                      length:data.groupName.size()
                                                    encoding:NSUTF8StringEncoding];
    }
    DispatchSuccess(context, response);
};

void CHIPIdentifyClusterIdentifyQueryResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Identify::Commands::IdentifyQueryResponse::DecodableType & data)
{
    auto * response = [CHIPIdentifyClusterIdentifyQueryResponseParams new];
    {
        response.timeout = [NSNumber numberWithUnsignedShort:data.timeout];
    }
    DispatchSuccess(context, response);
};

void CHIPKeypadInputClusterSendKeyResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType & data)
{
    auto * response = [CHIPKeypadInputClusterSendKeyResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    DispatchSuccess(context, response);
};

void CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType & data)
{
    auto * response = [CHIPMediaPlaybackClusterPlaybackResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    DispatchSuccess(context, response);
};

void CHIPNetworkCommissioningClusterConnectNetworkResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::ConnectNetworkResponse::DecodableType & data)
{
    auto * response = [CHIPNetworkCommissioningClusterConnectNetworkResponseParams new];
    {
        response.networkingStatus = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.networkingStatus)];
    }
    {
        response.debugText = [[NSString alloc] initWithBytes:data.debugText.data()
                                                      length:data.debugText.size()
                                                    encoding:NSUTF8StringEncoding];
    }
    {
        response.errorValue = [NSNumber numberWithInt:data.errorValue];
    }
    DispatchSuccess(context, response);
};

void CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType & data)
{
    auto * response = [CHIPNetworkCommissioningClusterNetworkConfigResponseParams new];
    {
        response.networkingStatus = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.networkingStatus)];
    }
    {
        response.debugText = [[NSString alloc] initWithBytes:data.debugText.data()
                                                      length:data.debugText.size()
                                                    encoding:NSUTF8StringEncoding];
    }
    DispatchSuccess(context, response);
};

void CHIPNetworkCommissioningClusterScanNetworksResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::NetworkCommissioning::Commands::ScanNetworksResponse::DecodableType & data)
{
    auto * response = [CHIPNetworkCommissioningClusterScanNetworksResponseParams new];
    {
        response.networkingStatus = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.networkingStatus)];
    }
    {
        response.debugText = [[NSString alloc] initWithBytes:data.debugText.data()
                                                      length:data.debugText.size()
                                                    encoding:NSUTF8StringEncoding];
    }
    {
        if (data.wiFiScanResults.HasValue()) {
            auto * array_1 = [NSMutableArray new];
            auto iter_1 = data.wiFiScanResults.Value().begin();
            while (iter_1.Next()) {
                auto & entry_1 = iter_1.GetValue();
                CHIPNetworkCommissioningClusterWiFiInterfaceScanResult * newElement_1;
                newElement_1 = [CHIPNetworkCommissioningClusterWiFiInterfaceScanResult new];
                newElement_1.security = [NSNumber numberWithUnsignedChar:entry_1.security];
                newElement_1.ssid = [NSData dataWithBytes:entry_1.ssid.data() length:entry_1.ssid.size()];
                newElement_1.bssid = [NSData dataWithBytes:entry_1.bssid.data() length:entry_1.bssid.size()];
                newElement_1.channel = [NSNumber numberWithUnsignedShort:entry_1.channel];
                newElement_1.wiFiBand = [NSNumber numberWithUnsignedChar:chip::to_underlying(entry_1.wiFiBand)];
                newElement_1.rssi = [NSNumber numberWithChar:entry_1.rssi];
                [array_1 addObject:newElement_1];
            }
            { // Scope for the error so we will know what it's named
                CHIP_ERROR err = iter_1.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    OnFailureFn(context, err);
                    return;
                }
            }
            response.wiFiScanResults = array_1;
        } else {
            response.wiFiScanResults = nil;
        }
    }
    {
        if (data.threadScanResults.HasValue()) {
            auto * array_1 = [NSMutableArray new];
            auto iter_1 = data.threadScanResults.Value().begin();
            while (iter_1.Next()) {
                auto & entry_1 = iter_1.GetValue();
                CHIPNetworkCommissioningClusterThreadInterfaceScanResult * newElement_1;
                newElement_1 = [CHIPNetworkCommissioningClusterThreadInterfaceScanResult new];
                newElement_1.panId = [NSNumber numberWithUnsignedLongLong:entry_1.panId];
                newElement_1.extendedPanId = [NSNumber numberWithUnsignedLongLong:entry_1.extendedPanId];
                newElement_1.networkName = [[NSString alloc] initWithBytes:entry_1.networkName.data()
                                                                    length:entry_1.networkName.size()
                                                                  encoding:NSUTF8StringEncoding];
                newElement_1.channel = [NSNumber numberWithUnsignedShort:entry_1.channel];
                newElement_1.version = [NSNumber numberWithUnsignedChar:entry_1.version];
                newElement_1.extendedAddress = [NSNumber numberWithUnsignedLongLong:entry_1.extendedAddress];
                newElement_1.rssi = [NSNumber numberWithChar:entry_1.rssi];
                newElement_1.lqi = [NSNumber numberWithUnsignedChar:entry_1.lqi];
                [array_1 addObject:newElement_1];
            }
            { // Scope for the error so we will know what it's named
                CHIP_ERROR err = iter_1.GetStatus();
                if (err != CHIP_NO_ERROR) {
                    OnFailureFn(context, err);
                    return;
                }
            }
            response.threadScanResults = array_1;
        } else {
            response.threadScanResults = nil;
        }
    }
    DispatchSuccess(context, response);
};

void CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateResponse::DecodableType & data)
{
    auto * response = [CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseParams new];
    {
        response.action = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.action)];
    }
    {
        response.delayedActionTime = [NSNumber numberWithUnsignedInt:data.delayedActionTime];
    }
    DispatchSuccess(context, response);
};

void CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::OtaSoftwareUpdateProvider::Commands::QueryImageResponse::DecodableType & data)
{
    auto * response = [CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    {
        if (data.delayedActionTime.HasValue()) {
            response.delayedActionTime = [NSNumber numberWithUnsignedInt:data.delayedActionTime.Value()];
        } else {
            response.delayedActionTime = nil;
        }
    }
    {
        if (data.imageURI.HasValue()) {
            response.imageURI = [[NSString alloc] initWithBytes:data.imageURI.Value().data()
                                                         length:data.imageURI.Value().size()
                                                       encoding:NSUTF8StringEncoding];
        } else {
            response.imageURI = nil;
        }
    }
    {
        if (data.softwareVersion.HasValue()) {
            response.softwareVersion = [NSNumber numberWithUnsignedInt:data.softwareVersion.Value()];
        } else {
            response.softwareVersion = nil;
        }
    }
    {
        if (data.softwareVersionString.HasValue()) {
            response.softwareVersionString = [[NSString alloc] initWithBytes:data.softwareVersionString.Value().data()
                                                                      length:data.softwareVersionString.Value().size()
                                                                    encoding:NSUTF8StringEncoding];
        } else {
            response.softwareVersionString = nil;
        }
    }
    {
        if (data.updateToken.HasValue()) {
            response.updateToken = [NSData dataWithBytes:data.updateToken.Value().data() length:data.updateToken.Value().size()];
        } else {
            response.updateToken = nil;
        }
    }
    {
        if (data.userConsentNeeded.HasValue()) {
            response.userConsentNeeded = [NSNumber numberWithBool:data.userConsentNeeded.Value()];
        } else {
            response.userConsentNeeded = nil;
        }
    }
    {
        if (data.metadataForRequestor.HasValue()) {
            response.metadataForRequestor = [NSData dataWithBytes:data.metadataForRequestor.Value().data()
                                                           length:data.metadataForRequestor.Value().size()];
        } else {
            response.metadataForRequestor = nil;
        }
    }
    DispatchSuccess(context, response);
};

void CHIPOperationalCredentialsClusterAttestationResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::AttestationResponse::DecodableType & data)
{
    auto * response = [CHIPOperationalCredentialsClusterAttestationResponseParams new];
    {
        response.attestationElements = [NSData dataWithBytes:data.attestationElements.data()
                                                      length:data.attestationElements.size()];
    }
    {
        response.signature = [NSData dataWithBytes:data.signature.data() length:data.signature.size()];
    }
    DispatchSuccess(context, response);
};

void CHIPOperationalCredentialsClusterCSRResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::CSRResponse::DecodableType & data)
{
    auto * response = [CHIPOperationalCredentialsClusterCSRResponseParams new];
    {
        response.nocsrElements = [NSData dataWithBytes:data.NOCSRElements.data() length:data.NOCSRElements.size()];
    }
    {
        response.attestationSignature = [NSData dataWithBytes:data.attestationSignature.data()
                                                       length:data.attestationSignature.size()];
    }
    DispatchSuccess(context, response);
};

void CHIPOperationalCredentialsClusterCertificateChainResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::CertificateChainResponse::DecodableType & data)
{
    auto * response = [CHIPOperationalCredentialsClusterCertificateChainResponseParams new];
    {
        response.certificate = [NSData dataWithBytes:data.certificate.data() length:data.certificate.size()];
    }
    DispatchSuccess(context, response);
};

void CHIPOperationalCredentialsClusterNOCResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType & data)
{
    auto * response = [CHIPOperationalCredentialsClusterNOCResponseParams new];
    {
        response.statusCode = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.statusCode)];
    }
    {
        if (data.fabricIndex.HasValue()) {
            response.fabricIndex = [NSNumber numberWithUnsignedChar:data.fabricIndex.Value()];
        } else {
            response.fabricIndex = nil;
        }
    }
    {
        if (data.debugText.HasValue()) {
            response.debugText = [[NSString alloc] initWithBytes:data.debugText.Value().data()
                                                          length:data.debugText.Value().size()
                                                        encoding:NSUTF8StringEncoding];
        } else {
            response.debugText = nil;
        }
    }
    DispatchSuccess(context, response);
};

void CHIPScenesClusterAddSceneResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Scenes::Commands::AddSceneResponse::DecodableType & data)
{
    auto * response = [CHIPScenesClusterAddSceneResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    {
        response.sceneId = [NSNumber numberWithUnsignedChar:data.sceneId];
    }
    DispatchSuccess(context, response);
};

void CHIPScenesClusterGetSceneMembershipResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Scenes::Commands::GetSceneMembershipResponse::DecodableType & data)
{
    auto * response = [CHIPScenesClusterGetSceneMembershipResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.capacity = [NSNumber numberWithUnsignedChar:data.capacity];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    {
        response.sceneCount = [NSNumber numberWithUnsignedChar:data.sceneCount];
    }
    {
        auto * array_0 = [NSMutableArray new];
        auto iter_0 = data.sceneList.begin();
        while (iter_0.Next()) {
            auto & entry_0 = iter_0.GetValue();
            NSNumber * newElement_0;
            newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
            [array_0 addObject:newElement_0];
        }
        { // Scope for the error so we will know what it's named
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                OnFailureFn(context, err);
                return;
            }
        }
        response.sceneList = array_0;
    }
    DispatchSuccess(context, response);
};

void CHIPScenesClusterRemoveAllScenesResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Scenes::Commands::RemoveAllScenesResponse::DecodableType & data)
{
    auto * response = [CHIPScenesClusterRemoveAllScenesResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    DispatchSuccess(context, response);
};

void CHIPScenesClusterRemoveSceneResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Scenes::Commands::RemoveSceneResponse::DecodableType & data)
{
    auto * response = [CHIPScenesClusterRemoveSceneResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    {
        response.sceneId = [NSNumber numberWithUnsignedChar:data.sceneId];
    }
    DispatchSuccess(context, response);
};

void CHIPScenesClusterStoreSceneResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Scenes::Commands::StoreSceneResponse::DecodableType & data)
{
    auto * response = [CHIPScenesClusterStoreSceneResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    {
        response.sceneId = [NSNumber numberWithUnsignedChar:data.sceneId];
    }
    DispatchSuccess(context, response);
};

void CHIPScenesClusterViewSceneResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Scenes::Commands::ViewSceneResponse::DecodableType & data)
{
    auto * response = [CHIPScenesClusterViewSceneResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:data.status];
    }
    {
        response.groupId = [NSNumber numberWithUnsignedShort:data.groupId];
    }
    {
        response.sceneId = [NSNumber numberWithUnsignedChar:data.sceneId];
    }
    {
        response.transitionTime = [NSNumber numberWithUnsignedShort:data.transitionTime];
    }
    {
        response.sceneName = [[NSString alloc] initWithBytes:data.sceneName.data()
                                                      length:data.sceneName.size()
                                                    encoding:NSUTF8StringEncoding];
    }
    {
        auto * array_0 = [NSMutableArray new];
        auto iter_0 = data.extensionFieldSets.begin();
        while (iter_0.Next()) {
            auto & entry_0 = iter_0.GetValue();
            CHIPScenesClusterSceneExtensionFieldSet * newElement_0;
            newElement_0 = [CHIPScenesClusterSceneExtensionFieldSet new];
            newElement_0.clusterId = [NSNumber numberWithUnsignedInt:entry_0.clusterId];
            newElement_0.length = [NSNumber numberWithUnsignedChar:entry_0.length];
            newElement_0.value = [NSNumber numberWithUnsignedChar:entry_0.value];
            [array_0 addObject:newElement_0];
        }
        { // Scope for the error so we will know what it's named
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                OnFailureFn(context, err);
                return;
            }
        }
        response.extensionFieldSets = array_0;
    }
    DispatchSuccess(context, response);
};

void CHIPTargetNavigatorClusterNavigateTargetResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType & data)
{
    auto * response = [CHIPTargetNavigatorClusterNavigateTargetResponseParams new];
    {
        response.status = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.status)];
    }
    {
        if (data.data.HasValue()) {
            response.data = [[NSString alloc] initWithBytes:data.data.Value().data()
                                                     length:data.data.Value().size()
                                                   encoding:NSUTF8StringEncoding];
        } else {
            response.data = nil;
        }
    }
    DispatchSuccess(context, response);
};

void CHIPTestClusterClusterBooleanResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType & data)
{
    auto * response = [CHIPTestClusterClusterBooleanResponseParams new];
    {
        response.value = [NSNumber numberWithBool:data.value];
    }
    DispatchSuccess(context, response);
};

void CHIPTestClusterClusterSimpleStructResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Commands::SimpleStructResponse::DecodableType & data)
{
    auto * response = [CHIPTestClusterClusterSimpleStructResponseParams new];
    {
        response.arg1 = [CHIPTestClusterClusterSimpleStruct new];
        response.arg1.a = [NSNumber numberWithUnsignedChar:data.arg1.a];
        response.arg1.b = [NSNumber numberWithBool:data.arg1.b];
        response.arg1.c = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.arg1.c)];
        response.arg1.d = [NSData dataWithBytes:data.arg1.d.data() length:data.arg1.d.size()];
        response.arg1.e = [[NSString alloc] initWithBytes:data.arg1.e.data()
                                                   length:data.arg1.e.size()
                                                 encoding:NSUTF8StringEncoding];
        response.arg1.f = [NSNumber numberWithUnsignedChar:data.arg1.f.Raw()];
        response.arg1.g = [NSNumber numberWithFloat:data.arg1.g];
        response.arg1.h = [NSNumber numberWithDouble:data.arg1.h];
    }
    DispatchSuccess(context, response);
};

void CHIPTestClusterClusterTestAddArgumentsResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType & data)
{
    auto * response = [CHIPTestClusterClusterTestAddArgumentsResponseParams new];
    {
        response.returnValue = [NSNumber numberWithUnsignedChar:data.returnValue];
    }
    DispatchSuccess(context, response);
};

void CHIPTestClusterClusterTestEmitTestEventResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestEmitTestEventResponse::DecodableType & data)
{
    auto * response = [CHIPTestClusterClusterTestEmitTestEventResponseParams new];
    {
        response.value = [NSNumber numberWithUnsignedLongLong:data.value];
    }
    DispatchSuccess(context, response);
};

void CHIPTestClusterClusterTestEnumsResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestEnumsResponse::DecodableType & data)
{
    auto * response = [CHIPTestClusterClusterTestEnumsResponseParams new];
    {
        response.arg1 = [NSNumber numberWithUnsignedShort:chip::to_underlying(data.arg1)];
    }
    {
        response.arg2 = [NSNumber numberWithUnsignedChar:chip::to_underlying(data.arg2)];
    }
    DispatchSuccess(context, response);
};

void CHIPTestClusterClusterTestListInt8UReverseResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType & data)
{
    auto * response = [CHIPTestClusterClusterTestListInt8UReverseResponseParams new];
    {
        auto * array_0 = [NSMutableArray new];
        auto iter_0 = data.arg1.begin();
        while (iter_0.Next()) {
            auto & entry_0 = iter_0.GetValue();
            NSNumber * newElement_0;
            newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
            [array_0 addObject:newElement_0];
        }
        { // Scope for the error so we will know what it's named
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                OnFailureFn(context, err);
                return;
            }
        }
        response.arg1 = array_0;
    }
    DispatchSuccess(context, response);
};

void CHIPTestClusterClusterTestNullableOptionalResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType & data)
{
    auto * response = [CHIPTestClusterClusterTestNullableOptionalResponseParams new];
    {
        response.wasPresent = [NSNumber numberWithBool:data.wasPresent];
    }
    {
        if (data.wasNull.HasValue()) {
            response.wasNull = [NSNumber numberWithBool:data.wasNull.Value()];
        } else {
            response.wasNull = nil;
        }
    }
    {
        if (data.value.HasValue()) {
            response.value = [NSNumber numberWithUnsignedChar:data.value.Value()];
        } else {
            response.value = nil;
        }
    }
    {
        if (data.originalValue.HasValue()) {
            if (data.originalValue.Value().IsNull()) {
                response.originalValue = nil;
            } else {
                response.originalValue = [NSNumber numberWithUnsignedChar:data.originalValue.Value().Value()];
            }
        } else {
            response.originalValue = nil;
        }
    }
    DispatchSuccess(context, response);
};

void CHIPTestClusterClusterTestSpecificResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::TestCluster::Commands::TestSpecificResponse::DecodableType & data)
{
    auto * response = [CHIPTestClusterClusterTestSpecificResponseParams new];
    {
        response.returnValue = [NSNumber numberWithUnsignedChar:data.returnValue];
    }
    DispatchSuccess(context, response);
};

void CHIPThermostatClusterGetRelayStatusLogResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Thermostat::Commands::GetRelayStatusLogResponse::DecodableType & data)
{
    auto * response = [CHIPThermostatClusterGetRelayStatusLogResponseParams new];
    {
        response.timeOfDay = [NSNumber numberWithUnsignedShort:data.timeOfDay];
    }
    {
        response.relayStatus = [NSNumber numberWithUnsignedShort:data.relayStatus];
    }
    {
        response.localTemperature = [NSNumber numberWithShort:data.localTemperature];
    }
    {
        response.humidityInPercentage = [NSNumber numberWithUnsignedChar:data.humidityInPercentage];
    }
    {
        response.setpoint = [NSNumber numberWithShort:data.setpoint];
    }
    {
        response.unreadEntries = [NSNumber numberWithUnsignedShort:data.unreadEntries];
    }
    DispatchSuccess(context, response);
};

void CHIPThermostatClusterGetWeeklyScheduleResponseCallbackBridge::OnSuccessFn(
    void * context, const chip::app::Clusters::Thermostat::Commands::GetWeeklyScheduleResponse::DecodableType & data)
{
    auto * response = [CHIPThermostatClusterGetWeeklyScheduleResponseParams new];
    {
        response.numberOfTransitionsForSequence = [NSNumber numberWithUnsignedChar:data.numberOfTransitionsForSequence];
    }
    {
        response.dayOfWeekForSequence = [NSNumber numberWithUnsignedChar:data.dayOfWeekForSequence.Raw()];
    }
    {
        response.modeForSequence = [NSNumber numberWithUnsignedChar:data.modeForSequence.Raw()];
    }
    {
        auto * array_0 = [NSMutableArray new];
        auto iter_0 = data.payload.begin();
        while (iter_0.Next()) {
            auto & entry_0 = iter_0.GetValue();
            NSNumber * newElement_0;
            newElement_0 = [NSNumber numberWithUnsignedChar:entry_0];
            [array_0 addObject:newElement_0];
        }
        { // Scope for the error so we will know what it's named
            CHIP_ERROR err = iter_0.GetStatus();
            if (err != CHIP_NO_ERROR) {
                OnFailureFn(context, err);
                return;
            }
        }
        response.payload = array_0;
    }
    DispatchSuccess(context, response);
};

void CHIPIdentifyClusterIdentifyEffectIdentifierAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Identify::IdentifyEffectIdentifier value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIdentifyClusterIdentifyEffectIdentifierAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIdentifyClusterIdentifyEffectIdentifierAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIdentifyClusterIdentifyEffectIdentifierAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Identify::IdentifyEffectIdentifier> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIdentifyClusterIdentifyEffectIdentifierAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableIdentifyClusterIdentifyEffectIdentifierAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIdentifyClusterIdentifyEffectVariantAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Identify::IdentifyEffectVariant value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIdentifyClusterIdentifyEffectVariantAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIdentifyClusterIdentifyEffectVariantAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIdentifyClusterIdentifyEffectVariantAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Identify::IdentifyEffectVariant> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIdentifyClusterIdentifyEffectVariantAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIdentifyClusterIdentifyEffectVariantAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIdentifyClusterIdentifyIdentifyTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Identify::IdentifyIdentifyType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIdentifyClusterIdentifyIdentifyTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIdentifyClusterIdentifyIdentifyTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIdentifyClusterIdentifyIdentifyTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Identify::IdentifyIdentifyType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIdentifyClusterIdentifyIdentifyTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIdentifyClusterIdentifyIdentifyTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffClusterOnOffDelayedAllOffEffectVariantAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OnOff::OnOffDelayedAllOffEffectVariant value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffClusterOnOffDelayedAllOffEffectVariantAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOnOffClusterOnOffDelayedAllOffEffectVariantAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOnOffClusterOnOffDelayedAllOffEffectVariantAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffDelayedAllOffEffectVariant> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOnOffClusterOnOffDelayedAllOffEffectVariantAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableOnOffClusterOnOffDelayedAllOffEffectVariantAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffClusterOnOffDyingLightEffectVariantAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OnOff::OnOffDyingLightEffectVariant value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffClusterOnOffDyingLightEffectVariantAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOnOffClusterOnOffDyingLightEffectVariantAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOnOffClusterOnOffDyingLightEffectVariantAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffDyingLightEffectVariant> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOnOffClusterOnOffDyingLightEffectVariantAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableOnOffClusterOnOffDyingLightEffectVariantAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOnOffClusterOnOffEffectIdentifierAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OnOff::OnOffEffectIdentifier value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOnOffClusterOnOffEffectIdentifierAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPOnOffClusterOnOffEffectIdentifierAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOnOffClusterOnOffEffectIdentifierAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffEffectIdentifier> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOnOffClusterOnOffEffectIdentifierAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableOnOffClusterOnOffEffectIdentifierAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLevelControlClusterMoveModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::LevelControl::MoveMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPLevelControlClusterMoveModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLevelControlClusterMoveModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableLevelControlClusterMoveModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::LevelControl::MoveMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableLevelControlClusterMoveModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableLevelControlClusterMoveModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPLevelControlClusterStepModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::LevelControl::StepMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPLevelControlClusterStepModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPLevelControlClusterStepModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableLevelControlClusterStepModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::LevelControl::StepMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableLevelControlClusterStepModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableLevelControlClusterStepModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplianceControlClusterApplianceStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ApplianceControl::ApplianceStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPApplianceControlClusterApplianceStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplianceControlClusterApplianceStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableApplianceControlClusterApplianceStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ApplianceControl::ApplianceStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableApplianceControlClusterApplianceStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableApplianceControlClusterApplianceStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplianceControlClusterCommandIdentificationAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ApplianceControl::CommandIdentification value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPApplianceControlClusterCommandIdentificationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplianceControlClusterCommandIdentificationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableApplianceControlClusterCommandIdentificationAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ApplianceControl::CommandIdentification> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableApplianceControlClusterCommandIdentificationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableApplianceControlClusterCommandIdentificationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplianceControlClusterWarningEventAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ApplianceControl::WarningEvent value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPApplianceControlClusterWarningEventAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplianceControlClusterWarningEventAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableApplianceControlClusterWarningEventAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ApplianceControl::WarningEvent> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableApplianceControlClusterWarningEventAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableApplianceControlClusterWarningEventAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccessControlClusterAuthModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::AccessControl::AuthMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPAccessControlClusterAuthModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccessControlClusterAuthModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableAccessControlClusterAuthModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::AccessControl::AuthMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableAccessControlClusterAuthModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableAccessControlClusterAuthModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccessControlClusterChangeTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::AccessControl::ChangeTypeEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPAccessControlClusterChangeTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccessControlClusterChangeTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableAccessControlClusterChangeTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::AccessControl::ChangeTypeEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableAccessControlClusterChangeTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableAccessControlClusterChangeTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAccessControlClusterPrivilegeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::AccessControl::Privilege value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPAccessControlClusterPrivilegeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAccessControlClusterPrivilegeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableAccessControlClusterPrivilegeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::AccessControl::Privilege> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableAccessControlClusterPrivilegeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableAccessControlClusterPrivilegeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsClusterActionErrorEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::BridgedActions::ActionErrorEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsClusterActionErrorEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsClusterActionErrorEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableBridgedActionsClusterActionErrorEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::BridgedActions::ActionErrorEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableBridgedActionsClusterActionErrorEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableBridgedActionsClusterActionErrorEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsClusterActionStateEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::BridgedActions::ActionStateEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsClusterActionStateEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsClusterActionStateEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableBridgedActionsClusterActionStateEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::BridgedActions::ActionStateEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableBridgedActionsClusterActionStateEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableBridgedActionsClusterActionStateEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsClusterActionTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::BridgedActions::ActionTypeEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsClusterActionTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsClusterActionTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableBridgedActionsClusterActionTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::BridgedActions::ActionTypeEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableBridgedActionsClusterActionTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableBridgedActionsClusterActionTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPBridgedActionsClusterEndpointListTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::BridgedActions::EndpointListTypeEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPBridgedActionsClusterEndpointListTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPBridgedActionsClusterEndpointListTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableBridgedActionsClusterEndpointListTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::BridgedActions::EndpointListTypeEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableBridgedActionsClusterEndpointListTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableBridgedActionsClusterEndpointListTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateProviderClusterOTAApplyUpdateActionAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OtaSoftwareUpdateProvider::OTAApplyUpdateAction value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateProviderClusterOTAApplyUpdateActionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOtaSoftwareUpdateProviderClusterOTAApplyUpdateActionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOtaSoftwareUpdateProviderClusterOTAApplyUpdateActionAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::OtaSoftwareUpdateProvider::OTAApplyUpdateAction> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOtaSoftwareUpdateProviderClusterOTAApplyUpdateActionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableOtaSoftwareUpdateProviderClusterOTAApplyUpdateActionAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateProviderClusterOTADownloadProtocolAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OtaSoftwareUpdateProvider::OTADownloadProtocol value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateProviderClusterOTADownloadProtocolAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOtaSoftwareUpdateProviderClusterOTADownloadProtocolAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOtaSoftwareUpdateProviderClusterOTADownloadProtocolAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::OtaSoftwareUpdateProvider::OTADownloadProtocol> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOtaSoftwareUpdateProviderClusterOTADownloadProtocolAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableOtaSoftwareUpdateProviderClusterOTADownloadProtocolAttributeCallbackSubscriptionBridge *>(
        context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateProviderClusterOTAQueryStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OtaSoftwareUpdateProvider::OTAQueryStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateProviderClusterOTAQueryStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPOtaSoftwareUpdateProviderClusterOTAQueryStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOtaSoftwareUpdateProviderClusterOTAQueryStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::OtaSoftwareUpdateProvider::OTAQueryStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOtaSoftwareUpdateProviderClusterOTAQueryStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableOtaSoftwareUpdateProviderClusterOTAQueryStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateRequestorClusterOTAAnnouncementReasonAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAAnnouncementReason value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateRequestorClusterOTAAnnouncementReasonAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOtaSoftwareUpdateRequestorClusterOTAAnnouncementReasonAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOtaSoftwareUpdateRequestorClusterOTAAnnouncementReasonAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAAnnouncementReason> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOtaSoftwareUpdateRequestorClusterOTAAnnouncementReasonAttributeCallbackSubscriptionBridge::
    OnSubscriptionEstablished(void * context)
{
    auto * self
        = static_cast<CHIPNullableOtaSoftwareUpdateRequestorClusterOTAAnnouncementReasonAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateRequestorClusterOTAChangeReasonEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAChangeReasonEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateRequestorClusterOTAChangeReasonEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOtaSoftwareUpdateRequestorClusterOTAChangeReasonEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOtaSoftwareUpdateRequestorClusterOTAChangeReasonEnumAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAChangeReasonEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOtaSoftwareUpdateRequestorClusterOTAChangeReasonEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableOtaSoftwareUpdateRequestorClusterOTAChangeReasonEnumAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAUpdateStateEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAUpdateStateEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackSubscriptionBridge *>(
        context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTimeFormatLocalizationClusterCalendarTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::TimeFormatLocalization::CalendarType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPTimeFormatLocalizationClusterCalendarTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTimeFormatLocalizationClusterCalendarTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableTimeFormatLocalizationClusterCalendarTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::TimeFormatLocalization::CalendarType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableTimeFormatLocalizationClusterCalendarTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableTimeFormatLocalizationClusterCalendarTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTimeFormatLocalizationClusterHourFormatAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::TimeFormatLocalization::HourFormat value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPTimeFormatLocalizationClusterHourFormatAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTimeFormatLocalizationClusterHourFormatAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableTimeFormatLocalizationClusterHourFormatAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::TimeFormatLocalization::HourFormat> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableTimeFormatLocalizationClusterHourFormatAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableTimeFormatLocalizationClusterHourFormatAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPUnitLocalizationClusterTempUnitAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::UnitLocalization::TempUnit value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPUnitLocalizationClusterTempUnitAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPUnitLocalizationClusterTempUnitAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableUnitLocalizationClusterTempUnitAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::UnitLocalization::TempUnit> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableUnitLocalizationClusterTempUnitAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableUnitLocalizationClusterTempUnitAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClusterBatChargeFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PowerSource::BatChargeFaultType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClusterBatChargeFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClusterBatChargeFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePowerSourceClusterBatChargeFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PowerSource::BatChargeFaultType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePowerSourceClusterBatChargeFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullablePowerSourceClusterBatChargeFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClusterBatChargeLevelAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PowerSource::BatChargeLevel value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClusterBatChargeLevelAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClusterBatChargeLevelAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePowerSourceClusterBatChargeLevelAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PowerSource::BatChargeLevel> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePowerSourceClusterBatChargeLevelAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullablePowerSourceClusterBatChargeLevelAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClusterBatChargeStateAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PowerSource::BatChargeState value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClusterBatChargeStateAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClusterBatChargeStateAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePowerSourceClusterBatChargeStateAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PowerSource::BatChargeState> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePowerSourceClusterBatChargeStateAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullablePowerSourceClusterBatChargeStateAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClusterBatFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PowerSource::BatFaultType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClusterBatFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClusterBatFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePowerSourceClusterBatFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PowerSource::BatFaultType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePowerSourceClusterBatFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullablePowerSourceClusterBatFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClusterBatReplaceabilityAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PowerSource::BatReplaceability value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClusterBatReplaceabilityAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClusterBatReplaceabilityAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePowerSourceClusterBatReplaceabilityAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PowerSource::BatReplaceability> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePowerSourceClusterBatReplaceabilityAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullablePowerSourceClusterBatReplaceabilityAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClusterPowerSourceStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PowerSource::PowerSourceStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClusterPowerSourceStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClusterPowerSourceStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePowerSourceClusterPowerSourceStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PowerSource::PowerSourceStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePowerSourceClusterPowerSourceStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullablePowerSourceClusterPowerSourceStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClusterWiredCurrentTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PowerSource::WiredCurrentType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClusterWiredCurrentTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClusterWiredCurrentTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePowerSourceClusterWiredCurrentTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PowerSource::WiredCurrentType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePowerSourceClusterWiredCurrentTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullablePowerSourceClusterWiredCurrentTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPowerSourceClusterWiredFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PowerSource::WiredFaultType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPowerSourceClusterWiredFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPPowerSourceClusterWiredFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePowerSourceClusterWiredFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PowerSource::WiredFaultType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePowerSourceClusterWiredFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullablePowerSourceClusterWiredFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralCommissioningClusterCommissioningErrorAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::GeneralCommissioning::CommissioningError value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralCommissioningClusterCommissioningErrorAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralCommissioningClusterCommissioningErrorAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableGeneralCommissioningClusterCommissioningErrorAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::GeneralCommissioning::CommissioningError> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableGeneralCommissioningClusterCommissioningErrorAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableGeneralCommissioningClusterCommissioningErrorAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::GeneralCommissioning::RegulatoryLocationType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::GeneralCommissioning::RegulatoryLocationType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackSubscriptionBridge::
    OnSubscriptionEstablished(void * context)
{
    auto * self
        = static_cast<CHIPNullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNetworkCommissioningClusterWiFiBandAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::NetworkCommissioning::WiFiBand value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPNetworkCommissioningClusterWiFiBandAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNetworkCommissioningClusterWiFiBandAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableNetworkCommissioningClusterWiFiBandAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::WiFiBand> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableNetworkCommissioningClusterWiFiBandAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableNetworkCommissioningClusterWiFiBandAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDiagnosticLogsClusterLogsIntentAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DiagnosticLogs::LogsIntent value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDiagnosticLogsClusterLogsIntentAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDiagnosticLogsClusterLogsIntentAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDiagnosticLogsClusterLogsIntentAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DiagnosticLogs::LogsIntent> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDiagnosticLogsClusterLogsIntentAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDiagnosticLogsClusterLogsIntentAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDiagnosticLogsClusterLogsStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DiagnosticLogs::LogsStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDiagnosticLogsClusterLogsStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDiagnosticLogsClusterLogsStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDiagnosticLogsClusterLogsStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DiagnosticLogs::LogsStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDiagnosticLogsClusterLogsStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDiagnosticLogsClusterLogsStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDiagnosticLogsClusterLogsTransferProtocolAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DiagnosticLogs::LogsTransferProtocol value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDiagnosticLogsClusterLogsTransferProtocolAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDiagnosticLogsClusterLogsTransferProtocolAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDiagnosticLogsClusterLogsTransferProtocolAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DiagnosticLogs::LogsTransferProtocol> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDiagnosticLogsClusterLogsTransferProtocolAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableDiagnosticLogsClusterLogsTransferProtocolAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsClusterBootReasonTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::GeneralDiagnostics::BootReasonType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsClusterBootReasonTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsClusterBootReasonTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableGeneralDiagnosticsClusterBootReasonTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::GeneralDiagnostics::BootReasonType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableGeneralDiagnosticsClusterBootReasonTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableGeneralDiagnosticsClusterBootReasonTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsClusterHardwareFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::GeneralDiagnostics::HardwareFaultType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsClusterHardwareFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsClusterHardwareFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableGeneralDiagnosticsClusterHardwareFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::GeneralDiagnostics::HardwareFaultType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableGeneralDiagnosticsClusterHardwareFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableGeneralDiagnosticsClusterHardwareFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsClusterInterfaceTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::GeneralDiagnostics::InterfaceType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsClusterInterfaceTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsClusterInterfaceTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableGeneralDiagnosticsClusterInterfaceTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::GeneralDiagnostics::InterfaceType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableGeneralDiagnosticsClusterInterfaceTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableGeneralDiagnosticsClusterInterfaceTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsClusterNetworkFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::GeneralDiagnostics::NetworkFaultType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsClusterNetworkFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsClusterNetworkFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableGeneralDiagnosticsClusterNetworkFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::GeneralDiagnostics::NetworkFaultType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableGeneralDiagnosticsClusterNetworkFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableGeneralDiagnosticsClusterNetworkFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGeneralDiagnosticsClusterRadioFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::GeneralDiagnostics::RadioFaultType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPGeneralDiagnosticsClusterRadioFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPGeneralDiagnosticsClusterRadioFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableGeneralDiagnosticsClusterRadioFaultTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::GeneralDiagnostics::RadioFaultType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableGeneralDiagnosticsClusterRadioFaultTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableGeneralDiagnosticsClusterRadioFaultTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsClusterNetworkFaultAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsClusterNetworkFaultAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPThreadNetworkDiagnosticsClusterNetworkFaultAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableThreadNetworkDiagnosticsClusterNetworkFaultAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableThreadNetworkDiagnosticsClusterNetworkFaultAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableThreadNetworkDiagnosticsClusterNetworkFaultAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsClusterRoutingRoleAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRole value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsClusterRoutingRoleAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPThreadNetworkDiagnosticsClusterRoutingRoleAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableThreadNetworkDiagnosticsClusterRoutingRoleAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRole> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableThreadNetworkDiagnosticsClusterRoutingRoleAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableThreadNetworkDiagnosticsClusterRoutingRoleAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThreadNetworkDiagnosticsClusterThreadConnectionStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ThreadNetworkDiagnostics::ThreadConnectionStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPThreadNetworkDiagnosticsClusterThreadConnectionStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPThreadNetworkDiagnosticsClusterThreadConnectionStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableThreadNetworkDiagnosticsClusterThreadConnectionStatusAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::ThreadConnectionStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableThreadNetworkDiagnosticsClusterThreadConnectionStatusAttributeCallbackSubscriptionBridge::
    OnSubscriptionEstablished(void * context)
{
    auto * self
        = static_cast<CHIPNullableThreadNetworkDiagnosticsClusterThreadConnectionStatusAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWiFiNetworkDiagnosticsClusterAssociationFailureCauseAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::WiFiNetworkDiagnostics::AssociationFailureCause value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPWiFiNetworkDiagnosticsClusterAssociationFailureCauseAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPWiFiNetworkDiagnosticsClusterAssociationFailureCauseAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableWiFiNetworkDiagnosticsClusterAssociationFailureCauseAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::AssociationFailureCause> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableWiFiNetworkDiagnosticsClusterAssociationFailureCauseAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableWiFiNetworkDiagnosticsClusterAssociationFailureCauseAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::WiFiNetworkDiagnostics::SecurityType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWiFiNetworkDiagnosticsClusterWiFiConnectionStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::WiFiNetworkDiagnostics::WiFiConnectionStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPWiFiNetworkDiagnosticsClusterWiFiConnectionStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPWiFiNetworkDiagnosticsClusterWiFiConnectionStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableWiFiNetworkDiagnosticsClusterWiFiConnectionStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiConnectionStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableWiFiNetworkDiagnosticsClusterWiFiConnectionStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableWiFiNetworkDiagnosticsClusterWiFiConnectionStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAdministratorCommissioningClusterCommissioningWindowStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPAdministratorCommissioningClusterCommissioningWindowStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPAdministratorCommissioningClusterCommissioningWindowStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableAdministratorCommissioningClusterCommissioningWindowStatusAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableAdministratorCommissioningClusterCommissioningWindowStatusAttributeCallbackSubscriptionBridge::
    OnSubscriptionEstablished(void * context)
{
    auto * self
        = static_cast<CHIPNullableAdministratorCommissioningClusterCommissioningWindowStatusAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAdministratorCommissioningClusterStatusCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::AdministratorCommissioning::StatusCode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPAdministratorCommissioningClusterStatusCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAdministratorCommissioningClusterStatusCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableAdministratorCommissioningClusterStatusCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::AdministratorCommissioning::StatusCode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableAdministratorCommissioningClusterStatusCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableAdministratorCommissioningClusterStatusCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPOperationalCredentialsClusterOperationalCertStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::OperationalCredentials::OperationalCertStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPOperationalCredentialsClusterOperationalCertStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPOperationalCredentialsClusterOperationalCertStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableOperationalCredentialsClusterOperationalCertStatusAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::OperationalCredentials::OperationalCertStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableOperationalCredentialsClusterOperationalCertStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableOperationalCredentialsClusterOperationalCertStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPGroupKeyManagementClusterGroupKeySecurityPolicyAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPGroupKeyManagementClusterGroupKeySecurityPolicyAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPGroupKeyManagementClusterGroupKeySecurityPolicyAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableGroupKeyManagementClusterGroupKeySecurityPolicyAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableGroupKeyManagementClusterGroupKeySecurityPolicyAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableGroupKeyManagementClusterGroupKeySecurityPolicyAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlAlarmCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlAlarmCode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlAlarmCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlAlarmCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlAlarmCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlAlarmCode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlAlarmCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlAlarmCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlCredentialRuleAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlCredentialRule value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlCredentialRuleAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlCredentialRuleAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlCredentialRuleAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialRule> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlCredentialRuleAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlCredentialRuleAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlCredentialTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlCredentialType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlCredentialTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlCredentialTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlCredentialTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlCredentialType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlCredentialTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlCredentialTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlDataOperationTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlDataOperationType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlDataOperationTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlDataOperationTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlDataOperationTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlDataOperationType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlDataOperationTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlDataOperationTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlDoorStateAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlDoorState value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlDoorStateAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlDoorStateAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlDoorStateAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlDoorState> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlDoorStateAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlDoorStateAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlLockDataTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlLockDataType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlLockDataTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlLockDataTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlLockDataTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockDataType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlLockDataTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlLockDataTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlLockOperationTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlLockOperationType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlLockOperationTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlLockOperationTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlLockOperationTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockOperationType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlLockOperationTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlLockOperationTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlLockStateAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlLockState value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlLockStateAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlLockStateAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlLockStateAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlLockStateAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlLockStateAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlLockTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlLockType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlLockTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlLockTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlLockTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlLockTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlLockTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlOperatingModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlOperatingMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlOperatingModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlOperatingModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlOperatingModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlOperatingMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlOperatingModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlOperatingModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlOperationErrorAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlOperationError value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlOperationErrorAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlOperationErrorAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlOperationErrorAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlOperationError> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlOperationErrorAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlOperationErrorAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlOperationSourceAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlOperationSource value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlOperationSourceAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlOperationSourceAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlOperationSourceAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlOperationSource> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlOperationSourceAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlOperationSourceAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlStatusAttributeCallbackBridge::OnSuccessFn(void * context, chip::app::Clusters::DoorLock::DlStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlUserStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlUserStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlUserStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlUserStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlUserStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlUserStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlUserStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDlUserTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DlUserType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDlUserTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDlUserTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDlUserTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlUserType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDlUserTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDlUserTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDoorLockOperationEventCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DoorLockOperationEventCode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDoorLockOperationEventCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDoorLockOperationEventCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDoorLockOperationEventCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorLockOperationEventCode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDoorLockOperationEventCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDoorLockOperationEventCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDoorLockProgrammingEventCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DoorLockProgrammingEventCode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDoorLockProgrammingEventCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDoorLockProgrammingEventCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDoorLockProgrammingEventCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorLockProgrammingEventCode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDoorLockProgrammingEventCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableDoorLockClusterDoorLockProgrammingEventCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDoorLockSetPinOrIdStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DoorLockSetPinOrIdStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDoorLockSetPinOrIdStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDoorLockSetPinOrIdStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDoorLockSetPinOrIdStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorLockSetPinOrIdStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDoorLockSetPinOrIdStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDoorLockSetPinOrIdStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDoorLockUserStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DoorLockUserStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDoorLockUserStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDoorLockUserStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDoorLockUserStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorLockUserStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDoorLockUserStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDoorLockUserStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPDoorLockClusterDoorLockUserTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::DoorLock::DoorLockUserType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPDoorLockClusterDoorLockUserTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPDoorLockClusterDoorLockUserTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableDoorLockClusterDoorLockUserTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorLockUserType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableDoorLockClusterDoorLockUserTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableDoorLockClusterDoorLockUserTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePumpConfigurationAndControlClusterPumpControlModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePumpConfigurationAndControlClusterPumpControlModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullablePumpConfigurationAndControlClusterPumpControlModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullablePumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullablePumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullablePumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackSubscriptionBridge *>(
        context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPThermostatClusterSetpointAdjustModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Thermostat::SetpointAdjustMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPThermostatClusterSetpointAdjustModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPThermostatClusterSetpointAdjustModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableThermostatClusterSetpointAdjustModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Thermostat::SetpointAdjustMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableThermostatClusterSetpointAdjustModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableThermostatClusterSetpointAdjustModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClusterColorLoopActionAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ColorControl::ColorLoopAction value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClusterColorLoopActionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClusterColorLoopActionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableColorControlClusterColorLoopActionAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ColorControl::ColorLoopAction> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableColorControlClusterColorLoopActionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableColorControlClusterColorLoopActionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClusterColorLoopDirectionAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ColorControl::ColorLoopDirection value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClusterColorLoopDirectionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClusterColorLoopDirectionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableColorControlClusterColorLoopDirectionAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ColorControl::ColorLoopDirection> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableColorControlClusterColorLoopDirectionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableColorControlClusterColorLoopDirectionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClusterColorModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ColorControl::ColorMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClusterColorModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClusterColorModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableColorControlClusterColorModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ColorControl::ColorMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableColorControlClusterColorModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableColorControlClusterColorModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClusterHueDirectionAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ColorControl::HueDirection value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClusterHueDirectionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClusterHueDirectionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableColorControlClusterHueDirectionAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ColorControl::HueDirection> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableColorControlClusterHueDirectionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableColorControlClusterHueDirectionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClusterHueMoveModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ColorControl::HueMoveMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClusterHueMoveModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClusterHueMoveModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableColorControlClusterHueMoveModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ColorControl::HueMoveMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableColorControlClusterHueMoveModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableColorControlClusterHueMoveModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClusterHueStepModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ColorControl::HueStepMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClusterHueStepModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClusterHueStepModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableColorControlClusterHueStepModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ColorControl::HueStepMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableColorControlClusterHueStepModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableColorControlClusterHueStepModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClusterSaturationMoveModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ColorControl::SaturationMoveMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClusterSaturationMoveModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClusterSaturationMoveModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableColorControlClusterSaturationMoveModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ColorControl::SaturationMoveMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableColorControlClusterSaturationMoveModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableColorControlClusterSaturationMoveModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPColorControlClusterSaturationStepModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ColorControl::SaturationStepMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPColorControlClusterSaturationStepModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPColorControlClusterSaturationStepModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableColorControlClusterSaturationStepModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ColorControl::SaturationStepMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableColorControlClusterSaturationStepModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableColorControlClusterSaturationStepModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIlluminanceMeasurementClusterLightSensorTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IlluminanceMeasurement::LightSensorType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIlluminanceMeasurementClusterLightSensorTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIlluminanceMeasurementClusterLightSensorTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIlluminanceMeasurementClusterLightSensorTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IlluminanceMeasurement::LightSensorType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIlluminanceMeasurementClusterLightSensorTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableIlluminanceMeasurementClusterLightSensorTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasZoneClusterIasEnrollResponseCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasZone::IasEnrollResponseCode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasZoneClusterIasEnrollResponseCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasZoneClusterIasEnrollResponseCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasZoneClusterIasEnrollResponseCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasZone::IasEnrollResponseCode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasZoneClusterIasEnrollResponseCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIasZoneClusterIasEnrollResponseCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasZoneClusterIasZoneTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasZone::IasZoneType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedShort:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasZoneClusterIasZoneTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasZoneClusterIasZoneTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasZoneClusterIasZoneTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasZone::IasZoneType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedShort:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasZoneClusterIasZoneTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIasZoneClusterIasZoneTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasAceClusterIasAceAlarmStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasAce::IasAceAlarmStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasAceClusterIasAceAlarmStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasAceClusterIasAceAlarmStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasAceClusterIasAceAlarmStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasAce::IasAceAlarmStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasAceClusterIasAceAlarmStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIasAceClusterIasAceAlarmStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasAceClusterIasAceArmModeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasAce::IasAceArmMode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasAceClusterIasAceArmModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasAceClusterIasAceArmModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasAceClusterIasAceArmModeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasAce::IasAceArmMode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasAceClusterIasAceArmModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIasAceClusterIasAceArmModeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasAceClusterIasAceArmNotificationAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasAce::IasAceArmNotification value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasAceClusterIasAceArmNotificationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasAceClusterIasAceArmNotificationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasAceClusterIasAceArmNotificationAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasAce::IasAceArmNotification> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasAceClusterIasAceArmNotificationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIasAceClusterIasAceArmNotificationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasAceClusterIasAceAudibleNotificationAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasAce::IasAceAudibleNotification value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasAceClusterIasAceAudibleNotificationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasAceClusterIasAceAudibleNotificationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasAceClusterIasAceAudibleNotificationAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasAce::IasAceAudibleNotification> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasAceClusterIasAceAudibleNotificationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableIasAceClusterIasAceAudibleNotificationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasAceClusterIasAceBypassResultAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasAce::IasAceBypassResult value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasAceClusterIasAceBypassResultAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasAceClusterIasAceBypassResultAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasAceClusterIasAceBypassResultAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasAce::IasAceBypassResult> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasAceClusterIasAceBypassResultAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIasAceClusterIasAceBypassResultAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasAceClusterIasAcePanelStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasAce::IasAcePanelStatus value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasAceClusterIasAcePanelStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasAceClusterIasAcePanelStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasAceClusterIasAcePanelStatusAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasAce::IasAcePanelStatus> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasAceClusterIasAcePanelStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIasAceClusterIasAcePanelStatusAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPIasAceClusterIasZoneTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::IasAce::IasZoneType value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedShort:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPIasAceClusterIasZoneTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPIasAceClusterIasZoneTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableIasAceClusterIasZoneTypeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::IasAce::IasZoneType> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedShort:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableIasAceClusterIasZoneTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableIasAceClusterIasZoneTypeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPChannelClusterErrorTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Channel::ErrorTypeEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPChannelClusterErrorTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPChannelClusterErrorTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableChannelClusterErrorTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::ErrorTypeEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableChannelClusterErrorTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableChannelClusterErrorTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPChannelClusterLineupInfoTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Channel::LineupInfoTypeEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPChannelClusterLineupInfoTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPChannelClusterLineupInfoTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableChannelClusterLineupInfoTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::LineupInfoTypeEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableChannelClusterLineupInfoTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableChannelClusterLineupInfoTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTargetNavigatorClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::TargetNavigator::StatusEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPTargetNavigatorClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTargetNavigatorClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableTargetNavigatorClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::TargetNavigator::StatusEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableTargetNavigatorClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableTargetNavigatorClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaPlaybackClusterPlaybackStateEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::MediaPlayback::PlaybackStateEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPMediaPlaybackClusterPlaybackStateEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaPlaybackClusterPlaybackStateEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableMediaPlaybackClusterPlaybackStateEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::PlaybackStateEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableMediaPlaybackClusterPlaybackStateEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableMediaPlaybackClusterPlaybackStateEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaPlaybackClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::MediaPlayback::StatusEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPMediaPlaybackClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaPlaybackClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableMediaPlaybackClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::StatusEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableMediaPlaybackClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableMediaPlaybackClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMediaInputClusterInputTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::MediaInput::InputTypeEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPMediaInputClusterInputTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMediaInputClusterInputTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableMediaInputClusterInputTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::MediaInput::InputTypeEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableMediaInputClusterInputTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableMediaInputClusterInputTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPKeypadInputClusterCecKeyCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::KeypadInput::CecKeyCode value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPKeypadInputClusterCecKeyCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPKeypadInputClusterCecKeyCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableKeypadInputClusterCecKeyCodeAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::KeypadInput::CecKeyCode> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableKeypadInputClusterCecKeyCodeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableKeypadInputClusterCecKeyCodeAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPKeypadInputClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::KeypadInput::StatusEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPKeypadInputClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPKeypadInputClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableKeypadInputClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::KeypadInput::StatusEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableKeypadInputClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableKeypadInputClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPContentLauncherClusterMetricTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ContentLauncher::MetricTypeEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPContentLauncherClusterMetricTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPContentLauncherClusterMetricTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableContentLauncherClusterMetricTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ContentLauncher::MetricTypeEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableContentLauncherClusterMetricTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableContentLauncherClusterMetricTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPContentLauncherClusterParameterEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ContentLauncher::ParameterEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPContentLauncherClusterParameterEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPContentLauncherClusterParameterEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableContentLauncherClusterParameterEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ContentLauncher::ParameterEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableContentLauncherClusterParameterEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableContentLauncherClusterParameterEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPContentLauncherClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ContentLauncher::StatusEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPContentLauncherClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPContentLauncherClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableContentLauncherClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ContentLauncher::StatusEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableContentLauncherClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableContentLauncherClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPAudioOutputClusterOutputTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::AudioOutput::OutputTypeEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPAudioOutputClusterOutputTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPAudioOutputClusterOutputTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableAudioOutputClusterOutputTypeEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::AudioOutput::OutputTypeEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableAudioOutputClusterOutputTypeEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableAudioOutputClusterOutputTypeEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationLauncherClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ApplicationLauncher::StatusEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationLauncherClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplicationLauncherClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableApplicationLauncherClusterStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::StatusEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableApplicationLauncherClusterStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableApplicationLauncherClusterStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplicationBasicClusterApplicationStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPApplicationBasicClusterApplicationStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPApplicationBasicClusterApplicationStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableApplicationBasicClusterApplicationStatusEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableApplicationBasicClusterApplicationStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableApplicationBasicClusterApplicationStatusEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPTestClusterClusterSimpleEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::TestCluster::SimpleEnum value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPTestClusterClusterSimpleEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPTestClusterClusterSimpleEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableTestClusterClusterSimpleEnumAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableTestClusterClusterSimpleEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableTestClusterClusterSimpleEnumAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMessagingClusterEventIdAttributeCallbackBridge::OnSuccessFn(void * context, chip::app::Clusters::Messaging::EventId value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPMessagingClusterEventIdAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMessagingClusterEventIdAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableMessagingClusterEventIdAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Messaging::EventId> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableMessagingClusterEventIdAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPNullableMessagingClusterEventIdAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMessagingClusterMessagingControlConfirmationAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Messaging::MessagingControlConfirmation value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPMessagingClusterMessagingControlConfirmationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMessagingClusterMessagingControlConfirmationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableMessagingClusterMessagingControlConfirmationAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Messaging::MessagingControlConfirmation> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableMessagingClusterMessagingControlConfirmationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableMessagingClusterMessagingControlConfirmationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMessagingClusterMessagingControlEnhancedConfirmationAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Messaging::MessagingControlEnhancedConfirmation value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPMessagingClusterMessagingControlEnhancedConfirmationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPMessagingClusterMessagingControlEnhancedConfirmationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableMessagingClusterMessagingControlEnhancedConfirmationAttributeCallbackBridge::OnSuccessFn(void * context,
    const chip::app::DataModel::Nullable<chip::app::Clusters::Messaging::MessagingControlEnhancedConfirmation> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableMessagingClusterMessagingControlEnhancedConfirmationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableMessagingClusterMessagingControlEnhancedConfirmationAttributeCallbackSubscriptionBridge *>(
            context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMessagingClusterMessagingControlImportanceAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Messaging::MessagingControlImportance value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPMessagingClusterMessagingControlImportanceAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMessagingClusterMessagingControlImportanceAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableMessagingClusterMessagingControlImportanceAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Messaging::MessagingControlImportance> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableMessagingClusterMessagingControlImportanceAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPNullableMessagingClusterMessagingControlImportanceAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPMessagingClusterMessagingControlTransmissionAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::Messaging::MessagingControlTransmission value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPMessagingClusterMessagingControlTransmissionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(void * context)
{
    auto * self = static_cast<CHIPMessagingClusterMessagingControlTransmissionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableMessagingClusterMessagingControlTransmissionAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::Messaging::MessagingControlTransmission> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableMessagingClusterMessagingControlTransmissionAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableMessagingClusterMessagingControlTransmissionAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPApplianceEventsAndAlertClusterEventIdentificationAttributeCallbackBridge::OnSuccessFn(
    void * context, chip::app::Clusters::ApplianceEventsAndAlert::EventIdentification value)
{
    NSNumber * _Nonnull objCValue;
    objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value)];
    DispatchSuccess(context, objCValue);
};

void CHIPApplianceEventsAndAlertClusterEventIdentificationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self = static_cast<CHIPApplianceEventsAndAlertClusterEventIdentificationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}

void CHIPNullableApplianceEventsAndAlertClusterEventIdentificationAttributeCallbackBridge::OnSuccessFn(
    void * context, const chip::app::DataModel::Nullable<chip::app::Clusters::ApplianceEventsAndAlert::EventIdentification> & value)
{
    NSNumber * _Nullable objCValue;
    if (value.IsNull()) {
        objCValue = nil;
    } else {
        objCValue = [NSNumber numberWithUnsignedChar:chip::to_underlying(value.Value())];
    }
    DispatchSuccess(context, objCValue);
};

void CHIPNullableApplianceEventsAndAlertClusterEventIdentificationAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished(
    void * context)
{
    auto * self
        = static_cast<CHIPNullableApplianceEventsAndAlertClusterEventIdentificationAttributeCallbackSubscriptionBridge *>(context);
    if (!self->mQueue) {
        return;
    }

    if (self->mEstablishedHandler != nil) {
        dispatch_async(self->mQueue, self->mEstablishedHandler);
        // On failure, mEstablishedHandler will be cleaned up by our destructor,
        // but we can clean it up earlier on successful subscription
        // establishment.
        self->mEstablishedHandler = nil;
    }
}
