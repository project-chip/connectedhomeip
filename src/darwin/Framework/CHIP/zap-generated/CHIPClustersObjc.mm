/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#import <Foundation/Foundation.h>

#import "CHIPAttributeCacheContainer_Internal.h"
#import "CHIPCallbackBridge_internal.h"
#import "CHIPCluster_internal.h"
#import "CHIPClustersObjc_internal.h"
#import "CHIPCommandPayloadsObjc.h"
#import "CHIPDevice.h"
#import "CHIPDevice_Internal.h"
#import "CHIPStructsObjc.h"

#include <lib/support/CHIPListUtils.h>
#include <type_traits>

using chip::Callback::Callback;
using chip::Callback::Cancelable;
using namespace chip::app::Clusters;

@implementation CHIPAccessControl

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeAclWithParams:(CHIPReadParams * _Nullable)params
                 completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlAclListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AccessControl::Attributes::Acl::TypeInfo;
            auto successFn = Callback<AccessControlAclListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)writeAttributeAclWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = AccessControl::Attributes::Acl::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPAccessControlClusterAccessControlEntry class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPAccessControlClusterAccessControlEntry *) value[i_0];
                        listHolder_0->mList[i_0].privilege
                            = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].privilege)>>(
                                element_0.privilege.unsignedCharValue);
                        listHolder_0->mList[i_0].authMode
                            = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].authMode)>>(
                                element_0.authMode.unsignedCharValue);
                        if (element_0.subjects == nil) {
                            listHolder_0->mList[i_0].subjects.SetNull();
                        } else {
                            auto & nonNullValue_2 = listHolder_0->mList[i_0].subjects.SetNonNull();
                            {
                                using ListType_3 = std::remove_reference_t<decltype(nonNullValue_2)>;
                                using ListMemberType_3 = ListMemberTypeGetter<ListType_3>::Type;
                                if (element_0.subjects.count != 0) {
                                    auto * listHolder_3 = new ListHolder<ListMemberType_3>(element_0.subjects.count);
                                    if (listHolder_3 == nullptr || listHolder_3->mList == nullptr) {
                                        return CHIP_ERROR_INVALID_ARGUMENT;
                                    }
                                    listFreer.add(listHolder_3);
                                    for (size_t i_3 = 0; i_3 < element_0.subjects.count; ++i_3) {
                                        if (![element_0.subjects[i_3] isKindOfClass:[NSNumber class]]) {
                                            // Wrong kind of value.
                                            return CHIP_ERROR_INVALID_ARGUMENT;
                                        }
                                        auto element_3 = (NSNumber *) element_0.subjects[i_3];
                                        listHolder_3->mList[i_3] = element_3.unsignedLongLongValue;
                                    }
                                    nonNullValue_2 = ListType_3(listHolder_3->mList, element_0.subjects.count);
                                } else {
                                    nonNullValue_2 = ListType_3();
                                }
                            }
                        }
                        if (element_0.targets == nil) {
                            listHolder_0->mList[i_0].targets.SetNull();
                        } else {
                            auto & nonNullValue_2 = listHolder_0->mList[i_0].targets.SetNonNull();
                            {
                                using ListType_3 = std::remove_reference_t<decltype(nonNullValue_2)>;
                                using ListMemberType_3 = ListMemberTypeGetter<ListType_3>::Type;
                                if (element_0.targets.count != 0) {
                                    auto * listHolder_3 = new ListHolder<ListMemberType_3>(element_0.targets.count);
                                    if (listHolder_3 == nullptr || listHolder_3->mList == nullptr) {
                                        return CHIP_ERROR_INVALID_ARGUMENT;
                                    }
                                    listFreer.add(listHolder_3);
                                    for (size_t i_3 = 0; i_3 < element_0.targets.count; ++i_3) {
                                        if (![element_0.targets[i_3] isKindOfClass:[CHIPAccessControlClusterTarget class]]) {
                                            // Wrong kind of value.
                                            return CHIP_ERROR_INVALID_ARGUMENT;
                                        }
                                        auto element_3 = (CHIPAccessControlClusterTarget *) element_0.targets[i_3];
                                        if (element_3.cluster == nil) {
                                            listHolder_3->mList[i_3].cluster.SetNull();
                                        } else {
                                            auto & nonNullValue_5 = listHolder_3->mList[i_3].cluster.SetNonNull();
                                            nonNullValue_5 = element_3.cluster.unsignedIntValue;
                                        }
                                        if (element_3.endpoint == nil) {
                                            listHolder_3->mList[i_3].endpoint.SetNull();
                                        } else {
                                            auto & nonNullValue_5 = listHolder_3->mList[i_3].endpoint.SetNonNull();
                                            nonNullValue_5 = element_3.endpoint.unsignedShortValue;
                                        }
                                        if (element_3.deviceType == nil) {
                                            listHolder_3->mList[i_3].deviceType.SetNull();
                                        } else {
                                            auto & nonNullValue_5 = listHolder_3->mList[i_3].deviceType.SetNonNull();
                                            nonNullValue_5 = element_3.deviceType.unsignedIntValue;
                                        }
                                    }
                                    nonNullValue_2 = ListType_3(listHolder_3->mList, element_0.targets.count);
                                } else {
                                    nonNullValue_2 = ListType_3();
                                }
                            }
                        }
                        listHolder_0->mList[i_0].fabricIndex = element_0.fabricIndex.unsignedCharValue;
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAclWithMinInterval:(NSNumber * _Nonnull)minInterval
                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                      params:(CHIPSubscribeParams * _Nullable)params
                     subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                               reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAccessControlAclListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::Acl::TypeInfo;
            auto successFn = Callback<AccessControlAclListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAccessControlAclListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAclWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                  endpoint:(NSNumber *)endpoint
                                     queue:(dispatch_queue_t)queue
                         completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlAclListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AccessControl::Attributes::Acl::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<AccessControlAclListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeExtensionWithParams:(CHIPReadParams * _Nullable)params
                       completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlExtensionListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AccessControl::Attributes::Extension::TypeInfo;
            auto successFn = Callback<AccessControlExtensionListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)writeAttributeExtensionWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = AccessControl::Attributes::Extension::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPAccessControlClusterExtensionEntry class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPAccessControlClusterExtensionEntry *) value[i_0];
                        listHolder_0->mList[i_0].data = [self asByteSpan:element_0.data];
                        listHolder_0->mList[i_0].fabricIndex = element_0.fabricIndex.unsignedCharValue;
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeExtensionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAccessControlExtensionListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::Extension::TypeInfo;
            auto successFn = Callback<AccessControlExtensionListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAccessControlExtensionListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeExtensionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlExtensionListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AccessControl::Attributes::Extension::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AccessControlExtensionListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeSubjectsPerAccessControlEntryWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AccessControl::Attributes::SubjectsPerAccessControlEntry::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSubjectsPerAccessControlEntryWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::SubjectsPerAccessControlEntry::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSubjectsPerAccessControlEntryWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AccessControl::Attributes::SubjectsPerAccessControlEntry::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTargetsPerAccessControlEntryWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AccessControl::Attributes::TargetsPerAccessControlEntry::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTargetsPerAccessControlEntryWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                                               params:(CHIPSubscribeParams * _Nullable)params
                                              subscriptionEstablished:
                                                  (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                        reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                          NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::TargetsPerAccessControlEntry::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTargetsPerAccessControlEntryWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                           endpoint:(NSNumber *)endpoint
                                                              queue:(dispatch_queue_t)queue
                                                  completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AccessControl::Attributes::TargetsPerAccessControlEntry::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAccessControlEntriesPerFabricWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AccessControl::Attributes::AccessControlEntriesPerFabric::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAccessControlEntriesPerFabricWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::AccessControlEntriesPerFabric::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAccessControlEntriesPerFabricWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AccessControl::Attributes::AccessControlEntriesPerFabric::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AccessControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<AccessControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAccessControlGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<AccessControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAccessControlGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AccessControl::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AccessControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AccessControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<AccessControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAccessControlAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<AccessControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAccessControlAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AccessControl::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AccessControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AccessControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<AccessControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAccessControlAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<AccessControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAccessControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccessControlAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AccessControl::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AccessControlAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AccessControl::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccessControl::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AccessControl::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPAccountLogin

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)getSetupPINWithParams:(CHIPAccountLoginClusterGetSetupPINParams *)params
            completionHandler:(void (^)(CHIPAccountLoginClusterGetSetupPINResponseParams * _Nullable data,
                                  NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    AccountLogin::Commands::GetSetupPIN::Type request;
    request.tempAccountIdentifier = [self asCharSpan:params.tempAccountIdentifier];

    new CHIPAccountLoginClusterGetSetupPINResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPAccountLoginClusterGetSetupPINResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)loginWithParams:(CHIPAccountLoginClusterLoginParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    AccountLogin::Commands::Login::Type request;
    request.tempAccountIdentifier = [self asCharSpan:params.tempAccountIdentifier];
    request.setupPIN = [self asCharSpan:params.setupPIN];

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)logoutWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    AccountLogin::Commands::Logout::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPAccountLoginGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AccountLogin::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<AccountLoginGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAccountLoginGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccountLogin::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<AccountLoginGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAccountLoginGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccountLoginGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AccountLogin::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AccountLoginGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPAccountLoginAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AccountLogin::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<AccountLoginAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAccountLoginAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccountLogin::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<AccountLoginAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAccountLoginAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccountLoginAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AccountLogin::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AccountLoginAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccountLoginAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AccountLogin::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<AccountLoginAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAccountLoginAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccountLogin::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<AccountLoginAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAccountLoginAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAccountLoginAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AccountLogin::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AccountLoginAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AccountLogin::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AccountLogin::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AccountLogin::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPAdministratorCommissioning

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)openBasicCommissioningWindowWithParams:(CHIPAdministratorCommissioningClusterOpenBasicCommissioningWindowParams *)params
                             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type request;
    request.commissioningTimeout = params.commissioningTimeout.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)openCommissioningWindowWithParams:(CHIPAdministratorCommissioningClusterOpenCommissioningWindowParams *)params
                        completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    AdministratorCommissioning::Commands::OpenCommissioningWindow::Type request;
    request.commissioningTimeout = params.commissioningTimeout.unsignedShortValue;
    request.PAKEVerifier = [self asByteSpan:params.pakeVerifier];
    request.discriminator = params.discriminator.unsignedShortValue;
    request.iterations = params.iterations.unsignedIntValue;
    request.salt = [self asByteSpan:params.salt];

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)revokeCommissioningWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    AdministratorCommissioning::Commands::RevokeCommissioning::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)readAttributeWindowStatusWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AdministratorCommissioning::Attributes::WindowStatus::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeWindowStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AdministratorCommissioning::Attributes::WindowStatus::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeWindowStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AdministratorCommissioning::Attributes::WindowStatus::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAdminFabricIndexWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AdministratorCommissioning::Attributes::AdminFabricIndex::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAdminFabricIndexWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AdministratorCommissioning::Attributes::AdminFabricIndex::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAdminFabricIndexWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AdministratorCommissioning::Attributes::AdminFabricIndex::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAdminVendorIdWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AdministratorCommissioning::Attributes::AdminVendorId::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAdminVendorIdWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AdministratorCommissioning::Attributes::AdminVendorId::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAdminVendorIdWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AdministratorCommissioning::Attributes::AdminVendorId::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPAdministratorCommissioningGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AdministratorCommissioning::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<AdministratorCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAdministratorCommissioningGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AdministratorCommissioning::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<AdministratorCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAdministratorCommissioningGeneratedCommandListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAdministratorCommissioningGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AdministratorCommissioning::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<AdministratorCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPAdministratorCommissioningAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AdministratorCommissioning::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<AdministratorCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAdministratorCommissioningAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AdministratorCommissioning::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<AdministratorCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAdministratorCommissioningAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAdministratorCommissioningAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AdministratorCommissioning::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<AdministratorCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAdministratorCommissioningAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AdministratorCommissioning::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<AdministratorCommissioningAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAdministratorCommissioningAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AdministratorCommissioning::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<AdministratorCommissioningAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAdministratorCommissioningAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAdministratorCommissioningAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AdministratorCommissioning::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AdministratorCommissioningAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AdministratorCommissioning::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AdministratorCommissioning::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AdministratorCommissioning::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPApplicationBasic

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeVendorNameWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ApplicationBasic::Attributes::VendorName::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeVendorNameWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::VendorName::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeVendorNameWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ApplicationBasic::Attributes::VendorName::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeVendorIDWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ApplicationBasic::Attributes::VendorID::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeVendorIDWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::VendorID::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeVendorIDWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ApplicationBasic::Attributes::VendorID::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeApplicationNameWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ApplicationBasic::Attributes::ApplicationName::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeApplicationNameWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::ApplicationName::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeApplicationNameWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ApplicationBasic::Attributes::ApplicationName::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeProductIDWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ApplicationBasic::Attributes::ProductID::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeProductIDWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::ProductID::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeProductIDWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ApplicationBasic::Attributes::ProductID::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeApplicationWithCompletionHandler:
    (void (^)(CHIPApplicationBasicClusterApplicationBasicApplication * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicApplicationStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationBasic::Attributes::Application::TypeInfo;
            auto successFn = Callback<ApplicationBasicApplicationStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeApplicationWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:
                                           (void (^)(CHIPApplicationBasicClusterApplicationBasicApplication * _Nullable value,
                                               NSError * _Nullable error))reportHandler
{
    new CHIPApplicationBasicApplicationStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::Application::TypeInfo;
            auto successFn = Callback<ApplicationBasicApplicationStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationBasicApplicationStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeApplicationWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(CHIPApplicationBasicClusterApplicationBasicApplication * _Nullable value,
                                         NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicApplicationStructAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationBasic::Attributes::Application::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationBasicApplicationStructAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeStatusWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicClusterApplicationStatusEnumAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationBasic::Attributes::Status::TypeInfo;
            auto successFn = Callback<ApplicationBasicClusterApplicationStatusEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationBasicClusterApplicationStatusEnumAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::Status::TypeInfo;
            auto successFn = Callback<ApplicationBasicClusterApplicationStatusEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationBasicClusterApplicationStatusEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicClusterApplicationStatusEnumAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationBasic::Attributes::Status::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationBasicClusterApplicationStatusEnumAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeApplicationVersionWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ApplicationBasic::Attributes::ApplicationVersion::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeApplicationVersionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::ApplicationVersion::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeApplicationVersionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ApplicationBasic::Attributes::ApplicationVersion::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAllowedVendorListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicAllowedVendorListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationBasic::Attributes::AllowedVendorList::TypeInfo;
            auto successFn = Callback<ApplicationBasicAllowedVendorListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAllowedVendorListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationBasicAllowedVendorListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::AllowedVendorList::TypeInfo;
            auto successFn = Callback<ApplicationBasicAllowedVendorListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationBasicAllowedVendorListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAllowedVendorListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicAllowedVendorListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationBasic::Attributes::AllowedVendorList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationBasicAllowedVendorListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ApplicationBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationBasicGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ApplicationBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationBasicGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationBasic::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ApplicationBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationBasicAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ApplicationBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationBasicAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationBasic::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationBasic::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ApplicationBasicAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationBasicAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ApplicationBasicAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationBasicAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationBasicAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationBasic::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationBasicAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ApplicationBasic::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationBasic::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ApplicationBasic::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPApplicationLauncher

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)hideAppWithParams:(CHIPApplicationLauncherClusterHideAppParams *)params
        completionHandler:(void (^)(CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable data,
                              NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    ApplicationLauncher::Commands::HideApp::Type request;
    request.application.catalogVendorId = params.application.catalogVendorId.unsignedShortValue;
    request.application.applicationId = [self asCharSpan:params.application.applicationId];

    new CHIPApplicationLauncherClusterLauncherResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPApplicationLauncherClusterLauncherResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)launchAppWithParams:(CHIPApplicationLauncherClusterLaunchAppParams *)params
          completionHandler:(void (^)(CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable data,
                                NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    ApplicationLauncher::Commands::LaunchApp::Type request;
    request.application.catalogVendorId = params.application.catalogVendorId.unsignedShortValue;
    request.application.applicationId = [self asCharSpan:params.application.applicationId];
    if (params.data != nil) {
        auto & definedValue_0 = request.data.Emplace();
        definedValue_0 = [self asByteSpan:params.data];
    }

    new CHIPApplicationLauncherClusterLauncherResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPApplicationLauncherClusterLauncherResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stopAppWithParams:(CHIPApplicationLauncherClusterStopAppParams *)params
        completionHandler:(void (^)(CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable data,
                              NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    ApplicationLauncher::Commands::StopApp::Type request;
    request.application.catalogVendorId = params.application.catalogVendorId.unsignedShortValue;
    request.application.applicationId = [self asCharSpan:params.application.applicationId];

    new CHIPApplicationLauncherClusterLauncherResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPApplicationLauncherClusterLauncherResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeCatalogListWithCompletionHandler:(void (^)(
                                                          NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherCatalogListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationLauncher::Attributes::CatalogList::TypeInfo;
            auto successFn = Callback<ApplicationLauncherCatalogListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCatalogListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationLauncherCatalogListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationLauncher::Attributes::CatalogList::TypeInfo;
            auto successFn = Callback<ApplicationLauncherCatalogListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationLauncherCatalogListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCatalogListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherCatalogListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationLauncher::Attributes::CatalogList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationLauncherCatalogListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentAppWithCompletionHandler:(void (^)(CHIPApplicationLauncherClusterApplicationEP * _Nullable value,
                                                         NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherCurrentAppStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationLauncher::Attributes::CurrentApp::TypeInfo;
            auto successFn = Callback<ApplicationLauncherCurrentAppStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeCurrentAppWithValue:(CHIPApplicationLauncherClusterApplicationEP * _Nullable)value
                        completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ApplicationLauncher::Attributes::CurrentApp::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0.application.catalogVendorId = value.application.catalogVendorId.unsignedShortValue;
                nonNullValue_0.application.applicationId = [self asCharSpan:value.application.applicationId];
                if (value.endpoint != nil) {
                    auto & definedValue_2 = nonNullValue_0.endpoint.Emplace();
                    definedValue_2 = value.endpoint.unsignedShortValue;
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentAppWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(CHIPApplicationLauncherClusterApplicationEP * _Nullable value,
                                                        NSError * _Nullable error))reportHandler
{
    new CHIPApplicationLauncherCurrentAppStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationLauncher::Attributes::CurrentApp::TypeInfo;
            auto successFn = Callback<ApplicationLauncherCurrentAppStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationLauncherCurrentAppStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentAppWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(CHIPApplicationLauncherClusterApplicationEP * _Nullable value,
                                                      NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherCurrentAppStructAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationLauncher::Attributes::CurrentApp::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationLauncherCurrentAppStructAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ApplicationLauncherGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationLauncherGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ApplicationLauncherGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationLauncherGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationLauncher::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationLauncherGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ApplicationLauncherAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationLauncherAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ApplicationLauncherAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationLauncherAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationLauncher::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationLauncherAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ApplicationLauncher::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ApplicationLauncherAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPApplicationLauncherAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationLauncher::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ApplicationLauncherAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPApplicationLauncherAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPApplicationLauncherAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ApplicationLauncher::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ApplicationLauncherAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ApplicationLauncher::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ApplicationLauncher::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ApplicationLauncher::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPAudioOutput

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)renameOutputWithParams:(CHIPAudioOutputClusterRenameOutputParams *)params
             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    AudioOutput::Commands::RenameOutput::Type request;
    request.index = params.index.unsignedCharValue;
    request.name = [self asCharSpan:params.name];

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)selectOutputWithParams:(CHIPAudioOutputClusterSelectOutputParams *)params
             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    AudioOutput::Commands::SelectOutput::Type request;
    request.index = params.index.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeOutputListWithCompletionHandler:(void (^)(
                                                         NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAudioOutputOutputListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AudioOutput::Attributes::OutputList::TypeInfo;
            auto successFn = Callback<AudioOutputOutputListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOutputListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAudioOutputOutputListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AudioOutput::Attributes::OutputList::TypeInfo;
            auto successFn = Callback<AudioOutputOutputListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAudioOutputOutputListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOutputListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAudioOutputOutputListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AudioOutput::Attributes::OutputList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AudioOutputOutputListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentOutputWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AudioOutput::Attributes::CurrentOutput::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentOutputWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AudioOutput::Attributes::CurrentOutput::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentOutputWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AudioOutput::Attributes::CurrentOutput::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPAudioOutputGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AudioOutput::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<AudioOutputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAudioOutputGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AudioOutput::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<AudioOutputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAudioOutputGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAudioOutputGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AudioOutput::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AudioOutputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPAudioOutputAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AudioOutput::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<AudioOutputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAudioOutputAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AudioOutput::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<AudioOutputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAudioOutputAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAudioOutputAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AudioOutput::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AudioOutputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAudioOutputAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = AudioOutput::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<AudioOutputAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPAudioOutputAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AudioOutput::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<AudioOutputAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPAudioOutputAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPAudioOutputAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = AudioOutput::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<AudioOutputAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = AudioOutput::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = AudioOutput::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = AudioOutput::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPBarrierControl

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)barrierControlGoToPercentWithParams:(CHIPBarrierControlClusterBarrierControlGoToPercentParams *)params
                          completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BarrierControl::Commands::BarrierControlGoToPercent::Type request;
    request.percentOpen = params.percentOpen.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)barrierControlStopWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BarrierControl::Commands::BarrierControlStop::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeBarrierMovingStateWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BarrierControl::Attributes::BarrierMovingState::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBarrierMovingStateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BarrierControl::Attributes::BarrierMovingState::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBarrierMovingStateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BarrierControl::Attributes::BarrierMovingState::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBarrierSafetyStatusWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BarrierControl::Attributes::BarrierSafetyStatus::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBarrierSafetyStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BarrierControl::Attributes::BarrierSafetyStatus::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBarrierSafetyStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BarrierControl::Attributes::BarrierSafetyStatus::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBarrierCapabilitiesWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BarrierControl::Attributes::BarrierCapabilities::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBarrierCapabilitiesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BarrierControl::Attributes::BarrierCapabilities::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBarrierCapabilitiesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BarrierControl::Attributes::BarrierCapabilities::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBarrierPositionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BarrierControl::Attributes::BarrierPosition::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBarrierPositionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BarrierControl::Attributes::BarrierPosition::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBarrierPositionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BarrierControl::Attributes::BarrierPosition::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPBarrierControlGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BarrierControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BarrierControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBarrierControlGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BarrierControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BarrierControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBarrierControlGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBarrierControlGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BarrierControl::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BarrierControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBarrierControlAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BarrierControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BarrierControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBarrierControlAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BarrierControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BarrierControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBarrierControlAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBarrierControlAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BarrierControl::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BarrierControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBarrierControlAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BarrierControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BarrierControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBarrierControlAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BarrierControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BarrierControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBarrierControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBarrierControlAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BarrierControl::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BarrierControlAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BarrierControl::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BarrierControl::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BarrierControl::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPBasic

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeDataModelRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::DataModelRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeDataModelRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::DataModelRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDataModelRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::DataModelRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeVendorNameWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::VendorName::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeVendorNameWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::VendorName::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeVendorNameWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::VendorName::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeVendorIDWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPVendorIdAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::VendorID::TypeInfo;
        auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeVendorIDWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPVendorIdAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::VendorID::TypeInfo;
            auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPVendorIdAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeVendorIDWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPVendorIdAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::VendorID::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeProductNameWithCompletionHandler:(void (^)(
                                                          NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::ProductName::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeProductNameWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::ProductName::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeProductNameWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::ProductName::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeProductIDWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::ProductID::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeProductIDWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::ProductID::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeProductIDWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::ProductID::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNodeLabelWithCompletionHandler:(void (^)(
                                                        NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::NodeLabel::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeNodeLabelWithValue:(NSString * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Basic::Attributes::NodeLabel::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asCharSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNodeLabelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::NodeLabel::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNodeLabelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::NodeLabel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLocationWithCompletionHandler:(void (^)(
                                                       NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::Location::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeLocationWithValue:(NSString * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Basic::Attributes::Location::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asCharSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLocationWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::Location::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLocationWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::Location::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeHardwareVersionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::HardwareVersion::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeHardwareVersionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::HardwareVersion::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeHardwareVersionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::HardwareVersion::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeHardwareVersionStringWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::HardwareVersionString::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeHardwareVersionStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::HardwareVersionString::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeHardwareVersionStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::HardwareVersionString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSoftwareVersionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::SoftwareVersion::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSoftwareVersionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::SoftwareVersion::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSoftwareVersionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::SoftwareVersion::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSoftwareVersionStringWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::SoftwareVersionString::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSoftwareVersionStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::SoftwareVersionString::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSoftwareVersionStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::SoftwareVersionString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeManufacturingDateWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::ManufacturingDate::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeManufacturingDateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::ManufacturingDate::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeManufacturingDateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::ManufacturingDate::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePartNumberWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::PartNumber::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePartNumberWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::PartNumber::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePartNumberWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::PartNumber::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeProductURLWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::ProductURL::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeProductURLWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::ProductURL::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeProductURLWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::ProductURL::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeProductLabelWithCompletionHandler:(void (^)(
                                                           NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::ProductLabel::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeProductLabelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::ProductLabel::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeProductLabelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::ProductLabel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSerialNumberWithCompletionHandler:(void (^)(
                                                           NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::SerialNumber::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSerialNumberWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::SerialNumber::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSerialNumberWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::SerialNumber::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLocalConfigDisabledWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::LocalConfigDisabled::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeLocalConfigDisabledWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Basic::Attributes::LocalConfigDisabled::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLocalConfigDisabledWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::LocalConfigDisabled::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLocalConfigDisabledWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::LocalConfigDisabled::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeReachableWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::Reachable::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeReachableWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::Reachable::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeReachableWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::Reachable::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeUniqueIDWithCompletionHandler:(void (^)(
                                                       NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::UniqueID::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeUniqueIDWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::UniqueID::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeUniqueIDWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::UniqueID::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCapabilityMinimaWithCompletionHandler:(void (^)(CHIPBasicClusterCapabilityMinimaStruct * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPBasicCapabilityMinimaStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Basic::Attributes::CapabilityMinima::TypeInfo;
            auto successFn = Callback<BasicCapabilityMinimaStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCapabilityMinimaWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:(void (^)(CHIPBasicClusterCapabilityMinimaStruct * _Nullable value,
                                                              NSError * _Nullable error))reportHandler
{
    new CHIPBasicCapabilityMinimaStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::CapabilityMinima::TypeInfo;
            auto successFn = Callback<BasicCapabilityMinimaStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBasicCapabilityMinimaStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCapabilityMinimaWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:(void (^)(CHIPBasicClusterCapabilityMinimaStruct * _Nullable value,
                                                            NSError * _Nullable error))completionHandler
{
    new CHIPBasicCapabilityMinimaStructAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Basic::Attributes::CapabilityMinima::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BasicCapabilityMinimaStructAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPBasicGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Basic::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBasicGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBasicGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBasicGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Basic::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBasicAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Basic::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBasicAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBasicAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBasicAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Basic::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBasicAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Basic::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BasicAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBasicAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BasicAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBasicAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBasicAttributeListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::AttributeList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BasicAttributeListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Basic::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Basic::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Basic::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPBinaryInputBasic

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeOutOfServiceWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BinaryInputBasic::Attributes::OutOfService::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeOutOfServiceWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = BinaryInputBasic::Attributes::OutOfService::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOutOfServiceWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BinaryInputBasic::Attributes::OutOfService::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOutOfServiceWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BinaryInputBasic::Attributes::OutOfService::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePresentValueWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BinaryInputBasic::Attributes::PresentValue::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributePresentValueWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = BinaryInputBasic::Attributes::PresentValue::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributePresentValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BinaryInputBasic::Attributes::PresentValue::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePresentValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BinaryInputBasic::Attributes::PresentValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeStatusFlagsWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BinaryInputBasic::Attributes::StatusFlags::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeStatusFlagsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BinaryInputBasic::Attributes::StatusFlags::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStatusFlagsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BinaryInputBasic::Attributes::StatusFlags::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPBinaryInputBasicGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BinaryInputBasic::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BinaryInputBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBinaryInputBasicGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BinaryInputBasic::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BinaryInputBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBinaryInputBasicGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBinaryInputBasicGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BinaryInputBasic::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BinaryInputBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBinaryInputBasicAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BinaryInputBasic::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BinaryInputBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBinaryInputBasicAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BinaryInputBasic::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BinaryInputBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBinaryInputBasicAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBinaryInputBasicAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BinaryInputBasic::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BinaryInputBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBinaryInputBasicAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BinaryInputBasic::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BinaryInputBasicAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBinaryInputBasicAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BinaryInputBasic::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BinaryInputBasicAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBinaryInputBasicAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBinaryInputBasicAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BinaryInputBasic::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BinaryInputBasicAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BinaryInputBasic::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BinaryInputBasic::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BinaryInputBasic::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPBinding

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeBindingWithParams:(CHIPReadParams * _Nullable)params
                     completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBindingBindingListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Binding::Attributes::Binding::TypeInfo;
            auto successFn = Callback<BindingBindingListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)writeAttributeBindingWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Binding::Attributes::Binding::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPBindingClusterTargetStruct class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPBindingClusterTargetStruct *) value[i_0];
                        if (element_0.node != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].node.Emplace();
                            definedValue_2 = element_0.node.unsignedLongLongValue;
                        }
                        if (element_0.group != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].group.Emplace();
                            definedValue_2 = element_0.group.unsignedShortValue;
                        }
                        if (element_0.endpoint != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].endpoint.Emplace();
                            definedValue_2 = element_0.endpoint.unsignedShortValue;
                        }
                        if (element_0.cluster != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].cluster.Emplace();
                            definedValue_2 = element_0.cluster.unsignedIntValue;
                        }
                        listHolder_0->mList[i_0].fabricIndex = element_0.fabricIndex.unsignedCharValue;
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeBindingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBindingBindingListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Binding::Attributes::Binding::TypeInfo;
            auto successFn = Callback<BindingBindingListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBindingBindingListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBindingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBindingBindingListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Binding::Attributes::Binding::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BindingBindingListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPBindingGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Binding::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BindingGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBindingGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Binding::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BindingGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBindingGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBindingGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Binding::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BindingGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBindingAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Binding::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BindingAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBindingAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Binding::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BindingAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBindingAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBindingAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Binding::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BindingAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBindingAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Binding::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BindingAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBindingAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Binding::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BindingAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBindingAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBindingAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Binding::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BindingAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Binding::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Binding::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Binding::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPBooleanState

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeStateValueWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BooleanState::Attributes::StateValue::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeStateValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BooleanState::Attributes::StateValue::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStateValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BooleanState::Attributes::StateValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPBooleanStateGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BooleanState::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BooleanStateGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanStateGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BooleanState::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BooleanStateGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanStateGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanStateGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BooleanState::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BooleanStateGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBooleanStateAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BooleanState::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BooleanStateAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanStateAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BooleanState::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BooleanStateAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanStateAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanStateAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BooleanState::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BooleanStateAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanStateAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BooleanState::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BooleanStateAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanStateAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BooleanState::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BooleanStateAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanStateAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanStateAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BooleanState::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BooleanStateAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BooleanState::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BooleanState::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BooleanState::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPBridgedActions

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)disableActionWithParams:(CHIPBridgedActionsClusterDisableActionParams *)params
              completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::DisableAction::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)disableActionWithDurationWithParams:(CHIPBridgedActionsClusterDisableActionWithDurationParams *)params
                          completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::DisableActionWithDuration::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }
    request.duration = params.duration.unsignedIntValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)enableActionWithParams:(CHIPBridgedActionsClusterEnableActionParams *)params
             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::EnableAction::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)enableActionWithDurationWithParams:(CHIPBridgedActionsClusterEnableActionWithDurationParams *)params
                         completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::EnableActionWithDuration::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }
    request.duration = params.duration.unsignedIntValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)instantActionWithParams:(CHIPBridgedActionsClusterInstantActionParams *)params
              completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::InstantAction::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)instantActionWithTransitionWithParams:(CHIPBridgedActionsClusterInstantActionWithTransitionParams *)params
                            completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::InstantActionWithTransition::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }
    request.transitionTime = params.transitionTime.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)pauseActionWithParams:(CHIPBridgedActionsClusterPauseActionParams *)params
            completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::PauseAction::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)pauseActionWithDurationWithParams:(CHIPBridgedActionsClusterPauseActionWithDurationParams *)params
                        completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::PauseActionWithDuration::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }
    request.duration = params.duration.unsignedIntValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)resumeActionWithParams:(CHIPBridgedActionsClusterResumeActionParams *)params
             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::ResumeAction::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)startActionWithParams:(CHIPBridgedActionsClusterStartActionParams *)params
            completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::StartAction::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)startActionWithDurationWithParams:(CHIPBridgedActionsClusterStartActionWithDurationParams *)params
                        completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::StartActionWithDuration::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }
    request.duration = params.duration.unsignedIntValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stopActionWithParams:(CHIPBridgedActionsClusterStopActionParams *)params
           completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    BridgedActions::Commands::StopAction::Type request;
    request.actionID = params.actionID.unsignedShortValue;
    if (params.invokeID != nil) {
        auto & definedValue_0 = request.invokeID.Emplace();
        definedValue_0 = params.invokeID.unsignedIntValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeActionListWithCompletionHandler:(void (^)(
                                                         NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsActionListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BridgedActions::Attributes::ActionList::TypeInfo;
            auto successFn = Callback<BridgedActionsActionListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeActionListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBridgedActionsActionListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedActions::Attributes::ActionList::TypeInfo;
            auto successFn = Callback<BridgedActionsActionListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBridgedActionsActionListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActionListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsActionListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BridgedActions::Attributes::ActionList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BridgedActionsActionListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeEndpointListWithCompletionHandler:(void (^)(
                                                           NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsEndpointListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BridgedActions::Attributes::EndpointList::TypeInfo;
            auto successFn = Callback<BridgedActionsEndpointListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEndpointListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBridgedActionsEndpointListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedActions::Attributes::EndpointList::TypeInfo;
            auto successFn = Callback<BridgedActionsEndpointListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBridgedActionsEndpointListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEndpointListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsEndpointListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BridgedActions::Attributes::EndpointList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BridgedActionsEndpointListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeSetupUrlWithCompletionHandler:(void (^)(
                                                       NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedActions::Attributes::SetupUrl::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSetupUrlWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedActions::Attributes::SetupUrl::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSetupUrlWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedActions::Attributes::SetupUrl::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BridgedActions::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BridgedActionsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBridgedActionsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedActions::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BridgedActionsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBridgedActionsGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BridgedActions::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BridgedActionsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BridgedActions::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BridgedActionsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBridgedActionsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedActions::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BridgedActionsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBridgedActionsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BridgedActions::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BridgedActionsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BridgedActions::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BridgedActionsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBridgedActionsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedActions::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BridgedActionsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBridgedActionsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedActionsAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BridgedActions::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BridgedActionsAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedActions::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedActions::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedActions::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPBridgedDeviceBasic

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeVendorNameWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::VendorName::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeVendorNameWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::VendorName::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeVendorNameWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::VendorName::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeVendorIDWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPVendorIdAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::VendorID::TypeInfo;
        auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeVendorIDWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPVendorIdAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::VendorID::TypeInfo;
            auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPVendorIdAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeVendorIDWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPVendorIdAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::VendorID::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeProductNameWithCompletionHandler:(void (^)(
                                                          NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::ProductName::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeProductNameWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::ProductName::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeProductNameWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::ProductName::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNodeLabelWithCompletionHandler:(void (^)(
                                                        NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::NodeLabel::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeNodeLabelWithValue:(NSString * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = BridgedDeviceBasic::Attributes::NodeLabel::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asCharSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNodeLabelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::NodeLabel::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNodeLabelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::NodeLabel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeHardwareVersionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::HardwareVersion::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeHardwareVersionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::HardwareVersion::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeHardwareVersionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::HardwareVersion::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeHardwareVersionStringWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::HardwareVersionString::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeHardwareVersionStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::HardwareVersionString::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeHardwareVersionStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::HardwareVersionString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSoftwareVersionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::SoftwareVersion::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSoftwareVersionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::SoftwareVersion::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSoftwareVersionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::SoftwareVersion::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSoftwareVersionStringWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::SoftwareVersionString::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSoftwareVersionStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::SoftwareVersionString::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSoftwareVersionStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::SoftwareVersionString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeManufacturingDateWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::ManufacturingDate::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeManufacturingDateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::ManufacturingDate::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeManufacturingDateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::ManufacturingDate::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePartNumberWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::PartNumber::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePartNumberWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::PartNumber::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePartNumberWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::PartNumber::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeProductURLWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::ProductURL::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeProductURLWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::ProductURL::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeProductURLWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::ProductURL::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeProductLabelWithCompletionHandler:(void (^)(
                                                           NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::ProductLabel::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeProductLabelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::ProductLabel::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeProductLabelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::ProductLabel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSerialNumberWithCompletionHandler:(void (^)(
                                                           NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::SerialNumber::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSerialNumberWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::SerialNumber::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSerialNumberWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::SerialNumber::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeReachableWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::Reachable::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeReachableWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::Reachable::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeReachableWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::Reachable::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeUniqueIDWithCompletionHandler:(void (^)(
                                                       NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::UniqueID::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeUniqueIDWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::UniqueID::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeUniqueIDWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::UniqueID::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPBridgedDeviceBasicGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BridgedDeviceBasic::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BridgedDeviceBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBridgedDeviceBasicGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<BridgedDeviceBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBridgedDeviceBasicGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedDeviceBasicGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BridgedDeviceBasic::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BridgedDeviceBasicGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBridgedDeviceBasicAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BridgedDeviceBasic::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BridgedDeviceBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBridgedDeviceBasicAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<BridgedDeviceBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBridgedDeviceBasicAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedDeviceBasicAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BridgedDeviceBasic::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BridgedDeviceBasicAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedDeviceBasicAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = BridgedDeviceBasic::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BridgedDeviceBasicAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBridgedDeviceBasicAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<BridgedDeviceBasicAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBridgedDeviceBasicAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBridgedDeviceBasicAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = BridgedDeviceBasic::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<BridgedDeviceBasicAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = BridgedDeviceBasic::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = BridgedDeviceBasic::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = BridgedDeviceBasic::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPChannel

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)changeChannelWithParams:(CHIPChannelClusterChangeChannelParams *)params
              completionHandler:(void (^)(CHIPChannelClusterChangeChannelResponseParams * _Nullable data,
                                    NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Channel::Commands::ChangeChannel::Type request;
    request.match = [self asCharSpan:params.match];

    new CHIPChannelClusterChangeChannelResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPChannelClusterChangeChannelResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)changeChannelByNumberWithParams:(CHIPChannelClusterChangeChannelByNumberParams *)params
                      completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Channel::Commands::ChangeChannelByNumber::Type request;
    request.majorNumber = params.majorNumber.unsignedShortValue;
    request.minorNumber = params.minorNumber.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)skipChannelWithParams:(CHIPChannelClusterSkipChannelParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Channel::Commands::SkipChannel::Type request;
    request.count = params.count.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeChannelListWithCompletionHandler:(void (^)(
                                                          NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPChannelChannelListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Channel::Attributes::ChannelList::TypeInfo;
            auto successFn = Callback<ChannelChannelListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeChannelListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPChannelChannelListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Channel::Attributes::ChannelList::TypeInfo;
            auto successFn = Callback<ChannelChannelListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPChannelChannelListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeChannelListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPChannelChannelListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Channel::Attributes::ChannelList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<ChannelChannelListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLineupWithCompletionHandler:(void (^)(CHIPChannelClusterLineupInfo * _Nullable value,
                                                     NSError * _Nullable error))completionHandler
{
    new CHIPChannelLineupStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Channel::Attributes::Lineup::TypeInfo;
            auto successFn = Callback<ChannelLineupStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLineupWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(CHIPChannelClusterLineupInfo * _Nullable value,
                                                    NSError * _Nullable error))reportHandler
{
    new CHIPChannelLineupStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Channel::Attributes::Lineup::TypeInfo;
            auto successFn = Callback<ChannelLineupStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPChannelLineupStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLineupWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(CHIPChannelClusterLineupInfo * _Nullable value,
                                                  NSError * _Nullable error))completionHandler
{
    new CHIPChannelLineupStructAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Channel::Attributes::Lineup::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<ChannelLineupStructAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentChannelWithCompletionHandler:(void (^)(CHIPChannelClusterChannelInfo * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPChannelCurrentChannelStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Channel::Attributes::CurrentChannel::TypeInfo;
            auto successFn = Callback<ChannelCurrentChannelStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentChannelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:(void (^)(CHIPChannelClusterChannelInfo * _Nullable value,
                                                            NSError * _Nullable error))reportHandler
{
    new CHIPChannelCurrentChannelStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Channel::Attributes::CurrentChannel::TypeInfo;
            auto successFn = Callback<ChannelCurrentChannelStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPChannelCurrentChannelStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentChannelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:(void (^)(CHIPChannelClusterChannelInfo * _Nullable value,
                                                          NSError * _Nullable error))completionHandler
{
    new CHIPChannelCurrentChannelStructAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Channel::Attributes::CurrentChannel::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ChannelCurrentChannelStructAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPChannelGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Channel::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ChannelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPChannelGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Channel::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ChannelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPChannelGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPChannelGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Channel::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ChannelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPChannelAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Channel::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ChannelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPChannelAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Channel::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ChannelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPChannelAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPChannelAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Channel::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ChannelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPChannelAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Channel::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ChannelAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPChannelAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Channel::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ChannelAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPChannelAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPChannelAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Channel::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ChannelAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Channel::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Channel::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Channel::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPColorControl

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)colorLoopSetWithParams:(CHIPColorControlClusterColorLoopSetParams *)params
             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::ColorLoopSet::Type request;
    request.updateFlags = static_cast<std::remove_reference_t<decltype(request.updateFlags)>>(params.updateFlags.unsignedCharValue);
    request.action = static_cast<std::remove_reference_t<decltype(request.action)>>(params.action.unsignedCharValue);
    request.direction = static_cast<std::remove_reference_t<decltype(request.direction)>>(params.direction.unsignedCharValue);
    request.time = params.time.unsignedShortValue;
    request.startHue = params.startHue.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)enhancedMoveHueWithParams:(CHIPColorControlClusterEnhancedMoveHueParams *)params
                completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::EnhancedMoveHue::Type request;
    request.moveMode = static_cast<std::remove_reference_t<decltype(request.moveMode)>>(params.moveMode.unsignedCharValue);
    request.rate = params.rate.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)enhancedMoveToHueWithParams:(CHIPColorControlClusterEnhancedMoveToHueParams *)params
                  completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::EnhancedMoveToHue::Type request;
    request.enhancedHue = params.enhancedHue.unsignedShortValue;
    request.direction = static_cast<std::remove_reference_t<decltype(request.direction)>>(params.direction.unsignedCharValue);
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)enhancedMoveToHueAndSaturationWithParams:(CHIPColorControlClusterEnhancedMoveToHueAndSaturationParams *)params
                               completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type request;
    request.enhancedHue = params.enhancedHue.unsignedShortValue;
    request.saturation = params.saturation.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)enhancedStepHueWithParams:(CHIPColorControlClusterEnhancedStepHueParams *)params
                completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::EnhancedStepHue::Type request;
    request.stepMode = static_cast<std::remove_reference_t<decltype(request.stepMode)>>(params.stepMode.unsignedCharValue);
    request.stepSize = params.stepSize.unsignedShortValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveColorWithParams:(CHIPColorControlClusterMoveColorParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveColor::Type request;
    request.rateX = params.rateX.shortValue;
    request.rateY = params.rateY.shortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveColorTemperatureWithParams:(CHIPColorControlClusterMoveColorTemperatureParams *)params
                     completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveColorTemperature::Type request;
    request.moveMode = static_cast<std::remove_reference_t<decltype(request.moveMode)>>(params.moveMode.unsignedCharValue);
    request.rate = params.rate.unsignedShortValue;
    request.colorTemperatureMinimum = params.colorTemperatureMinimum.unsignedShortValue;
    request.colorTemperatureMaximum = params.colorTemperatureMaximum.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveHueWithParams:(CHIPColorControlClusterMoveHueParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveHue::Type request;
    request.moveMode = static_cast<std::remove_reference_t<decltype(request.moveMode)>>(params.moveMode.unsignedCharValue);
    request.rate = params.rate.unsignedCharValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveSaturationWithParams:(CHIPColorControlClusterMoveSaturationParams *)params
               completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveSaturation::Type request;
    request.moveMode = static_cast<std::remove_reference_t<decltype(request.moveMode)>>(params.moveMode.unsignedCharValue);
    request.rate = params.rate.unsignedCharValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveToColorWithParams:(CHIPColorControlClusterMoveToColorParams *)params
            completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveToColor::Type request;
    request.colorX = params.colorX.unsignedShortValue;
    request.colorY = params.colorY.unsignedShortValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveToColorTemperatureWithParams:(CHIPColorControlClusterMoveToColorTemperatureParams *)params
                       completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveToColorTemperature::Type request;
    request.colorTemperature = params.colorTemperature.unsignedShortValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveToHueWithParams:(CHIPColorControlClusterMoveToHueParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveToHue::Type request;
    request.hue = params.hue.unsignedCharValue;
    request.direction = static_cast<std::remove_reference_t<decltype(request.direction)>>(params.direction.unsignedCharValue);
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveToHueAndSaturationWithParams:(CHIPColorControlClusterMoveToHueAndSaturationParams *)params
                       completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveToHueAndSaturation::Type request;
    request.hue = params.hue.unsignedCharValue;
    request.saturation = params.saturation.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveToSaturationWithParams:(CHIPColorControlClusterMoveToSaturationParams *)params
                 completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::MoveToSaturation::Type request;
    request.saturation = params.saturation.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stepColorWithParams:(CHIPColorControlClusterStepColorParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::StepColor::Type request;
    request.stepX = params.stepX.shortValue;
    request.stepY = params.stepY.shortValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stepColorTemperatureWithParams:(CHIPColorControlClusterStepColorTemperatureParams *)params
                     completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::StepColorTemperature::Type request;
    request.stepMode = static_cast<std::remove_reference_t<decltype(request.stepMode)>>(params.stepMode.unsignedCharValue);
    request.stepSize = params.stepSize.unsignedShortValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.colorTemperatureMinimum = params.colorTemperatureMinimum.unsignedShortValue;
    request.colorTemperatureMaximum = params.colorTemperatureMaximum.unsignedShortValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stepHueWithParams:(CHIPColorControlClusterStepHueParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::StepHue::Type request;
    request.stepMode = static_cast<std::remove_reference_t<decltype(request.stepMode)>>(params.stepMode.unsignedCharValue);
    request.stepSize = params.stepSize.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedCharValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stepSaturationWithParams:(CHIPColorControlClusterStepSaturationParams *)params
               completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::StepSaturation::Type request;
    request.stepMode = static_cast<std::remove_reference_t<decltype(request.stepMode)>>(params.stepMode.unsignedCharValue);
    request.stepSize = params.stepSize.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedCharValue;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stopMoveStepWithParams:(CHIPColorControlClusterStopMoveStepParams *)params
             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ColorControl::Commands::StopMoveStep::Type request;
    request.optionsMask = params.optionsMask.unsignedCharValue;
    request.optionsOverride = params.optionsOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeCurrentHueWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::CurrentHue::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentHueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::CurrentHue::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentHueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::CurrentHue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentSaturationWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::CurrentSaturation::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentSaturationWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::CurrentSaturation::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentSaturationWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::CurrentSaturation::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRemainingTimeWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::RemainingTime::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRemainingTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::RemainingTime::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRemainingTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::RemainingTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentXWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::CurrentX::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentXWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::CurrentX::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentXWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::CurrentX::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentYWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::CurrentY::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentYWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::CurrentY::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentYWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::CurrentY::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeDriftCompensationWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::DriftCompensation::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeDriftCompensationWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::DriftCompensation::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDriftCompensationWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::DriftCompensation::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCompensationTextWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::CompensationText::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCompensationTextWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::CompensationText::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCompensationTextWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::CompensationText::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorTemperatureWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorTemperature::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorTemperatureWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorTemperature::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorTemperatureWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorTemperature::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorModeWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorMode::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorMode::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorMode::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorControlOptionsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorControlOptions::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorControlOptionsWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorControlOptions::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorControlOptionsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorControlOptions::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorControlOptionsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorControlOptions::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNumberOfPrimariesWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::NumberOfPrimaries::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfPrimariesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::NumberOfPrimaries::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfPrimariesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::NumberOfPrimaries::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary1XWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary1X::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary1XWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary1X::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary1XWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary1X::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary1YWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary1Y::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary1YWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary1Y::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary1YWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary1Y::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary1IntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary1Intensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary1IntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary1Intensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary1IntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary1Intensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary2XWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary2X::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary2XWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary2X::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary2XWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary2X::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary2YWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary2Y::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary2YWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary2Y::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary2YWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary2Y::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary2IntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary2Intensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary2IntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary2Intensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary2IntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary2Intensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary3XWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary3X::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary3XWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary3X::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary3XWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary3X::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary3YWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary3Y::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary3YWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary3Y::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary3YWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary3Y::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary3IntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary3Intensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary3IntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary3Intensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary3IntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary3Intensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary4XWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary4X::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary4XWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary4X::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary4XWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary4X::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary4YWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary4Y::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary4YWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary4Y::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary4YWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary4Y::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary4IntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary4Intensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary4IntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary4Intensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary4IntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary4Intensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary5XWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary5X::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary5XWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary5X::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary5XWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary5X::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary5YWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary5Y::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary5YWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary5Y::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary5YWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary5Y::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary5IntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary5Intensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary5IntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary5Intensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary5IntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary5Intensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary6XWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary6X::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary6XWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary6X::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary6XWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary6X::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary6YWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary6Y::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary6YWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary6Y::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary6YWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary6Y::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePrimary6IntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::Primary6Intensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePrimary6IntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::Primary6Intensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePrimary6IntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::Primary6Intensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeWhitePointXWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::WhitePointX::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeWhitePointXWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::WhitePointX::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeWhitePointXWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::WhitePointX::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeWhitePointXWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::WhitePointX::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeWhitePointYWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::WhitePointY::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeWhitePointYWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::WhitePointY::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeWhitePointYWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::WhitePointY::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeWhitePointYWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::WhitePointY::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointRXWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointRX::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointRXWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointRX::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointRXWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointRX::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointRXWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointRX::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointRYWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointRY::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointRYWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointRY::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointRYWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointRY::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointRYWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointRY::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointRIntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointRIntensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointRIntensityWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointRIntensity::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointRIntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointRIntensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointRIntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointRIntensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointGXWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointGX::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointGXWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointGX::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointGXWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointGX::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointGXWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointGX::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointGYWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointGY::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointGYWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointGY::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointGYWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointGY::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointGYWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointGY::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointGIntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointGIntensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointGIntensityWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointGIntensity::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointGIntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointGIntensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointGIntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointGIntensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointBXWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointBX::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointBXWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointBX::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointBXWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointBX::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointBXWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointBX::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointBYWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointBY::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointBYWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointBY::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointBYWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointBY::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointBYWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointBY::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorPointBIntensityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorPointBIntensity::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeColorPointBIntensityWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::ColorPointBIntensity::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeColorPointBIntensityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorPointBIntensity::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorPointBIntensityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorPointBIntensity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEnhancedCurrentHueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::EnhancedCurrentHue::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeEnhancedCurrentHueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::EnhancedCurrentHue::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEnhancedCurrentHueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::EnhancedCurrentHue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEnhancedColorModeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::EnhancedColorMode::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeEnhancedColorModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::EnhancedColorMode::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEnhancedColorModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::EnhancedColorMode::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorLoopActiveWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorLoopActive::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorLoopActiveWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorLoopActive::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorLoopActiveWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorLoopActive::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorLoopDirectionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorLoopDirection::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorLoopDirectionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorLoopDirection::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorLoopDirectionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorLoopDirection::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorLoopTimeWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorLoopTime::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorLoopTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorLoopTime::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorLoopTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorLoopTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorLoopStartEnhancedHueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorLoopStartEnhancedHueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                                            params:(CHIPSubscribeParams * _Nullable)params
                                           subscriptionEstablished:
                                               (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                     reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorLoopStartEnhancedHueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                        endpoint:(NSNumber *)endpoint
                                                           queue:(dispatch_queue_t)queue
                                               completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorLoopStoredEnhancedHueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                                             params:(CHIPSubscribeParams * _Nullable)params
                                            subscriptionEstablished:
                                                (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                      reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorLoopStoredEnhancedHueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                         endpoint:(NSNumber *)endpoint
                                                            queue:(dispatch_queue_t)queue
                                                completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorCapabilitiesWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorCapabilities::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorCapabilitiesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorCapabilities::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorCapabilitiesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorCapabilities::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorTempPhysicalMinWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorTempPhysicalMinWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorTempPhysicalMinWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeColorTempPhysicalMaxWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeColorTempPhysicalMaxWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeColorTempPhysicalMaxWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCoupleColorTempToLevelMinMiredsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCoupleColorTempToLevelMinMiredsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                  params:(CHIPSubscribeParams * _Nullable)params
                                                 subscriptionEstablished:
                                                     (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                           reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                             NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCoupleColorTempToLevelMinMiredsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                              endpoint:(NSNumber *)endpoint
                                                                 queue:(dispatch_queue_t)queue
                                                     completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeStartUpColorTemperatureMiredsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeStartUpColorTemperatureMiredsWithValue:(NSNumber * _Nonnull)value
                                           completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeStartUpColorTemperatureMiredsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStartUpColorTemperatureMiredsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPColorControlGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ColorControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ColorControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPColorControlGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ColorControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPColorControlGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPColorControlGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ColorControl::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ColorControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPColorControlAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ColorControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ColorControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPColorControlAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ColorControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPColorControlAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPColorControlAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ColorControl::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ColorControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPColorControlAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ColorControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ColorControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPColorControlAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ColorControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPColorControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPColorControlAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ColorControl::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ColorControlAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ColorControl::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ColorControl::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ColorControl::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPContentLauncher

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)launchContentWithParams:(CHIPContentLauncherClusterLaunchContentParams *)params
              completionHandler:(void (^)(CHIPContentLauncherClusterLaunchResponseParams * _Nullable data,
                                    NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    ContentLauncher::Commands::LaunchContent::Type request;
    {
        using ListType_1 = std::remove_reference_t<decltype(request.search.parameterList)>;
        using ListMemberType_1 = ListMemberTypeGetter<ListType_1>::Type;
        if (params.search.parameterList.count != 0) {
            auto * listHolder_1 = new ListHolder<ListMemberType_1>(params.search.parameterList.count);
            if (listHolder_1 == nullptr || listHolder_1->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_1);
            for (size_t i_1 = 0; i_1 < params.search.parameterList.count; ++i_1) {
                if (![params.search.parameterList[i_1] isKindOfClass:[CHIPContentLauncherClusterParameter class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_1 = (CHIPContentLauncherClusterParameter *) params.search.parameterList[i_1];
                listHolder_1->mList[i_1].type = static_cast<std::remove_reference_t<decltype(listHolder_1->mList[i_1].type)>>(
                    element_1.type.unsignedCharValue);
                listHolder_1->mList[i_1].value = [self asCharSpan:element_1.value];
                if (element_1.externalIDList != nil) {
                    auto & definedValue_3 = listHolder_1->mList[i_1].externalIDList.Emplace();
                    {
                        using ListType_4 = std::remove_reference_t<decltype(definedValue_3)>;
                        using ListMemberType_4 = ListMemberTypeGetter<ListType_4>::Type;
                        if (element_1.externalIDList.count != 0) {
                            auto * listHolder_4 = new ListHolder<ListMemberType_4>(element_1.externalIDList.count);
                            if (listHolder_4 == nullptr || listHolder_4->mList == nullptr) {
                                return;
                            }
                            listFreer.add(listHolder_4);
                            for (size_t i_4 = 0; i_4 < element_1.externalIDList.count; ++i_4) {
                                if (![element_1.externalIDList[i_4]
                                        isKindOfClass:[CHIPContentLauncherClusterAdditionalInfo class]]) {
                                    // Wrong kind of value.
                                    return;
                                }
                                auto element_4 = (CHIPContentLauncherClusterAdditionalInfo *) element_1.externalIDList[i_4];
                                listHolder_4->mList[i_4].name = [self asCharSpan:element_4.name];
                                listHolder_4->mList[i_4].value = [self asCharSpan:element_4.value];
                            }
                            definedValue_3 = ListType_4(listHolder_4->mList, element_1.externalIDList.count);
                        } else {
                            definedValue_3 = ListType_4();
                        }
                    }
                }
            }
            request.search.parameterList = ListType_1(listHolder_1->mList, params.search.parameterList.count);
        } else {
            request.search.parameterList = ListType_1();
        }
    }
    request.autoPlay = params.autoPlay.boolValue;
    if (params.data != nil) {
        auto & definedValue_0 = request.data.Emplace();
        definedValue_0 = [self asCharSpan:params.data];
    }

    new CHIPContentLauncherClusterLaunchResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPContentLauncherClusterLaunchResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)launchURLWithParams:(CHIPContentLauncherClusterLaunchURLParams *)params
          completionHandler:(void (^)(CHIPContentLauncherClusterLaunchResponseParams * _Nullable data,
                                NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    ContentLauncher::Commands::LaunchURL::Type request;
    request.contentURL = [self asCharSpan:params.contentURL];
    if (params.displayString != nil) {
        auto & definedValue_0 = request.displayString.Emplace();
        definedValue_0 = [self asCharSpan:params.displayString];
    }
    if (params.brandingInformation != nil) {
        auto & definedValue_0 = request.brandingInformation.Emplace();
        definedValue_0.providerName = [self asCharSpan:params.brandingInformation.providerName];
        if (params.brandingInformation.background != nil) {
            auto & definedValue_2 = definedValue_0.background.Emplace();
            if (params.brandingInformation.background.imageUrl != nil) {
                auto & definedValue_4 = definedValue_2.imageUrl.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.background.imageUrl];
            }
            if (params.brandingInformation.background.color != nil) {
                auto & definedValue_4 = definedValue_2.color.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.background.color];
            }
            if (params.brandingInformation.background.size != nil) {
                auto & definedValue_4 = definedValue_2.size.Emplace();
                definedValue_4.width = params.brandingInformation.background.size.width.doubleValue;
                definedValue_4.height = params.brandingInformation.background.size.height.doubleValue;
                definedValue_4.metric = static_cast<std::remove_reference_t<decltype(definedValue_4.metric)>>(
                    params.brandingInformation.background.size.metric.unsignedCharValue);
            }
        }
        if (params.brandingInformation.logo != nil) {
            auto & definedValue_2 = definedValue_0.logo.Emplace();
            if (params.brandingInformation.logo.imageUrl != nil) {
                auto & definedValue_4 = definedValue_2.imageUrl.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.logo.imageUrl];
            }
            if (params.brandingInformation.logo.color != nil) {
                auto & definedValue_4 = definedValue_2.color.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.logo.color];
            }
            if (params.brandingInformation.logo.size != nil) {
                auto & definedValue_4 = definedValue_2.size.Emplace();
                definedValue_4.width = params.brandingInformation.logo.size.width.doubleValue;
                definedValue_4.height = params.brandingInformation.logo.size.height.doubleValue;
                definedValue_4.metric = static_cast<std::remove_reference_t<decltype(definedValue_4.metric)>>(
                    params.brandingInformation.logo.size.metric.unsignedCharValue);
            }
        }
        if (params.brandingInformation.progressBar != nil) {
            auto & definedValue_2 = definedValue_0.progressBar.Emplace();
            if (params.brandingInformation.progressBar.imageUrl != nil) {
                auto & definedValue_4 = definedValue_2.imageUrl.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.progressBar.imageUrl];
            }
            if (params.brandingInformation.progressBar.color != nil) {
                auto & definedValue_4 = definedValue_2.color.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.progressBar.color];
            }
            if (params.brandingInformation.progressBar.size != nil) {
                auto & definedValue_4 = definedValue_2.size.Emplace();
                definedValue_4.width = params.brandingInformation.progressBar.size.width.doubleValue;
                definedValue_4.height = params.brandingInformation.progressBar.size.height.doubleValue;
                definedValue_4.metric = static_cast<std::remove_reference_t<decltype(definedValue_4.metric)>>(
                    params.brandingInformation.progressBar.size.metric.unsignedCharValue);
            }
        }
        if (params.brandingInformation.splash != nil) {
            auto & definedValue_2 = definedValue_0.splash.Emplace();
            if (params.brandingInformation.splash.imageUrl != nil) {
                auto & definedValue_4 = definedValue_2.imageUrl.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.splash.imageUrl];
            }
            if (params.brandingInformation.splash.color != nil) {
                auto & definedValue_4 = definedValue_2.color.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.splash.color];
            }
            if (params.brandingInformation.splash.size != nil) {
                auto & definedValue_4 = definedValue_2.size.Emplace();
                definedValue_4.width = params.brandingInformation.splash.size.width.doubleValue;
                definedValue_4.height = params.brandingInformation.splash.size.height.doubleValue;
                definedValue_4.metric = static_cast<std::remove_reference_t<decltype(definedValue_4.metric)>>(
                    params.brandingInformation.splash.size.metric.unsignedCharValue);
            }
        }
        if (params.brandingInformation.waterMark != nil) {
            auto & definedValue_2 = definedValue_0.waterMark.Emplace();
            if (params.brandingInformation.waterMark.imageUrl != nil) {
                auto & definedValue_4 = definedValue_2.imageUrl.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.waterMark.imageUrl];
            }
            if (params.brandingInformation.waterMark.color != nil) {
                auto & definedValue_4 = definedValue_2.color.Emplace();
                definedValue_4 = [self asCharSpan:params.brandingInformation.waterMark.color];
            }
            if (params.brandingInformation.waterMark.size != nil) {
                auto & definedValue_4 = definedValue_2.size.Emplace();
                definedValue_4.width = params.brandingInformation.waterMark.size.width.doubleValue;
                definedValue_4.height = params.brandingInformation.waterMark.size.height.doubleValue;
                definedValue_4.metric = static_cast<std::remove_reference_t<decltype(definedValue_4.metric)>>(
                    params.brandingInformation.waterMark.size.metric.unsignedCharValue);
            }
        }
    }

    new CHIPContentLauncherClusterLaunchResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPContentLauncherClusterLaunchResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeAcceptHeaderWithCompletionHandler:(void (^)(
                                                           NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPContentLauncherAcceptHeaderListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ContentLauncher::Attributes::AcceptHeader::TypeInfo;
            auto successFn = Callback<ContentLauncherAcceptHeaderListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptHeaderWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPContentLauncherAcceptHeaderListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ContentLauncher::Attributes::AcceptHeader::TypeInfo;
            auto successFn = Callback<ContentLauncherAcceptHeaderListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPContentLauncherAcceptHeaderListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptHeaderWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPContentLauncherAcceptHeaderListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ContentLauncher::Attributes::AcceptHeader::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ContentLauncherAcceptHeaderListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeSupportedStreamingProtocolsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                          NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeSupportedStreamingProtocolsWithValue:(NSNumber * _Nonnull)value
                                         completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedIntValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSupportedStreamingProtocolsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                                              params:(CHIPSubscribeParams * _Nullable)params
                                             subscriptionEstablished:
                                                 (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                       reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSupportedStreamingProtocolsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                          endpoint:(NSNumber *)endpoint
                                                             queue:(dispatch_queue_t)queue
                                                 completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ContentLauncher::Attributes::SupportedStreamingProtocols::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPContentLauncherGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ContentLauncher::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ContentLauncherGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPContentLauncherGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ContentLauncher::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ContentLauncherGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPContentLauncherGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPContentLauncherGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ContentLauncher::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ContentLauncherGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPContentLauncherAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ContentLauncher::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ContentLauncherAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPContentLauncherAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ContentLauncher::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ContentLauncherAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPContentLauncherAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPContentLauncherAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ContentLauncher::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ContentLauncherAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPContentLauncherAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ContentLauncher::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ContentLauncherAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPContentLauncherAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ContentLauncher::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ContentLauncherAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPContentLauncherAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPContentLauncherAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ContentLauncher::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ContentLauncherAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ContentLauncher::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ContentLauncher::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ContentLauncher::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPDescriptor

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeDeviceListWithCompletionHandler:(void (^)(
                                                         NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorDeviceListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Descriptor::Attributes::DeviceList::TypeInfo;
            auto successFn = Callback<DescriptorDeviceListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeDeviceListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDescriptorDeviceListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Descriptor::Attributes::DeviceList::TypeInfo;
            auto successFn = Callback<DescriptorDeviceListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDescriptorDeviceListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDeviceListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorDeviceListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Descriptor::Attributes::DeviceList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DescriptorDeviceListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeServerListWithCompletionHandler:(void (^)(
                                                         NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorServerListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Descriptor::Attributes::ServerList::TypeInfo;
            auto successFn = Callback<DescriptorServerListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeServerListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDescriptorServerListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Descriptor::Attributes::ServerList::TypeInfo;
            auto successFn = Callback<DescriptorServerListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDescriptorServerListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeServerListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorServerListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Descriptor::Attributes::ServerList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DescriptorServerListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClientListWithCompletionHandler:(void (^)(
                                                         NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorClientListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Descriptor::Attributes::ClientList::TypeInfo;
            auto successFn = Callback<DescriptorClientListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeClientListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDescriptorClientListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Descriptor::Attributes::ClientList::TypeInfo;
            auto successFn = Callback<DescriptorClientListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDescriptorClientListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClientListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorClientListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Descriptor::Attributes::ClientList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DescriptorClientListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributePartsListWithCompletionHandler:(void (^)(
                                                        NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorPartsListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Descriptor::Attributes::PartsList::TypeInfo;
            auto successFn = Callback<DescriptorPartsListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributePartsListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDescriptorPartsListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Descriptor::Attributes::PartsList::TypeInfo;
            auto successFn = Callback<DescriptorPartsListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDescriptorPartsListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePartsListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorPartsListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Descriptor::Attributes::PartsList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<DescriptorPartsListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Descriptor::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<DescriptorGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDescriptorGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Descriptor::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<DescriptorGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDescriptorGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Descriptor::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DescriptorGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Descriptor::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<DescriptorAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDescriptorAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Descriptor::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<DescriptorAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDescriptorAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Descriptor::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DescriptorAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Descriptor::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<DescriptorAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDescriptorAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Descriptor::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<DescriptorAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDescriptorAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDescriptorAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Descriptor::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DescriptorAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Descriptor::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Descriptor::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Descriptor::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPDiagnosticLogs

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)retrieveLogsRequestWithParams:(CHIPDiagnosticLogsClusterRetrieveLogsRequestParams *)params
                    completionHandler:(void (^)(CHIPDiagnosticLogsClusterRetrieveLogsResponseParams * _Nullable data,
                                          NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    DiagnosticLogs::Commands::RetrieveLogsRequest::Type request;
    request.intent = static_cast<std::remove_reference_t<decltype(request.intent)>>(params.intent.unsignedCharValue);
    request.requestedProtocol
        = static_cast<std::remove_reference_t<decltype(request.requestedProtocol)>>(params.requestedProtocol.unsignedCharValue);
    request.transferFileDesignator = [self asByteSpan:params.transferFileDesignator];

    new CHIPDiagnosticLogsClusterRetrieveLogsResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPDiagnosticLogsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DiagnosticLogs::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<DiagnosticLogsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDiagnosticLogsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DiagnosticLogs::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<DiagnosticLogsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDiagnosticLogsGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDiagnosticLogsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DiagnosticLogs::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DiagnosticLogsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPDiagnosticLogsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DiagnosticLogs::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<DiagnosticLogsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDiagnosticLogsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DiagnosticLogs::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<DiagnosticLogsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDiagnosticLogsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDiagnosticLogsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DiagnosticLogs::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DiagnosticLogsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDiagnosticLogsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DiagnosticLogs::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<DiagnosticLogsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDiagnosticLogsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DiagnosticLogs::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<DiagnosticLogsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDiagnosticLogsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDiagnosticLogsAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DiagnosticLogs::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DiagnosticLogsAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

@end

@implementation CHIPDoorLock

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)clearCredentialWithParams:(CHIPDoorLockClusterClearCredentialParams *)params
                completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::ClearCredential::Type request;
    if (params.credential == nil) {
        request.credential.SetNull();
    } else {
        auto & nonNullValue_0 = request.credential.SetNonNull();
        nonNullValue_0.credentialType = static_cast<std::remove_reference_t<decltype(nonNullValue_0.credentialType)>>(
            params.credential.credentialType.unsignedCharValue);
        nonNullValue_0.credentialIndex = params.credential.credentialIndex.unsignedShortValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)clearHolidayScheduleWithParams:(CHIPDoorLockClusterClearHolidayScheduleParams *)params
                     completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::ClearHolidaySchedule::Type request;
    request.holidayIndex = params.holidayIndex.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)clearUserWithParams:(CHIPDoorLockClusterClearUserParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::ClearUser::Type request;
    request.userIndex = params.userIndex.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)clearWeekDayScheduleWithParams:(CHIPDoorLockClusterClearWeekDayScheduleParams *)params
                     completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::ClearWeekDaySchedule::Type request;
    request.weekDayIndex = params.weekDayIndex.unsignedCharValue;
    request.userIndex = params.userIndex.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)clearYearDayScheduleWithParams:(CHIPDoorLockClusterClearYearDayScheduleParams *)params
                     completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::ClearYearDaySchedule::Type request;
    request.yearDayIndex = params.yearDayIndex.unsignedCharValue;
    request.userIndex = params.userIndex.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getCredentialStatusWithParams:(CHIPDoorLockClusterGetCredentialStatusParams *)params
                    completionHandler:(void (^)(CHIPDoorLockClusterGetCredentialStatusResponseParams * _Nullable data,
                                          NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::GetCredentialStatus::Type request;
    request.credential.credentialType = static_cast<std::remove_reference_t<decltype(request.credential.credentialType)>>(
        params.credential.credentialType.unsignedCharValue);
    request.credential.credentialIndex = params.credential.credentialIndex.unsignedShortValue;

    new CHIPDoorLockClusterGetCredentialStatusResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPDoorLockClusterGetCredentialStatusResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getHolidayScheduleWithParams:(CHIPDoorLockClusterGetHolidayScheduleParams *)params
                   completionHandler:(void (^)(CHIPDoorLockClusterGetHolidayScheduleResponseParams * _Nullable data,
                                         NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::GetHolidaySchedule::Type request;
    request.holidayIndex = params.holidayIndex.unsignedCharValue;

    new CHIPDoorLockClusterGetHolidayScheduleResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPDoorLockClusterGetHolidayScheduleResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getUserWithParams:(CHIPDoorLockClusterGetUserParams *)params
        completionHandler:
            (void (^)(CHIPDoorLockClusterGetUserResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::GetUser::Type request;
    request.userIndex = params.userIndex.unsignedShortValue;

    new CHIPDoorLockClusterGetUserResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPDoorLockClusterGetUserResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getWeekDayScheduleWithParams:(CHIPDoorLockClusterGetWeekDayScheduleParams *)params
                   completionHandler:(void (^)(CHIPDoorLockClusterGetWeekDayScheduleResponseParams * _Nullable data,
                                         NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::GetWeekDaySchedule::Type request;
    request.weekDayIndex = params.weekDayIndex.unsignedCharValue;
    request.userIndex = params.userIndex.unsignedShortValue;

    new CHIPDoorLockClusterGetWeekDayScheduleResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPDoorLockClusterGetWeekDayScheduleResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getYearDayScheduleWithParams:(CHIPDoorLockClusterGetYearDayScheduleParams *)params
                   completionHandler:(void (^)(CHIPDoorLockClusterGetYearDayScheduleResponseParams * _Nullable data,
                                         NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::GetYearDaySchedule::Type request;
    request.yearDayIndex = params.yearDayIndex.unsignedCharValue;
    request.userIndex = params.userIndex.unsignedShortValue;

    new CHIPDoorLockClusterGetYearDayScheduleResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPDoorLockClusterGetYearDayScheduleResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)lockDoorWithParams:(CHIPDoorLockClusterLockDoorParams * _Nullable)params
         completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::LockDoor::Type request;
    if (params != nil) {
        if (params.pinCode != nil) {
            auto & definedValue_0 = request.pinCode.Emplace();
            definedValue_0 = [self asByteSpan:params.pinCode];
        }
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)setCredentialWithParams:(CHIPDoorLockClusterSetCredentialParams *)params
              completionHandler:(void (^)(CHIPDoorLockClusterSetCredentialResponseParams * _Nullable data,
                                    NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::SetCredential::Type request;
    request.operationType
        = static_cast<std::remove_reference_t<decltype(request.operationType)>>(params.operationType.unsignedCharValue);
    request.credential.credentialType = static_cast<std::remove_reference_t<decltype(request.credential.credentialType)>>(
        params.credential.credentialType.unsignedCharValue);
    request.credential.credentialIndex = params.credential.credentialIndex.unsignedShortValue;
    request.credentialData = [self asByteSpan:params.credentialData];
    if (params.userIndex == nil) {
        request.userIndex.SetNull();
    } else {
        auto & nonNullValue_0 = request.userIndex.SetNonNull();
        nonNullValue_0 = params.userIndex.unsignedShortValue;
    }
    if (params.userStatus == nil) {
        request.userStatus.SetNull();
    } else {
        auto & nonNullValue_0 = request.userStatus.SetNonNull();
        nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(params.userStatus.unsignedCharValue);
    }
    if (params.userType == nil) {
        request.userType.SetNull();
    } else {
        auto & nonNullValue_0 = request.userType.SetNonNull();
        nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(params.userType.unsignedCharValue);
    }

    new CHIPDoorLockClusterSetCredentialResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPDoorLockClusterSetCredentialResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)setHolidayScheduleWithParams:(CHIPDoorLockClusterSetHolidayScheduleParams *)params
                   completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::SetHolidaySchedule::Type request;
    request.holidayIndex = params.holidayIndex.unsignedCharValue;
    request.localStartTime = params.localStartTime.unsignedIntValue;
    request.localEndTime = params.localEndTime.unsignedIntValue;
    request.operatingMode
        = static_cast<std::remove_reference_t<decltype(request.operatingMode)>>(params.operatingMode.unsignedCharValue);

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)setUserWithParams:(CHIPDoorLockClusterSetUserParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::SetUser::Type request;
    request.operationType
        = static_cast<std::remove_reference_t<decltype(request.operationType)>>(params.operationType.unsignedCharValue);
    request.userIndex = params.userIndex.unsignedShortValue;
    if (params.userName == nil) {
        request.userName.SetNull();
    } else {
        auto & nonNullValue_0 = request.userName.SetNonNull();
        nonNullValue_0 = [self asCharSpan:params.userName];
    }
    if (params.userUniqueId == nil) {
        request.userUniqueId.SetNull();
    } else {
        auto & nonNullValue_0 = request.userUniqueId.SetNonNull();
        nonNullValue_0 = params.userUniqueId.unsignedIntValue;
    }
    if (params.userStatus == nil) {
        request.userStatus.SetNull();
    } else {
        auto & nonNullValue_0 = request.userStatus.SetNonNull();
        nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(params.userStatus.unsignedCharValue);
    }
    if (params.userType == nil) {
        request.userType.SetNull();
    } else {
        auto & nonNullValue_0 = request.userType.SetNonNull();
        nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(params.userType.unsignedCharValue);
    }
    if (params.credentialRule == nil) {
        request.credentialRule.SetNull();
    } else {
        auto & nonNullValue_0 = request.credentialRule.SetNonNull();
        nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(params.credentialRule.unsignedCharValue);
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)setWeekDayScheduleWithParams:(CHIPDoorLockClusterSetWeekDayScheduleParams *)params
                   completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::SetWeekDaySchedule::Type request;
    request.weekDayIndex = params.weekDayIndex.unsignedCharValue;
    request.userIndex = params.userIndex.unsignedShortValue;
    request.daysMask = static_cast<std::remove_reference_t<decltype(request.daysMask)>>(params.daysMask.unsignedCharValue);
    request.startHour = params.startHour.unsignedCharValue;
    request.startMinute = params.startMinute.unsignedCharValue;
    request.endHour = params.endHour.unsignedCharValue;
    request.endMinute = params.endMinute.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)setYearDayScheduleWithParams:(CHIPDoorLockClusterSetYearDayScheduleParams *)params
                   completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::SetYearDaySchedule::Type request;
    request.yearDayIndex = params.yearDayIndex.unsignedCharValue;
    request.userIndex = params.userIndex.unsignedShortValue;
    request.localStartTime = params.localStartTime.unsignedIntValue;
    request.localEndTime = params.localEndTime.unsignedIntValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)unlockDoorWithParams:(CHIPDoorLockClusterUnlockDoorParams * _Nullable)params
           completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::UnlockDoor::Type request;
    if (params != nil) {
        if (params.pinCode != nil) {
            auto & definedValue_0 = request.pinCode.Emplace();
            definedValue_0 = [self asByteSpan:params.pinCode];
        }
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)unlockWithTimeoutWithParams:(CHIPDoorLockClusterUnlockWithTimeoutParams *)params
                  completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    DoorLock::Commands::UnlockWithTimeout::Type request;
    request.timeout = params.timeout.unsignedShortValue;
    if (params.pinCode != nil) {
        auto & definedValue_0 = request.pinCode.Emplace();
        definedValue_0 = [self asByteSpan:params.pinCode];
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)readAttributeLockStateWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableDoorLockClusterDlLockStateAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DoorLock::Attributes::LockState::TypeInfo;
            auto successFn = Callback<NullableDoorLockClusterDlLockStateAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLockStateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableDoorLockClusterDlLockStateAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::LockState::TypeInfo;
            auto successFn = Callback<NullableDoorLockClusterDlLockStateAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableDoorLockClusterDlLockStateAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLockStateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableDoorLockClusterDlLockStateAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DoorLock::Attributes::LockState::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<NullableDoorLockClusterDlLockStateAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeLockTypeWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockClusterDlLockTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DoorLock::Attributes::LockType::TypeInfo;
            auto successFn = Callback<DoorLockClusterDlLockTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLockTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDoorLockClusterDlLockTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::LockType::TypeInfo;
            auto successFn = Callback<DoorLockClusterDlLockTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDoorLockClusterDlLockTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLockTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockClusterDlLockTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DoorLock::Attributes::LockType::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DoorLockClusterDlLockTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeActuatorEnabledWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::ActuatorEnabled::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeActuatorEnabledWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::ActuatorEnabled::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActuatorEnabledWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::ActuatorEnabled::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeDoorStateWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableDoorLockClusterDlDoorStateAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DoorLock::Attributes::DoorState::TypeInfo;
            auto successFn = Callback<NullableDoorLockClusterDlDoorStateAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeDoorStateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableDoorLockClusterDlDoorStateAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::DoorState::TypeInfo;
            auto successFn = Callback<NullableDoorLockClusterDlDoorStateAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableDoorLockClusterDlDoorStateAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDoorStateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableDoorLockClusterDlDoorStateAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DoorLock::Attributes::DoorState::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<NullableDoorLockClusterDlDoorStateAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeNumberOfTotalUsersSupportedWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                          NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::NumberOfTotalUsersSupported::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfTotalUsersSupportedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                                              params:(CHIPSubscribeParams * _Nullable)params
                                             subscriptionEstablished:
                                                 (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                       reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::NumberOfTotalUsersSupported::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfTotalUsersSupportedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                          endpoint:(NSNumber *)endpoint
                                                             queue:(dispatch_queue_t)queue
                                                 completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::NumberOfTotalUsersSupported::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNumberOfPINUsersSupportedWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::NumberOfPINUsersSupported::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfPINUsersSupportedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                                            params:(CHIPSubscribeParams * _Nullable)params
                                           subscriptionEstablished:
                                               (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                     reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::NumberOfPINUsersSupported::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfPINUsersSupportedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                        endpoint:(NSNumber *)endpoint
                                                           queue:(dispatch_queue_t)queue
                                               completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::NumberOfPINUsersSupported::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNumberOfRFIDUsersSupportedWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::NumberOfRFIDUsersSupported::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfRFIDUsersSupportedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                                             params:(CHIPSubscribeParams * _Nullable)params
                                            subscriptionEstablished:
                                                (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                      reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::NumberOfRFIDUsersSupported::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfRFIDUsersSupportedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                         endpoint:(NSNumber *)endpoint
                                                            queue:(dispatch_queue_t)queue
                                                completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::NumberOfRFIDUsersSupported::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNumberOfWeekDaySchedulesSupportedPerUserWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::NumberOfWeekDaySchedulesSupportedPerUser::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfWeekDaySchedulesSupportedPerUserWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                           params:(CHIPSubscribeParams * _Nullable)params
                                                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)
                                                                                      subscriptionEstablishedHandler
                                                                    reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                                      NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::NumberOfWeekDaySchedulesSupportedPerUser::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfWeekDaySchedulesSupportedPerUserWithAttributeCache:
            (CHIPAttributeCacheContainer *)attributeCacheContainer
                                                                       endpoint:(NSNumber *)endpoint
                                                                          queue:(dispatch_queue_t)queue
                                                              completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::NumberOfWeekDaySchedulesSupportedPerUser::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNumberOfYearDaySchedulesSupportedPerUserWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::NumberOfYearDaySchedulesSupportedPerUser::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfYearDaySchedulesSupportedPerUserWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                           params:(CHIPSubscribeParams * _Nullable)params
                                                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)
                                                                                      subscriptionEstablishedHandler
                                                                    reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                                      NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::NumberOfYearDaySchedulesSupportedPerUser::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfYearDaySchedulesSupportedPerUserWithAttributeCache:
            (CHIPAttributeCacheContainer *)attributeCacheContainer
                                                                       endpoint:(NSNumber *)endpoint
                                                                          queue:(dispatch_queue_t)queue
                                                              completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::NumberOfYearDaySchedulesSupportedPerUser::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNumberOfHolidaySchedulesSupportedWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::NumberOfHolidaySchedulesSupported::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfHolidaySchedulesSupportedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                    params:(CHIPSubscribeParams * _Nullable)params
                                                   subscriptionEstablished:
                                                       (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                             reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                               NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::NumberOfHolidaySchedulesSupported::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfHolidaySchedulesSupportedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                                endpoint:(NSNumber *)endpoint
                                                                   queue:(dispatch_queue_t)queue
                                                       completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::NumberOfHolidaySchedulesSupported::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxPINCodeLengthWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::MaxPINCodeLength::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMaxPINCodeLengthWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::MaxPINCodeLength::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxPINCodeLengthWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::MaxPINCodeLength::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinPINCodeLengthWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::MinPINCodeLength::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMinPINCodeLengthWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::MinPINCodeLength::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinPINCodeLengthWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::MinPINCodeLength::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxRFIDCodeLengthWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::MaxRFIDCodeLength::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMaxRFIDCodeLengthWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::MaxRFIDCodeLength::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxRFIDCodeLengthWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::MaxRFIDCodeLength::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinRFIDCodeLengthWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::MinRFIDCodeLength::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMinRFIDCodeLengthWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::MinRFIDCodeLength::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinRFIDCodeLengthWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::MinRFIDCodeLength::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLanguageWithCompletionHandler:(void (^)(
                                                       NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::Language::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeLanguageWithValue:(NSString * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::Language::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asCharSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLanguageWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::Language::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLanguageWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::Language::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAutoRelockTimeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::AutoRelockTime::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeAutoRelockTimeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::AutoRelockTime::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedIntValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAutoRelockTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::AutoRelockTime::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAutoRelockTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::AutoRelockTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSoundVolumeWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::SoundVolume::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeSoundVolumeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::SoundVolume::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSoundVolumeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::SoundVolume::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSoundVolumeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::SoundVolume::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOperatingModeWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockClusterDlOperatingModeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DoorLock::Attributes::OperatingMode::TypeInfo;
            auto successFn = Callback<DoorLockClusterDlOperatingModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeOperatingModeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::OperatingMode::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOperatingModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDoorLockClusterDlOperatingModeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::OperatingMode::TypeInfo;
            auto successFn = Callback<DoorLockClusterDlOperatingModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDoorLockClusterDlOperatingModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOperatingModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockClusterDlOperatingModeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DoorLock::Attributes::OperatingMode::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DoorLockClusterDlOperatingModeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeSupportedOperatingModesWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockSupportedOperatingModesAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DoorLock::Attributes::SupportedOperatingModes::TypeInfo;
            auto successFn = Callback<DoorLockSupportedOperatingModesAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSupportedOperatingModesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPDoorLockSupportedOperatingModesAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::SupportedOperatingModes::TypeInfo;
            auto successFn = Callback<DoorLockSupportedOperatingModesAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDoorLockSupportedOperatingModesAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSupportedOperatingModesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockSupportedOperatingModesAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DoorLock::Attributes::SupportedOperatingModes::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DoorLockSupportedOperatingModesAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeEnableOneTouchLockingWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::EnableOneTouchLocking::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeEnableOneTouchLockingWithValue:(NSNumber * _Nonnull)value
                                   completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::EnableOneTouchLocking::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEnableOneTouchLockingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::EnableOneTouchLocking::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEnableOneTouchLockingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::EnableOneTouchLocking::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEnablePrivacyModeButtonWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::EnablePrivacyModeButton::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeEnablePrivacyModeButtonWithValue:(NSNumber * _Nonnull)value
                                     completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::EnablePrivacyModeButton::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEnablePrivacyModeButtonWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::EnablePrivacyModeButton::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEnablePrivacyModeButtonWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::EnablePrivacyModeButton::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeWrongCodeEntryLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::WrongCodeEntryLimit::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeWrongCodeEntryLimitWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::WrongCodeEntryLimit::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeWrongCodeEntryLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::WrongCodeEntryLimit::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeWrongCodeEntryLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::WrongCodeEntryLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeUserCodeTemporaryDisableTimeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::UserCodeTemporaryDisableTime::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeUserCodeTemporaryDisableTimeWithValue:(NSNumber * _Nonnull)value
                                          completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::UserCodeTemporaryDisableTime::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeUserCodeTemporaryDisableTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                                               params:(CHIPSubscribeParams * _Nullable)params
                                              subscriptionEstablished:
                                                  (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                        reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                          NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::UserCodeTemporaryDisableTime::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeUserCodeTemporaryDisableTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                           endpoint:(NSNumber *)endpoint
                                                              queue:(dispatch_queue_t)queue
                                                  completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::UserCodeTemporaryDisableTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRequirePINforRemoteOperationWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::RequirePINforRemoteOperation::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeRequirePINforRemoteOperationWithValue:(NSNumber * _Nonnull)value
                                          completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = DoorLock::Attributes::RequirePINforRemoteOperation::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DoorLock::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<DoorLockGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDoorLockGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<DoorLockGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDoorLockGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DoorLock::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DoorLockGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DoorLock::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<DoorLockAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDoorLockAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<DoorLockAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDoorLockAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DoorLock::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DoorLockAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = DoorLock::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<DoorLockAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDoorLockAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<DoorLockAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDoorLockAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoorLockAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = DoorLock::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<DoorLockAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = DoorLock::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = DoorLock::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = DoorLock::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPElectricalMeasurement

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeMeasurementTypeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::MeasurementType::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMeasurementTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::MeasurementType::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMeasurementTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::MeasurementType::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTotalActivePowerWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt32sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::TotalActivePower::TypeInfo;
        auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTotalActivePowerWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::TotalActivePower::TypeInfo;
            auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTotalActivePowerWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::TotalActivePower::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRmsVoltageWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltage::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRmsVoltageWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltage::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRmsVoltageWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltage::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRmsVoltageMinWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltageMin::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRmsVoltageMinWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltageMin::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRmsVoltageMinWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltageMin::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRmsVoltageMaxWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltageMax::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRmsVoltageMaxWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltageMax::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRmsVoltageMaxWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::RmsVoltageMax::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRmsCurrentWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrent::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRmsCurrentWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrent::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRmsCurrentWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrent::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRmsCurrentMinWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrentMin::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRmsCurrentMinWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrentMin::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRmsCurrentMinWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrentMin::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRmsCurrentMaxWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrentMax::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRmsCurrentMaxWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrentMax::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRmsCurrentMaxWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::RmsCurrentMax::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeActivePowerWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::ActivePower::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeActivePowerWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::ActivePower::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActivePowerWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::ActivePower::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeActivePowerMinWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::ActivePowerMin::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeActivePowerMinWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::ActivePowerMin::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActivePowerMinWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::ActivePowerMin::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeActivePowerMaxWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::ActivePowerMax::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeActivePowerMaxWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::ActivePowerMax::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActivePowerMaxWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::ActivePowerMax::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPElectricalMeasurementGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ElectricalMeasurement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ElectricalMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPElectricalMeasurementGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ElectricalMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPElectricalMeasurementGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPElectricalMeasurementGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ElectricalMeasurement::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ElectricalMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPElectricalMeasurementAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ElectricalMeasurement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ElectricalMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPElectricalMeasurementAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ElectricalMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPElectricalMeasurementAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPElectricalMeasurementAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ElectricalMeasurement::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ElectricalMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPElectricalMeasurementAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ElectricalMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ElectricalMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPElectricalMeasurementAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ElectricalMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPElectricalMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPElectricalMeasurementAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ElectricalMeasurement::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ElectricalMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPEthernetNetworkDiagnostics

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)resetCountsWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    EthernetNetworkDiagnostics::Commands::ResetCounts::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributePHYRateWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::PHYRate::TypeInfo;
            auto successFn
                = Callback<NullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributePHYRateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::PHYRate::TypeInfo;
            auto successFn
                = Callback<NullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePHYRateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = EthernetNetworkDiagnostics::Attributes::PHYRate::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<NullableEthernetNetworkDiagnosticsClusterPHYRateTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFullDuplexWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableBooleanAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::FullDuplex::TypeInfo;
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeFullDuplexWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::FullDuplex::TypeInfo;
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFullDuplexWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::FullDuplex::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePacketRxCountWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = EthernetNetworkDiagnostics::Attributes::PacketRxCount::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePacketRxCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::PacketRxCount::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePacketRxCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::PacketRxCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePacketTxCountWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = EthernetNetworkDiagnostics::Attributes::PacketTxCount::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePacketTxCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::PacketTxCount::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePacketTxCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::PacketTxCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxErrCountWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = EthernetNetworkDiagnostics::Attributes::TxErrCount::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxErrCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::TxErrCount::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxErrCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::TxErrCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCollisionCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = EthernetNetworkDiagnostics::Attributes::CollisionCount::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCollisionCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::CollisionCount::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCollisionCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::CollisionCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOverrunCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = EthernetNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOverrunCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOverrunCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCarrierDetectWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableBooleanAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::CarrierDetect::TypeInfo;
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCarrierDetectWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::CarrierDetect::TypeInfo;
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCarrierDetectWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::CarrierDetect::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTimeSinceResetWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = EthernetNetworkDiagnostics::Attributes::TimeSinceReset::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTimeSinceResetWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::TimeSinceReset::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTimeSinceResetWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::TimeSinceReset::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPEthernetNetworkDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<EthernetNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPEthernetNetworkDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<EthernetNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPEthernetNetworkDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPEthernetNetworkDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = EthernetNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<EthernetNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPEthernetNetworkDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<EthernetNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPEthernetNetworkDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<EthernetNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPEthernetNetworkDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPEthernetNetworkDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = EthernetNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<EthernetNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPEthernetNetworkDiagnosticsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<EthernetNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPEthernetNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<EthernetNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPEthernetNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPEthernetNetworkDiagnosticsAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = EthernetNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<EthernetNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = EthernetNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = EthernetNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = EthernetNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPFanControl

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeFanModeWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFanControlClusterFanModeTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FanControl::Attributes::FanMode::TypeInfo;
            auto successFn = Callback<FanControlClusterFanModeTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeFanModeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = FanControl::Attributes::FanMode::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeFanModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFanControlClusterFanModeTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::FanMode::TypeInfo;
            auto successFn = Callback<FanControlClusterFanModeTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFanControlClusterFanModeTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFanModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFanControlClusterFanModeTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FanControl::Attributes::FanMode::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FanControlClusterFanModeTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFanModeSequenceWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPFanControlClusterFanModeSequenceTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FanControl::Attributes::FanModeSequence::TypeInfo;
            auto successFn = Callback<FanControlClusterFanModeSequenceTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeFanModeSequenceWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = FanControl::Attributes::FanModeSequence::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeFanModeSequenceWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFanControlClusterFanModeSequenceTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::FanModeSequence::TypeInfo;
            auto successFn = Callback<FanControlClusterFanModeSequenceTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFanControlClusterFanModeSequenceTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFanModeSequenceWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFanControlClusterFanModeSequenceTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FanControl::Attributes::FanModeSequence::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FanControlClusterFanModeSequenceTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributePercentSettingWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::PercentSetting::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributePercentSettingWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = FanControl::Attributes::PercentSetting::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributePercentSettingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::PercentSetting::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePercentSettingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::PercentSetting::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePercentCurrentWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::PercentCurrent::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePercentCurrentWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::PercentCurrent::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePercentCurrentWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::PercentCurrent::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSpeedMaxWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::SpeedMax::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSpeedMaxWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::SpeedMax::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSpeedMaxWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::SpeedMax::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSpeedSettingWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::SpeedSetting::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeSpeedSettingWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = FanControl::Attributes::SpeedSetting::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSpeedSettingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::SpeedSetting::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSpeedSettingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::SpeedSetting::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSpeedCurrentWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::SpeedCurrent::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSpeedCurrentWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::SpeedCurrent::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSpeedCurrentWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::SpeedCurrent::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRockSupportWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::RockSupport::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRockSupportWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::RockSupport::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRockSupportWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::RockSupport::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRockSettingWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::RockSetting::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeRockSettingWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = FanControl::Attributes::RockSetting::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeRockSettingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::RockSetting::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRockSettingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::RockSetting::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeWindSupportWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::WindSupport::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeWindSupportWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::WindSupport::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeWindSupportWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::WindSupport::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeWindSettingWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::WindSetting::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeWindSettingWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = FanControl::Attributes::WindSetting::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeWindSettingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::WindSetting::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeWindSettingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::WindSetting::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPFanControlGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FanControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<FanControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFanControlGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<FanControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFanControlGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFanControlGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FanControl::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FanControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPFanControlAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FanControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<FanControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFanControlAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<FanControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFanControlAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFanControlAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FanControl::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FanControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFanControlAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FanControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<FanControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFanControlAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<FanControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFanControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFanControlAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FanControl::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FanControlAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FanControl::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FanControl::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FanControl::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPFixedLabel

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeLabelListWithCompletionHandler:(void (^)(
                                                        NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFixedLabelLabelListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FixedLabel::Attributes::LabelList::TypeInfo;
            auto successFn = Callback<FixedLabelLabelListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLabelListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFixedLabelLabelListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FixedLabel::Attributes::LabelList::TypeInfo;
            auto successFn = Callback<FixedLabelLabelListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFixedLabelLabelListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLabelListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFixedLabelLabelListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FixedLabel::Attributes::LabelList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<FixedLabelLabelListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPFixedLabelGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FixedLabel::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<FixedLabelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFixedLabelGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FixedLabel::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<FixedLabelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFixedLabelGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFixedLabelGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FixedLabel::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FixedLabelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPFixedLabelAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FixedLabel::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<FixedLabelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFixedLabelAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FixedLabel::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<FixedLabelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFixedLabelAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFixedLabelAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FixedLabel::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FixedLabelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFixedLabelAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FixedLabel::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<FixedLabelAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFixedLabelAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FixedLabel::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<FixedLabelAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFixedLabelAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFixedLabelAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FixedLabel::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FixedLabelAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FixedLabel::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FixedLabel::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FixedLabel::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPFlowMeasurement

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeMeasuredValueWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FlowMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FlowMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FlowMeasurement::Attributes::MeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeToleranceWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FlowMeasurement::Attributes::Tolerance::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeToleranceWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FlowMeasurement::Attributes::Tolerance::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeToleranceWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FlowMeasurement::Attributes::Tolerance::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPFlowMeasurementGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FlowMeasurement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<FlowMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFlowMeasurementGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FlowMeasurement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<FlowMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFlowMeasurementGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFlowMeasurementGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FlowMeasurement::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FlowMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPFlowMeasurementAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FlowMeasurement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<FlowMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFlowMeasurementAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FlowMeasurement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<FlowMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFlowMeasurementAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFlowMeasurementAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FlowMeasurement::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FlowMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFlowMeasurementAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = FlowMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<FlowMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFlowMeasurementAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FlowMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<FlowMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFlowMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFlowMeasurementAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = FlowMeasurement::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<FlowMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = FlowMeasurement::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = FlowMeasurement::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = FlowMeasurement::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPGeneralCommissioning

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)armFailSafeWithParams:(CHIPGeneralCommissioningClusterArmFailSafeParams *)params
            completionHandler:(void (^)(CHIPGeneralCommissioningClusterArmFailSafeResponseParams * _Nullable data,
                                  NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    GeneralCommissioning::Commands::ArmFailSafe::Type request;
    request.expiryLengthSeconds = params.expiryLengthSeconds.unsignedShortValue;
    request.breadcrumb = params.breadcrumb.unsignedLongLongValue;

    new CHIPGeneralCommissioningClusterArmFailSafeResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPGeneralCommissioningClusterArmFailSafeResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)commissioningCompleteWithCompletionHandler:
    (void (^)(CHIPGeneralCommissioningClusterCommissioningCompleteResponseParams * _Nullable data,
        NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    GeneralCommissioning::Commands::CommissioningComplete::Type request;

    new CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn
                = Callback<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)setRegulatoryConfigWithParams:(CHIPGeneralCommissioningClusterSetRegulatoryConfigParams *)params
                    completionHandler:(void (^)(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseParams * _Nullable data,
                                          NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    GeneralCommissioning::Commands::SetRegulatoryConfig::Type request;
    request.newRegulatoryConfig
        = static_cast<std::remove_reference_t<decltype(request.newRegulatoryConfig)>>(params.newRegulatoryConfig.unsignedCharValue);
    request.countryCode = [self asCharSpan:params.countryCode];
    request.breadcrumb = params.breadcrumb.unsignedLongLongValue;

    new CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn
                = Callback<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeBreadcrumbWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GeneralCommissioning::Attributes::Breadcrumb::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeBreadcrumbWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = GeneralCommissioning::Attributes::Breadcrumb::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedLongLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeBreadcrumbWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::Breadcrumb::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBreadcrumbWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GeneralCommissioning::Attributes::Breadcrumb::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBasicCommissioningInfoWithCompletionHandler:
    (void (^)(CHIPGeneralCommissioningClusterBasicCommissioningInfo * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningBasicCommissioningInfoStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralCommissioning::Attributes::BasicCommissioningInfo::TypeInfo;
            auto successFn = Callback<GeneralCommissioningBasicCommissioningInfoStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)
    subscribeAttributeBasicCommissioningInfoWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(CHIPGeneralCommissioningClusterBasicCommissioningInfo * _Nullable value,
                                                      NSError * _Nullable error))reportHandler
{
    new CHIPGeneralCommissioningBasicCommissioningInfoStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::BasicCommissioningInfo::TypeInfo;
            auto successFn = Callback<GeneralCommissioningBasicCommissioningInfoStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralCommissioningBasicCommissioningInfoStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBasicCommissioningInfoWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(CHIPGeneralCommissioningClusterBasicCommissioningInfo * _Nullable value,
                                                    NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningBasicCommissioningInfoStructAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralCommissioning::Attributes::BasicCommissioningInfo::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<GeneralCommissioningBasicCommissioningInfoStructAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeRegulatoryConfigWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralCommissioning::Attributes::RegulatoryConfig::TypeInfo;
            auto successFn = Callback<GeneralCommissioningClusterRegulatoryLocationTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeRegulatoryConfigWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::RegulatoryConfig::TypeInfo;
            auto successFn = Callback<GeneralCommissioningClusterRegulatoryLocationTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRegulatoryConfigWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralCommissioning::Attributes::RegulatoryConfig::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<GeneralCommissioningClusterRegulatoryLocationTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeLocationCapabilityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralCommissioning::Attributes::LocationCapability::TypeInfo;
            auto successFn = Callback<GeneralCommissioningClusterRegulatoryLocationTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLocationCapabilityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::LocationCapability::TypeInfo;
            auto successFn = Callback<GeneralCommissioningClusterRegulatoryLocationTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLocationCapabilityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningClusterRegulatoryLocationTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralCommissioning::Attributes::LocationCapability::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<GeneralCommissioningClusterRegulatoryLocationTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeSupportsConcurrentConnectionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GeneralCommissioning::Attributes::SupportsConcurrentConnection::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSupportsConcurrentConnectionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                                               params:(CHIPSubscribeParams * _Nullable)params
                                              subscriptionEstablished:
                                                  (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                        reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                          NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::SupportsConcurrentConnection::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSupportsConcurrentConnectionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                           endpoint:(NSNumber *)endpoint
                                                              queue:(dispatch_queue_t)queue
                                                  completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GeneralCommissioning::Attributes::SupportsConcurrentConnection::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralCommissioning::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<GeneralCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralCommissioningGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<GeneralCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralCommissioningGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralCommissioning::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralCommissioning::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<GeneralCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralCommissioningAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<GeneralCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralCommissioningAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralCommissioning::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralCommissioning::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<GeneralCommissioningAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralCommissioningAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<GeneralCommissioningAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralCommissioningAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralCommissioningAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralCommissioning::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralCommissioningAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GeneralCommissioning::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralCommissioning::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GeneralCommissioning::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPGeneralDiagnostics

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeNetworkInterfacesWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsNetworkInterfacesListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralDiagnostics::Attributes::NetworkInterfaces::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNetworkInterfacesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralDiagnosticsNetworkInterfacesListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::NetworkInterfaces::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralDiagnosticsNetworkInterfacesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNetworkInterfacesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsNetworkInterfacesListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralDiagnostics::Attributes::NetworkInterfaces::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeRebootCountWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GeneralDiagnostics::Attributes::RebootCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRebootCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::RebootCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRebootCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GeneralDiagnostics::Attributes::RebootCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeUpTimeWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GeneralDiagnostics::Attributes::UpTime::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeUpTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::UpTime::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeUpTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GeneralDiagnostics::Attributes::UpTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTotalOperationalHoursWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GeneralDiagnostics::Attributes::TotalOperationalHours::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTotalOperationalHoursWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::TotalOperationalHours::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTotalOperationalHoursWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GeneralDiagnostics::Attributes::TotalOperationalHours::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBootReasonsWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GeneralDiagnostics::Attributes::BootReasons::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBootReasonsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::BootReasons::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBootReasonsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GeneralDiagnostics::Attributes::BootReasons::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeActiveHardwareFaultsWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsActiveHardwareFaultsListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralDiagnostics::Attributes::ActiveHardwareFaults::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeActiveHardwareFaultsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralDiagnosticsActiveHardwareFaultsListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::ActiveHardwareFaults::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralDiagnosticsActiveHardwareFaultsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActiveHardwareFaultsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsActiveHardwareFaultsListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralDiagnostics::Attributes::ActiveHardwareFaults::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeActiveRadioFaultsWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsActiveRadioFaultsListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralDiagnostics::Attributes::ActiveRadioFaults::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeActiveRadioFaultsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralDiagnosticsActiveRadioFaultsListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::ActiveRadioFaults::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralDiagnosticsActiveRadioFaultsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActiveRadioFaultsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsActiveRadioFaultsListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralDiagnostics::Attributes::ActiveRadioFaults::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeActiveNetworkFaultsWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsActiveNetworkFaultsListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralDiagnostics::Attributes::ActiveNetworkFaults::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeActiveNetworkFaultsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralDiagnosticsActiveNetworkFaultsListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::ActiveNetworkFaults::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralDiagnosticsActiveNetworkFaultsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActiveNetworkFaultsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsActiveNetworkFaultsListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralDiagnostics::Attributes::ActiveNetworkFaults::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GeneralDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGeneralDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<GeneralDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGeneralDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGeneralDiagnosticsAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GeneralDiagnostics::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GeneralDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GeneralDiagnostics::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GeneralDiagnostics::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GeneralDiagnostics::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPGroupKeyManagement

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)keySetReadWithParams:(CHIPGroupKeyManagementClusterKeySetReadParams *)params
           completionHandler:(void (^)(CHIPGroupKeyManagementClusterKeySetReadResponseParams * _Nullable data,
                                 NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    GroupKeyManagement::Commands::KeySetRead::Type request;
    request.groupKeySetID = params.groupKeySetID.unsignedShortValue;

    new CHIPGroupKeyManagementClusterKeySetReadResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPGroupKeyManagementClusterKeySetReadResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)keySetReadAllIndicesWithParams:(CHIPGroupKeyManagementClusterKeySetReadAllIndicesParams *)params
                     completionHandler:(void (^)(CHIPGroupKeyManagementClusterKeySetReadAllIndicesResponseParams * _Nullable data,
                                           NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    GroupKeyManagement::Commands::KeySetReadAllIndices::Type request;
    {
        using ListType_0 = std::remove_reference_t<decltype(request.groupKeySetIDs)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.groupKeySetIDs.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.groupKeySetIDs.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.groupKeySetIDs.count; ++i_0) {
                if (![params.groupKeySetIDs[i_0] isKindOfClass:[NSNumber class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (NSNumber *) params.groupKeySetIDs[i_0];
                listHolder_0->mList[i_0] = element_0.unsignedShortValue;
            }
            request.groupKeySetIDs = ListType_0(listHolder_0->mList, params.groupKeySetIDs.count);
        } else {
            request.groupKeySetIDs = ListType_0();
        }
    }

    new CHIPGroupKeyManagementClusterKeySetReadAllIndicesResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn
                = Callback<CHIPGroupKeyManagementClusterKeySetReadAllIndicesResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)keySetRemoveWithParams:(CHIPGroupKeyManagementClusterKeySetRemoveParams *)params
             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    GroupKeyManagement::Commands::KeySetRemove::Type request;
    request.groupKeySetID = params.groupKeySetID.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)keySetWriteWithParams:(CHIPGroupKeyManagementClusterKeySetWriteParams *)params
            completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    GroupKeyManagement::Commands::KeySetWrite::Type request;
    request.groupKeySet.groupKeySetID = params.groupKeySet.groupKeySetID.unsignedShortValue;
    request.groupKeySet.groupKeySecurityPolicy
        = static_cast<std::remove_reference_t<decltype(request.groupKeySet.groupKeySecurityPolicy)>>(
            params.groupKeySet.groupKeySecurityPolicy.unsignedCharValue);
    if (params.groupKeySet.epochKey0 == nil) {
        request.groupKeySet.epochKey0.SetNull();
    } else {
        auto & nonNullValue_1 = request.groupKeySet.epochKey0.SetNonNull();
        nonNullValue_1 = [self asByteSpan:params.groupKeySet.epochKey0];
    }
    if (params.groupKeySet.epochStartTime0 == nil) {
        request.groupKeySet.epochStartTime0.SetNull();
    } else {
        auto & nonNullValue_1 = request.groupKeySet.epochStartTime0.SetNonNull();
        nonNullValue_1 = params.groupKeySet.epochStartTime0.unsignedLongLongValue;
    }
    if (params.groupKeySet.epochKey1 == nil) {
        request.groupKeySet.epochKey1.SetNull();
    } else {
        auto & nonNullValue_1 = request.groupKeySet.epochKey1.SetNonNull();
        nonNullValue_1 = [self asByteSpan:params.groupKeySet.epochKey1];
    }
    if (params.groupKeySet.epochStartTime1 == nil) {
        request.groupKeySet.epochStartTime1.SetNull();
    } else {
        auto & nonNullValue_1 = request.groupKeySet.epochStartTime1.SetNonNull();
        nonNullValue_1 = params.groupKeySet.epochStartTime1.unsignedLongLongValue;
    }
    if (params.groupKeySet.epochKey2 == nil) {
        request.groupKeySet.epochKey2.SetNull();
    } else {
        auto & nonNullValue_1 = request.groupKeySet.epochKey2.SetNonNull();
        nonNullValue_1 = [self asByteSpan:params.groupKeySet.epochKey2];
    }
    if (params.groupKeySet.epochStartTime2 == nil) {
        request.groupKeySet.epochStartTime2.SetNull();
    } else {
        auto & nonNullValue_1 = request.groupKeySet.epochStartTime2.SetNonNull();
        nonNullValue_1 = params.groupKeySet.epochStartTime2.unsignedLongLongValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeGroupKeyMapWithParams:(CHIPReadParams * _Nullable)params
                         completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementGroupKeyMapListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GroupKeyManagement::Attributes::GroupKeyMap::TypeInfo;
            auto successFn = Callback<GroupKeyManagementGroupKeyMapListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)writeAttributeGroupKeyMapWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = GroupKeyManagement::Attributes::GroupKeyMap::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPGroupKeyManagementClusterGroupKeyMapStruct class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPGroupKeyManagementClusterGroupKeyMapStruct *) value[i_0];
                        listHolder_0->mList[i_0].groupId = element_0.groupId.unsignedShortValue;
                        listHolder_0->mList[i_0].groupKeySetID = element_0.groupKeySetID.unsignedShortValue;
                        listHolder_0->mList[i_0].fabricIndex = element_0.fabricIndex.unsignedCharValue;
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGroupKeyMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGroupKeyManagementGroupKeyMapListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GroupKeyManagement::Attributes::GroupKeyMap::TypeInfo;
            auto successFn = Callback<GroupKeyManagementGroupKeyMapListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGroupKeyManagementGroupKeyMapListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGroupKeyMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementGroupKeyMapListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GroupKeyManagement::Attributes::GroupKeyMap::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GroupKeyManagementGroupKeyMapListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGroupTableWithParams:(CHIPReadParams * _Nullable)params
                        completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementGroupTableListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GroupKeyManagement::Attributes::GroupTable::TypeInfo;
            auto successFn = Callback<GroupKeyManagementGroupTableListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)subscribeAttributeGroupTableWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGroupKeyManagementGroupTableListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GroupKeyManagement::Attributes::GroupTable::TypeInfo;
            auto successFn = Callback<GroupKeyManagementGroupTableListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGroupKeyManagementGroupTableListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGroupTableWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementGroupTableListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GroupKeyManagement::Attributes::GroupTable::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GroupKeyManagementGroupTableListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeMaxGroupsPerFabricWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GroupKeyManagement::Attributes::MaxGroupsPerFabric::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMaxGroupsPerFabricWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GroupKeyManagement::Attributes::MaxGroupsPerFabric::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxGroupsPerFabricWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GroupKeyManagement::Attributes::MaxGroupsPerFabric::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxGroupKeysPerFabricWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GroupKeyManagement::Attributes::MaxGroupKeysPerFabric::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMaxGroupKeysPerFabricWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GroupKeyManagement::Attributes::MaxGroupKeysPerFabric::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxGroupKeysPerFabricWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GroupKeyManagement::Attributes::MaxGroupKeysPerFabric::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GroupKeyManagement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<GroupKeyManagementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGroupKeyManagementGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GroupKeyManagement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<GroupKeyManagementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGroupKeyManagementGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GroupKeyManagement::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GroupKeyManagementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GroupKeyManagement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<GroupKeyManagementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGroupKeyManagementAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GroupKeyManagement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<GroupKeyManagementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGroupKeyManagementAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GroupKeyManagement::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GroupKeyManagementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = GroupKeyManagement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<GroupKeyManagementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGroupKeyManagementAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GroupKeyManagement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<GroupKeyManagementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGroupKeyManagementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupKeyManagementAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = GroupKeyManagement::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GroupKeyManagementAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = GroupKeyManagement::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = GroupKeyManagement::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = GroupKeyManagement::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPGroups

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)addGroupWithParams:(CHIPGroupsClusterAddGroupParams *)params
         completionHandler:
             (void (^)(CHIPGroupsClusterAddGroupResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Groups::Commands::AddGroup::Type request;
    request.groupId = params.groupId.unsignedShortValue;
    request.groupName = [self asCharSpan:params.groupName];

    new CHIPGroupsClusterAddGroupResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPGroupsClusterAddGroupResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)addGroupIfIdentifyingWithParams:(CHIPGroupsClusterAddGroupIfIdentifyingParams *)params
                      completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Groups::Commands::AddGroupIfIdentifying::Type request;
    request.groupId = params.groupId.unsignedShortValue;
    request.groupName = [self asCharSpan:params.groupName];

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getGroupMembershipWithParams:(CHIPGroupsClusterGetGroupMembershipParams *)params
                   completionHandler:(void (^)(CHIPGroupsClusterGetGroupMembershipResponseParams * _Nullable data,
                                         NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Groups::Commands::GetGroupMembership::Type request;
    {
        using ListType_0 = std::remove_reference_t<decltype(request.groupList)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.groupList.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.groupList.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.groupList.count; ++i_0) {
                if (![params.groupList[i_0] isKindOfClass:[NSNumber class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (NSNumber *) params.groupList[i_0];
                listHolder_0->mList[i_0] = element_0.unsignedShortValue;
            }
            request.groupList = ListType_0(listHolder_0->mList, params.groupList.count);
        } else {
            request.groupList = ListType_0();
        }
    }

    new CHIPGroupsClusterGetGroupMembershipResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPGroupsClusterGetGroupMembershipResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)removeAllGroupsWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Groups::Commands::RemoveAllGroups::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)removeGroupWithParams:(CHIPGroupsClusterRemoveGroupParams *)params
            completionHandler:
                (void (^)(CHIPGroupsClusterRemoveGroupResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Groups::Commands::RemoveGroup::Type request;
    request.groupId = params.groupId.unsignedShortValue;

    new CHIPGroupsClusterRemoveGroupResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPGroupsClusterRemoveGroupResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)viewGroupWithParams:(CHIPGroupsClusterViewGroupParams *)params
          completionHandler:
              (void (^)(CHIPGroupsClusterViewGroupResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Groups::Commands::ViewGroup::Type request;
    request.groupId = params.groupId.unsignedShortValue;

    new CHIPGroupsClusterViewGroupResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPGroupsClusterViewGroupResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeNameSupportWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Groups::Attributes::NameSupport::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNameSupportWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Groups::Attributes::NameSupport::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNameSupportWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Groups::Attributes::NameSupport::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPGroupsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Groups::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<GroupsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGroupsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Groups::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<GroupsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGroupsGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Groups::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GroupsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPGroupsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Groups::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<GroupsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGroupsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Groups::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<GroupsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGroupsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Groups::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<GroupsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Groups::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<GroupsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPGroupsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Groups::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<GroupsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPGroupsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPGroupsAttributeListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Groups::Attributes::AttributeList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<GroupsAttributeListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Groups::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Groups::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Groups::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPIdentify

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)identifyWithParams:(CHIPIdentifyClusterIdentifyParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Identify::Commands::Identify::Type request;
    request.identifyTime = params.identifyTime.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)identifyQueryWithCompletionHandler:(void (^)(CHIPIdentifyClusterIdentifyQueryResponseParams * _Nullable data,
                                               NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Identify::Commands::IdentifyQuery::Type request;

    new CHIPIdentifyClusterIdentifyQueryResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPIdentifyClusterIdentifyQueryResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)triggerEffectWithParams:(CHIPIdentifyClusterTriggerEffectParams *)params
              completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Identify::Commands::TriggerEffect::Type request;
    request.effectIdentifier
        = static_cast<std::remove_reference_t<decltype(request.effectIdentifier)>>(params.effectIdentifier.unsignedCharValue);
    request.effectVariant
        = static_cast<std::remove_reference_t<decltype(request.effectVariant)>>(params.effectVariant.unsignedCharValue);

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeIdentifyTimeWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Identify::Attributes::IdentifyTime::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeIdentifyTimeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Identify::Attributes::IdentifyTime::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeIdentifyTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Identify::Attributes::IdentifyTime::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeIdentifyTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Identify::Attributes::IdentifyTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeIdentifyTypeWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Identify::Attributes::IdentifyType::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeIdentifyTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Identify::Attributes::IdentifyType::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeIdentifyTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Identify::Attributes::IdentifyType::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPIdentifyGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Identify::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<IdentifyGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPIdentifyGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Identify::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<IdentifyGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPIdentifyGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPIdentifyGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Identify::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<IdentifyGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPIdentifyAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Identify::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<IdentifyAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPIdentifyAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Identify::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<IdentifyAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPIdentifyAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPIdentifyAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Identify::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<IdentifyAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPIdentifyAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Identify::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<IdentifyAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPIdentifyAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Identify::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<IdentifyAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPIdentifyAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPIdentifyAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Identify::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<IdentifyAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Identify::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Identify::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Identify::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPIlluminanceMeasurement

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeMeasuredValueWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = IlluminanceMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = IlluminanceMeasurement::Attributes::MeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = IlluminanceMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = IlluminanceMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = IlluminanceMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = IlluminanceMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeToleranceWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = IlluminanceMeasurement::Attributes::Tolerance::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeToleranceWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::Tolerance::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeToleranceWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = IlluminanceMeasurement::Attributes::Tolerance::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLightSensorTypeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = IlluminanceMeasurement::Attributes::LightSensorType::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLightSensorTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::LightSensorType::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLightSensorTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = IlluminanceMeasurement::Attributes::LightSensorType::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPIlluminanceMeasurementGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = IlluminanceMeasurement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<IlluminanceMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPIlluminanceMeasurementGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<IlluminanceMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPIlluminanceMeasurementGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPIlluminanceMeasurementGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = IlluminanceMeasurement::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<IlluminanceMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPIlluminanceMeasurementAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = IlluminanceMeasurement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<IlluminanceMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPIlluminanceMeasurementAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<IlluminanceMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPIlluminanceMeasurementAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPIlluminanceMeasurementAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = IlluminanceMeasurement::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<IlluminanceMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPIlluminanceMeasurementAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = IlluminanceMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<IlluminanceMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPIlluminanceMeasurementAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<IlluminanceMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPIlluminanceMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPIlluminanceMeasurementAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = IlluminanceMeasurement::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<IlluminanceMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPKeypadInput

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)sendKeyWithParams:(CHIPKeypadInputClusterSendKeyParams *)params
        completionHandler:
            (void (^)(CHIPKeypadInputClusterSendKeyResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    KeypadInput::Commands::SendKey::Type request;
    request.keyCode = static_cast<std::remove_reference_t<decltype(request.keyCode)>>(params.keyCode.unsignedCharValue);

    new CHIPKeypadInputClusterSendKeyResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPKeypadInputClusterSendKeyResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPKeypadInputGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = KeypadInput::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<KeypadInputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPKeypadInputGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = KeypadInput::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<KeypadInputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPKeypadInputGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPKeypadInputGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = KeypadInput::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<KeypadInputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPKeypadInputAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = KeypadInput::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<KeypadInputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPKeypadInputAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = KeypadInput::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<KeypadInputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPKeypadInputAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPKeypadInputAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = KeypadInput::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<KeypadInputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPKeypadInputAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = KeypadInput::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<KeypadInputAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPKeypadInputAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = KeypadInput::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<KeypadInputAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPKeypadInputAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPKeypadInputAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = KeypadInput::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<KeypadInputAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = KeypadInput::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = KeypadInput::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = KeypadInput::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPLevelControl

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)moveWithParams:(CHIPLevelControlClusterMoveParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LevelControl::Commands::Move::Type request;
    request.moveMode = static_cast<std::remove_reference_t<decltype(request.moveMode)>>(params.moveMode.unsignedCharValue);
    request.rate = params.rate.unsignedCharValue;
    request.optionMask = params.optionMask.unsignedCharValue;
    request.optionOverride = params.optionOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveToLevelWithParams:(CHIPLevelControlClusterMoveToLevelParams *)params
            completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LevelControl::Commands::MoveToLevel::Type request;
    request.level = params.level.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionMask = params.optionMask.unsignedCharValue;
    request.optionOverride = params.optionOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveToLevelWithOnOffWithParams:(CHIPLevelControlClusterMoveToLevelWithOnOffParams *)params
                     completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LevelControl::Commands::MoveToLevelWithOnOff::Type request;
    request.level = params.level.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)moveWithOnOffWithParams:(CHIPLevelControlClusterMoveWithOnOffParams *)params
              completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LevelControl::Commands::MoveWithOnOff::Type request;
    request.moveMode = static_cast<std::remove_reference_t<decltype(request.moveMode)>>(params.moveMode.unsignedCharValue);
    request.rate = params.rate.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stepWithParams:(CHIPLevelControlClusterStepParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LevelControl::Commands::Step::Type request;
    request.stepMode = static_cast<std::remove_reference_t<decltype(request.stepMode)>>(params.stepMode.unsignedCharValue);
    request.stepSize = params.stepSize.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.optionMask = params.optionMask.unsignedCharValue;
    request.optionOverride = params.optionOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stepWithOnOffWithParams:(CHIPLevelControlClusterStepWithOnOffParams *)params
              completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LevelControl::Commands::StepWithOnOff::Type request;
    request.stepMode = static_cast<std::remove_reference_t<decltype(request.stepMode)>>(params.stepMode.unsignedCharValue);
    request.stepSize = params.stepSize.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stopWithParams:(CHIPLevelControlClusterStopParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LevelControl::Commands::Stop::Type request;
    request.optionMask = params.optionMask.unsignedCharValue;
    request.optionOverride = params.optionOverride.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stopWithOnOffWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LevelControl::Commands::StopWithOnOff::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeCurrentLevelWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::CurrentLevel::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentLevelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::CurrentLevel::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentLevelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::CurrentLevel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRemainingTimeWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::RemainingTime::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRemainingTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::RemainingTime::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRemainingTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::RemainingTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinLevelWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::MinLevel::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMinLevelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::MinLevel::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinLevelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::MinLevel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxLevelWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::MaxLevel::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMaxLevelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::MaxLevel::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxLevelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::MaxLevel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentFrequencyWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::CurrentFrequency::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentFrequencyWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::CurrentFrequency::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentFrequencyWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::CurrentFrequency::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinFrequencyWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::MinFrequency::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMinFrequencyWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::MinFrequency::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinFrequencyWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::MinFrequency::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxFrequencyWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::MaxFrequency::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMaxFrequencyWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::MaxFrequency::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxFrequencyWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::MaxFrequency::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOptionsWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::Options::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeOptionsWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = LevelControl::Attributes::Options::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOptionsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::Options::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOptionsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::Options::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOnOffTransitionTimeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::OnOffTransitionTime::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeOnOffTransitionTimeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = LevelControl::Attributes::OnOffTransitionTime::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOnOffTransitionTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::OnOffTransitionTime::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOnOffTransitionTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::OnOffTransitionTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOnLevelWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LevelControl::Attributes::OnLevel::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeOnLevelWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = LevelControl::Attributes::OnLevel::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedCharValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOnLevelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::OnLevel::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOnLevelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::OnLevel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOnTransitionTimeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LevelControl::Attributes::OnTransitionTime::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeOnTransitionTimeWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = LevelControl::Attributes::OnTransitionTime::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedShortValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOnTransitionTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::OnTransitionTime::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOnTransitionTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::OnTransitionTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOffTransitionTimeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LevelControl::Attributes::OffTransitionTime::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeOffTransitionTimeWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = LevelControl::Attributes::OffTransitionTime::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedShortValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOffTransitionTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::OffTransitionTime::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOffTransitionTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::OffTransitionTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeDefaultMoveRateWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LevelControl::Attributes::DefaultMoveRate::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeDefaultMoveRateWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = LevelControl::Attributes::DefaultMoveRate::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedCharValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeDefaultMoveRateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::DefaultMoveRate::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDefaultMoveRateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::DefaultMoveRate::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeStartUpCurrentLevelWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LevelControl::Attributes::StartUpCurrentLevel::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeStartUpCurrentLevelWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = LevelControl::Attributes::StartUpCurrentLevel::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedCharValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeStartUpCurrentLevelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::StartUpCurrentLevel::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStartUpCurrentLevelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::StartUpCurrentLevel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPLevelControlGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LevelControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<LevelControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLevelControlGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<LevelControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLevelControlGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLevelControlGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LevelControl::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<LevelControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPLevelControlAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LevelControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<LevelControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLevelControlAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<LevelControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLevelControlAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLevelControlAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LevelControl::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<LevelControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLevelControlAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LevelControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<LevelControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLevelControlAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<LevelControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLevelControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLevelControlAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LevelControl::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<LevelControlAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LevelControl::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LevelControl::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LevelControl::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPLocalizationConfiguration

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeActiveLocaleWithCompletionHandler:(void (^)(
                                                           NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LocalizationConfiguration::Attributes::ActiveLocale::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeActiveLocaleWithValue:(NSString * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = LocalizationConfiguration::Attributes::ActiveLocale::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asCharSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeActiveLocaleWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LocalizationConfiguration::Attributes::ActiveLocale::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActiveLocaleWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LocalizationConfiguration::Attributes::ActiveLocale::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSupportedLocalesWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPLocalizationConfigurationSupportedLocalesListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LocalizationConfiguration::Attributes::SupportedLocales::TypeInfo;
            auto successFn = Callback<LocalizationConfigurationSupportedLocalesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSupportedLocalesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLocalizationConfigurationSupportedLocalesListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LocalizationConfiguration::Attributes::SupportedLocales::TypeInfo;
            auto successFn = Callback<LocalizationConfigurationSupportedLocalesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLocalizationConfigurationSupportedLocalesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSupportedLocalesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLocalizationConfigurationSupportedLocalesListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LocalizationConfiguration::Attributes::SupportedLocales::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<LocalizationConfigurationSupportedLocalesListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPLocalizationConfigurationGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LocalizationConfiguration::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<LocalizationConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLocalizationConfigurationGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LocalizationConfiguration::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<LocalizationConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLocalizationConfigurationGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLocalizationConfigurationGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LocalizationConfiguration::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<LocalizationConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPLocalizationConfigurationAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LocalizationConfiguration::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<LocalizationConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLocalizationConfigurationAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LocalizationConfiguration::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<LocalizationConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLocalizationConfigurationAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLocalizationConfigurationAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LocalizationConfiguration::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<LocalizationConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LocalizationConfiguration::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LocalizationConfiguration::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LocalizationConfiguration::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPLowPower

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)sleepWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    LowPower::Commands::Sleep::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPLowPowerGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LowPower::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<LowPowerGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLowPowerGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LowPower::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<LowPowerGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLowPowerGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLowPowerGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LowPower::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<LowPowerGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPLowPowerAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LowPower::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<LowPowerAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLowPowerAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LowPower::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<LowPowerAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLowPowerAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLowPowerAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LowPower::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<LowPowerAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLowPowerAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = LowPower::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<LowPowerAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPLowPowerAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LowPower::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<LowPowerAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPLowPowerAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPLowPowerAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = LowPower::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<LowPowerAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = LowPower::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = LowPower::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = LowPower::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPMediaInput

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)hideInputStatusWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    MediaInput::Commands::HideInputStatus::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)renameInputWithParams:(CHIPMediaInputClusterRenameInputParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    MediaInput::Commands::RenameInput::Type request;
    request.index = params.index.unsignedCharValue;
    request.name = [self asCharSpan:params.name];

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)selectInputWithParams:(CHIPMediaInputClusterSelectInputParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    MediaInput::Commands::SelectInput::Type request;
    request.index = params.index.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)showInputStatusWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    MediaInput::Commands::ShowInputStatus::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeInputListWithCompletionHandler:(void (^)(
                                                        NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaInputInputListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaInput::Attributes::InputList::TypeInfo;
            auto successFn = Callback<MediaInputInputListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInputListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPMediaInputInputListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaInput::Attributes::InputList::TypeInfo;
            auto successFn = Callback<MediaInputInputListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaInputInputListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInputListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaInputInputListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaInput::Attributes::InputList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<MediaInputInputListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentInputWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = MediaInput::Attributes::CurrentInput::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentInputWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaInput::Attributes::CurrentInput::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentInputWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaInput::Attributes::CurrentInput::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPMediaInputGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaInput::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<MediaInputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPMediaInputGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaInput::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<MediaInputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaInputGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaInputGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = MediaInput::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<MediaInputGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPMediaInputAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaInput::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<MediaInputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPMediaInputAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaInput::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<MediaInputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaInputAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaInputAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = MediaInput::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<MediaInputAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaInputAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaInput::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<MediaInputAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPMediaInputAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaInput::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<MediaInputAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaInputAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaInputAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = MediaInput::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<MediaInputAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = MediaInput::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaInput::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaInput::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPMediaPlayback

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)fastForwardWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                             NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::FastForward::Type request;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)nextWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                      NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::Next::Type request;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)pauseWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                       NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::Pause::Type request;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)playWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                      NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::Play::Type request;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)previousWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                          NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::Previous::Type request;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)rewindWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                        NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::Rewind::Type request;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)seekWithParams:(CHIPMediaPlaybackClusterSeekParams *)params
     completionHandler:
         (void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::Seek::Type request;
    request.position = params.position.unsignedLongLongValue;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)skipBackwardWithParams:(CHIPMediaPlaybackClusterSkipBackwardParams *)params
             completionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                   NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::SkipBackward::Type request;
    request.deltaPositionMilliseconds = params.deltaPositionMilliseconds.unsignedLongLongValue;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)skipForwardWithParams:(CHIPMediaPlaybackClusterSkipForwardParams *)params
            completionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                  NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::SkipForward::Type request;
    request.deltaPositionMilliseconds = params.deltaPositionMilliseconds.unsignedLongLongValue;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)startOverWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                           NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::StartOver::Type request;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stopPlaybackWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable data,
                                              NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    MediaPlayback::Commands::StopPlayback::Type request;

    new CHIPMediaPlaybackClusterPlaybackResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPMediaPlaybackClusterPlaybackResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeCurrentStateWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackClusterPlaybackStateEnumAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::CurrentState::TypeInfo;
            auto successFn = Callback<MediaPlaybackClusterPlaybackStateEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentStateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPMediaPlaybackClusterPlaybackStateEnumAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::CurrentState::TypeInfo;
            auto successFn = Callback<MediaPlaybackClusterPlaybackStateEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaPlaybackClusterPlaybackStateEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentStateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackClusterPlaybackStateEnumAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = MediaPlayback::Attributes::CurrentState::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<MediaPlaybackClusterPlaybackStateEnumAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeStartTimeWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::StartTime::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeStartTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::StartTime::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStartTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaPlayback::Attributes::StartTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeDurationWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::Duration::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeDurationWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::Duration::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDurationWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaPlayback::Attributes::Duration::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSampledPositionWithCompletionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackPosition * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackSampledPositionStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::SampledPosition::TypeInfo;
            auto successFn = Callback<MediaPlaybackSampledPositionStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSampledPositionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackPosition * _Nullable value,
                                                             NSError * _Nullable error))reportHandler
{
    new CHIPMediaPlaybackSampledPositionStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::SampledPosition::TypeInfo;
            auto successFn = Callback<MediaPlaybackSampledPositionStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaPlaybackSampledPositionStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSampledPositionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:(void (^)(CHIPMediaPlaybackClusterPlaybackPosition * _Nullable value,
                                                           NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackSampledPositionStructAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = MediaPlayback::Attributes::SampledPosition::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<MediaPlaybackSampledPositionStructAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributePlaybackSpeedWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFloatAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = MediaPlayback::Attributes::PlaybackSpeed::TypeInfo;
        auto successFn = Callback<FloatAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePlaybackSpeedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFloatAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::PlaybackSpeed::TypeInfo;
            auto successFn = Callback<FloatAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFloatAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePlaybackSpeedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFloatAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaPlayback::Attributes::PlaybackSpeed::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<FloatAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSeekRangeEndWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::SeekRangeEnd::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSeekRangeEndWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::SeekRangeEnd::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSeekRangeEndWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaPlayback::Attributes::SeekRangeEnd::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSeekRangeStartWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::SeekRangeStart::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSeekRangeStartWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::SeekRangeStart::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSeekRangeStartWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaPlayback::Attributes::SeekRangeStart::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<MediaPlaybackGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPMediaPlaybackGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<MediaPlaybackGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaPlaybackGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = MediaPlayback::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<MediaPlaybackGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<MediaPlaybackAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPMediaPlaybackAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<MediaPlaybackAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaPlaybackAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = MediaPlayback::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<MediaPlaybackAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = MediaPlayback::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<MediaPlaybackAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPMediaPlaybackAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<MediaPlaybackAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPMediaPlaybackAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPMediaPlaybackAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = MediaPlayback::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<MediaPlaybackAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = MediaPlayback::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = MediaPlayback::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = MediaPlayback::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPModeSelect

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)changeToModeWithParams:(CHIPModeSelectClusterChangeToModeParams *)params
             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ModeSelect::Commands::ChangeToMode::Type request;
    request.newMode = params.newMode.unsignedCharValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeDescriptionWithCompletionHandler:(void (^)(
                                                          NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ModeSelect::Attributes::Description::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeDescriptionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::Description::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDescriptionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ModeSelect::Attributes::Description::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeStandardNamespaceWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ModeSelect::Attributes::StandardNamespace::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeStandardNamespaceWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::StandardNamespace::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStandardNamespaceWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ModeSelect::Attributes::StandardNamespace::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSupportedModesWithCompletionHandler:(void (^)(
                                                             NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPModeSelectSupportedModesListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ModeSelect::Attributes::SupportedModes::TypeInfo;
            auto successFn = Callback<ModeSelectSupportedModesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSupportedModesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPModeSelectSupportedModesListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::SupportedModes::TypeInfo;
            auto successFn = Callback<ModeSelectSupportedModesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPModeSelectSupportedModesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSupportedModesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPModeSelectSupportedModesListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ModeSelect::Attributes::SupportedModes::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ModeSelectSupportedModesListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentModeWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ModeSelect::Attributes::CurrentMode::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::CurrentMode::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ModeSelect::Attributes::CurrentMode::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeStartUpModeWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ModeSelect::Attributes::StartUpMode::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeStartUpModeWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ModeSelect::Attributes::StartUpMode::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedCharValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeStartUpModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::StartUpMode::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStartUpModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ModeSelect::Attributes::StartUpMode::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOnModeWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ModeSelect::Attributes::OnMode::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeOnModeWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ModeSelect::Attributes::OnMode::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedCharValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOnModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::OnMode::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOnModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ModeSelect::Attributes::OnMode::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPModeSelectGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ModeSelect::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ModeSelectGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPModeSelectGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ModeSelectGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPModeSelectGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPModeSelectGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ModeSelect::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ModeSelectGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPModeSelectAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ModeSelect::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ModeSelectAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPModeSelectAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ModeSelectAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPModeSelectAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPModeSelectAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ModeSelect::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ModeSelectAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPModeSelectAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ModeSelect::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ModeSelectAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPModeSelectAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ModeSelectAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPModeSelectAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPModeSelectAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ModeSelect::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ModeSelectAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ModeSelect::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ModeSelect::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ModeSelect::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ModeSelect::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ModeSelect::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPNetworkCommissioning

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)addOrUpdateThreadNetworkWithParams:(CHIPNetworkCommissioningClusterAddOrUpdateThreadNetworkParams *)params
                         completionHandler:(void (^)(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable data,
                                               NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    NetworkCommissioning::Commands::AddOrUpdateThreadNetwork::Type request;
    request.operationalDataset = [self asByteSpan:params.operationalDataset];
    if (params.breadcrumb != nil) {
        auto & definedValue_0 = request.breadcrumb.Emplace();
        definedValue_0 = params.breadcrumb.unsignedLongLongValue;
    }

    new CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)addOrUpdateWiFiNetworkWithParams:(CHIPNetworkCommissioningClusterAddOrUpdateWiFiNetworkParams *)params
                       completionHandler:(void (^)(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable data,
                                             NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    NetworkCommissioning::Commands::AddOrUpdateWiFiNetwork::Type request;
    request.ssid = [self asByteSpan:params.ssid];
    request.credentials = [self asByteSpan:params.credentials];
    if (params.breadcrumb != nil) {
        auto & definedValue_0 = request.breadcrumb.Emplace();
        definedValue_0 = params.breadcrumb.unsignedLongLongValue;
    }

    new CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)connectNetworkWithParams:(CHIPNetworkCommissioningClusterConnectNetworkParams *)params
               completionHandler:(void (^)(CHIPNetworkCommissioningClusterConnectNetworkResponseParams * _Nullable data,
                                     NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    NetworkCommissioning::Commands::ConnectNetwork::Type request;
    request.networkID = [self asByteSpan:params.networkID];
    if (params.breadcrumb != nil) {
        auto & definedValue_0 = request.breadcrumb.Emplace();
        definedValue_0 = params.breadcrumb.unsignedLongLongValue;
    }

    new CHIPNetworkCommissioningClusterConnectNetworkResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPNetworkCommissioningClusterConnectNetworkResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)removeNetworkWithParams:(CHIPNetworkCommissioningClusterRemoveNetworkParams *)params
              completionHandler:(void (^)(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable data,
                                    NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    NetworkCommissioning::Commands::RemoveNetwork::Type request;
    request.networkID = [self asByteSpan:params.networkID];
    if (params.breadcrumb != nil) {
        auto & definedValue_0 = request.breadcrumb.Emplace();
        definedValue_0 = params.breadcrumb.unsignedLongLongValue;
    }

    new CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)reorderNetworkWithParams:(CHIPNetworkCommissioningClusterReorderNetworkParams *)params
               completionHandler:(void (^)(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable data,
                                     NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    NetworkCommissioning::Commands::ReorderNetwork::Type request;
    request.networkID = [self asByteSpan:params.networkID];
    request.networkIndex = params.networkIndex.unsignedCharValue;
    if (params.breadcrumb != nil) {
        auto & definedValue_0 = request.breadcrumb.Emplace();
        definedValue_0 = params.breadcrumb.unsignedLongLongValue;
    }

    new CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPNetworkCommissioningClusterNetworkConfigResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)scanNetworksWithParams:(CHIPNetworkCommissioningClusterScanNetworksParams * _Nullable)params
             completionHandler:(void (^)(CHIPNetworkCommissioningClusterScanNetworksResponseParams * _Nullable data,
                                   NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    NetworkCommissioning::Commands::ScanNetworks::Type request;
    if (params != nil) {
        if (params.ssid != nil) {
            auto & definedValue_0 = request.ssid.Emplace();
            if (params.ssid == nil) {
                definedValue_0.SetNull();
            } else {
                auto & nonNullValue_1 = definedValue_0.SetNonNull();
                nonNullValue_1 = [self asByteSpan:params.ssid];
            }
        }
        if (params.breadcrumb != nil) {
            auto & definedValue_0 = request.breadcrumb.Emplace();
            definedValue_0 = params.breadcrumb.unsignedLongLongValue;
        }
    }

    new CHIPNetworkCommissioningClusterScanNetworksResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPNetworkCommissioningClusterScanNetworksResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeMaxNetworksWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = NetworkCommissioning::Attributes::MaxNetworks::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMaxNetworksWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::MaxNetworks::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxNetworksWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = NetworkCommissioning::Attributes::MaxNetworks::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNetworksWithCompletionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNetworkCommissioningNetworksListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = NetworkCommissioning::Attributes::Networks::TypeInfo;
            auto successFn = Callback<NetworkCommissioningNetworksListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNetworksWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNetworkCommissioningNetworksListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::Networks::TypeInfo;
            auto successFn = Callback<NetworkCommissioningNetworksListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNetworkCommissioningNetworksListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNetworksWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNetworkCommissioningNetworksListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = NetworkCommissioning::Attributes::Networks::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<NetworkCommissioningNetworksListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeScanMaxTimeSecondsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = NetworkCommissioning::Attributes::ScanMaxTimeSeconds::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeScanMaxTimeSecondsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::ScanMaxTimeSeconds::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeScanMaxTimeSecondsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = NetworkCommissioning::Attributes::ScanMaxTimeSeconds::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeConnectMaxTimeSecondsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = NetworkCommissioning::Attributes::ConnectMaxTimeSeconds::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeConnectMaxTimeSecondsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::ConnectMaxTimeSeconds::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeConnectMaxTimeSecondsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = NetworkCommissioning::Attributes::ConnectMaxTimeSeconds::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInterfaceEnabledWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = NetworkCommissioning::Attributes::InterfaceEnabled::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInterfaceEnabledWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = NetworkCommissioning::Attributes::InterfaceEnabled::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInterfaceEnabledWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::InterfaceEnabled::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInterfaceEnabledWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = NetworkCommissioning::Attributes::InterfaceEnabled::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLastNetworkingStatusWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPNullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = NetworkCommissioning::Attributes::LastNetworkingStatus::TypeInfo;
            auto successFn
                = Callback<NullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLastNetworkingStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::LastNetworkingStatus::TypeInfo;
            auto successFn
                = Callback<NullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLastNetworkingStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = NetworkCommissioning::Attributes::LastNetworkingStatus::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<NullableNetworkCommissioningClusterNetworkCommissioningStatusAttributeCallback>::FromCancelable(
                        success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeLastNetworkIDWithCompletionHandler:(void (^)(
                                                            NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableOctetStringAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = NetworkCommissioning::Attributes::LastNetworkID::TypeInfo;
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLastNetworkIDWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSData * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableOctetStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::LastNetworkID::TypeInfo;
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLastNetworkIDWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableOctetStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = NetworkCommissioning::Attributes::LastNetworkID::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLastConnectErrorValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = NetworkCommissioning::Attributes::LastConnectErrorValue::TypeInfo;
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLastConnectErrorValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt32sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::LastConnectErrorValue::TypeInfo;
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt32sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLastConnectErrorValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = NetworkCommissioning::Attributes::LastConnectErrorValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPNetworkCommissioningGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = NetworkCommissioning::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<NetworkCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNetworkCommissioningGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<NetworkCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNetworkCommissioningGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNetworkCommissioningGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = NetworkCommissioning::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<NetworkCommissioningGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPNetworkCommissioningAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = NetworkCommissioning::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<NetworkCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNetworkCommissioningAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<NetworkCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNetworkCommissioningAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNetworkCommissioningAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = NetworkCommissioning::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<NetworkCommissioningAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = NetworkCommissioning::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = NetworkCommissioning::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = NetworkCommissioning::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = NetworkCommissioning::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = NetworkCommissioning::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPOtaSoftwareUpdateProvider

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)applyUpdateRequestWithParams:(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestParams *)params
                   completionHandler:(void (^)(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseParams * _Nullable data,
                                         NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OtaSoftwareUpdateProvider::Commands::ApplyUpdateRequest::Type request;
    request.updateToken = [self asByteSpan:params.updateToken];
    request.newVersion = params.newVersion.unsignedIntValue;

    new CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)notifyUpdateAppliedWithParams:(CHIPOtaSoftwareUpdateProviderClusterNotifyUpdateAppliedParams *)params
                    completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OtaSoftwareUpdateProvider::Commands::NotifyUpdateApplied::Type request;
    request.updateToken = [self asByteSpan:params.updateToken];
    request.softwareVersion = params.softwareVersion.unsignedIntValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)queryImageWithParams:(CHIPOtaSoftwareUpdateProviderClusterQueryImageParams *)params
           completionHandler:(void (^)(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseParams * _Nullable data,
                                 NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OtaSoftwareUpdateProvider::Commands::QueryImage::Type request;
    request.vendorId = static_cast<std::remove_reference_t<decltype(request.vendorId)>>(params.vendorId.unsignedShortValue);
    request.productId = params.productId.unsignedShortValue;
    request.softwareVersion = params.softwareVersion.unsignedIntValue;
    {
        using ListType_0 = std::remove_reference_t<decltype(request.protocolsSupported)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.protocolsSupported.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.protocolsSupported.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.protocolsSupported.count; ++i_0) {
                if (![params.protocolsSupported[i_0] isKindOfClass:[NSNumber class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (NSNumber *) params.protocolsSupported[i_0];
                listHolder_0->mList[i_0]
                    = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0])>>(element_0.unsignedCharValue);
            }
            request.protocolsSupported = ListType_0(listHolder_0->mList, params.protocolsSupported.count);
        } else {
            request.protocolsSupported = ListType_0();
        }
    }
    if (params.hardwareVersion != nil) {
        auto & definedValue_0 = request.hardwareVersion.Emplace();
        definedValue_0 = params.hardwareVersion.unsignedShortValue;
    }
    if (params.location != nil) {
        auto & definedValue_0 = request.location.Emplace();
        definedValue_0 = [self asCharSpan:params.location];
    }
    if (params.requestorCanConsent != nil) {
        auto & definedValue_0 = request.requestorCanConsent.Emplace();
        definedValue_0 = params.requestorCanConsent.boolValue;
    }
    if (params.metadataForProvider != nil) {
        auto & definedValue_0 = request.metadataForProvider.Emplace();
        definedValue_0 = [self asByteSpan:params.metadataForProvider];
    }

    new CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOtaSoftwareUpdateProviderAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OtaSoftwareUpdateProvider::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OtaSoftwareUpdateProviderAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOtaSoftwareUpdateProviderAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OtaSoftwareUpdateProvider::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OtaSoftwareUpdateProviderAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOtaSoftwareUpdateProviderAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOtaSoftwareUpdateProviderAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OtaSoftwareUpdateProvider::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OtaSoftwareUpdateProviderAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OtaSoftwareUpdateProvider::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OtaSoftwareUpdateProvider::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OtaSoftwareUpdateProvider::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPOtaSoftwareUpdateRequestor

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)announceOtaProviderWithParams:(CHIPOtaSoftwareUpdateRequestorClusterAnnounceOtaProviderParams *)params
                    completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OtaSoftwareUpdateRequestor::Commands::AnnounceOtaProvider::Type request;
    request.providerNodeId = params.providerNodeId.unsignedLongLongValue;
    request.vendorId = static_cast<std::remove_reference_t<decltype(request.vendorId)>>(params.vendorId.unsignedShortValue);
    request.announcementReason
        = static_cast<std::remove_reference_t<decltype(request.announcementReason)>>(params.announcementReason.unsignedCharValue);
    if (params.metadataForNode != nil) {
        auto & definedValue_0 = request.metadataForNode.Emplace();
        definedValue_0 = [self asByteSpan:params.metadataForNode];
    }
    request.endpoint = params.endpoint.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeDefaultOtaProvidersWithParams:(CHIPReadParams * _Nullable)params
                                 completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::DefaultOtaProviders::TypeInfo;
            auto successFn = Callback<OtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)writeAttributeDefaultOtaProvidersWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::DefaultOtaProviders::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPOtaSoftwareUpdateRequestorClusterProviderLocation class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPOtaSoftwareUpdateRequestorClusterProviderLocation *) value[i_0];
                        listHolder_0->mList[i_0].providerNodeID = element_0.providerNodeID.unsignedLongLongValue;
                        listHolder_0->mList[i_0].endpoint = element_0.endpoint.unsignedShortValue;
                        listHolder_0->mList[i_0].fabricIndex = element_0.fabricIndex.unsignedCharValue;
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeDefaultOtaProvidersWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::DefaultOtaProviders::TypeInfo;
            auto successFn = Callback<OtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDefaultOtaProvidersWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::DefaultOtaProviders::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<OtaSoftwareUpdateRequestorDefaultOtaProvidersListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeUpdatePossibleWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdatePossible::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeUpdatePossibleWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdatePossible::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeUpdatePossibleWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdatePossible::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeUpdateStateWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdateState::TypeInfo;
            auto successFn
                = Callback<OtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeUpdateStateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdateState::TypeInfo;
            auto successFn
                = Callback<OtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeUpdateStateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdateState::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<OtaSoftwareUpdateRequestorClusterOTAUpdateStateEnumAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeUpdateStateProgressWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdateStateProgress::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeUpdateStateProgressWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdateStateProgress::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeUpdateStateProgressWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::UpdateStateProgress::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOtaSoftwareUpdateRequestorAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OtaSoftwareUpdateRequestorAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOtaSoftwareUpdateRequestorAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OtaSoftwareUpdateRequestorAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOtaSoftwareUpdateRequestorAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOtaSoftwareUpdateRequestorAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OtaSoftwareUpdateRequestorAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OtaSoftwareUpdateRequestor::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPOccupancySensing

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeOccupancyWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OccupancySensing::Attributes::Occupancy::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOccupancyWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OccupancySensing::Attributes::Occupancy::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOccupancyWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OccupancySensing::Attributes::Occupancy::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOccupancySensorTypeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OccupancySensing::Attributes::OccupancySensorType::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOccupancySensorTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OccupancySensing::Attributes::OccupancySensorType::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOccupancySensorTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OccupancySensing::Attributes::OccupancySensorType::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOccupancySensorTypeBitmapWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOccupancySensorTypeBitmapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                                            params:(CHIPSubscribeParams * _Nullable)params
                                           subscriptionEstablished:
                                               (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                     reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOccupancySensorTypeBitmapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                        endpoint:(NSNumber *)endpoint
                                                           queue:(dispatch_queue_t)queue
                                               completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPOccupancySensingGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OccupancySensing::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<OccupancySensingGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOccupancySensingGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OccupancySensing::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<OccupancySensingGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOccupancySensingGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOccupancySensingGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OccupancySensing::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OccupancySensingGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPOccupancySensingAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OccupancySensing::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<OccupancySensingAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOccupancySensingAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OccupancySensing::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<OccupancySensingAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOccupancySensingAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOccupancySensingAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OccupancySensing::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OccupancySensingAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOccupancySensingAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OccupancySensing::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OccupancySensingAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOccupancySensingAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OccupancySensing::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OccupancySensingAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOccupancySensingAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOccupancySensingAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OccupancySensing::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OccupancySensingAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OccupancySensing::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OccupancySensing::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OccupancySensing::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPOnOff

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)offWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OnOff::Commands::Off::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)offWithEffectWithParams:(CHIPOnOffClusterOffWithEffectParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OnOff::Commands::OffWithEffect::Type request;
    request.effectId = static_cast<std::remove_reference_t<decltype(request.effectId)>>(params.effectId.unsignedCharValue);
    request.effectVariant
        = static_cast<std::remove_reference_t<decltype(request.effectVariant)>>(params.effectVariant.unsignedCharValue);

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)onWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OnOff::Commands::On::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)onWithRecallGlobalSceneWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OnOff::Commands::OnWithRecallGlobalScene::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)onWithTimedOffWithParams:(CHIPOnOffClusterOnWithTimedOffParams *)params
               completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OnOff::Commands::OnWithTimedOff::Type request;
    request.onOffControl
        = static_cast<std::remove_reference_t<decltype(request.onOffControl)>>(params.onOffControl.unsignedCharValue);
    request.onTime = params.onTime.unsignedShortValue;
    request.offWaitTime = params.offWaitTime.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)toggleWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OnOff::Commands::Toggle::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeOnOffWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOff::Attributes::OnOff::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOnOffWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::OnOff::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOnOffWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOff::Attributes::OnOff::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGlobalSceneControlWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOff::Attributes::GlobalSceneControl::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeGlobalSceneControlWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::GlobalSceneControl::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGlobalSceneControlWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOff::Attributes::GlobalSceneControl::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOnTimeWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOff::Attributes::OnTime::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeOnTimeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = OnOff::Attributes::OnTime::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOnTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::OnTime::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOnTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOff::Attributes::OnTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOffWaitTimeWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOff::Attributes::OffWaitTime::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeOffWaitTimeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = OnOff::Attributes::OffWaitTime::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOffWaitTimeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::OffWaitTime::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOffWaitTimeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOff::Attributes::OffWaitTime::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeStartUpOnOffWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableOnOffClusterOnOffStartUpOnOffAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OnOff::Attributes::StartUpOnOff::TypeInfo;
            auto successFn = Callback<NullableOnOffClusterOnOffStartUpOnOffAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeStartUpOnOffWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = OnOff::Attributes::StartUpOnOff::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(value.unsignedCharValue);
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeStartUpOnOffWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableOnOffClusterOnOffStartUpOnOffAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::StartUpOnOff::TypeInfo;
            auto successFn = Callback<NullableOnOffClusterOnOffStartUpOnOffAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableOnOffClusterOnOffStartUpOnOffAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStartUpOnOffWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableOnOffClusterOnOffStartUpOnOffAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OnOff::Attributes::StartUpOnOff::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<NullableOnOffClusterOnOffStartUpOnOffAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPOnOffGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OnOff::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<OnOffGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOnOffGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<OnOffGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOnOffGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOnOffGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OnOff::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OnOffGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPOnOffAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OnOff::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<OnOffAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOnOffAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<OnOffAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOnOffAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOnOffAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OnOff::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OnOffAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOnOffAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OnOff::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OnOffAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOnOffAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OnOffAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOnOffAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOnOffAttributeListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOff::Attributes::AttributeList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<OnOffAttributeListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOff::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOff::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOff::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOff::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOff::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPOnOffSwitchConfiguration

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeSwitchTypeWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOffSwitchConfiguration::Attributes::SwitchType::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSwitchTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOffSwitchConfiguration::Attributes::SwitchType::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSwitchTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOffSwitchConfiguration::Attributes::SwitchType::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSwitchActionsWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOffSwitchConfiguration::Attributes::SwitchActions::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeSwitchActionsWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = OnOffSwitchConfiguration::Attributes::SwitchActions::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSwitchActionsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOffSwitchConfiguration::Attributes::SwitchActions::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSwitchActionsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOffSwitchConfiguration::Attributes::SwitchActions::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPOnOffSwitchConfigurationGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OnOffSwitchConfiguration::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<OnOffSwitchConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOnOffSwitchConfigurationGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOffSwitchConfiguration::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<OnOffSwitchConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOnOffSwitchConfigurationGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOnOffSwitchConfigurationGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OnOffSwitchConfiguration::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<OnOffSwitchConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPOnOffSwitchConfigurationAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OnOffSwitchConfiguration::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<OnOffSwitchConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOnOffSwitchConfigurationAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOffSwitchConfiguration::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<OnOffSwitchConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOnOffSwitchConfigurationAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOnOffSwitchConfigurationAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OnOffSwitchConfiguration::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<OnOffSwitchConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOnOffSwitchConfigurationAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OnOffSwitchConfiguration::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OnOffSwitchConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOnOffSwitchConfigurationAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOffSwitchConfiguration::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OnOffSwitchConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOnOffSwitchConfigurationAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOnOffSwitchConfigurationAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OnOffSwitchConfiguration::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OnOffSwitchConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OnOffSwitchConfiguration::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OnOffSwitchConfiguration::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OnOffSwitchConfiguration::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPOperationalCredentials

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)addNOCWithParams:(CHIPOperationalCredentialsClusterAddNOCParams *)params
       completionHandler:(void (^)(CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable data,
                             NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::AddNOC::Type request;
    request.NOCValue = [self asByteSpan:params.nocValue];
    if (params.icacValue != nil) {
        auto & definedValue_0 = request.ICACValue.Emplace();
        definedValue_0 = [self asByteSpan:params.icacValue];
    }
    request.IPKValue = [self asByteSpan:params.ipkValue];
    request.caseAdminNode = params.caseAdminNode.unsignedLongLongValue;
    request.adminVendorId = params.adminVendorId.unsignedShortValue;

    new CHIPOperationalCredentialsClusterNOCResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)addTrustedRootCertificateWithParams:(CHIPOperationalCredentialsClusterAddTrustedRootCertificateParams *)params
                          completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::AddTrustedRootCertificate::Type request;
    request.rootCertificate = [self asByteSpan:params.rootCertificate];

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)attestationRequestWithParams:(CHIPOperationalCredentialsClusterAttestationRequestParams *)params
                   completionHandler:(void (^)(CHIPOperationalCredentialsClusterAttestationResponseParams * _Nullable data,
                                         NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::AttestationRequest::Type request;
    request.attestationNonce = [self asByteSpan:params.attestationNonce];

    new CHIPOperationalCredentialsClusterAttestationResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPOperationalCredentialsClusterAttestationResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)CSRRequestWithParams:(CHIPOperationalCredentialsClusterCSRRequestParams *)params
           completionHandler:(void (^)(CHIPOperationalCredentialsClusterCSRResponseParams * _Nullable data,
                                 NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::CSRRequest::Type request;
    request.CSRNonce = [self asByteSpan:params.csrNonce];

    new CHIPOperationalCredentialsClusterCSRResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPOperationalCredentialsClusterCSRResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)certificateChainRequestWithParams:(CHIPOperationalCredentialsClusterCertificateChainRequestParams *)params
                        completionHandler:
                            (void (^)(CHIPOperationalCredentialsClusterCertificateChainResponseParams * _Nullable data,
                                NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::CertificateChainRequest::Type request;
    request.certificateType = params.certificateType.unsignedCharValue;

    new CHIPOperationalCredentialsClusterCertificateChainResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn
                = Callback<CHIPOperationalCredentialsClusterCertificateChainResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)removeFabricWithParams:(CHIPOperationalCredentialsClusterRemoveFabricParams *)params
             completionHandler:(void (^)(CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable data,
                                   NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::RemoveFabric::Type request;
    request.fabricIndex = params.fabricIndex.unsignedCharValue;

    new CHIPOperationalCredentialsClusterNOCResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)removeTrustedRootCertificateWithParams:(CHIPOperationalCredentialsClusterRemoveTrustedRootCertificateParams *)params
                             completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::RemoveTrustedRootCertificate::Type request;
    request.trustedRootIdentifier = [self asByteSpan:params.trustedRootIdentifier];

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)updateFabricLabelWithParams:(CHIPOperationalCredentialsClusterUpdateFabricLabelParams *)params
                  completionHandler:(void (^)(CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable data,
                                        NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::UpdateFabricLabel::Type request;
    request.label = [self asCharSpan:params.label];

    new CHIPOperationalCredentialsClusterNOCResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)updateNOCWithParams:(CHIPOperationalCredentialsClusterUpdateNOCParams *)params
          completionHandler:(void (^)(CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable data,
                                NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    OperationalCredentials::Commands::UpdateNOC::Type request;
    request.NOCValue = [self asByteSpan:params.nocValue];
    if (params.icacValue != nil) {
        auto & definedValue_0 = request.ICACValue.Emplace();
        definedValue_0 = [self asByteSpan:params.icacValue];
    }

    new CHIPOperationalCredentialsClusterNOCResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPOperationalCredentialsClusterNOCResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeNOCsWithParams:(CHIPReadParams * _Nullable)params
                  completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsNOCsListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OperationalCredentials::Attributes::NOCs::TypeInfo;
            auto successFn = Callback<OperationalCredentialsNOCsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)subscribeAttributeNOCsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                       params:(CHIPSubscribeParams * _Nullable)params
                      subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOperationalCredentialsNOCsListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::NOCs::TypeInfo;
            auto successFn = Callback<OperationalCredentialsNOCsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOperationalCredentialsNOCsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNOCsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                   endpoint:(NSNumber *)endpoint
                                      queue:(dispatch_queue_t)queue
                          completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsNOCsListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OperationalCredentials::Attributes::NOCs::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OperationalCredentialsNOCsListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFabricsWithParams:(CHIPReadParams * _Nullable)params
                     completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsFabricsListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OperationalCredentials::Attributes::Fabrics::TypeInfo;
            auto successFn = Callback<OperationalCredentialsFabricsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)subscribeAttributeFabricsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOperationalCredentialsFabricsListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::Fabrics::TypeInfo;
            auto successFn = Callback<OperationalCredentialsFabricsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOperationalCredentialsFabricsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFabricsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsFabricsListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OperationalCredentials::Attributes::Fabrics::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OperationalCredentialsFabricsListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeSupportedFabricsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OperationalCredentials::Attributes::SupportedFabrics::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSupportedFabricsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::SupportedFabrics::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSupportedFabricsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OperationalCredentials::Attributes::SupportedFabrics::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCommissionedFabricsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCommissionedFabricsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCommissionedFabricsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTrustedRootCertificatesWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsTrustedRootCertificatesListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OperationalCredentials::Attributes::TrustedRootCertificates::TypeInfo;
            auto successFn = Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeTrustedRootCertificatesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:
                                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOperationalCredentialsTrustedRootCertificatesListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::TrustedRootCertificates::TypeInfo;
            auto successFn = Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOperationalCredentialsTrustedRootCertificatesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTrustedRootCertificatesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsTrustedRootCertificatesListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OperationalCredentials::Attributes::TrustedRootCertificates::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentFabricIndexWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OperationalCredentials::Attributes::CurrentFabricIndex::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentFabricIndexWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::CurrentFabricIndex::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentFabricIndexWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OperationalCredentials::Attributes::CurrentFabricIndex::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OperationalCredentials::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<OperationalCredentialsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOperationalCredentialsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<OperationalCredentialsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOperationalCredentialsGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OperationalCredentials::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OperationalCredentialsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OperationalCredentials::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<OperationalCredentialsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOperationalCredentialsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<OperationalCredentialsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOperationalCredentialsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OperationalCredentials::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OperationalCredentialsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = OperationalCredentials::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OperationalCredentialsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOperationalCredentialsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<OperationalCredentialsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOperationalCredentialsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOperationalCredentialsAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = OperationalCredentials::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<OperationalCredentialsAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = OperationalCredentials::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = OperationalCredentials::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = OperationalCredentials::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPPowerSource

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeStatusWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::Status::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::Status::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::Status::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOrderWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::Order::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOrderWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::Order::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOrderWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::Order::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeDescriptionWithCompletionHandler:(void (^)(
                                                          NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::Description::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeDescriptionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::Description::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDescriptionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::Description::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBatteryVoltageWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::BatteryVoltage::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBatteryVoltageWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::BatteryVoltage::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBatteryVoltageWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::BatteryVoltage::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBatteryPercentRemainingWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::BatteryPercentRemaining::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBatteryPercentRemainingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::BatteryPercentRemaining::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBatteryPercentRemainingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::BatteryPercentRemaining::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBatteryTimeRemainingWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::BatteryTimeRemaining::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBatteryTimeRemainingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::BatteryTimeRemaining::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBatteryTimeRemainingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::BatteryTimeRemaining::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBatteryChargeLevelWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::BatteryChargeLevel::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBatteryChargeLevelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::BatteryChargeLevel::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBatteryChargeLevelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::BatteryChargeLevel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeActiveBatteryFaultsWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceActiveBatteryFaultsListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PowerSource::Attributes::ActiveBatteryFaults::TypeInfo;
            auto successFn = Callback<PowerSourceActiveBatteryFaultsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeActiveBatteryFaultsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPowerSourceActiveBatteryFaultsListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::ActiveBatteryFaults::TypeInfo;
            auto successFn = Callback<PowerSourceActiveBatteryFaultsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPowerSourceActiveBatteryFaultsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActiveBatteryFaultsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceActiveBatteryFaultsListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PowerSource::Attributes::ActiveBatteryFaults::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<PowerSourceActiveBatteryFaultsListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeBatteryChargeStateWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::BatteryChargeState::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBatteryChargeStateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::BatteryChargeState::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBatteryChargeStateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::BatteryChargeState::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PowerSource::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<PowerSourceGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPowerSourceGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<PowerSourceGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPowerSourceGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PowerSource::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<PowerSourceGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PowerSource::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<PowerSourceAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPowerSourceAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<PowerSourceAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPowerSourceAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PowerSource::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<PowerSourceAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PowerSource::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<PowerSourceAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPowerSourceAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<PowerSourceAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPowerSourceAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PowerSource::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<PowerSourceAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSource::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSource::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSource::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPPowerSourceConfiguration

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeSourcesWithCompletionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceConfigurationSourcesListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PowerSourceConfiguration::Attributes::Sources::TypeInfo;
            auto successFn = Callback<PowerSourceConfigurationSourcesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSourcesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPowerSourceConfigurationSourcesListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSourceConfiguration::Attributes::Sources::TypeInfo;
            auto successFn = Callback<PowerSourceConfigurationSourcesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPowerSourceConfigurationSourcesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSourcesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceConfigurationSourcesListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PowerSourceConfiguration::Attributes::Sources::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<PowerSourceConfigurationSourcesListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceConfigurationGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PowerSourceConfiguration::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<PowerSourceConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPowerSourceConfigurationGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSourceConfiguration::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<PowerSourceConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPowerSourceConfigurationGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceConfigurationGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PowerSourceConfiguration::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<PowerSourceConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceConfigurationAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PowerSourceConfiguration::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<PowerSourceConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPowerSourceConfigurationAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSourceConfiguration::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<PowerSourceConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPowerSourceConfigurationAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceConfigurationAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PowerSourceConfiguration::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<PowerSourceConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceConfigurationAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PowerSourceConfiguration::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<PowerSourceConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPowerSourceConfigurationAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSourceConfiguration::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<PowerSourceConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPowerSourceConfigurationAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPowerSourceConfigurationAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PowerSourceConfiguration::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<PowerSourceConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PowerSourceConfiguration::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PowerSourceConfiguration::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PowerSourceConfiguration::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPPressureMeasurement

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeMeasuredValueWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PressureMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PressureMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PressureMeasurement::Attributes::MeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPressureMeasurementAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PressureMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<PressureMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPressureMeasurementAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PressureMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<PressureMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPressureMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPressureMeasurementAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PressureMeasurement::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<PressureMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PressureMeasurement::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PressureMeasurement::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PressureMeasurement::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPPumpConfigurationAndControl

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeMaxPressureWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxPressureWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxPressureWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxSpeedWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxSpeed::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxSpeedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxSpeed::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxSpeedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxSpeed::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxFlowWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxFlow::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxFlowWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxFlow::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxFlowWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxFlow::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinConstPressureWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinConstPressureWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinConstPressureWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstPressure::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxConstPressureWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxConstPressureWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxConstPressureWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstPressure::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinCompPressureWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinCompPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinCompPressureWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinCompPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinCompPressureWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinCompPressure::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxCompPressureWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxCompPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxCompPressureWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxCompPressure::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxCompPressureWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxCompPressure::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinConstSpeedWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstSpeed::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinConstSpeedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstSpeed::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinConstSpeedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstSpeed::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxConstSpeedWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstSpeed::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxConstSpeedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstSpeed::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxConstSpeedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstSpeed::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinConstFlowWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstFlow::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinConstFlowWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstFlow::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinConstFlowWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstFlow::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxConstFlowWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstFlow::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxConstFlowWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstFlow::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxConstFlowWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstFlow::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinConstTempWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstTemp::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinConstTempWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstTemp::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinConstTempWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MinConstTemp::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxConstTempWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstTemp::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxConstTempWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstTemp::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxConstTempWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::MaxConstTemp::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePumpStatusWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PumpConfigurationAndControl::Attributes::PumpStatus::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePumpStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::PumpStatus::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePumpStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::PumpStatus::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEffectiveOperationModeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo;
            auto successFn
                = Callback<PumpConfigurationAndControlClusterPumpOperationModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEffectiveOperationModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo;
            auto successFn
                = Callback<PumpConfigurationAndControlClusterPumpOperationModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEffectiveOperationModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<PumpConfigurationAndControlClusterPumpOperationModeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeEffectiveControlModeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo;
            auto successFn = Callback<PumpConfigurationAndControlClusterPumpControlModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEffectiveControlModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo;
            auto successFn = Callback<PumpConfigurationAndControlClusterPumpControlModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEffectiveControlModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<PumpConfigurationAndControlClusterPumpControlModeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCapacityWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::Capacity::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCapacityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::Capacity::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCapacityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::Capacity::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSpeedWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::Speed::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSpeedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::Speed::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSpeedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::Speed::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLifetimeRunningHoursWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeLifetimeRunningHoursWithValue:(NSNumber * _Nullable)value
                                  completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedIntValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLifetimeRunningHoursWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLifetimeRunningHoursWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::LifetimeRunningHours::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePowerWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::Power::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributePowerWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::Power::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePowerWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::Power::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLifetimeEnergyConsumedWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeLifetimeEnergyConsumedWithValue:(NSNumber * _Nullable)value
                                    completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedIntValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLifetimeEnergyConsumedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLifetimeEnergyConsumedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOperationModeWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo;
            auto successFn
                = Callback<PumpConfigurationAndControlClusterPumpOperationModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeOperationModeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOperationModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo;
            auto successFn
                = Callback<PumpConfigurationAndControlClusterPumpOperationModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOperationModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpOperationModeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<PumpConfigurationAndControlClusterPumpOperationModeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeControlModeWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo;
            auto successFn = Callback<PumpConfigurationAndControlClusterPumpControlModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeControlModeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeControlModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo;
            auto successFn = Callback<PumpConfigurationAndControlClusterPumpControlModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeControlModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlClusterPumpControlModeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PumpConfigurationAndControl::Attributes::ControlMode::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<PumpConfigurationAndControlClusterPumpControlModeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAlarmMaskWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PumpConfigurationAndControl::Attributes::AlarmMask::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAlarmMaskWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::AlarmMask::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAlarmMaskWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::AlarmMask::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn
                = Callback<PumpConfigurationAndControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPumpConfigurationAndControlGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn
                = Callback<PumpConfigurationAndControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPumpConfigurationAndControlGeneratedCommandListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PumpConfigurationAndControl::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<PumpConfigurationAndControlGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<PumpConfigurationAndControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPumpConfigurationAndControlAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<PumpConfigurationAndControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPumpConfigurationAndControlAcceptedCommandListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PumpConfigurationAndControl::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<PumpConfigurationAndControlAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = PumpConfigurationAndControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<PumpConfigurationAndControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPPumpConfigurationAndControlAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<PumpConfigurationAndControlAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPPumpConfigurationAndControlAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPPumpConfigurationAndControlAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = PumpConfigurationAndControl::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<PumpConfigurationAndControlAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PumpConfigurationAndControl::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPRelativeHumidityMeasurement

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeMeasuredValueWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = RelativeHumidityMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeToleranceWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = RelativeHumidityMeasurement::Attributes::Tolerance::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeToleranceWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = RelativeHumidityMeasurement::Attributes::Tolerance::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeToleranceWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = RelativeHumidityMeasurement::Attributes::Tolerance::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPRelativeHumidityMeasurementGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = RelativeHumidityMeasurement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn
                = Callback<RelativeHumidityMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPRelativeHumidityMeasurementGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = RelativeHumidityMeasurement::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn
                = Callback<RelativeHumidityMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPRelativeHumidityMeasurementGeneratedCommandListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPRelativeHumidityMeasurementGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = RelativeHumidityMeasurement::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<RelativeHumidityMeasurementGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPRelativeHumidityMeasurementAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = RelativeHumidityMeasurement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<RelativeHumidityMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPRelativeHumidityMeasurementAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = RelativeHumidityMeasurement::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<RelativeHumidityMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPRelativeHumidityMeasurementAcceptedCommandListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPRelativeHumidityMeasurementAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = RelativeHumidityMeasurement::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<RelativeHumidityMeasurementAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPRelativeHumidityMeasurementAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = RelativeHumidityMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<RelativeHumidityMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPRelativeHumidityMeasurementAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = RelativeHumidityMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<RelativeHumidityMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPRelativeHumidityMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPRelativeHumidityMeasurementAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = RelativeHumidityMeasurement::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<RelativeHumidityMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPScenes

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)addSceneWithParams:(CHIPScenesClusterAddSceneParams *)params
         completionHandler:
             (void (^)(CHIPScenesClusterAddSceneResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Scenes::Commands::AddScene::Type request;
    request.groupId = params.groupId.unsignedShortValue;
    request.sceneId = params.sceneId.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;
    request.sceneName = [self asCharSpan:params.sceneName];
    {
        using ListType_0 = std::remove_reference_t<decltype(request.extensionFieldSets)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.extensionFieldSets.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.extensionFieldSets.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.extensionFieldSets.count; ++i_0) {
                if (![params.extensionFieldSets[i_0] isKindOfClass:[CHIPScenesClusterSceneExtensionFieldSet class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (CHIPScenesClusterSceneExtensionFieldSet *) params.extensionFieldSets[i_0];
                listHolder_0->mList[i_0].clusterId = element_0.clusterId.unsignedIntValue;
                listHolder_0->mList[i_0].length = element_0.length.unsignedCharValue;
                listHolder_0->mList[i_0].value = element_0.value.unsignedCharValue;
            }
            request.extensionFieldSets = ListType_0(listHolder_0->mList, params.extensionFieldSets.count);
        } else {
            request.extensionFieldSets = ListType_0();
        }
    }

    new CHIPScenesClusterAddSceneResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPScenesClusterAddSceneResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getSceneMembershipWithParams:(CHIPScenesClusterGetSceneMembershipParams *)params
                   completionHandler:(void (^)(CHIPScenesClusterGetSceneMembershipResponseParams * _Nullable data,
                                         NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Scenes::Commands::GetSceneMembership::Type request;
    request.groupId = params.groupId.unsignedShortValue;

    new CHIPScenesClusterGetSceneMembershipResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPScenesClusterGetSceneMembershipResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)recallSceneWithParams:(CHIPScenesClusterRecallSceneParams *)params completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Scenes::Commands::RecallScene::Type request;
    request.groupId = params.groupId.unsignedShortValue;
    request.sceneId = params.sceneId.unsignedCharValue;
    request.transitionTime = params.transitionTime.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)removeAllScenesWithParams:(CHIPScenesClusterRemoveAllScenesParams *)params
                completionHandler:(void (^)(CHIPScenesClusterRemoveAllScenesResponseParams * _Nullable data,
                                      NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Scenes::Commands::RemoveAllScenes::Type request;
    request.groupId = params.groupId.unsignedShortValue;

    new CHIPScenesClusterRemoveAllScenesResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPScenesClusterRemoveAllScenesResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)removeSceneWithParams:(CHIPScenesClusterRemoveSceneParams *)params
            completionHandler:
                (void (^)(CHIPScenesClusterRemoveSceneResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Scenes::Commands::RemoveScene::Type request;
    request.groupId = params.groupId.unsignedShortValue;
    request.sceneId = params.sceneId.unsignedCharValue;

    new CHIPScenesClusterRemoveSceneResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPScenesClusterRemoveSceneResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)storeSceneWithParams:(CHIPScenesClusterStoreSceneParams *)params
           completionHandler:
               (void (^)(CHIPScenesClusterStoreSceneResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Scenes::Commands::StoreScene::Type request;
    request.groupId = params.groupId.unsignedShortValue;
    request.sceneId = params.sceneId.unsignedCharValue;

    new CHIPScenesClusterStoreSceneResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPScenesClusterStoreSceneResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)viewSceneWithParams:(CHIPScenesClusterViewSceneParams *)params
          completionHandler:
              (void (^)(CHIPScenesClusterViewSceneResponseParams * _Nullable data, NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Scenes::Commands::ViewScene::Type request;
    request.groupId = params.groupId.unsignedShortValue;
    request.sceneId = params.sceneId.unsignedCharValue;

    new CHIPScenesClusterViewSceneResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPScenesClusterViewSceneResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeSceneCountWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Scenes::Attributes::SceneCount::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSceneCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::SceneCount::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSceneCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Scenes::Attributes::SceneCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentSceneWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Scenes::Attributes::CurrentScene::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentSceneWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::CurrentScene::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentSceneWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Scenes::Attributes::CurrentScene::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentGroupWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Scenes::Attributes::CurrentGroup::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentGroupWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::CurrentGroup::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentGroupWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Scenes::Attributes::CurrentGroup::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSceneValidWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Scenes::Attributes::SceneValid::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSceneValidWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::SceneValid::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSceneValidWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Scenes::Attributes::SceneValid::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNameSupportWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Scenes::Attributes::NameSupport::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNameSupportWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::NameSupport::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNameSupportWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Scenes::Attributes::NameSupport::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPScenesGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Scenes::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ScenesGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPScenesGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ScenesGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPScenesGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPScenesGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Scenes::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ScenesGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPScenesAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Scenes::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ScenesAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPScenesAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ScenesAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPScenesAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPScenesAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Scenes::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ScenesAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPScenesAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Scenes::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ScenesAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPScenesAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ScenesAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPScenesAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPScenesAttributeListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Scenes::Attributes::AttributeList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<ScenesAttributeListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Scenes::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Scenes::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Scenes::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPSoftwareDiagnostics

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)resetWatermarksWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    SoftwareDiagnostics::Commands::ResetWatermarks::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeThreadMetricsWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSoftwareDiagnosticsThreadMetricsListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = SoftwareDiagnostics::Attributes::ThreadMetrics::TypeInfo;
            auto successFn = Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeThreadMetricsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPSoftwareDiagnosticsThreadMetricsListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::ThreadMetrics::TypeInfo;
            auto successFn = Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPSoftwareDiagnosticsThreadMetricsListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeThreadMetricsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSoftwareDiagnosticsThreadMetricsListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = SoftwareDiagnostics::Attributes::ThreadMetrics::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentHeapFreeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapFree::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentHeapFreeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapFree::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentHeapFreeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapFree::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentHeapUsedWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapUsed::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentHeapUsedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapUsed::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentHeapUsedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapUsed::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentHeapHighWatermarkWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentHeapHighWatermarkWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                                           params:(CHIPSubscribeParams * _Nullable)params
                                          subscriptionEstablished:
                                              (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                    reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentHeapHighWatermarkWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                       endpoint:(NSNumber *)endpoint
                                                          queue:(dispatch_queue_t)queue
                                              completionHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPSoftwareDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = SoftwareDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<SoftwareDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPSoftwareDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<SoftwareDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPSoftwareDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSoftwareDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = SoftwareDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<SoftwareDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPSoftwareDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = SoftwareDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<SoftwareDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPSoftwareDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<SoftwareDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPSoftwareDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSoftwareDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = SoftwareDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<SoftwareDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSoftwareDiagnosticsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = SoftwareDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<SoftwareDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPSoftwareDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<SoftwareDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPSoftwareDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSoftwareDiagnosticsAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = SoftwareDiagnostics::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<SoftwareDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = SoftwareDiagnostics::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = SoftwareDiagnostics::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = SoftwareDiagnostics::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = SoftwareDiagnostics::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = SoftwareDiagnostics::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPSwitch

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeNumberOfPositionsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Switch::Attributes::NumberOfPositions::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfPositionsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Switch::Attributes::NumberOfPositions::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfPositionsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Switch::Attributes::NumberOfPositions::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentPositionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Switch::Attributes::CurrentPosition::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentPositionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Switch::Attributes::CurrentPosition::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentPositionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Switch::Attributes::CurrentPosition::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMultiPressMaxWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Switch::Attributes::MultiPressMax::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMultiPressMaxWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Switch::Attributes::MultiPressMax::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMultiPressMaxWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Switch::Attributes::MultiPressMax::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPSwitchGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Switch::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<SwitchGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPSwitchGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Switch::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<SwitchGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPSwitchGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSwitchGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Switch::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<SwitchGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPSwitchAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Switch::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<SwitchAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPSwitchAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Switch::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<SwitchAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPSwitchAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSwitchAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Switch::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<SwitchAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSwitchAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Switch::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<SwitchAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPSwitchAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Switch::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<SwitchAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPSwitchAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPSwitchAttributeListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Switch::Attributes::AttributeList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<SwitchAttributeListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Switch::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Switch::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Switch::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Switch::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Switch::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Switch::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPTargetNavigator

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)navigateTargetWithParams:(CHIPTargetNavigatorClusterNavigateTargetParams *)params
               completionHandler:(void (^)(CHIPTargetNavigatorClusterNavigateTargetResponseParams * _Nullable data,
                                     NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TargetNavigator::Commands::NavigateTarget::Type request;
    request.target = params.target.unsignedCharValue;
    if (params.data != nil) {
        auto & definedValue_0 = request.data.Emplace();
        definedValue_0 = [self asCharSpan:params.data];
    }

    new CHIPTargetNavigatorClusterNavigateTargetResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTargetNavigatorClusterNavigateTargetResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeTargetListWithCompletionHandler:(void (^)(
                                                         NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTargetNavigatorTargetListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TargetNavigator::Attributes::TargetList::TypeInfo;
            auto successFn = Callback<TargetNavigatorTargetListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeTargetListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTargetNavigatorTargetListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TargetNavigator::Attributes::TargetList::TypeInfo;
            auto successFn = Callback<TargetNavigatorTargetListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTargetNavigatorTargetListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTargetListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTargetNavigatorTargetListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TargetNavigator::Attributes::TargetList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TargetNavigatorTargetListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentTargetWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TargetNavigator::Attributes::CurrentTarget::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentTargetWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TargetNavigator::Attributes::CurrentTarget::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentTargetWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TargetNavigator::Attributes::CurrentTarget::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPTargetNavigatorGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TargetNavigator::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<TargetNavigatorGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTargetNavigatorGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TargetNavigator::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<TargetNavigatorGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTargetNavigatorGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTargetNavigatorGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TargetNavigator::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TargetNavigatorGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPTargetNavigatorAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TargetNavigator::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<TargetNavigatorAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTargetNavigatorAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TargetNavigator::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<TargetNavigatorAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTargetNavigatorAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTargetNavigatorAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TargetNavigator::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TargetNavigatorAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTargetNavigatorAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TargetNavigator::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<TargetNavigatorAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTargetNavigatorAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TargetNavigator::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<TargetNavigatorAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTargetNavigatorAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTargetNavigatorAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TargetNavigator::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TargetNavigatorAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TargetNavigator::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TargetNavigator::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TargetNavigator::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPTemperatureMeasurement

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeMeasuredValueWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TemperatureMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TemperatureMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TemperatureMeasurement::Attributes::MinMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxMeasuredValueWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TemperatureMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxMeasuredValueWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TemperatureMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxMeasuredValueWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TemperatureMeasurement::Attributes::MaxMeasuredValue::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeToleranceWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TemperatureMeasurement::Attributes::Tolerance::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeToleranceWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TemperatureMeasurement::Attributes::Tolerance::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeToleranceWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TemperatureMeasurement::Attributes::Tolerance::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTemperatureMeasurementAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TemperatureMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<TemperatureMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTemperatureMeasurementAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TemperatureMeasurement::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<TemperatureMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTemperatureMeasurementAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTemperatureMeasurementAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TemperatureMeasurement::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TemperatureMeasurementAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPTestCluster

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)simpleStructEchoRequestWithParams:(CHIPTestClusterClusterSimpleStructEchoRequestParams *)params
                        completionHandler:(void (^)(CHIPTestClusterClusterSimpleStructResponseParams * _Nullable data,
                                              NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::SimpleStructEchoRequest::Type request;
    request.arg1.a = params.arg1.a.unsignedCharValue;
    request.arg1.b = params.arg1.b.boolValue;
    request.arg1.c = static_cast<std::remove_reference_t<decltype(request.arg1.c)>>(params.arg1.c.unsignedCharValue);
    request.arg1.d = [self asByteSpan:params.arg1.d];
    request.arg1.e = [self asCharSpan:params.arg1.e];
    request.arg1.f = static_cast<std::remove_reference_t<decltype(request.arg1.f)>>(params.arg1.f.unsignedCharValue);
    request.arg1.g = params.arg1.g.floatValue;
    request.arg1.h = params.arg1.h.doubleValue;

    new CHIPTestClusterClusterSimpleStructResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterSimpleStructResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::Test::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testAddArgumentsWithParams:(CHIPTestClusterClusterTestAddArgumentsParams *)params
                 completionHandler:(void (^)(CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable data,
                                       NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestAddArguments::Type request;
    request.arg1 = params.arg1.unsignedCharValue;
    request.arg2 = params.arg2.unsignedCharValue;

    new CHIPTestClusterClusterTestAddArgumentsResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterTestAddArgumentsResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testEmitTestEventRequestWithParams:(CHIPTestClusterClusterTestEmitTestEventRequestParams *)params
                         completionHandler:(void (^)(CHIPTestClusterClusterTestEmitTestEventResponseParams * _Nullable data,
                                               NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestEmitTestEventRequest::Type request;
    request.arg1 = params.arg1.unsignedCharValue;
    request.arg2 = static_cast<std::remove_reference_t<decltype(request.arg2)>>(params.arg2.unsignedCharValue);
    request.arg3 = params.arg3.boolValue;

    new CHIPTestClusterClusterTestEmitTestEventResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterTestEmitTestEventResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testEnumsRequestWithParams:(CHIPTestClusterClusterTestEnumsRequestParams *)params
                 completionHandler:(void (^)(CHIPTestClusterClusterTestEnumsResponseParams * _Nullable data,
                                       NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestEnumsRequest::Type request;
    request.arg1 = static_cast<std::remove_reference_t<decltype(request.arg1)>>(params.arg1.unsignedShortValue);
    request.arg2 = static_cast<std::remove_reference_t<decltype(request.arg2)>>(params.arg2.unsignedCharValue);

    new CHIPTestClusterClusterTestEnumsResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterTestEnumsResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testListInt8UArgumentRequestWithParams:(CHIPTestClusterClusterTestListInt8UArgumentRequestParams *)params
                             completionHandler:(void (^)(CHIPTestClusterClusterBooleanResponseParams * _Nullable data,
                                                   NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestListInt8UArgumentRequest::Type request;
    {
        using ListType_0 = std::remove_reference_t<decltype(request.arg1)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.arg1.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.arg1.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.arg1.count; ++i_0) {
                if (![params.arg1[i_0] isKindOfClass:[NSNumber class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (NSNumber *) params.arg1[i_0];
                listHolder_0->mList[i_0] = element_0.unsignedCharValue;
            }
            request.arg1 = ListType_0(listHolder_0->mList, params.arg1.count);
        } else {
            request.arg1 = ListType_0();
        }
    }

    new CHIPTestClusterClusterBooleanResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testListInt8UReverseRequestWithParams:(CHIPTestClusterClusterTestListInt8UReverseRequestParams *)params
                            completionHandler:(void (^)(CHIPTestClusterClusterTestListInt8UReverseResponseParams * _Nullable data,
                                                  NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestListInt8UReverseRequest::Type request;
    {
        using ListType_0 = std::remove_reference_t<decltype(request.arg1)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.arg1.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.arg1.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.arg1.count; ++i_0) {
                if (![params.arg1[i_0] isKindOfClass:[NSNumber class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (NSNumber *) params.arg1[i_0];
                listHolder_0->mList[i_0] = element_0.unsignedCharValue;
            }
            request.arg1 = ListType_0(listHolder_0->mList, params.arg1.count);
        } else {
            request.arg1 = ListType_0();
        }
    }

    new CHIPTestClusterClusterTestListInt8UReverseResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterTestListInt8UReverseResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testListNestedStructListArgumentRequestWithParams:
            (CHIPTestClusterClusterTestListNestedStructListArgumentRequestParams *)params
                                        completionHandler:(void (^)(CHIPTestClusterClusterBooleanResponseParams * _Nullable data,
                                                              NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestListNestedStructListArgumentRequest::Type request;
    {
        using ListType_0 = std::remove_reference_t<decltype(request.arg1)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.arg1.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.arg1.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.arg1.count; ++i_0) {
                if (![params.arg1[i_0] isKindOfClass:[CHIPTestClusterClusterNestedStructList class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (CHIPTestClusterClusterNestedStructList *) params.arg1[i_0];
                listHolder_0->mList[i_0].a = element_0.a.unsignedCharValue;
                listHolder_0->mList[i_0].b = element_0.b.boolValue;
                listHolder_0->mList[i_0].c.a = element_0.c.a.unsignedCharValue;
                listHolder_0->mList[i_0].c.b = element_0.c.b.boolValue;
                listHolder_0->mList[i_0].c.c
                    = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].c.c)>>(element_0.c.c.unsignedCharValue);
                listHolder_0->mList[i_0].c.d = [self asByteSpan:element_0.c.d];
                listHolder_0->mList[i_0].c.e = [self asCharSpan:element_0.c.e];
                listHolder_0->mList[i_0].c.f
                    = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].c.f)>>(element_0.c.f.unsignedCharValue);
                listHolder_0->mList[i_0].c.g = element_0.c.g.floatValue;
                listHolder_0->mList[i_0].c.h = element_0.c.h.doubleValue;
                {
                    using ListType_2 = std::remove_reference_t<decltype(listHolder_0->mList[i_0].d)>;
                    using ListMemberType_2 = ListMemberTypeGetter<ListType_2>::Type;
                    if (element_0.d.count != 0) {
                        auto * listHolder_2 = new ListHolder<ListMemberType_2>(element_0.d.count);
                        if (listHolder_2 == nullptr || listHolder_2->mList == nullptr) {
                            return;
                        }
                        listFreer.add(listHolder_2);
                        for (size_t i_2 = 0; i_2 < element_0.d.count; ++i_2) {
                            if (![element_0.d[i_2] isKindOfClass:[CHIPTestClusterClusterSimpleStruct class]]) {
                                // Wrong kind of value.
                                return;
                            }
                            auto element_2 = (CHIPTestClusterClusterSimpleStruct *) element_0.d[i_2];
                            listHolder_2->mList[i_2].a = element_2.a.unsignedCharValue;
                            listHolder_2->mList[i_2].b = element_2.b.boolValue;
                            listHolder_2->mList[i_2].c = static_cast<std::remove_reference_t<decltype(listHolder_2->mList[i_2].c)>>(
                                element_2.c.unsignedCharValue);
                            listHolder_2->mList[i_2].d = [self asByteSpan:element_2.d];
                            listHolder_2->mList[i_2].e = [self asCharSpan:element_2.e];
                            listHolder_2->mList[i_2].f = static_cast<std::remove_reference_t<decltype(listHolder_2->mList[i_2].f)>>(
                                element_2.f.unsignedCharValue);
                            listHolder_2->mList[i_2].g = element_2.g.floatValue;
                            listHolder_2->mList[i_2].h = element_2.h.doubleValue;
                        }
                        listHolder_0->mList[i_0].d = ListType_2(listHolder_2->mList, element_0.d.count);
                    } else {
                        listHolder_0->mList[i_0].d = ListType_2();
                    }
                }
                {
                    using ListType_2 = std::remove_reference_t<decltype(listHolder_0->mList[i_0].e)>;
                    using ListMemberType_2 = ListMemberTypeGetter<ListType_2>::Type;
                    if (element_0.e.count != 0) {
                        auto * listHolder_2 = new ListHolder<ListMemberType_2>(element_0.e.count);
                        if (listHolder_2 == nullptr || listHolder_2->mList == nullptr) {
                            return;
                        }
                        listFreer.add(listHolder_2);
                        for (size_t i_2 = 0; i_2 < element_0.e.count; ++i_2) {
                            if (![element_0.e[i_2] isKindOfClass:[NSNumber class]]) {
                                // Wrong kind of value.
                                return;
                            }
                            auto element_2 = (NSNumber *) element_0.e[i_2];
                            listHolder_2->mList[i_2] = element_2.unsignedIntValue;
                        }
                        listHolder_0->mList[i_0].e = ListType_2(listHolder_2->mList, element_0.e.count);
                    } else {
                        listHolder_0->mList[i_0].e = ListType_2();
                    }
                }
                {
                    using ListType_2 = std::remove_reference_t<decltype(listHolder_0->mList[i_0].f)>;
                    using ListMemberType_2 = ListMemberTypeGetter<ListType_2>::Type;
                    if (element_0.f.count != 0) {
                        auto * listHolder_2 = new ListHolder<ListMemberType_2>(element_0.f.count);
                        if (listHolder_2 == nullptr || listHolder_2->mList == nullptr) {
                            return;
                        }
                        listFreer.add(listHolder_2);
                        for (size_t i_2 = 0; i_2 < element_0.f.count; ++i_2) {
                            if (![element_0.f[i_2] isKindOfClass:[NSData class]]) {
                                // Wrong kind of value.
                                return;
                            }
                            auto element_2 = (NSData *) element_0.f[i_2];
                            listHolder_2->mList[i_2] = [self asByteSpan:element_2];
                        }
                        listHolder_0->mList[i_0].f = ListType_2(listHolder_2->mList, element_0.f.count);
                    } else {
                        listHolder_0->mList[i_0].f = ListType_2();
                    }
                }
                {
                    using ListType_2 = std::remove_reference_t<decltype(listHolder_0->mList[i_0].g)>;
                    using ListMemberType_2 = ListMemberTypeGetter<ListType_2>::Type;
                    if (element_0.g.count != 0) {
                        auto * listHolder_2 = new ListHolder<ListMemberType_2>(element_0.g.count);
                        if (listHolder_2 == nullptr || listHolder_2->mList == nullptr) {
                            return;
                        }
                        listFreer.add(listHolder_2);
                        for (size_t i_2 = 0; i_2 < element_0.g.count; ++i_2) {
                            if (![element_0.g[i_2] isKindOfClass:[NSNumber class]]) {
                                // Wrong kind of value.
                                return;
                            }
                            auto element_2 = (NSNumber *) element_0.g[i_2];
                            listHolder_2->mList[i_2] = element_2.unsignedCharValue;
                        }
                        listHolder_0->mList[i_0].g = ListType_2(listHolder_2->mList, element_0.g.count);
                    } else {
                        listHolder_0->mList[i_0].g = ListType_2();
                    }
                }
            }
            request.arg1 = ListType_0(listHolder_0->mList, params.arg1.count);
        } else {
            request.arg1 = ListType_0();
        }
    }

    new CHIPTestClusterClusterBooleanResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testListStructArgumentRequestWithParams:(CHIPTestClusterClusterTestListStructArgumentRequestParams *)params
                              completionHandler:(void (^)(CHIPTestClusterClusterBooleanResponseParams * _Nullable data,
                                                    NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestListStructArgumentRequest::Type request;
    {
        using ListType_0 = std::remove_reference_t<decltype(request.arg1)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.arg1.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.arg1.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.arg1.count; ++i_0) {
                if (![params.arg1[i_0] isKindOfClass:[CHIPTestClusterClusterSimpleStruct class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (CHIPTestClusterClusterSimpleStruct *) params.arg1[i_0];
                listHolder_0->mList[i_0].a = element_0.a.unsignedCharValue;
                listHolder_0->mList[i_0].b = element_0.b.boolValue;
                listHolder_0->mList[i_0].c
                    = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].c)>>(element_0.c.unsignedCharValue);
                listHolder_0->mList[i_0].d = [self asByteSpan:element_0.d];
                listHolder_0->mList[i_0].e = [self asCharSpan:element_0.e];
                listHolder_0->mList[i_0].f
                    = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].f)>>(element_0.f.unsignedCharValue);
                listHolder_0->mList[i_0].g = element_0.g.floatValue;
                listHolder_0->mList[i_0].h = element_0.h.doubleValue;
            }
            request.arg1 = ListType_0(listHolder_0->mList, params.arg1.count);
        } else {
            request.arg1 = ListType_0();
        }
    }

    new CHIPTestClusterClusterBooleanResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testNestedStructArgumentRequestWithParams:(CHIPTestClusterClusterTestNestedStructArgumentRequestParams *)params
                                completionHandler:(void (^)(CHIPTestClusterClusterBooleanResponseParams * _Nullable data,
                                                      NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestNestedStructArgumentRequest::Type request;
    request.arg1.a = params.arg1.a.unsignedCharValue;
    request.arg1.b = params.arg1.b.boolValue;
    request.arg1.c.a = params.arg1.c.a.unsignedCharValue;
    request.arg1.c.b = params.arg1.c.b.boolValue;
    request.arg1.c.c = static_cast<std::remove_reference_t<decltype(request.arg1.c.c)>>(params.arg1.c.c.unsignedCharValue);
    request.arg1.c.d = [self asByteSpan:params.arg1.c.d];
    request.arg1.c.e = [self asCharSpan:params.arg1.c.e];
    request.arg1.c.f = static_cast<std::remove_reference_t<decltype(request.arg1.c.f)>>(params.arg1.c.f.unsignedCharValue);
    request.arg1.c.g = params.arg1.c.g.floatValue;
    request.arg1.c.h = params.arg1.c.h.doubleValue;

    new CHIPTestClusterClusterBooleanResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testNestedStructListArgumentRequestWithParams:(CHIPTestClusterClusterTestNestedStructListArgumentRequestParams *)params
                                    completionHandler:(void (^)(CHIPTestClusterClusterBooleanResponseParams * _Nullable data,
                                                          NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestNestedStructListArgumentRequest::Type request;
    request.arg1.a = params.arg1.a.unsignedCharValue;
    request.arg1.b = params.arg1.b.boolValue;
    request.arg1.c.a = params.arg1.c.a.unsignedCharValue;
    request.arg1.c.b = params.arg1.c.b.boolValue;
    request.arg1.c.c = static_cast<std::remove_reference_t<decltype(request.arg1.c.c)>>(params.arg1.c.c.unsignedCharValue);
    request.arg1.c.d = [self asByteSpan:params.arg1.c.d];
    request.arg1.c.e = [self asCharSpan:params.arg1.c.e];
    request.arg1.c.f = static_cast<std::remove_reference_t<decltype(request.arg1.c.f)>>(params.arg1.c.f.unsignedCharValue);
    request.arg1.c.g = params.arg1.c.g.floatValue;
    request.arg1.c.h = params.arg1.c.h.doubleValue;
    {
        using ListType_1 = std::remove_reference_t<decltype(request.arg1.d)>;
        using ListMemberType_1 = ListMemberTypeGetter<ListType_1>::Type;
        if (params.arg1.d.count != 0) {
            auto * listHolder_1 = new ListHolder<ListMemberType_1>(params.arg1.d.count);
            if (listHolder_1 == nullptr || listHolder_1->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_1);
            for (size_t i_1 = 0; i_1 < params.arg1.d.count; ++i_1) {
                if (![params.arg1.d[i_1] isKindOfClass:[CHIPTestClusterClusterSimpleStruct class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_1 = (CHIPTestClusterClusterSimpleStruct *) params.arg1.d[i_1];
                listHolder_1->mList[i_1].a = element_1.a.unsignedCharValue;
                listHolder_1->mList[i_1].b = element_1.b.boolValue;
                listHolder_1->mList[i_1].c
                    = static_cast<std::remove_reference_t<decltype(listHolder_1->mList[i_1].c)>>(element_1.c.unsignedCharValue);
                listHolder_1->mList[i_1].d = [self asByteSpan:element_1.d];
                listHolder_1->mList[i_1].e = [self asCharSpan:element_1.e];
                listHolder_1->mList[i_1].f
                    = static_cast<std::remove_reference_t<decltype(listHolder_1->mList[i_1].f)>>(element_1.f.unsignedCharValue);
                listHolder_1->mList[i_1].g = element_1.g.floatValue;
                listHolder_1->mList[i_1].h = element_1.h.doubleValue;
            }
            request.arg1.d = ListType_1(listHolder_1->mList, params.arg1.d.count);
        } else {
            request.arg1.d = ListType_1();
        }
    }
    {
        using ListType_1 = std::remove_reference_t<decltype(request.arg1.e)>;
        using ListMemberType_1 = ListMemberTypeGetter<ListType_1>::Type;
        if (params.arg1.e.count != 0) {
            auto * listHolder_1 = new ListHolder<ListMemberType_1>(params.arg1.e.count);
            if (listHolder_1 == nullptr || listHolder_1->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_1);
            for (size_t i_1 = 0; i_1 < params.arg1.e.count; ++i_1) {
                if (![params.arg1.e[i_1] isKindOfClass:[NSNumber class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_1 = (NSNumber *) params.arg1.e[i_1];
                listHolder_1->mList[i_1] = element_1.unsignedIntValue;
            }
            request.arg1.e = ListType_1(listHolder_1->mList, params.arg1.e.count);
        } else {
            request.arg1.e = ListType_1();
        }
    }
    {
        using ListType_1 = std::remove_reference_t<decltype(request.arg1.f)>;
        using ListMemberType_1 = ListMemberTypeGetter<ListType_1>::Type;
        if (params.arg1.f.count != 0) {
            auto * listHolder_1 = new ListHolder<ListMemberType_1>(params.arg1.f.count);
            if (listHolder_1 == nullptr || listHolder_1->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_1);
            for (size_t i_1 = 0; i_1 < params.arg1.f.count; ++i_1) {
                if (![params.arg1.f[i_1] isKindOfClass:[NSData class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_1 = (NSData *) params.arg1.f[i_1];
                listHolder_1->mList[i_1] = [self asByteSpan:element_1];
            }
            request.arg1.f = ListType_1(listHolder_1->mList, params.arg1.f.count);
        } else {
            request.arg1.f = ListType_1();
        }
    }
    {
        using ListType_1 = std::remove_reference_t<decltype(request.arg1.g)>;
        using ListMemberType_1 = ListMemberTypeGetter<ListType_1>::Type;
        if (params.arg1.g.count != 0) {
            auto * listHolder_1 = new ListHolder<ListMemberType_1>(params.arg1.g.count);
            if (listHolder_1 == nullptr || listHolder_1->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_1);
            for (size_t i_1 = 0; i_1 < params.arg1.g.count; ++i_1) {
                if (![params.arg1.g[i_1] isKindOfClass:[NSNumber class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_1 = (NSNumber *) params.arg1.g[i_1];
                listHolder_1->mList[i_1] = element_1.unsignedCharValue;
            }
            request.arg1.g = ListType_1(listHolder_1->mList, params.arg1.g.count);
        } else {
            request.arg1.g = ListType_1();
        }
    }

    new CHIPTestClusterClusterBooleanResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testNotHandledWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestNotHandled::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testNullableOptionalRequestWithParams:(CHIPTestClusterClusterTestNullableOptionalRequestParams * _Nullable)params
                            completionHandler:(void (^)(CHIPTestClusterClusterTestNullableOptionalResponseParams * _Nullable data,
                                                  NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestNullableOptionalRequest::Type request;
    if (params != nil) {
        if (params.arg1 != nil) {
            auto & definedValue_0 = request.arg1.Emplace();
            if (params.arg1 == nil) {
                definedValue_0.SetNull();
            } else {
                auto & nonNullValue_1 = definedValue_0.SetNonNull();
                nonNullValue_1 = params.arg1.unsignedCharValue;
            }
        }
    }

    new CHIPTestClusterClusterTestNullableOptionalResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterTestNullableOptionalResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testSimpleOptionalArgumentRequestWithParams:
            (CHIPTestClusterClusterTestSimpleOptionalArgumentRequestParams * _Nullable)params
                                  completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type request;
    if (params != nil) {
        if (params.arg1 != nil) {
            auto & definedValue_0 = request.arg1.Emplace();
            definedValue_0 = params.arg1.boolValue;
        }
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testSpecificWithCompletionHandler:(void (^)(CHIPTestClusterClusterTestSpecificResponseParams * _Nullable data,
                                              NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestSpecific::Type request;

    new CHIPTestClusterClusterTestSpecificResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterTestSpecificResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testStructArgumentRequestWithParams:(CHIPTestClusterClusterTestStructArgumentRequestParams *)params
                          completionHandler:(void (^)(CHIPTestClusterClusterBooleanResponseParams * _Nullable data,
                                                NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestStructArgumentRequest::Type request;
    request.arg1.a = params.arg1.a.unsignedCharValue;
    request.arg1.b = params.arg1.b.boolValue;
    request.arg1.c = static_cast<std::remove_reference_t<decltype(request.arg1.c)>>(params.arg1.c.unsignedCharValue);
    request.arg1.d = [self asByteSpan:params.arg1.d];
    request.arg1.e = [self asCharSpan:params.arg1.e];
    request.arg1.f = static_cast<std::remove_reference_t<decltype(request.arg1.f)>>(params.arg1.f.unsignedCharValue);
    request.arg1.g = params.arg1.g.floatValue;
    request.arg1.h = params.arg1.h.doubleValue;

    new CHIPTestClusterClusterBooleanResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPTestClusterClusterBooleanResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)testUnknownCommandWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TestUnknownCommand::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)timedInvokeRequestWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    TestCluster::Commands::TimedInvokeRequest::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)readAttributeBooleanWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Boolean::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeBooleanWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Boolean::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeBooleanWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Boolean::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBooleanWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Boolean::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBitmap8WithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterBitmap8AttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::Bitmap8::TypeInfo;
            auto successFn = Callback<TestClusterBitmap8AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeBitmap8WithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Bitmap8::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeBitmap8WithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterBitmap8AttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Bitmap8::TypeInfo;
            auto successFn = Callback<TestClusterBitmap8AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterBitmap8AttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBitmap8WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterBitmap8AttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Bitmap8::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<TestClusterBitmap8AttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBitmap16WithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterBitmap16AttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::Bitmap16::TypeInfo;
            auto successFn = Callback<TestClusterBitmap16AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeBitmap16WithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Bitmap16::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedShortValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeBitmap16WithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterBitmap16AttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Bitmap16::TypeInfo;
            auto successFn = Callback<TestClusterBitmap16AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterBitmap16AttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBitmap16WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterBitmap16AttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Bitmap16::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<TestClusterBitmap16AttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBitmap32WithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterBitmap32AttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::Bitmap32::TypeInfo;
            auto successFn = Callback<TestClusterBitmap32AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeBitmap32WithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Bitmap32::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedIntValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeBitmap32WithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterBitmap32AttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Bitmap32::TypeInfo;
            auto successFn = Callback<TestClusterBitmap32AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterBitmap32AttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBitmap32WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterBitmap32AttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Bitmap32::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<TestClusterBitmap32AttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBitmap64WithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterBitmap64AttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::Bitmap64::TypeInfo;
            auto successFn = Callback<TestClusterBitmap64AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeBitmap64WithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Bitmap64::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedLongLongValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeBitmap64WithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterBitmap64AttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Bitmap64::TypeInfo;
            auto successFn = Callback<TestClusterBitmap64AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterBitmap64AttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBitmap64WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterBitmap64AttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Bitmap64::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<TestClusterBitmap64AttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt8uWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int8u::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt8uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int8u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt8uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int8u::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt8uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int8u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt16uWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int16u::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt16uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int16u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt16uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int16u::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt16uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int16u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt24uWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int24u::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt24uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int24u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedIntValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt24uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int24u::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt24uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int24u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt32uWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int32u::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt32uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int32u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedIntValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt32uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int32u::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt32uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int32u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt40uWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int40u::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt40uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int40u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedLongLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt40uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int40u::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt40uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int40u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt48uWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int48u::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt48uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int48u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedLongLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt48uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int48u::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt48uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int48u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt56uWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int56u::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt56uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int56u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedLongLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt56uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int56u::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt56uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int56u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt64uWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int64u::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt64uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int64u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedLongLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt64uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int64u::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt64uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int64u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt8sWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int8s::TypeInfo;
        auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt8sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int8s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.charValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt8sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int8s::TypeInfo;
            auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt8sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int8s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt16sWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int16s::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt16sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int16s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.shortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt16sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int16s::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt16sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int16s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt24sWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int24s::TypeInfo;
        auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt24sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int24s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.intValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt24sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int24s::TypeInfo;
            auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt24sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int24s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt32sWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int32s::TypeInfo;
        auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt32sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int32s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.intValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt32sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int32s::TypeInfo;
            auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt32sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int32s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt40sWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int40s::TypeInfo;
        auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt40sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int40s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.longLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt40sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int40s::TypeInfo;
            auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt40sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int40s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt48sWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int48s::TypeInfo;
        auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt48sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int48s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.longLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt48sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int48s::TypeInfo;
            auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt48sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int48s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt56sWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int56s::TypeInfo;
        auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt56sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int56s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.longLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt56sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int56s::TypeInfo;
            auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt56sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int56s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInt64sWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Int64s::TypeInfo;
        auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeInt64sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Int64s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.longLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeInt64sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Int64s::TypeInfo;
            auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInt64sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Int64s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEnum8WithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Enum8::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeEnum8WithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Enum8::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEnum8WithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Enum8::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEnum8WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Enum8::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEnum16WithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Enum16::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeEnum16WithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Enum16::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEnum16WithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Enum16::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEnum16WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Enum16::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeFloatSingleWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFloatAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::FloatSingle::TypeInfo;
        auto successFn = Callback<FloatAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeFloatSingleWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::FloatSingle::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.floatValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeFloatSingleWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPFloatAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::FloatSingle::TypeInfo;
            auto successFn = Callback<FloatAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPFloatAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFloatSingleWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPFloatAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::FloatSingle::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<FloatAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeFloatDoubleWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoubleAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::FloatDouble::TypeInfo;
        auto successFn = Callback<DoubleAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeFloatDoubleWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::FloatDouble::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.doubleValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeFloatDoubleWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPDoubleAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::FloatDouble::TypeInfo;
            auto successFn = Callback<DoubleAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPDoubleAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFloatDoubleWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPDoubleAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::FloatDouble::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<DoubleAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOctetStringWithCompletionHandler:(void (^)(
                                                          NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOctetStringAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::OctetString::TypeInfo;
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeOctetStringWithValue:(NSData * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::OctetString::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asByteSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOctetStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSData * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOctetStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::OctetString::TypeInfo;
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOctetStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:(void (^)(NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOctetStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::OctetString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeListInt8uWithCompletionHandler:(void (^)(
                                                        NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListInt8uListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::ListInt8u::TypeInfo;
            auto successFn = Callback<TestClusterListInt8uListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeListInt8uWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::ListInt8u::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[NSNumber class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (NSNumber *) value[i_0];
                        listHolder_0->mList[i_0] = element_0.unsignedCharValue;
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeListInt8uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterListInt8uListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::ListInt8u::TypeInfo;
            auto successFn = Callback<TestClusterListInt8uListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterListInt8uListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeListInt8uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListInt8uListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::ListInt8u::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterListInt8uListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeListOctetStringWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListOctetStringListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::ListOctetString::TypeInfo;
            auto successFn = Callback<TestClusterListOctetStringListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeListOctetStringWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::ListOctetString::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[NSData class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (NSData *) value[i_0];
                        listHolder_0->mList[i_0] = [self asByteSpan:element_0];
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeListOctetStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterListOctetStringListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::ListOctetString::TypeInfo;
            auto successFn = Callback<TestClusterListOctetStringListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterListOctetStringListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeListOctetStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListOctetStringListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::ListOctetString::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterListOctetStringListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeListStructOctetStringWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListStructOctetStringListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::ListStructOctetString::TypeInfo;
            auto successFn = Callback<TestClusterListStructOctetStringListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeListStructOctetStringWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::ListStructOctetString::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPTestClusterClusterTestListStructOctet class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPTestClusterClusterTestListStructOctet *) value[i_0];
                        listHolder_0->mList[i_0].fabricIndex = element_0.fabricIndex.unsignedLongLongValue;
                        listHolder_0->mList[i_0].operationalCert = [self asByteSpan:element_0.operationalCert];
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeListStructOctetStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterListStructOctetStringListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::ListStructOctetString::TypeInfo;
            auto successFn = Callback<TestClusterListStructOctetStringListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterListStructOctetStringListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeListStructOctetStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListStructOctetStringListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::ListStructOctetString::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterListStructOctetStringListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeLongOctetStringWithCompletionHandler:(void (^)(
                                                              NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOctetStringAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::LongOctetString::TypeInfo;
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeLongOctetStringWithValue:(NSData * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::LongOctetString::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asByteSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLongOctetStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSData * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOctetStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::LongOctetString::TypeInfo;
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLongOctetStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOctetStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::LongOctetString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCharStringWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::CharString::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeCharStringWithValue:(NSString * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::CharString::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asCharSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCharStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::CharString::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCharStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::CharString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLongCharStringWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::LongCharString::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeLongCharStringWithValue:(NSString * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::LongCharString::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = [self asCharSpan:value];
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLongCharStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::LongCharString::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLongCharStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::LongCharString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEpochUsWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::EpochUs::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeEpochUsWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::EpochUs::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedLongLongValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEpochUsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::EpochUs::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEpochUsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::EpochUs::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEpochSWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::EpochS::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeEpochSWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::EpochS::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedIntValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEpochSWithMinInterval:(NSNumber * _Nonnull)minInterval
                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                         params:(CHIPSubscribeParams * _Nullable)params
                        subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                  reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::EpochS::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEpochSWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                     endpoint:(NSNumber *)endpoint
                                        queue:(dispatch_queue_t)queue
                            completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::EpochS::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeVendorIdWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPVendorIdAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::VendorId::TypeInfo;
        auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeVendorIdWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::VendorId::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedShortValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeVendorIdWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPVendorIdAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::VendorId::TypeInfo;
            auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPVendorIdAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeVendorIdWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPVendorIdAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::VendorId::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<VendorIdAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeListNullablesAndOptionalsStructWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                              NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListNullablesAndOptionalsStructListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::ListNullablesAndOptionalsStruct::TypeInfo;
            auto successFn = Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeListNullablesAndOptionalsStructWithValue:(NSArray * _Nonnull)value
                                             completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::ListNullablesAndOptionalsStruct::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPTestClusterClusterNullablesAndOptionalsStruct class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPTestClusterClusterNullablesAndOptionalsStruct *) value[i_0];
                        if (element_0.nullableInt == nil) {
                            listHolder_0->mList[i_0].nullableInt.SetNull();
                        } else {
                            auto & nonNullValue_2 = listHolder_0->mList[i_0].nullableInt.SetNonNull();
                            nonNullValue_2 = element_0.nullableInt.unsignedShortValue;
                        }
                        if (element_0.optionalInt != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].optionalInt.Emplace();
                            definedValue_2 = element_0.optionalInt.unsignedShortValue;
                        }
                        if (element_0.nullableOptionalInt != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].nullableOptionalInt.Emplace();
                            if (element_0.nullableOptionalInt == nil) {
                                definedValue_2.SetNull();
                            } else {
                                auto & nonNullValue_3 = definedValue_2.SetNonNull();
                                nonNullValue_3 = element_0.nullableOptionalInt.unsignedShortValue;
                            }
                        }
                        if (element_0.nullableString == nil) {
                            listHolder_0->mList[i_0].nullableString.SetNull();
                        } else {
                            auto & nonNullValue_2 = listHolder_0->mList[i_0].nullableString.SetNonNull();
                            nonNullValue_2 = [self asCharSpan:element_0.nullableString];
                        }
                        if (element_0.optionalString != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].optionalString.Emplace();
                            definedValue_2 = [self asCharSpan:element_0.optionalString];
                        }
                        if (element_0.nullableOptionalString != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].nullableOptionalString.Emplace();
                            if (element_0.nullableOptionalString == nil) {
                                definedValue_2.SetNull();
                            } else {
                                auto & nonNullValue_3 = definedValue_2.SetNonNull();
                                nonNullValue_3 = [self asCharSpan:element_0.nullableOptionalString];
                            }
                        }
                        if (element_0.nullableStruct == nil) {
                            listHolder_0->mList[i_0].nullableStruct.SetNull();
                        } else {
                            auto & nonNullValue_2 = listHolder_0->mList[i_0].nullableStruct.SetNonNull();
                            nonNullValue_2.a = element_0.nullableStruct.a.unsignedCharValue;
                            nonNullValue_2.b = element_0.nullableStruct.b.boolValue;
                            nonNullValue_2.c = static_cast<std::remove_reference_t<decltype(nonNullValue_2.c)>>(
                                element_0.nullableStruct.c.unsignedCharValue);
                            nonNullValue_2.d = [self asByteSpan:element_0.nullableStruct.d];
                            nonNullValue_2.e = [self asCharSpan:element_0.nullableStruct.e];
                            nonNullValue_2.f = static_cast<std::remove_reference_t<decltype(nonNullValue_2.f)>>(
                                element_0.nullableStruct.f.unsignedCharValue);
                            nonNullValue_2.g = element_0.nullableStruct.g.floatValue;
                            nonNullValue_2.h = element_0.nullableStruct.h.doubleValue;
                        }
                        if (element_0.optionalStruct != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].optionalStruct.Emplace();
                            definedValue_2.a = element_0.optionalStruct.a.unsignedCharValue;
                            definedValue_2.b = element_0.optionalStruct.b.boolValue;
                            definedValue_2.c = static_cast<std::remove_reference_t<decltype(definedValue_2.c)>>(
                                element_0.optionalStruct.c.unsignedCharValue);
                            definedValue_2.d = [self asByteSpan:element_0.optionalStruct.d];
                            definedValue_2.e = [self asCharSpan:element_0.optionalStruct.e];
                            definedValue_2.f = static_cast<std::remove_reference_t<decltype(definedValue_2.f)>>(
                                element_0.optionalStruct.f.unsignedCharValue);
                            definedValue_2.g = element_0.optionalStruct.g.floatValue;
                            definedValue_2.h = element_0.optionalStruct.h.doubleValue;
                        }
                        if (element_0.nullableOptionalStruct != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].nullableOptionalStruct.Emplace();
                            if (element_0.nullableOptionalStruct == nil) {
                                definedValue_2.SetNull();
                            } else {
                                auto & nonNullValue_3 = definedValue_2.SetNonNull();
                                nonNullValue_3.a = element_0.nullableOptionalStruct.a.unsignedCharValue;
                                nonNullValue_3.b = element_0.nullableOptionalStruct.b.boolValue;
                                nonNullValue_3.c = static_cast<std::remove_reference_t<decltype(nonNullValue_3.c)>>(
                                    element_0.nullableOptionalStruct.c.unsignedCharValue);
                                nonNullValue_3.d = [self asByteSpan:element_0.nullableOptionalStruct.d];
                                nonNullValue_3.e = [self asCharSpan:element_0.nullableOptionalStruct.e];
                                nonNullValue_3.f = static_cast<std::remove_reference_t<decltype(nonNullValue_3.f)>>(
                                    element_0.nullableOptionalStruct.f.unsignedCharValue);
                                nonNullValue_3.g = element_0.nullableOptionalStruct.g.floatValue;
                                nonNullValue_3.h = element_0.nullableOptionalStruct.h.doubleValue;
                            }
                        }
                        if (element_0.nullableList == nil) {
                            listHolder_0->mList[i_0].nullableList.SetNull();
                        } else {
                            auto & nonNullValue_2 = listHolder_0->mList[i_0].nullableList.SetNonNull();
                            {
                                using ListType_3 = std::remove_reference_t<decltype(nonNullValue_2)>;
                                using ListMemberType_3 = ListMemberTypeGetter<ListType_3>::Type;
                                if (element_0.nullableList.count != 0) {
                                    auto * listHolder_3 = new ListHolder<ListMemberType_3>(element_0.nullableList.count);
                                    if (listHolder_3 == nullptr || listHolder_3->mList == nullptr) {
                                        return CHIP_ERROR_INVALID_ARGUMENT;
                                    }
                                    listFreer.add(listHolder_3);
                                    for (size_t i_3 = 0; i_3 < element_0.nullableList.count; ++i_3) {
                                        if (![element_0.nullableList[i_3] isKindOfClass:[NSNumber class]]) {
                                            // Wrong kind of value.
                                            return CHIP_ERROR_INVALID_ARGUMENT;
                                        }
                                        auto element_3 = (NSNumber *) element_0.nullableList[i_3];
                                        listHolder_3->mList[i_3]
                                            = static_cast<std::remove_reference_t<decltype(listHolder_3->mList[i_3])>>(
                                                element_3.unsignedCharValue);
                                    }
                                    nonNullValue_2 = ListType_3(listHolder_3->mList, element_0.nullableList.count);
                                } else {
                                    nonNullValue_2 = ListType_3();
                                }
                            }
                        }
                        if (element_0.optionalList != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].optionalList.Emplace();
                            {
                                using ListType_3 = std::remove_reference_t<decltype(definedValue_2)>;
                                using ListMemberType_3 = ListMemberTypeGetter<ListType_3>::Type;
                                if (element_0.optionalList.count != 0) {
                                    auto * listHolder_3 = new ListHolder<ListMemberType_3>(element_0.optionalList.count);
                                    if (listHolder_3 == nullptr || listHolder_3->mList == nullptr) {
                                        return CHIP_ERROR_INVALID_ARGUMENT;
                                    }
                                    listFreer.add(listHolder_3);
                                    for (size_t i_3 = 0; i_3 < element_0.optionalList.count; ++i_3) {
                                        if (![element_0.optionalList[i_3] isKindOfClass:[NSNumber class]]) {
                                            // Wrong kind of value.
                                            return CHIP_ERROR_INVALID_ARGUMENT;
                                        }
                                        auto element_3 = (NSNumber *) element_0.optionalList[i_3];
                                        listHolder_3->mList[i_3]
                                            = static_cast<std::remove_reference_t<decltype(listHolder_3->mList[i_3])>>(
                                                element_3.unsignedCharValue);
                                    }
                                    definedValue_2 = ListType_3(listHolder_3->mList, element_0.optionalList.count);
                                } else {
                                    definedValue_2 = ListType_3();
                                }
                            }
                        }
                        if (element_0.nullableOptionalList != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].nullableOptionalList.Emplace();
                            if (element_0.nullableOptionalList == nil) {
                                definedValue_2.SetNull();
                            } else {
                                auto & nonNullValue_3 = definedValue_2.SetNonNull();
                                {
                                    using ListType_4 = std::remove_reference_t<decltype(nonNullValue_3)>;
                                    using ListMemberType_4 = ListMemberTypeGetter<ListType_4>::Type;
                                    if (element_0.nullableOptionalList.count != 0) {
                                        auto * listHolder_4
                                            = new ListHolder<ListMemberType_4>(element_0.nullableOptionalList.count);
                                        if (listHolder_4 == nullptr || listHolder_4->mList == nullptr) {
                                            return CHIP_ERROR_INVALID_ARGUMENT;
                                        }
                                        listFreer.add(listHolder_4);
                                        for (size_t i_4 = 0; i_4 < element_0.nullableOptionalList.count; ++i_4) {
                                            if (![element_0.nullableOptionalList[i_4] isKindOfClass:[NSNumber class]]) {
                                                // Wrong kind of value.
                                                return CHIP_ERROR_INVALID_ARGUMENT;
                                            }
                                            auto element_4 = (NSNumber *) element_0.nullableOptionalList[i_4];
                                            listHolder_4->mList[i_4]
                                                = static_cast<std::remove_reference_t<decltype(listHolder_4->mList[i_4])>>(
                                                    element_4.unsignedCharValue);
                                        }
                                        nonNullValue_3 = ListType_4(listHolder_4->mList, element_0.nullableOptionalList.count);
                                    } else {
                                        nonNullValue_3 = ListType_4();
                                    }
                                }
                            }
                        }
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeListNullablesAndOptionalsStructWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                  params:(CHIPSubscribeParams * _Nullable)params
                                                 subscriptionEstablished:
                                                     (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                           reportHandler:(void (^)(NSArray * _Nullable value,
                                                                             NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterListNullablesAndOptionalsStructListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::ListNullablesAndOptionalsStruct::TypeInfo;
            auto successFn = Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterListNullablesAndOptionalsStructListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeListNullablesAndOptionalsStructWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                              endpoint:(NSNumber *)endpoint
                                                                 queue:(dispatch_queue_t)queue
                                                     completionHandler:(void (^)(NSArray * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListNullablesAndOptionalsStructListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::ListNullablesAndOptionalsStruct::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeEnumAttrWithCompletionHandler:(void (^)(
                                                       NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterClusterSimpleEnumAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::EnumAttr::TypeInfo;
            auto successFn = Callback<TestClusterClusterSimpleEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeEnumAttrWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::EnumAttr::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEnumAttrWithMinInterval:(NSNumber * _Nonnull)minInterval
                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                           params:(CHIPSubscribeParams * _Nullable)params
                          subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                    reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterClusterSimpleEnumAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::EnumAttr::TypeInfo;
            auto successFn = Callback<TestClusterClusterSimpleEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterClusterSimpleEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEnumAttrWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                       endpoint:(NSNumber *)endpoint
                                          queue:(dispatch_queue_t)queue
                              completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterClusterSimpleEnumAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::EnumAttr::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterClusterSimpleEnumAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeStructAttrWithCompletionHandler:(void (^)(CHIPTestClusterClusterSimpleStruct * _Nullable value,
                                                         NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterStructAttrStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::StructAttr::TypeInfo;
            auto successFn = Callback<TestClusterStructAttrStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeStructAttrWithValue:(CHIPTestClusterClusterSimpleStruct * _Nonnull)value
                        completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::StructAttr::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue.a = value.a.unsignedCharValue;
            cppValue.b = value.b.boolValue;
            cppValue.c = static_cast<std::remove_reference_t<decltype(cppValue.c)>>(value.c.unsignedCharValue);
            cppValue.d = [self asByteSpan:value.d];
            cppValue.e = [self asCharSpan:value.e];
            cppValue.f = static_cast<std::remove_reference_t<decltype(cppValue.f)>>(value.f.unsignedCharValue);
            cppValue.g = value.g.floatValue;
            cppValue.h = value.h.doubleValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeStructAttrWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(CHIPTestClusterClusterSimpleStruct * _Nullable value,
                                                        NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterStructAttrStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::StructAttr::TypeInfo;
            auto successFn = Callback<TestClusterStructAttrStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterStructAttrStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStructAttrWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(CHIPTestClusterClusterSimpleStruct * _Nullable value,
                                                      NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterStructAttrStructAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::StructAttr::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterStructAttrStructAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeRangeRestrictedInt8uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeRangeRestrictedInt8uWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeRangeRestrictedInt8uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRangeRestrictedInt8uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt8u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRangeRestrictedInt8sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt8sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo;
        auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeRangeRestrictedInt8sWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.charValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeRangeRestrictedInt8sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo;
            auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRangeRestrictedInt8sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt8s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRangeRestrictedInt16uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeRangeRestrictedInt16uWithValue:(NSNumber * _Nonnull)value
                                   completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedShortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeRangeRestrictedInt16uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRangeRestrictedInt16uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt16u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRangeRestrictedInt16sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeRangeRestrictedInt16sWithValue:(NSNumber * _Nonnull)value
                                   completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.shortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeRangeRestrictedInt16sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRangeRestrictedInt16sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::RangeRestrictedInt16s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeListLongOctetStringWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListLongOctetStringListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::ListLongOctetString::TypeInfo;
            auto successFn = Callback<TestClusterListLongOctetStringListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeListLongOctetStringWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::ListLongOctetString::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[NSData class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (NSData *) value[i_0];
                        listHolder_0->mList[i_0] = [self asByteSpan:element_0];
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeListLongOctetStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterListLongOctetStringListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::ListLongOctetString::TypeInfo;
            auto successFn = Callback<TestClusterListLongOctetStringListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterListLongOctetStringListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeListLongOctetStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListLongOctetStringListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::ListLongOctetString::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterListLongOctetStringListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeListFabricScopedWithParams:(CHIPReadParams * _Nullable)params
                              completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListFabricScopedListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::ListFabricScoped::TypeInfo;
            auto successFn = Callback<TestClusterListFabricScopedListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue]);
        });
}

- (void)writeAttributeListFabricScopedWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::ListFabricScoped::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPTestClusterClusterTestFabricScoped class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPTestClusterClusterTestFabricScoped *) value[i_0];
                        listHolder_0->mList[i_0].fabricSensitiveInt8u = element_0.fabricSensitiveInt8u.unsignedCharValue;
                        if (element_0.optionalFabricSensitiveInt8u != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].optionalFabricSensitiveInt8u.Emplace();
                            definedValue_2 = element_0.optionalFabricSensitiveInt8u.unsignedCharValue;
                        }
                        if (element_0.nullableFabricSensitiveInt8u == nil) {
                            listHolder_0->mList[i_0].nullableFabricSensitiveInt8u.SetNull();
                        } else {
                            auto & nonNullValue_2 = listHolder_0->mList[i_0].nullableFabricSensitiveInt8u.SetNonNull();
                            nonNullValue_2 = element_0.nullableFabricSensitiveInt8u.unsignedCharValue;
                        }
                        if (element_0.nullableOptionalFabricSensitiveInt8u != nil) {
                            auto & definedValue_2 = listHolder_0->mList[i_0].nullableOptionalFabricSensitiveInt8u.Emplace();
                            if (element_0.nullableOptionalFabricSensitiveInt8u == nil) {
                                definedValue_2.SetNull();
                            } else {
                                auto & nonNullValue_3 = definedValue_2.SetNonNull();
                                nonNullValue_3 = element_0.nullableOptionalFabricSensitiveInt8u.unsignedCharValue;
                            }
                        }
                        listHolder_0->mList[i_0].fabricSensitiveCharString = [self asCharSpan:element_0.fabricSensitiveCharString];
                        listHolder_0->mList[i_0].fabricSensitiveStruct.a = element_0.fabricSensitiveStruct.a.unsignedCharValue;
                        listHolder_0->mList[i_0].fabricSensitiveStruct.b = element_0.fabricSensitiveStruct.b.boolValue;
                        listHolder_0->mList[i_0].fabricSensitiveStruct.c
                            = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].fabricSensitiveStruct.c)>>(
                                element_0.fabricSensitiveStruct.c.unsignedCharValue);
                        listHolder_0->mList[i_0].fabricSensitiveStruct.d = [self asByteSpan:element_0.fabricSensitiveStruct.d];
                        listHolder_0->mList[i_0].fabricSensitiveStruct.e = [self asCharSpan:element_0.fabricSensitiveStruct.e];
                        listHolder_0->mList[i_0].fabricSensitiveStruct.f
                            = static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].fabricSensitiveStruct.f)>>(
                                element_0.fabricSensitiveStruct.f.unsignedCharValue);
                        listHolder_0->mList[i_0].fabricSensitiveStruct.g = element_0.fabricSensitiveStruct.g.floatValue;
                        listHolder_0->mList[i_0].fabricSensitiveStruct.h = element_0.fabricSensitiveStruct.h.doubleValue;
                        {
                            using ListType_2 = std::remove_reference_t<decltype(listHolder_0->mList[i_0].fabricSensitiveInt8uList)>;
                            using ListMemberType_2 = ListMemberTypeGetter<ListType_2>::Type;
                            if (element_0.fabricSensitiveInt8uList.count != 0) {
                                auto * listHolder_2 = new ListHolder<ListMemberType_2>(element_0.fabricSensitiveInt8uList.count);
                                if (listHolder_2 == nullptr || listHolder_2->mList == nullptr) {
                                    return CHIP_ERROR_INVALID_ARGUMENT;
                                }
                                listFreer.add(listHolder_2);
                                for (size_t i_2 = 0; i_2 < element_0.fabricSensitiveInt8uList.count; ++i_2) {
                                    if (![element_0.fabricSensitiveInt8uList[i_2] isKindOfClass:[NSNumber class]]) {
                                        // Wrong kind of value.
                                        return CHIP_ERROR_INVALID_ARGUMENT;
                                    }
                                    auto element_2 = (NSNumber *) element_0.fabricSensitiveInt8uList[i_2];
                                    listHolder_2->mList[i_2] = element_2.unsignedCharValue;
                                }
                                listHolder_0->mList[i_0].fabricSensitiveInt8uList
                                    = ListType_2(listHolder_2->mList, element_0.fabricSensitiveInt8uList.count);
                            } else {
                                listHolder_0->mList[i_0].fabricSensitiveInt8uList = ListType_2();
                            }
                        }
                        listHolder_0->mList[i_0].fabricIndex = element_0.fabricIndex.unsignedCharValue;
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeListFabricScopedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterListFabricScopedListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::ListFabricScoped::TypeInfo;
            auto successFn = Callback<TestClusterListFabricScopedListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterListFabricScopedListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeListFabricScopedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterListFabricScopedListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::ListFabricScoped::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterListFabricScopedListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeTimedWriteBooleanWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::TimedWriteBoolean::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeTimedWriteBooleanWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::TimedWriteBoolean::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(
                cppValue, successFn->mContext, successFn->mCall, failureFn->mCall, 10000);
        });
}

- (void)subscribeAttributeTimedWriteBooleanWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::TimedWriteBoolean::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTimedWriteBooleanWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::TimedWriteBoolean::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneralErrorBooleanWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::GeneralErrorBoolean::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeGeneralErrorBooleanWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::GeneralErrorBoolean::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneralErrorBooleanWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::GeneralErrorBoolean::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneralErrorBooleanWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::GeneralErrorBoolean::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterErrorBooleanWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::ClusterErrorBoolean::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeClusterErrorBooleanWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::ClusterErrorBoolean::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeClusterErrorBooleanWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::ClusterErrorBoolean::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterErrorBooleanWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::ClusterErrorBoolean::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeUnsupportedWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::Unsupported::TypeInfo;
        auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeUnsupportedWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::Unsupported::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.boolValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeUnsupportedWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::Unsupported::TypeInfo;
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeUnsupportedWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::Unsupported::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<BooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableBooleanWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPNullableBooleanAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableBoolean::TypeInfo;
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableBooleanWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableBoolean::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.boolValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableBooleanWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableBooleanAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableBoolean::TypeInfo;
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableBooleanAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableBooleanWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableBooleanAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableBoolean::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableBooleanAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableBitmap8WithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableBitmap8AttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableBitmap8::TypeInfo;
            auto successFn = Callback<TestClusterNullableBitmap8AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableBitmap8WithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableBitmap8::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(value.unsignedCharValue);
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableBitmap8WithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterNullableBitmap8AttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableBitmap8::TypeInfo;
            auto successFn = Callback<TestClusterNullableBitmap8AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterNullableBitmap8AttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableBitmap8WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableBitmap8AttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::NullableBitmap8::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterNullableBitmap8AttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeNullableBitmap16WithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableBitmap16AttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableBitmap16::TypeInfo;
            auto successFn = Callback<TestClusterNullableBitmap16AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableBitmap16WithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableBitmap16::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(value.unsignedShortValue);
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableBitmap16WithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterNullableBitmap16AttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableBitmap16::TypeInfo;
            auto successFn = Callback<TestClusterNullableBitmap16AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterNullableBitmap16AttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableBitmap16WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableBitmap16AttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::NullableBitmap16::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterNullableBitmap16AttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeNullableBitmap32WithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableBitmap32AttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableBitmap32::TypeInfo;
            auto successFn = Callback<TestClusterNullableBitmap32AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableBitmap32WithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableBitmap32::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(value.unsignedIntValue);
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableBitmap32WithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterNullableBitmap32AttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableBitmap32::TypeInfo;
            auto successFn = Callback<TestClusterNullableBitmap32AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterNullableBitmap32AttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableBitmap32WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableBitmap32AttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::NullableBitmap32::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterNullableBitmap32AttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeNullableBitmap64WithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableBitmap64AttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableBitmap64::TypeInfo;
            auto successFn = Callback<TestClusterNullableBitmap64AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableBitmap64WithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableBitmap64::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(value.unsignedLongLongValue);
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableBitmap64WithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterNullableBitmap64AttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableBitmap64::TypeInfo;
            auto successFn = Callback<TestClusterNullableBitmap64AttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterNullableBitmap64AttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableBitmap64WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableBitmap64AttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::NullableBitmap64::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterNullableBitmap64AttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeNullableInt8uWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt8u::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt8uWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt8u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedCharValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt8uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt8u::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt8uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt8u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt16uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt16u::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt16uWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt16u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedShortValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt16uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt16u::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt16uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt16u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt24uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt24u::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt24uWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt24u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedIntValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt24uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt24u::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt24uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt24u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt32uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt32u::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt32uWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt32u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedIntValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt32uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt32u::TypeInfo;
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt32uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt32u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt40uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt40u::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt40uWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt40u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedLongLongValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt40uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt40u::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt40uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt40u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt48uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt48u::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt48uWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt48u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedLongLongValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt48uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt48u::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt48uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt48u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt56uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt56u::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt56uWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt56u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedLongLongValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt56uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt56u::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt56uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt56u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt64uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt64u::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt64uWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt64u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedLongLongValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt64uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt64u::TypeInfo;
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt64uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt64u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt8sWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt8s::TypeInfo;
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt8sWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt8s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.charValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt8sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt8s::TypeInfo;
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt8sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt8s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt16sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt16s::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt16sWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt16s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.shortValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt16sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt16s::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt16sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt16s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt24sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt24s::TypeInfo;
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt24sWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt24s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.intValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt24sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt32sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt24s::TypeInfo;
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt32sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt24sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt24s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt32sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt32s::TypeInfo;
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt32sWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt32s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.intValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt32sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt32sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt32s::TypeInfo;
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt32sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt32sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt32sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt32s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt32sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt40sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt40s::TypeInfo;
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt40sWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt40s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.longLongValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt40sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt40s::TypeInfo;
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt40sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt40s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt48sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt48s::TypeInfo;
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt48sWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt48s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.longLongValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt48sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt48s::TypeInfo;
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt48sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt48s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt56sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt56s::TypeInfo;
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt56sWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt56s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.longLongValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt56sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt56s::TypeInfo;
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt56sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt56s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableInt64sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableInt64s::TypeInfo;
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableInt64sWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableInt64s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.longLongValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableInt64sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt64sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableInt64s::TypeInfo;
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt64sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableInt64sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt64sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableInt64s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt64sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableEnum8WithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableEnum8::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableEnum8WithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableEnum8::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedCharValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableEnum8WithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableEnum8::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableEnum8WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableEnum8::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableEnum16WithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableEnum16::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableEnum16WithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableEnum16::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedShortValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableEnum16WithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableEnum16::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableEnum16WithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableEnum16::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableFloatSingleWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPNullableFloatAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableFloatSingle::TypeInfo;
            auto successFn = Callback<NullableFloatAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableFloatSingleWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableFloatSingle::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.floatValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableFloatSingleWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableFloatAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableFloatSingle::TypeInfo;
            auto successFn = Callback<NullableFloatAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableFloatAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableFloatSingleWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableFloatAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableFloatSingle::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableFloatAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableFloatDoubleWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPNullableDoubleAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableFloatDouble::TypeInfo;
            auto successFn = Callback<NullableDoubleAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableFloatDoubleWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableFloatDouble::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.doubleValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableFloatDoubleWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableDoubleAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableFloatDouble::TypeInfo;
            auto successFn = Callback<NullableDoubleAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableDoubleAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableFloatDoubleWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableDoubleAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableFloatDouble::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableDoubleAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableOctetStringWithCompletionHandler:(void (^)(NSData * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPNullableOctetStringAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableOctetString::TypeInfo;
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableOctetStringWithValue:(NSData * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableOctetString::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = [self asByteSpan:value];
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableOctetStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSData * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableOctetStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableOctetString::TypeInfo;
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableOctetStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableOctetStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableOctetString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableCharStringWithCompletionHandler:(void (^)(NSString * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPNullableCharStringAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableCharString::TypeInfo;
            auto successFn = Callback<NullableCharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableCharStringWithValue:(NSString * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableCharString::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = [self asCharSpan:value];
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableCharStringWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableCharString::TypeInfo;
            auto successFn = Callback<NullableCharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableCharStringWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableCharString::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableCharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableEnumAttrWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableTestClusterClusterSimpleEnumAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableEnumAttr::TypeInfo;
            auto successFn = Callback<NullableTestClusterClusterSimpleEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableEnumAttrWithValue:(NSNumber * _Nullable)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableEnumAttr::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = static_cast<std::remove_reference_t<decltype(nonNullValue_0)>>(value.unsignedCharValue);
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableEnumAttrWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableTestClusterClusterSimpleEnumAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableEnumAttr::TypeInfo;
            auto successFn = Callback<NullableTestClusterClusterSimpleEnumAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableTestClusterClusterSimpleEnumAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableEnumAttrWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableTestClusterClusterSimpleEnumAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::NullableEnumAttr::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<NullableTestClusterClusterSimpleEnumAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeNullableStructWithCompletionHandler:(void (^)(CHIPTestClusterClusterSimpleStruct * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableStructStructAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableStruct::TypeInfo;
            auto successFn = Callback<TestClusterNullableStructStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableStructWithValue:(CHIPTestClusterClusterSimpleStruct * _Nullable)value
                            completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableStruct::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0.a = value.a.unsignedCharValue;
                nonNullValue_0.b = value.b.boolValue;
                nonNullValue_0.c = static_cast<std::remove_reference_t<decltype(nonNullValue_0.c)>>(value.c.unsignedCharValue);
                nonNullValue_0.d = [self asByteSpan:value.d];
                nonNullValue_0.e = [self asCharSpan:value.e];
                nonNullValue_0.f = static_cast<std::remove_reference_t<decltype(nonNullValue_0.f)>>(value.f.unsignedCharValue);
                nonNullValue_0.g = value.g.floatValue;
                nonNullValue_0.h = value.h.doubleValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableStructWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:(void (^)(CHIPTestClusterClusterSimpleStruct * _Nullable value,
                                                            NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterNullableStructStructAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableStruct::TypeInfo;
            auto successFn = Callback<TestClusterNullableStructStructAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterNullableStructStructAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableStructWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:(void (^)(CHIPTestClusterClusterSimpleStruct * _Nullable value,
                                                          NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterNullableStructStructAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::NullableStruct::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterNullableStructStructAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableRangeRestrictedInt8uWithValue:(NSNumber * _Nullable)value
                                          completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedCharValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableRangeRestrictedInt8uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                                               params:(CHIPSubscribeParams * _Nullable)params
                                              subscriptionEstablished:
                                                  (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                        reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                          NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableRangeRestrictedInt8uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                           endpoint:(NSNumber *)endpoint
                                                              queue:(dispatch_queue_t)queue
                                                  completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt8u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo;
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableRangeRestrictedInt8sWithValue:(NSNumber * _Nullable)value
                                          completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.charValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableRangeRestrictedInt8sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                                               params:(CHIPSubscribeParams * _Nullable)params
                                              subscriptionEstablished:
                                                  (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                        reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                          NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo;
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableRangeRestrictedInt8sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                           endpoint:(NSNumber *)endpoint
                                                              queue:(dispatch_queue_t)queue
                                                  completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt8s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableRangeRestrictedInt16uWithValue:(NSNumber * _Nullable)value
                                           completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.unsignedShortValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableRangeRestrictedInt16uWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableRangeRestrictedInt16uWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt16u::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeNullableRangeRestrictedInt16sWithValue:(NSNumber * _Nullable)value
                                           completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo;
            TypeInfo::Type cppValue;
            if (value == nil) {
                cppValue.SetNull();
            } else {
                auto & nonNullValue_0 = cppValue.SetNonNull();
                nonNullValue_0 = value.shortValue;
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNullableRangeRestrictedInt16sWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo;
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNullableRangeRestrictedInt16sWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::NullableRangeRestrictedInt16s::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<TestClusterGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<TestClusterGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<TestClusterAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<TestClusterAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TestCluster::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<TestClusterAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTestClusterAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<TestClusterAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTestClusterAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTestClusterAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TestCluster::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TestClusterAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TestCluster::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TestCluster::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TestCluster::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPThermostat

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)clearWeeklyScheduleWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Thermostat::Commands::ClearWeeklySchedule::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getRelayStatusLogWithCompletionHandler:(void (^)(CHIPThermostatClusterGetRelayStatusLogResponseParams * _Nullable data,
                                                   NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Thermostat::Commands::GetRelayStatusLog::Type request;

    new CHIPThermostatClusterGetRelayStatusLogResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPThermostatClusterGetRelayStatusLogResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)getWeeklyScheduleWithParams:(CHIPThermostatClusterGetWeeklyScheduleParams *)params
                  completionHandler:(void (^)(CHIPThermostatClusterGetWeeklyScheduleResponseParams * _Nullable data,
                                        NSError * _Nullable error))completionHandler
{
    ListFreer listFreer;
    Thermostat::Commands::GetWeeklySchedule::Type request;
    request.daysToReturn
        = static_cast<std::remove_reference_t<decltype(request.daysToReturn)>>(params.daysToReturn.unsignedCharValue);
    request.modeToReturn
        = static_cast<std::remove_reference_t<decltype(request.modeToReturn)>>(params.modeToReturn.unsignedCharValue);

    new CHIPThermostatClusterGetWeeklyScheduleResponseCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPThermostatClusterGetWeeklyScheduleResponseCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)setWeeklyScheduleWithParams:(CHIPThermostatClusterSetWeeklyScheduleParams *)params
                  completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Thermostat::Commands::SetWeeklySchedule::Type request;
    request.numberOfTransitionsForSequence = params.numberOfTransitionsForSequence.unsignedCharValue;
    request.dayOfWeekForSequence = static_cast<std::remove_reference_t<decltype(request.dayOfWeekForSequence)>>(
        params.dayOfWeekForSequence.unsignedCharValue);
    request.modeForSequence
        = static_cast<std::remove_reference_t<decltype(request.modeForSequence)>>(params.modeForSequence.unsignedCharValue);
    {
        using ListType_0 = std::remove_reference_t<decltype(request.payload)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        if (params.payload.count != 0) {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(params.payload.count);
            if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                return;
            }
            listFreer.add(listHolder_0);
            for (size_t i_0 = 0; i_0 < params.payload.count; ++i_0) {
                if (![params.payload[i_0] isKindOfClass:[NSNumber class]]) {
                    // Wrong kind of value.
                    return;
                }
                auto element_0 = (NSNumber *) params.payload[i_0];
                listHolder_0->mList[i_0] = element_0.unsignedCharValue;
            }
            request.payload = ListType_0(listHolder_0->mList, params.payload.count);
        } else {
            request.payload = ListType_0();
        }
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)setpointRaiseLowerWithParams:(CHIPThermostatClusterSetpointRaiseLowerParams *)params
                   completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    Thermostat::Commands::SetpointRaiseLower::Type request;
    request.mode = static_cast<std::remove_reference_t<decltype(request.mode)>>(params.mode.unsignedCharValue);
    request.amount = params.amount.charValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeLocalTemperatureWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::LocalTemperature::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeLocalTemperatureWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::LocalTemperature::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLocalTemperatureWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::LocalTemperature::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAbsMinHeatSetpointLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAbsMinHeatSetpointLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAbsMinHeatSetpointLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAbsMaxHeatSetpointLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAbsMaxHeatSetpointLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAbsMaxHeatSetpointLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAbsMinCoolSetpointLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAbsMinCoolSetpointLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAbsMinCoolSetpointLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAbsMaxCoolSetpointLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAbsMaxCoolSetpointLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAbsMaxCoolSetpointLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOccupiedCoolingSetpointWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeOccupiedCoolingSetpointWithValue:(NSNumber * _Nonnull)value
                                     completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.shortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOccupiedCoolingSetpointWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOccupiedCoolingSetpointWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOccupiedHeatingSetpointWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeOccupiedHeatingSetpointWithValue:(NSNumber * _Nonnull)value
                                     completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.shortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOccupiedHeatingSetpointWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOccupiedHeatingSetpointWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinHeatSetpointLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeMinHeatSetpointLimitWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.shortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinHeatSetpointLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinHeatSetpointLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxHeatSetpointLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeMaxHeatSetpointLimitWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.shortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxHeatSetpointLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxHeatSetpointLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinCoolSetpointLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeMinCoolSetpointLimitWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.shortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinCoolSetpointLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinCoolSetpointLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMaxCoolSetpointLimitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo;
        auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeMaxCoolSetpointLimitWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.shortValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMaxCoolSetpointLimitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo;
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMaxCoolSetpointLimitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMinSetpointDeadBandWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt8sAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::MinSetpointDeadBand::TypeInfo;
        auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeMinSetpointDeadBandWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::MinSetpointDeadBand::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.charValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMinSetpointDeadBandWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::MinSetpointDeadBand::TypeInfo;
            auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMinSetpointDeadBandWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::MinSetpointDeadBand::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeControlSequenceOfOperationWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPThermostatClusterThermostatControlSequenceAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo;
            auto successFn = Callback<ThermostatClusterThermostatControlSequenceAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeControlSequenceOfOperationWithValue:(NSNumber * _Nonnull)value
                                        completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeControlSequenceOfOperationWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                                             params:(CHIPSubscribeParams * _Nullable)params
                                            subscriptionEstablished:
                                                (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                      reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))reportHandler
{
    new CHIPThermostatClusterThermostatControlSequenceAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo;
            auto successFn = Callback<ThermostatClusterThermostatControlSequenceAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThermostatClusterThermostatControlSequenceAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeControlSequenceOfOperationWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                         endpoint:(NSNumber *)endpoint
                                                            queue:(dispatch_queue_t)queue
                                                completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPThermostatClusterThermostatControlSequenceAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ThermostatClusterThermostatControlSequenceAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeSystemModeWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::SystemMode::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeSystemModeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = Thermostat::Attributes::SystemMode::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSystemModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::SystemMode::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSystemModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::SystemMode::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeStartOfWeekWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::StartOfWeek::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeStartOfWeekWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::StartOfWeek::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStartOfWeekWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::StartOfWeek::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNumberOfWeeklyTransitionsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfWeeklyTransitionsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                                            params:(CHIPSubscribeParams * _Nullable)params
                                           subscriptionEstablished:
                                               (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                     reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfWeeklyTransitionsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                        endpoint:(NSNumber *)endpoint
                                                           queue:(dispatch_queue_t)queue
                                               completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNumberOfDailyTransitionsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNumberOfDailyTransitionsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                                           params:(CHIPSubscribeParams * _Nullable)params
                                          subscriptionEstablished:
                                              (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                    reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNumberOfDailyTransitionsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                       endpoint:(NSNumber *)endpoint
                                                          queue:(dispatch_queue_t)queue
                                              completionHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThermostatAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = Thermostat::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ThermostatAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThermostatAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ThermostatAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThermostatAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThermostatAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = Thermostat::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ThermostatAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = Thermostat::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = Thermostat::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = Thermostat::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPThermostatUserInterfaceConfiguration

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeTemperatureDisplayModeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeTemperatureDisplayModeWithValue:(NSNumber * _Nonnull)value
                                    completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeTemperatureDisplayModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTemperatureDisplayModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeKeypadLockoutWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeKeypadLockoutWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeKeypadLockoutWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeKeypadLockoutWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeScheduleProgrammingVisibilityWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)writeAttributeScheduleProgrammingVisibilityWithValue:(NSNumber * _Nonnull)value
                                           completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = value.unsignedCharValue;
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeScheduleProgrammingVisibilityWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeScheduleProgrammingVisibilityWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPThermostatUserInterfaceConfigurationGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn
                = Callback<ThermostatUserInterfaceConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThermostatUserInterfaceConfigurationGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn
                = Callback<ThermostatUserInterfaceConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThermostatUserInterfaceConfigurationGeneratedCommandListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThermostatUserInterfaceConfigurationGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<ThermostatUserInterfaceConfigurationGeneratedCommandListListAttributeCallback>::FromCancelable(
                        success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPThermostatUserInterfaceConfigurationAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn
                = Callback<ThermostatUserInterfaceConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThermostatUserInterfaceConfigurationAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn
                = Callback<ThermostatUserInterfaceConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThermostatUserInterfaceConfigurationAcceptedCommandListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThermostatUserInterfaceConfigurationAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<ThermostatUserInterfaceConfigurationAcceptedCommandListListAttributeCallback>::FromCancelable(
                        success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThermostatUserInterfaceConfigurationAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::AttributeList::TypeInfo;
            auto successFn
                = Callback<ThermostatUserInterfaceConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThermostatUserInterfaceConfigurationAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::AttributeList::TypeInfo;
            auto successFn
                = Callback<ThermostatUserInterfaceConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThermostatUserInterfaceConfigurationAttributeListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThermostatUserInterfaceConfigurationAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<ThermostatUserInterfaceConfigurationAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPThreadNetworkDiagnostics

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)resetCountsWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    ThreadNetworkDiagnostics::Commands::ResetCounts::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeChannelWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::Channel::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeChannelWithMinInterval:(NSNumber * _Nonnull)minInterval
                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                          params:(CHIPSubscribeParams * _Nullable)params
                         subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                   reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::Channel::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeChannelWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                      endpoint:(NSNumber *)endpoint
                                         queue:(dispatch_queue_t)queue
                             completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::Channel::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRoutingRoleWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RoutingRole::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRoutingRoleWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RoutingRole::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRoutingRoleWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RoutingRole::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNetworkNameWithCompletionHandler:(void (^)(
                                                          NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::NetworkName::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeNetworkNameWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::NetworkName::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNetworkNameWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::NetworkName::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePanIdWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::PanId::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePanIdWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::PanId::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePanIdWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::PanId::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeExtendedPanIdWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::ExtendedPanId::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeExtendedPanIdWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ExtendedPanId::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeExtendedPanIdWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ExtendedPanId::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeMeshLocalPrefixWithCompletionHandler:(void (^)(
                                                              NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOctetStringAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::MeshLocalPrefix::TypeInfo;
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeMeshLocalPrefixWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSData * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOctetStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::MeshLocalPrefix::TypeInfo;
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMeshLocalPrefixWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOctetStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::MeshLocalPrefix::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOverrunCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOverrunCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOverrunCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeNeighborTableListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsNeighborTableListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::NeighborTableList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeNeighborTableListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThreadNetworkDiagnosticsNeighborTableListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::NeighborTableList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThreadNetworkDiagnosticsNeighborTableListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeNeighborTableListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsNeighborTableListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThreadNetworkDiagnostics::Attributes::NeighborTableList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeRouteTableListWithCompletionHandler:(void (^)(
                                                             NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsRouteTableListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RouteTableList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeRouteTableListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThreadNetworkDiagnosticsRouteTableListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RouteTableList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThreadNetworkDiagnosticsRouteTableListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRouteTableListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsRouteTableListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThreadNetworkDiagnostics::Attributes::RouteTableList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributePartitionIdWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::PartitionId::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePartitionIdWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::PartitionId::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePartitionIdWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::PartitionId::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeWeightingWithCompletionHandler:(void (^)(
                                                        NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::Weighting::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeWeightingWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::Weighting::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeWeightingWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::Weighting::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeDataVersionWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::DataVersion::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeDataVersionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::DataVersion::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDataVersionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::DataVersion::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeStableDataVersionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::StableDataVersion::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeStableDataVersionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::StableDataVersion::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeStableDataVersionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::StableDataVersion::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLeaderRouterIdWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::LeaderRouterId::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeLeaderRouterIdWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::LeaderRouterId::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLeaderRouterIdWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::LeaderRouterId::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeDetachedRoleCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::DetachedRoleCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeDetachedRoleCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::DetachedRoleCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDetachedRoleCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::DetachedRoleCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeChildRoleCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::ChildRoleCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeChildRoleCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ChildRoleCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeChildRoleCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ChildRoleCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRouterRoleCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RouterRoleCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRouterRoleCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RouterRoleCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRouterRoleCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RouterRoleCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeLeaderRoleCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::LeaderRoleCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeLeaderRoleCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::LeaderRoleCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLeaderRoleCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::LeaderRoleCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeAttachAttemptCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::AttachAttemptCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeAttachAttemptCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::AttachAttemptCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttachAttemptCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::AttachAttemptCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePartitionIdChangeCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::PartitionIdChangeCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePartitionIdChangeCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::PartitionIdChangeCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePartitionIdChangeCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::PartitionIdChangeCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBetterPartitionAttachAttemptCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::BetterPartitionAttachAttemptCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBetterPartitionAttachAttemptCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                    params:(CHIPSubscribeParams * _Nullable)params
                                                   subscriptionEstablished:
                                                       (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                             reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                               NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::BetterPartitionAttachAttemptCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBetterPartitionAttachAttemptCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                                endpoint:(NSNumber *)endpoint
                                                                   queue:(dispatch_queue_t)queue
                                                       completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::BetterPartitionAttachAttemptCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeParentChangeCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::ParentChangeCount::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeParentChangeCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ParentChangeCount::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeParentChangeCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ParentChangeCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxTotalCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxTotalCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxTotalCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxTotalCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxTotalCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxTotalCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxUnicastCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxUnicastCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxUnicastCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxUnicastCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxUnicastCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxUnicastCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxBroadcastCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBroadcastCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxBroadcastCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBroadcastCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxBroadcastCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBroadcastCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxAckRequestedCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxAckRequestedCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxAckRequestedCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxAckRequestedCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxAckRequestedCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxAckRequestedCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxAckedCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxAckedCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxAckedCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxAckedCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxAckedCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxAckedCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxNoAckRequestedCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxNoAckRequestedCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxNoAckRequestedCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxNoAckRequestedCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxNoAckRequestedCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxNoAckRequestedCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxDataCountWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDataCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxDataCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDataCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxDataCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDataCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxDataPollCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDataPollCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxDataPollCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDataPollCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxDataPollCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDataPollCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxBeaconCountWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBeaconCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxBeaconCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBeaconCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxBeaconCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBeaconCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxBeaconRequestCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBeaconRequestCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxBeaconRequestCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBeaconRequestCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxBeaconRequestCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxBeaconRequestCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxOtherCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxOtherCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxOtherCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxOtherCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxOtherCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxOtherCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxRetryCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxRetryCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxRetryCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxRetryCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxRetryCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxRetryCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxDirectMaxRetryExpiryCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                          NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDirectMaxRetryExpiryCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxDirectMaxRetryExpiryCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                                              params:(CHIPSubscribeParams * _Nullable)params
                                             subscriptionEstablished:
                                                 (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                       reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDirectMaxRetryExpiryCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxDirectMaxRetryExpiryCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                          endpoint:(NSNumber *)endpoint
                                                             queue:(dispatch_queue_t)queue
                                                 completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxDirectMaxRetryExpiryCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxIndirectMaxRetryExpiryCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxIndirectMaxRetryExpiryCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxIndirectMaxRetryExpiryCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxIndirectMaxRetryExpiryCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxIndirectMaxRetryExpiryCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxIndirectMaxRetryExpiryCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxErrCcaCountWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrCcaCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxErrCcaCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrCcaCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxErrCcaCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrCcaCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxErrAbortCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrAbortCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxErrAbortCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrAbortCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxErrAbortCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrAbortCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTxErrBusyChannelCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                    NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrBusyChannelCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeTxErrBusyChannelCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                                        params:(CHIPSubscribeParams * _Nullable)params
                                       subscriptionEstablished:
                                           (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                 reportHandler:
                                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrBusyChannelCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTxErrBusyChannelCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                    endpoint:(NSNumber *)endpoint
                                                       queue:(dispatch_queue_t)queue
                                           completionHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::TxErrBusyChannelCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxTotalCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxTotalCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxTotalCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxTotalCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxTotalCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxTotalCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxUnicastCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxUnicastCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxUnicastCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxUnicastCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxUnicastCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxUnicastCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxBroadcastCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBroadcastCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxBroadcastCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBroadcastCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxBroadcastCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBroadcastCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxDataCountWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDataCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxDataCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDataCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxDataCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDataCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxDataPollCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDataPollCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxDataPollCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDataPollCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxDataPollCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDataPollCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxBeaconCountWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBeaconCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxBeaconCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBeaconCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxBeaconCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBeaconCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxBeaconRequestCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBeaconRequestCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxBeaconRequestCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBeaconRequestCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxBeaconRequestCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxBeaconRequestCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxOtherCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxOtherCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxOtherCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxOtherCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxOtherCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxOtherCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxAddressFilteredCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxAddressFilteredCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxAddressFilteredCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxAddressFilteredCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxAddressFilteredCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxAddressFilteredCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxDestAddrFilteredCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDestAddrFilteredCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxDestAddrFilteredCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDestAddrFilteredCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxDestAddrFilteredCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDestAddrFilteredCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxDuplicatedCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDuplicatedCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxDuplicatedCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDuplicatedCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxDuplicatedCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxDuplicatedCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxErrNoFrameCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrNoFrameCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxErrNoFrameCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrNoFrameCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxErrNoFrameCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrNoFrameCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxErrUnknownNeighborCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrUnknownNeighborCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxErrUnknownNeighborCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                                            params:(CHIPSubscribeParams * _Nullable)params
                                           subscriptionEstablished:
                                               (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                     reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrUnknownNeighborCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxErrUnknownNeighborCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                        endpoint:(NSNumber *)endpoint
                                                           queue:(dispatch_queue_t)queue
                                               completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrUnknownNeighborCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxErrInvalidSrcAddrCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrInvalidSrcAddrCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxErrInvalidSrcAddrCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                                           params:(CHIPSubscribeParams * _Nullable)params
                                          subscriptionEstablished:
                                              (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                    reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrInvalidSrcAddrCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxErrInvalidSrcAddrCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                       endpoint:(NSNumber *)endpoint
                                                          queue:(dispatch_queue_t)queue
                                              completionHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrInvalidSrcAddrCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxErrSecCountWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrSecCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxErrSecCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrSecCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxErrSecCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrSecCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxErrFcsCountWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrFcsCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxErrFcsCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrFcsCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxErrFcsCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrFcsCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRxErrOtherCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrOtherCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeRxErrOtherCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrOtherCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRxErrOtherCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::RxErrOtherCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeActiveTimestampWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::ActiveTimestamp::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeActiveTimestampWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ActiveTimestamp::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActiveTimestampWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ActiveTimestamp::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePendingTimestampWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                               NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::PendingTimestamp::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePendingTimestampWithMinInterval:(NSNumber * _Nonnull)minInterval
                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                   params:(CHIPSubscribeParams * _Nullable)params
                                  subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                            reportHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::PendingTimestamp::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePendingTimestampWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                               endpoint:(NSNumber *)endpoint
                                                  queue:(dispatch_queue_t)queue
                                      completionHandler:
                                          (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::PendingTimestamp::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeDelayWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::Delay::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeDelayWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::Delay::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeDelayWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::Delay::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSecurityPolicyWithCompletionHandler:(void (^)(
                                                             NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsSecurityPolicyListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::SecurityPolicy::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSecurityPolicyWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThreadNetworkDiagnosticsSecurityPolicyListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::SecurityPolicy::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThreadNetworkDiagnosticsSecurityPolicyListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSecurityPolicyWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsSecurityPolicyListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThreadNetworkDiagnostics::Attributes::SecurityPolicy::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeChannelMaskWithCompletionHandler:(void (^)(
                                                          NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOctetStringAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ChannelMask::TypeInfo;
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeChannelMaskWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSData * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPOctetStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ChannelMask::TypeInfo;
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeChannelMaskWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:(void (^)(NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPOctetStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ChannelMask::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<OctetStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOperationalDatasetComponentsWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::OperationalDatasetComponents::TypeInfo;
            auto successFn
                = Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeOperationalDatasetComponentsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                                               params:(CHIPSubscribeParams * _Nullable)params
                                              subscriptionEstablished:
                                                  (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                        reportHandler:(void (^)(NSArray * _Nullable value,
                                                                          NSError * _Nullable error))reportHandler
{
    new CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::OperationalDatasetComponents::TypeInfo;
            auto successFn
                = Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOperationalDatasetComponentsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                           endpoint:(NSNumber *)endpoint
                                                              queue:(dispatch_queue_t)queue
                                                  completionHandler:(void (^)(NSArray * _Nullable value,
                                                                        NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThreadNetworkDiagnostics::Attributes::OperationalDatasetComponents::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeActiveNetworkFaultsListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                      NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ActiveNetworkFaultsList::TypeInfo;
            auto successFn
                = Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeActiveNetworkFaultsListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                     maxInterval:(NSNumber * _Nonnull)maxInterval
                                                          params:(CHIPSubscribeParams * _Nullable)params
                                         subscriptionEstablished:
                                             (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                   reportHandler:
                                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ActiveNetworkFaultsList::TypeInfo;
            auto successFn
                = Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActiveNetworkFaultsListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                      endpoint:(NSNumber *)endpoint
                                                         queue:(dispatch_queue_t)queue
                                             completionHandler:
                                                 (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThreadNetworkDiagnostics::Attributes::ActiveNetworkFaultsList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThreadNetworkDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThreadNetworkDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThreadNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<ThreadNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThreadNetworkDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThreadNetworkDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThreadNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<ThreadNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPThreadNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<ThreadNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPThreadNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPThreadNetworkDiagnosticsAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = ThreadNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<ThreadNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPTimeFormatLocalization

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeHourFormatWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationClusterHourFormatAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TimeFormatLocalization::Attributes::HourFormat::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationClusterHourFormatAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeHourFormatWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TimeFormatLocalization::Attributes::HourFormat::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeHourFormatWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTimeFormatLocalizationClusterHourFormatAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TimeFormatLocalization::Attributes::HourFormat::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationClusterHourFormatAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTimeFormatLocalizationClusterHourFormatAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeHourFormatWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationClusterHourFormatAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TimeFormatLocalization::Attributes::HourFormat::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TimeFormatLocalizationClusterHourFormatAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeActiveCalendarTypeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                 NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationClusterCalendarTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TimeFormatLocalization::Attributes::ActiveCalendarType::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationClusterCalendarTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeActiveCalendarTypeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = TimeFormatLocalization::Attributes::ActiveCalendarType::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeActiveCalendarTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                maxInterval:(NSNumber * _Nonnull)maxInterval
                                                     params:(CHIPSubscribeParams * _Nullable)params
                                    subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                              reportHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTimeFormatLocalizationClusterCalendarTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TimeFormatLocalization::Attributes::ActiveCalendarType::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationClusterCalendarTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTimeFormatLocalizationClusterCalendarTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeActiveCalendarTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                 endpoint:(NSNumber *)endpoint
                                                    queue:(dispatch_queue_t)queue
                                        completionHandler:
                                            (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationClusterCalendarTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TimeFormatLocalization::Attributes::ActiveCalendarType::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TimeFormatLocalizationClusterCalendarTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeSupportedCalendarTypesWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationSupportedCalendarTypesListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TimeFormatLocalization::Attributes::SupportedCalendarTypes::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationSupportedCalendarTypesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSupportedCalendarTypesWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTimeFormatLocalizationSupportedCalendarTypesListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TimeFormatLocalization::Attributes::SupportedCalendarTypes::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationSupportedCalendarTypesListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTimeFormatLocalizationSupportedCalendarTypesListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSupportedCalendarTypesWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationSupportedCalendarTypesListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TimeFormatLocalization::Attributes::SupportedCalendarTypes::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<TimeFormatLocalizationSupportedCalendarTypesListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TimeFormatLocalization::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTimeFormatLocalizationGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TimeFormatLocalization::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTimeFormatLocalizationGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TimeFormatLocalization::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TimeFormatLocalizationGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = TimeFormatLocalization::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPTimeFormatLocalizationAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TimeFormatLocalization::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<TimeFormatLocalizationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPTimeFormatLocalizationAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPTimeFormatLocalizationAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = TimeFormatLocalization::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<TimeFormatLocalizationAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = TimeFormatLocalization::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = TimeFormatLocalization::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = TimeFormatLocalization::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPUnitLocalization

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeTemperatureUnitWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPUnitLocalizationClusterTempUnitAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = UnitLocalization::Attributes::TemperatureUnit::TypeInfo;
            auto successFn = Callback<UnitLocalizationClusterTempUnitAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeTemperatureUnitWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = UnitLocalization::Attributes::TemperatureUnit::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeTemperatureUnitWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPUnitLocalizationClusterTempUnitAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = UnitLocalization::Attributes::TemperatureUnit::TypeInfo;
            auto successFn = Callback<UnitLocalizationClusterTempUnitAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPUnitLocalizationClusterTempUnitAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTemperatureUnitWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPUnitLocalizationClusterTempUnitAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = UnitLocalization::Attributes::TemperatureUnit::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<UnitLocalizationClusterTempUnitAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPUnitLocalizationAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = UnitLocalization::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<UnitLocalizationAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPUnitLocalizationAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = UnitLocalization::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<UnitLocalizationAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPUnitLocalizationAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPUnitLocalizationAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = UnitLocalization::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<UnitLocalizationAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = UnitLocalization::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = UnitLocalization::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = UnitLocalization::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = UnitLocalization::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = UnitLocalization::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = UnitLocalization::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPUserLabel

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeLabelListWithCompletionHandler:(void (^)(
                                                        NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPUserLabelLabelListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = UserLabel::Attributes::LabelList::TypeInfo;
            auto successFn = Callback<UserLabelLabelListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeLabelListWithValue:(NSArray * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = UserLabel::Attributes::LabelList::TypeInfo;
            TypeInfo::Type cppValue;
            {
                using ListType_0 = std::remove_reference_t<decltype(cppValue)>;
                using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
                if (value.count != 0) {
                    auto * listHolder_0 = new ListHolder<ListMemberType_0>(value.count);
                    if (listHolder_0 == nullptr || listHolder_0->mList == nullptr) {
                        return CHIP_ERROR_INVALID_ARGUMENT;
                    }
                    listFreer.add(listHolder_0);
                    for (size_t i_0 = 0; i_0 < value.count; ++i_0) {
                        if (![value[i_0] isKindOfClass:[CHIPUserLabelClusterLabelStruct class]]) {
                            // Wrong kind of value.
                            return CHIP_ERROR_INVALID_ARGUMENT;
                        }
                        auto element_0 = (CHIPUserLabelClusterLabelStruct *) value[i_0];
                        listHolder_0->mList[i_0].label = [self asCharSpan:element_0.label];
                        listHolder_0->mList[i_0].value = [self asCharSpan:element_0.value];
                    }
                    cppValue = ListType_0(listHolder_0->mList, value.count);
                } else {
                    cppValue = ListType_0();
                }
            }
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeLabelListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                       maxInterval:(NSNumber * _Nonnull)maxInterval
                                            params:(CHIPSubscribeParams * _Nullable)params
                           subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                     reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPUserLabelLabelListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = UserLabel::Attributes::LabelList::TypeInfo;
            auto successFn = Callback<UserLabelLabelListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPUserLabelLabelListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeLabelListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                        endpoint:(NSNumber *)endpoint
                                           queue:(dispatch_queue_t)queue
                               completionHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPUserLabelLabelListListAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = UserLabel::Attributes::LabelList::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<UserLabelLabelListListAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPUserLabelGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = UserLabel::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<UserLabelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPUserLabelGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = UserLabel::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<UserLabelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPUserLabelGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPUserLabelGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = UserLabel::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<UserLabelGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPUserLabelAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = UserLabel::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<UserLabelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPUserLabelAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = UserLabel::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<UserLabelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPUserLabelAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPUserLabelAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = UserLabel::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<UserLabelAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = UserLabel::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = UserLabel::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = UserLabel::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPWakeOnLan

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)readAttributeMACAddressWithCompletionHandler:(void (^)(
                                                         NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WakeOnLan::Attributes::MACAddress::TypeInfo;
        auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeMACAddressWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPCharStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WakeOnLan::Attributes::MACAddress::TypeInfo;
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPCharStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeMACAddressWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSString * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPCharStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WakeOnLan::Attributes::MACAddress::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<CharStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPWakeOnLanGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WakeOnLan::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<WakeOnLanGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWakeOnLanGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WakeOnLan::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<WakeOnLanGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWakeOnLanGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWakeOnLanGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WakeOnLan::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WakeOnLanGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPWakeOnLanAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WakeOnLan::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<WakeOnLanAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWakeOnLanAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WakeOnLan::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<WakeOnLanAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWakeOnLanAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWakeOnLanAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WakeOnLan::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WakeOnLanAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWakeOnLanAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WakeOnLan::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<WakeOnLanAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWakeOnLanAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WakeOnLan::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<WakeOnLanAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWakeOnLanAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWakeOnLanAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WakeOnLan::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WakeOnLanAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WakeOnLan::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WakeOnLan::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WakeOnLan::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPWiFiNetworkDiagnostics

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)resetCountsWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    WiFiNetworkDiagnostics::Commands::ResetCounts::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeBssidWithCompletionHandler:(void (^)(NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableOctetStringAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::Bssid::TypeInfo;
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeBssidWithMinInterval:(NSNumber * _Nonnull)minInterval
                                   maxInterval:(NSNumber * _Nonnull)maxInterval
                                        params:(CHIPSubscribeParams * _Nullable)params
                       subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                 reportHandler:(void (^)(NSData * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableOctetStringAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::Bssid::TypeInfo;
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableOctetStringAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBssidWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                    endpoint:(NSNumber *)endpoint
                                       queue:(dispatch_queue_t)queue
                           completionHandler:(void (^)(NSData * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableOctetStringAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::Bssid::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableOctetStringAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSecurityTypeWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::SecurityType::TypeInfo;
            auto successFn = Callback<NullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeSecurityTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::SecurityType::TypeInfo;
            auto successFn = Callback<NullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSecurityTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WiFiNetworkDiagnostics::Attributes::SecurityType::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<NullableWiFiNetworkDiagnosticsClusterSecurityTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeWiFiVersionWithCompletionHandler:(void (^)(
                                                          NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::WiFiVersion::TypeInfo;
            auto successFn
                = Callback<NullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeWiFiVersionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                         maxInterval:(NSNumber * _Nonnull)maxInterval
                                              params:(CHIPSubscribeParams * _Nullable)params
                             subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                       reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::WiFiVersion::TypeInfo;
            auto successFn
                = Callback<NullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackSubscriptionBridge::
                    OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeWiFiVersionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                          endpoint:(NSNumber *)endpoint
                                             queue:(dispatch_queue_t)queue
                                 completionHandler:
                                     (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WiFiNetworkDiagnostics::Attributes::WiFiVersion::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn
                    = Callback<NullableWiFiNetworkDiagnosticsClusterWiFiVersionTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeChannelNumberWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::ChannelNumber::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeChannelNumberWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::ChannelNumber::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeChannelNumberWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::ChannelNumber::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeRssiWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8sAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::Rssi::TypeInfo;
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeRssiWithMinInterval:(NSNumber * _Nonnull)minInterval
                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                       params:(CHIPSubscribeParams * _Nullable)params
                      subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8sAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::Rssi::TypeInfo;
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8sAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeRssiWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                   endpoint:(NSNumber *)endpoint
                                      queue:(dispatch_queue_t)queue
                          completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8sAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::Rssi::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8sAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBeaconLostCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::BeaconLostCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBeaconLostCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::BeaconLostCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBeaconLostCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::BeaconLostCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeBeaconRxCountWithCompletionHandler:(void (^)(
                                                            NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::BeaconRxCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeBeaconRxCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::BeaconRxCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeBeaconRxCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::BeaconRxCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePacketMulticastRxCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketMulticastRxCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePacketMulticastRxCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketMulticastRxCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePacketMulticastRxCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketMulticastRxCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePacketMulticastTxCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketMulticastTxCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePacketMulticastTxCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketMulticastTxCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePacketMulticastTxCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketMulticastTxCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePacketUnicastRxCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketUnicastRxCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePacketUnicastRxCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketUnicastRxCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePacketUnicastRxCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketUnicastRxCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributePacketUnicastTxCountWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketUnicastTxCount::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributePacketUnicastTxCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketUnicastTxCount::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributePacketUnicastTxCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::PacketUnicastTxCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentMaxRateWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::CurrentMaxRate::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeCurrentMaxRateWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::CurrentMaxRate::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentMaxRateWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::CurrentMaxRate::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOverrunCountWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
        auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOverrunCountWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt64uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt64uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOverrunCountWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt64uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::OverrunCount::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int64uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPWiFiNetworkDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<WiFiNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWiFiNetworkDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<WiFiNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWiFiNetworkDiagnosticsGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWiFiNetworkDiagnosticsGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WiFiNetworkDiagnostics::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WiFiNetworkDiagnosticsGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPWiFiNetworkDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<WiFiNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWiFiNetworkDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<WiFiNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWiFiNetworkDiagnosticsAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWiFiNetworkDiagnosticsAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WiFiNetworkDiagnostics::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WiFiNetworkDiagnosticsAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWiFiNetworkDiagnosticsAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<WiFiNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWiFiNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<WiFiNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWiFiNetworkDiagnosticsAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWiFiNetworkDiagnosticsAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WiFiNetworkDiagnostics::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WiFiNetworkDiagnosticsAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WiFiNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WiFiNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end

@implementation CHIPWindowCovering

- (chip::Controller::ClusterBase *)getCluster
{
    return &_cppCluster;
}

- (void)downOrCloseWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    WindowCovering::Commands::DownOrClose::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)goToLiftPercentageWithParams:(CHIPWindowCoveringClusterGoToLiftPercentageParams *)params
                   completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    WindowCovering::Commands::GoToLiftPercentage::Type request;
    request.liftPercentageValue = params.liftPercentageValue.unsignedCharValue;
    if (params.liftPercent100thsValue != nil) {
        auto & definedValue_0 = request.liftPercent100thsValue.Emplace();
        definedValue_0 = params.liftPercent100thsValue.unsignedShortValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)goToLiftValueWithParams:(CHIPWindowCoveringClusterGoToLiftValueParams *)params
              completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    WindowCovering::Commands::GoToLiftValue::Type request;
    request.liftValue = params.liftValue.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)goToTiltPercentageWithParams:(CHIPWindowCoveringClusterGoToTiltPercentageParams *)params
                   completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    WindowCovering::Commands::GoToTiltPercentage::Type request;
    request.tiltPercentageValue = params.tiltPercentageValue.unsignedCharValue;
    if (params.tiltPercent100thsValue != nil) {
        auto & definedValue_0 = request.tiltPercent100thsValue.Emplace();
        definedValue_0 = params.tiltPercent100thsValue.unsignedShortValue;
    }

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)goToTiltValueWithParams:(CHIPWindowCoveringClusterGoToTiltValueParams *)params
              completionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    WindowCovering::Commands::GoToTiltValue::Type request;
    request.tiltValue = params.tiltValue.unsignedShortValue;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)stopMotionWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    WindowCovering::Commands::StopMotion::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)upOrOpenWithCompletionHandler:(StatusCompletion)completionHandler
{
    ListFreer listFreer;
    WindowCovering::Commands::UpOrOpen::Type request;

    new CHIPCommandSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable value, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            auto successFn = Callback<CHIPCommandSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)readAttributeTypeWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringClusterTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::Type::TypeInfo;
            auto successFn = Callback<WindowCoveringClusterTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                       params:(CHIPSubscribeParams * _Nullable)params
                      subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWindowCoveringClusterTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::Type::TypeInfo;
            auto successFn = Callback<WindowCoveringClusterTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWindowCoveringClusterTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                   endpoint:(NSNumber *)endpoint
                                      queue:(dispatch_queue_t)queue
                          completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringClusterTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WindowCovering::Attributes::Type::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WindowCoveringClusterTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentPositionLiftWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLift::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentPositionLiftWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLift::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentPositionLiftWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLift::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentPositionTiltWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTilt::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentPositionTiltWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTilt::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentPositionTiltWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTilt::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeConfigStatusWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringConfigStatusAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::ConfigStatus::TypeInfo;
            auto successFn = Callback<WindowCoveringConfigStatusAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeConfigStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWindowCoveringConfigStatusAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::ConfigStatus::TypeInfo;
            auto successFn = Callback<WindowCoveringConfigStatusAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWindowCoveringConfigStatusAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeConfigStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringConfigStatusAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WindowCovering::Attributes::ConfigStatus::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WindowCoveringConfigStatusAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentPositionLiftPercentageWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentPositionLiftPercentageWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentPositionLiftPercentageWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentPositionTiltPercentageWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentPositionTiltPercentageWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                params:(CHIPSubscribeParams * _Nullable)params
                                               subscriptionEstablished:
                                                   (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                         reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo;
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentPositionTiltPercentageWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                            endpoint:(NSNumber *)endpoint
                                                               queue:(dispatch_queue_t)queue
                                                   completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                         NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeOperationalStatusWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WindowCovering::Attributes::OperationalStatus::TypeInfo;
        auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeOperationalStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                               maxInterval:(NSNumber * _Nonnull)maxInterval
                                                    params:(CHIPSubscribeParams * _Nullable)params
                                   subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                             reportHandler:
                                                 (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt8uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::OperationalStatus::TypeInfo;
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt8uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeOperationalStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                endpoint:(NSNumber *)endpoint
                                                   queue:(dispatch_queue_t)queue
                                       completionHandler:
                                           (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt8uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::OperationalStatus::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int8uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTargetPositionLiftPercent100thsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                              NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeTargetPositionLiftPercent100thsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                  params:(CHIPSubscribeParams * _Nullable)params
                                                 subscriptionEstablished:
                                                     (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                           reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                             NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTargetPositionLiftPercent100thsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                              endpoint:(NSNumber *)endpoint
                                                                 queue:(dispatch_queue_t)queue
                                                     completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeTargetPositionTiltPercent100thsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                              NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeTargetPositionTiltPercent100thsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                  params:(CHIPSubscribeParams * _Nullable)params
                                                 subscriptionEstablished:
                                                     (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                           reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                             NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeTargetPositionTiltPercent100thsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                              endpoint:(NSNumber *)endpoint
                                                                 queue:(dispatch_queue_t)queue
                                                     completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                           NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeEndProductTypeWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                             NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringClusterEndProductTypeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::EndProductType::TypeInfo;
            auto successFn = Callback<WindowCoveringClusterEndProductTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeEndProductTypeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                            maxInterval:(NSNumber * _Nonnull)maxInterval
                                                 params:(CHIPSubscribeParams * _Nullable)params
                                subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                          reportHandler:
                                              (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWindowCoveringClusterEndProductTypeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::EndProductType::TypeInfo;
            auto successFn = Callback<WindowCoveringClusterEndProductTypeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWindowCoveringClusterEndProductTypeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeEndProductTypeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                             endpoint:(NSNumber *)endpoint
                                                queue:(dispatch_queue_t)queue
                                    completionHandler:
                                        (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringClusterEndProductTypeAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WindowCovering::Attributes::EndProductType::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WindowCoveringClusterEndProductTypeAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentPositionLiftPercent100thsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                   params:(CHIPSubscribeParams * _Nullable)params
                                                  subscriptionEstablished:
                                                      (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                            reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                              NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentPositionLiftPercent100thsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                               endpoint:(NSNumber *)endpoint
                                                                  queue:(dispatch_queue_t)queue
                                                      completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                               NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeCurrentPositionTiltPercent100thsWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                              maxInterval:(NSNumber * _Nonnull)maxInterval
                                                                   params:(CHIPSubscribeParams * _Nullable)params
                                                  subscriptionEstablished:
                                                      (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                            reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                              NSError * _Nullable error))reportHandler
{
    new CHIPNullableInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo;
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPNullableInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeCurrentPositionTiltPercent100thsWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                               endpoint:(NSNumber *)endpoint
                                                                  queue:(dispatch_queue_t)queue
                                                      completionHandler:(void (^)(NSNumber * _Nullable value,
                                                                            NSError * _Nullable error))completionHandler
{
    new CHIPNullableInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<NullableInt16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInstalledOpenLimitLiftWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeInstalledOpenLimitLiftWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInstalledOpenLimitLiftWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInstalledClosedLimitLiftWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeInstalledClosedLimitLiftWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                                           params:(CHIPSubscribeParams * _Nullable)params
                                          subscriptionEstablished:
                                              (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                    reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInstalledClosedLimitLiftWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                       endpoint:(NSNumber *)endpoint
                                                          queue:(dispatch_queue_t)queue
                                              completionHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInstalledOpenLimitTiltWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                     NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeInstalledOpenLimitTiltWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                    maxInterval:(NSNumber * _Nonnull)maxInterval
                                                         params:(CHIPSubscribeParams * _Nullable)params
                                        subscriptionEstablished:
                                            (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                  reportHandler:
                                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInstalledOpenLimitTiltWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                     endpoint:(NSNumber *)endpoint
                                                        queue:(dispatch_queue_t)queue
                                            completionHandler:
                                                (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeInstalledClosedLimitTiltWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                                       NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeInstalledClosedLimitTiltWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                      maxInterval:(NSNumber * _Nonnull)maxInterval
                                                           params:(CHIPSubscribeParams * _Nullable)params
                                          subscriptionEstablished:
                                              (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                    reportHandler:(void (^)(NSNumber * _Nullable value,
                                                                      NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeInstalledClosedLimitTiltWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                       endpoint:(NSNumber *)endpoint
                                                          queue:(dispatch_queue_t)queue
                                              completionHandler:
                                                  (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeModeWithCompletionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringModeAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::Mode::TypeInfo;
            auto successFn = Callback<WindowCoveringModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)writeAttributeModeWithValue:(NSNumber * _Nonnull)value completionHandler:(StatusCompletion)completionHandler
{
    new CHIPDefaultSuccessCallbackBridge(
        self.callbackQueue,
        ^(id _Nullable ignored, NSError * _Nullable error) {
            completionHandler(error);
        },
        ^(Cancelable * success, Cancelable * failure) {
            ListFreer listFreer;
            using TypeInfo = WindowCovering::Attributes::Mode::TypeInfo;
            TypeInfo::Type cppValue;
            cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(value.unsignedCharValue);
            auto successFn = Callback<CHIPDefaultSuccessCallbackType>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeModeWithMinInterval:(NSNumber * _Nonnull)minInterval
                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                       params:(CHIPSubscribeParams * _Nullable)params
                      subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWindowCoveringModeAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::Mode::TypeInfo;
            auto successFn = Callback<WindowCoveringModeAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWindowCoveringModeAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeModeWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                   endpoint:(NSNumber *)endpoint
                                      queue:(dispatch_queue_t)queue
                          completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringModeAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::Mode::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<WindowCoveringModeAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeSafetyStatusWithCompletionHandler:(void (^)(
                                                           NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WindowCovering::Attributes::SafetyStatus::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeSafetyStatusWithMinInterval:(NSNumber * _Nonnull)minInterval
                                          maxInterval:(NSNumber * _Nonnull)maxInterval
                                               params:(CHIPSubscribeParams * _Nullable)params
                              subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                        reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::SafetyStatus::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeSafetyStatusWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                           endpoint:(NSNumber *)endpoint
                                              queue:(dispatch_queue_t)queue
                                  completionHandler:
                                      (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::SafetyStatus::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeGeneratedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                   NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringGeneratedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<WindowCoveringGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeGeneratedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                  maxInterval:(NSNumber * _Nonnull)maxInterval
                                                       params:(CHIPSubscribeParams * _Nullable)params
                                      subscriptionEstablished:
                                          (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                                reportHandler:
                                                    (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWindowCoveringGeneratedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::GeneratedCommandList::TypeInfo;
            auto successFn = Callback<WindowCoveringGeneratedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWindowCoveringGeneratedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeGeneratedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                   endpoint:(NSNumber *)endpoint
                                                      queue:(dispatch_queue_t)queue
                                          completionHandler:
                                              (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringGeneratedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WindowCovering::Attributes::GeneratedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WindowCoveringGeneratedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAcceptedCommandListWithCompletionHandler:(void (^)(NSArray * _Nullable value,
                                                                  NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringAcceptedCommandListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<WindowCoveringAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAcceptedCommandListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                                 maxInterval:(NSNumber * _Nonnull)maxInterval
                                                      params:(CHIPSubscribeParams * _Nullable)params
                                     subscriptionEstablished:
                                         (SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                               reportHandler:
                                                   (void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWindowCoveringAcceptedCommandListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::AcceptedCommandList::TypeInfo;
            auto successFn = Callback<WindowCoveringAcceptedCommandListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWindowCoveringAcceptedCommandListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAcceptedCommandListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                                  endpoint:(NSNumber *)endpoint
                                                     queue:(dispatch_queue_t)queue
                                         completionHandler:
                                             (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringAcceptedCommandListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WindowCovering::Attributes::AcceptedCommandList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WindowCoveringAcceptedCommandListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeAttributeListWithCompletionHandler:(void (^)(
                                                            NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringAttributeListListAttributeCallbackBridge(
        self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            using TypeInfo = WindowCovering::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<WindowCoveringAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
        });
}

- (void)subscribeAttributeAttributeListWithMinInterval:(NSNumber * _Nonnull)minInterval
                                           maxInterval:(NSNumber * _Nonnull)maxInterval
                                                params:(CHIPSubscribeParams * _Nullable)params
                               subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                         reportHandler:(void (^)(NSArray * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPWindowCoveringAttributeListListAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::AttributeList::TypeInfo;
            auto successFn = Callback<WindowCoveringAttributeListListAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPWindowCoveringAttributeListListAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeAttributeListWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                            endpoint:(NSNumber *)endpoint
                                               queue:(dispatch_queue_t)queue
                                   completionHandler:
                                       (void (^)(NSArray * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPWindowCoveringAttributeListListAttributeCallbackBridge(
        queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
            if (attributeCacheContainer.cppAttributeCache) {
                chip::app::ConcreteAttributePath path;
                using TypeInfo = WindowCovering::Attributes::AttributeList::TypeInfo;
                path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
                path.mClusterId = TypeInfo::GetClusterId();
                path.mAttributeId = TypeInfo::GetAttributeId();
                TypeInfo::DecodableType value;
                CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
                auto successFn = Callback<WindowCoveringAttributeListListAttributeCallback>::FromCancelable(success);
                if (err == CHIP_NO_ERROR) {
                    successFn->mCall(successFn->mContext, value);
                }
                return err;
            }
            return CHIP_ERROR_NOT_FOUND;
        });
}

- (void)readAttributeFeatureMapWithCompletionHandler:(void (^)(
                                                         NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WindowCovering::Attributes::FeatureMap::TypeInfo;
        auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeFeatureMapWithMinInterval:(NSNumber * _Nonnull)minInterval
                                        maxInterval:(NSNumber * _Nonnull)maxInterval
                                             params:(CHIPSubscribeParams * _Nullable)params
                            subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                      reportHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt32uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::FeatureMap::TypeInfo;
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt32uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeFeatureMapWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                         endpoint:(NSNumber *)endpoint
                                            queue:(dispatch_queue_t)queue
                                completionHandler:(void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt32uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::FeatureMap::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int32uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

- (void)readAttributeClusterRevisionWithCompletionHandler:(void (^)(NSNumber * _Nullable value,
                                                              NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(self.callbackQueue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        using TypeInfo = WindowCovering::Attributes::ClusterRevision::TypeInfo;
        auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
        auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
        return self.cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall);
    });
}

- (void)subscribeAttributeClusterRevisionWithMinInterval:(NSNumber * _Nonnull)minInterval
                                             maxInterval:(NSNumber * _Nonnull)maxInterval
                                                  params:(CHIPSubscribeParams * _Nullable)params
                                 subscriptionEstablished:(SubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler
                                           reportHandler:
                                               (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))reportHandler
{
    new CHIPInt16uAttributeCallbackSubscriptionBridge(
        self.callbackQueue, reportHandler,
        ^(Cancelable * success, Cancelable * failure) {
            if (params != nil && params.autoResubscribe != nil && ![params.autoResubscribe boolValue]) {
                // We don't support disabling auto-resubscribe.
                return CHIP_ERROR_INVALID_ARGUMENT;
            }
            using TypeInfo = WindowCovering::Attributes::ClusterRevision::TypeInfo;
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            auto failureFn = Callback<CHIPDefaultFailureCallbackType>::FromCancelable(failure);
            return self.cppCluster.SubscribeAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall,
                [minInterval unsignedShortValue], [maxInterval unsignedShortValue],
                CHIPInt16uAttributeCallbackSubscriptionBridge::OnSubscriptionEstablished,
                params == nil || params.fabricFiltered == nil || [params.fabricFiltered boolValue],
                params != nil && params.keepPreviousSubscriptions != nil && [params.keepPreviousSubscriptions boolValue]);
        },
        subscriptionEstablishedHandler);
}

+ (void)readAttributeClusterRevisionWithAttributeCache:(CHIPAttributeCacheContainer *)attributeCacheContainer
                                              endpoint:(NSNumber *)endpoint
                                                 queue:(dispatch_queue_t)queue
                                     completionHandler:
                                         (void (^)(NSNumber * _Nullable value, NSError * _Nullable error))completionHandler
{
    new CHIPInt16uAttributeCallbackBridge(queue, completionHandler, ^(Cancelable * success, Cancelable * failure) {
        if (attributeCacheContainer.cppAttributeCache) {
            chip::app::ConcreteAttributePath path;
            using TypeInfo = WindowCovering::Attributes::ClusterRevision::TypeInfo;
            path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
            path.mClusterId = TypeInfo::GetClusterId();
            path.mAttributeId = TypeInfo::GetAttributeId();
            TypeInfo::DecodableType value;
            CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
            auto successFn = Callback<Int16uAttributeCallback>::FromCancelable(success);
            if (err == CHIP_NO_ERROR) {
                successFn->mCall(successFn->mContext, value);
            }
            return err;
        }
        return CHIP_ERROR_NOT_FOUND;
    });
}

@end
