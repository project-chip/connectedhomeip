/**
 *
 *    Copyright (c) 2023 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

#include <protocols/bdx/TransferFacilitator.h>

// #include <lib/core/OTAImageHeader.h>
// #include <platform/CHIPDeviceLayer.h>
// #include <platform/OTAImageProcessor.h>

/**
 * This class inherits from the AsyncResponder class and handles the BDX messages for a BDX transfer session.
 * It overrides the HandleTransferSessionOutput virtual method and provides an implementation for it to handle
 * the OutputEvents that are generated by the BDX transfer session state machine.
 *
 * An MTRDiagnosticLogsTransferHandler will be associated with a specific BDX transfer session.
 *
 * The lifecycle of this class is managed by the AsyncFacilitator class which calls the virtual CleanUp method
 * that is implemented by this class to clean up and destroy itself and the AsyncFacilitator instances.
 * Note: An object of this class can't be used after CleanUp has been called.
 */
class MTRDiagnosticLogsTransferHandler : public chip::bdx::Responder {
public:
    MTRDiagnosticLogsTransferHandler()
        : mFileURL(nil)
    {
    }

    MTRDiagnosticLogsTransferHandler(NSURL * _Nonnull url, void (^_Nonnull callback)(bool))
    {
        mFileURL = url;
        mCallback = callback;
    }

    ~MTRDiagnosticLogsTransferHandler() {};

    void HandleTransferSessionOutput(chip::bdx::TransferSession::OutputEvent & event) override;

    void AbortTransfer(chip::bdx::StatusCode reason);
  
    void Reset();

protected:
    CHIP_ERROR OnMessageReceived(chip::Messaging::ExchangeContext * _Nonnull ec, const chip::PayloadHeader & payloadHeader,
        chip::System::PacketBufferHandle && payload) override;

private:
    CHIP_ERROR PrepareForTransfer(chip::System::Layer * _Nonnull layer, chip::FabricIndex fabricIndex, chip::NodeId nodeId);

    CHIP_ERROR ConfigureState(chip::FabricIndex fabricIndex, chip::NodeId nodeId);

    CHIP_ERROR OnMessageToSend(chip::bdx::TransferSession::OutputEvent & event);

    CHIP_ERROR OnTransferSessionBegin(chip::bdx::TransferSession::OutputEvent & event);

    CHIP_ERROR OnTransferSessionEnd(chip::bdx::TransferSession::OutputEvent & event);

    CHIP_ERROR OnBlockReceived(chip::bdx::TransferSession::OutputEvent & event);

    // The fabric index of the node with which the BDX session is established.
    chip::Optional<chip::FabricIndex> mFabricIndex;

    // The node id of the node with which the BDX session is established.
    chip::Optional<chip::NodeId> mNodeId;

    chip::Messaging::ExchangeContext * _Nullable mExchangeCtx;

    NSURL * _Nullable mFileURL;

    NSFileHandle * _Nullable mFileHandle;
    std::function<void(bool)> mCallback;

    bool mInitialized = false;
};
