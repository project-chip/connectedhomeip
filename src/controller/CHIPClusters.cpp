/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPClusters.h"

#include <app/chip-zcl-zpro-codec-api.h>
#include <support/ReturnMacros.h>

namespace chip {
namespace Controller {

// TODO(#4502): onCompletion is not used by IM for now.
// TODO(#4503): length should be passed to commands when byte string is in argument list.
// TODO(#4503): Commands should take group id as an argument.

// ApplicationBasic Cluster Commands
// ApplicationBasic Cluster Attributes
CHIP_ERROR ApplicationBasicCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR ApplicationBasicCluster::ReadAttributeVendorName(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterReadVendorNameAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeVendorId(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterReadVendorIdAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeApplicationName(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterReadApplicationNameAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeProductId(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterReadProductIdAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeApplicationId(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterReadApplicationIdAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeCatalogVendorId(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterReadCatalogVendorIdAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeApplicationSatus(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterReadApplicationSatusAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ApplicationBasicCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeApplicationBasicClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// BarrierControl Cluster Commands
CHIP_ERROR BarrierControlCluster::BarrierControlGoToPercent(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, uint8_t percentOpen)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kBarrierControlGoToPercentCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // percentOpen: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), percentOpen));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeBarrierControlClusterBarrierControlGoToPercentCommand(seqNum, mEndpoint, percentOpen);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR BarrierControlCluster::BarrierControlStop(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kBarrierControlStopCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBarrierControlClusterBarrierControlStopCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// BarrierControl Cluster Attributes
CHIP_ERROR BarrierControlCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBarrierControlClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR BarrierControlCluster::ReadAttributeBarrierMovingState(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBarrierControlClusterReadBarrierMovingStateAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReadAttributeBarrierSafetyStatus(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBarrierControlClusterReadBarrierSafetyStatusAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReadAttributeBarrierCapabilities(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBarrierControlClusterReadBarrierCapabilitiesAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReadAttributeBarrierPosition(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBarrierControlClusterReadBarrierPositionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BarrierControlCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBarrierControlClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// Basic Cluster Commands
CHIP_ERROR BasicCluster::MfgSpecificPing(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMfgSpecificPingCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBasicClusterMfgSpecificPingCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR BasicCluster::ResetToFactoryDefaults(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kResetToFactoryDefaultsCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBasicClusterResetToFactoryDefaultsCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// Basic Cluster Attributes
CHIP_ERROR BasicCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBasicClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR BasicCluster::ReadAttributeZclVersion(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBasicClusterReadZclVersionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReadAttributePowerSource(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBasicClusterReadPowerSourceAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR BasicCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBasicClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// Binding Cluster Commands
CHIP_ERROR BindingCluster::Bind(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                chip::NodeId nodeId, chip::GroupId groupId, chip::EndpointId endpointId, chip::ClusterId clusterId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kBindCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // nodeId: nodeId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), nodeId));
    // groupId: groupId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // endpointId: endpointId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), endpointId));
    // clusterId: clusterId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), clusterId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeBindingClusterBindCommand(seqNum, mEndpoint, nodeId, groupId, endpointId, clusterId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR BindingCluster::Unbind(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                  chip::NodeId nodeId, chip::GroupId groupId, chip::EndpointId endpointId,
                                  chip::ClusterId clusterId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kUnbindCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // nodeId: nodeId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), nodeId));
    // groupId: groupId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // endpointId: endpointId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), endpointId));
    // clusterId: clusterId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), clusterId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeBindingClusterUnbindCommand(seqNum, mEndpoint, nodeId, groupId, endpointId, clusterId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// Binding Cluster Attributes
CHIP_ERROR BindingCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBindingClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR BindingCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeBindingClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// ColorControl Cluster Commands
CHIP_ERROR ColorControlCluster::MoveColor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          int16_t rateX, int16_t rateY, uint8_t optionsMask, uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveColorCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // rateX: int16s
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), rateX));
    // rateY: int16s
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), rateY));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterMoveColorCommand(seqNum, mEndpoint, rateX, rateY, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::MoveColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t moveMode, uint16_t rate,
                                                     uint16_t colorTemperatureMinimum, uint16_t colorTemperatureMaximum,
                                                     uint8_t optionsMask, uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveColorTemperatureCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // moveMode: hueMoveMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), rate));
    // colorTemperatureMinimum: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), colorTemperatureMinimum));
    // colorTemperatureMaximum: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), colorTemperatureMaximum));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterMoveColorTemperatureCommand(
        seqNum, mEndpoint, moveMode, rate, colorTemperatureMinimum, colorTemperatureMaximum, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::MoveHue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint8_t moveMode, uint8_t rate, uint8_t optionsMask, uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveHueCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // moveMode: hueMoveMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), rate));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterMoveHueCommand(seqNum, mEndpoint, moveMode, rate, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::MoveSaturation(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t moveMode, uint8_t rate, uint8_t optionsMask, uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveSaturationCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // moveMode: saturationMoveMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), rate));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterMoveSaturationCommand(seqNum, mEndpoint, moveMode, rate, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::MoveToColor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                            uint16_t colorX, uint16_t colorY, uint16_t transitionTime, uint8_t optionsMask,
                                            uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveToColorCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // colorX: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), colorX));
    // colorY: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), colorY));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterMoveToColorCommand(
        seqNum, mEndpoint, colorX, colorY, transitionTime, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::MoveToColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t colorTemperature,
                                                       uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveToColorTemperatureCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // colorTemperature: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), colorTemperature));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterMoveToColorTemperatureCommand(
        seqNum, mEndpoint, colorTemperature, transitionTime, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::MoveToHue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          uint8_t hue, uint8_t direction, uint16_t transitionTime, uint8_t optionsMask,
                                          uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveToHueCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // hue: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), hue));
    // direction: hueDirection
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), direction));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterMoveToHueCommand(seqNum, mEndpoint, hue, direction, transitionTime, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::MoveToHueAndSaturation(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint8_t hue, uint8_t saturation,
                                                       uint16_t transitionTime, uint8_t optionsMask, uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveToHueAndSaturationCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // hue: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), hue));
    // saturation: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), saturation));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterMoveToHueAndSaturationCommand(
        seqNum, mEndpoint, hue, saturation, transitionTime, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::MoveToSaturation(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t saturation, uint16_t transitionTime, uint8_t optionsMask,
                                                 uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveToSaturationCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // saturation: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), saturation));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterMoveToSaturationCommand(
        seqNum, mEndpoint, saturation, transitionTime, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::StepColor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          int16_t stepX, int16_t stepY, uint16_t transitionTime, uint8_t optionsMask,
                                          uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStepColorCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // stepX: int16s
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepX));
    // stepY: int16s
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepY));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterStepColorCommand(seqNum, mEndpoint, stepX, stepY, transitionTime, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::StepColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t stepMode, uint16_t stepSize,
                                                     uint16_t transitionTime, uint16_t colorTemperatureMinimum,
                                                     uint16_t colorTemperatureMaximum, uint8_t optionsMask, uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStepColorTemperatureCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // stepMode: hueStepMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // colorTemperatureMinimum: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), colorTemperatureMinimum));
    // colorTemperatureMaximum: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), colorTemperatureMaximum));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterStepColorTemperatureCommand(
        seqNum, mEndpoint, stepMode, stepSize, transitionTime, colorTemperatureMinimum, colorTemperatureMaximum, optionsMask,
        optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::StepHue(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint8_t stepMode, uint8_t stepSize, uint8_t transitionTime, uint8_t optionsMask,
                                        uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStepHueCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // stepMode: hueStepMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterStepHueCommand(
        seqNum, mEndpoint, stepMode, stepSize, transitionTime, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::StepSaturation(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t stepMode, uint8_t stepSize, uint8_t transitionTime, uint8_t optionsMask,
                                               uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStepSaturationCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // stepMode: saturationStepMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterStepSaturationCommand(
        seqNum, mEndpoint, stepMode, stepSize, transitionTime, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ColorControlCluster::StopMoveStep(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             uint8_t optionsMask, uint8_t optionsOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStopMoveStepCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // optionsMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsMask));
    // optionsOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionsOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterStopMoveStepCommand(seqNum, mEndpoint, optionsMask, optionsOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// ColorControl Cluster Attributes
CHIP_ERROR ColorControlCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR ColorControlCluster::ReadAttributeCurrentHue(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadCurrentHueAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ConfigureAttributeCurrentHue(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                             uint16_t maxInterval, uint8_t change)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterConfigureCurrentHueAttribute(seqNum, mEndpoint, minInterval, maxInterval, change);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCurrentHue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0000, onReportCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCurrentSaturation(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadCurrentSaturationAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ConfigureAttributeCurrentSaturation(Callback::Cancelable * onSuccessCallback,
                                                                    Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                    uint16_t maxInterval, uint8_t change)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterConfigureCurrentSaturationAttribute(seqNum, mEndpoint, minInterval, maxInterval, change);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCurrentSaturation(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0001, onReportCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeRemainingTime(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadRemainingTimeAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCurrentX(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadCurrentXAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ConfigureAttributeCurrentX(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval, uint16_t change)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterConfigureCurrentXAttribute(seqNum, mEndpoint, minInterval, maxInterval, change);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCurrentX(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0003, onReportCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCurrentY(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadCurrentYAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ConfigureAttributeCurrentY(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                           uint16_t maxInterval, uint16_t change)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterConfigureCurrentYAttribute(seqNum, mEndpoint, minInterval, maxInterval, change);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeCurrentY(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0004, onReportCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeDriftCompensation(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadDriftCompensationAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCompensationText(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadCompensationTextAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorTemperatureAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ConfigureAttributeColorTemperature(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                                   uint16_t maxInterval, uint16_t change)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterConfigureColorTemperatureAttribute(seqNum, mEndpoint, minInterval, maxInterval, change);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReportAttributeColorTemperature(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0007, onReportCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorMode(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorModeAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorControlOptions(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorControlOptionsAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorControlOptions(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback, uint8_t value)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterWriteColorControlOptionsAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeNumberOfPrimaries(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadNumberOfPrimariesAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary1X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary1XAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary1Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary1YAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary1Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary1IntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary2X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary2XAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary2Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary2YAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary2Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary2IntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary3X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary3XAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary3Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary3YAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary3Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary3IntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary4X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary4XAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary4Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary4YAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary4Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary4IntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary5X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary5XAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary5Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary5YAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary5Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary5IntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary6X(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary6XAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary6Y(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary6YAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributePrimary6Intensity(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadPrimary6IntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeWhitePointX(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadWhitePointXAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeWhitePointX(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterWriteWhitePointXAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeWhitePointY(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadWhitePointYAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeWhitePointY(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterWriteWhitePointYAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointRX(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointRXAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointRX(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterWriteColorPointRXAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointRY(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointRYAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointRY(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterWriteColorPointRYAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointRIntensity(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointRIntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointRIntensity(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterWriteColorPointRIntensityAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointGX(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointGXAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointGX(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterWriteColorPointGXAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointGY(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointGYAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointGY(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterWriteColorPointGYAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointGIntensity(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointGIntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointGIntensity(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterWriteColorPointGIntensityAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointBX(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointBXAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointBX(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterWriteColorPointBXAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointBY(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointBYAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointBY(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterWriteColorPointBYAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorPointBIntensity(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorPointBIntensityAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeColorPointBIntensity(Callback::Cancelable * onSuccessCallback,
                                                                   Callback::Cancelable * onFailureCallback, uint8_t value)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterWriteColorPointBIntensityAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeEnhancedCurrentHue(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadEnhancedCurrentHueAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeEnhancedColorMode(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadEnhancedColorModeAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorLoopActive(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorLoopActiveAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorLoopDirection(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorLoopDirectionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorLoopTime(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorLoopTimeAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorCapabilities(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorCapabilitiesAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorTempPhysicalMin(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorTempPhysicalMinAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeColorTempPhysicalMax(Callback::Cancelable * onSuccessCallback,
                                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadColorTempPhysicalMaxAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeCoupleColorTempToLevelMinMireds(Callback::Cancelable * onSuccessCallback,
                                                                             Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterReadCoupleColorTempToLevelMinMiredsAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeStartUpColorTemperatureMireds(Callback::Cancelable * onSuccessCallback,
                                                                           Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterReadStartUpColorTemperatureMiredsAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::WriteAttributeStartUpColorTemperatureMireds(Callback::Cancelable * onSuccessCallback,
                                                                            Callback::Cancelable * onFailureCallback,
                                                                            uint16_t value)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeColorControlClusterWriteStartUpColorTemperatureMiredsAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ColorControlCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeColorControlClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// ContentLaunch Cluster Commands
CHIP_ERROR ContentLaunchCluster::LaunchContent(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kLaunchContentCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeContentLaunchClusterLaunchContentCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ContentLaunchCluster::LaunchURL(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kLaunchURLCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeContentLaunchClusterLaunchURLCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// ContentLaunch Cluster Attributes
CHIP_ERROR ContentLaunchCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeContentLaunchClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR ContentLaunchCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeContentLaunchClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// DoorLock Cluster Commands
CHIP_ERROR DoorLockCluster::ClearAllPins(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kClearAllPinsCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterClearAllPinsCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::ClearAllRfids(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kClearAllRfidsCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterClearAllRfidsCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::ClearHolidaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t scheduleId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kClearHolidayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterClearHolidayScheduleCommand(seqNum, mEndpoint, scheduleId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::ClearPin(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kClearPinCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterClearPinCommand(seqNum, mEndpoint, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::ClearRfid(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kClearRfidCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterClearRfidCommand(seqNum, mEndpoint, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::ClearWeekdaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t scheduleId, uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kClearWeekdayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterClearWeekdayScheduleCommand(seqNum, mEndpoint, scheduleId, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::ClearYeardaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint8_t scheduleId, uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kClearYeardayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterClearYeardayScheduleCommand(seqNum, mEndpoint, scheduleId, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::GetHolidaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetHolidayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterGetHolidayScheduleCommand(seqNum, mEndpoint, scheduleId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::GetLogRecord(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                         uint16_t logIndex)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetLogRecordCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // logIndex: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), logIndex));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterGetLogRecordCommand(seqNum, mEndpoint, logIndex);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::GetPin(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                   uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetPinCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterGetPinCommand(seqNum, mEndpoint, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::GetRfid(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                    uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetRfidCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterGetRfidCommand(seqNum, mEndpoint, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::GetUserType(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetUserTypeCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterGetUserTypeCommand(seqNum, mEndpoint, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::GetWeekdaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetWeekdayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterGetWeekdayScheduleCommand(seqNum, mEndpoint, scheduleId, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::GetYeardaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint16_t userId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetYeardayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterGetYeardayScheduleCommand(seqNum, mEndpoint, scheduleId, userId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::LockDoor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback, char * pin)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kLockDoorCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // pin: charString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), pin));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterLockDoorCommand(seqNum, mEndpoint, pin);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::SetHolidaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint32_t localStartTime, uint32_t localEndTime,
                                               uint8_t operatingModeDuringHoliday)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSetHolidayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // localStartTime: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), localStartTime));
    // localEndTime: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), localEndTime));
    // operatingModeDuringHoliday: enum8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), operatingModeDuringHoliday));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterSetHolidayScheduleCommand(
        seqNum, mEndpoint, scheduleId, localStartTime, localEndTime, operatingModeDuringHoliday);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::SetPin(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                   uint16_t userId, uint8_t userStatus, uint8_t userType, char * pin)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSetPinCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));
    // userStatus: doorLockUserStatus
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userStatus));
    // userType: doorLockUserType
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userType));
    // pin: charString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), pin));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterSetPinCommand(seqNum, mEndpoint, userId, userStatus, userType, pin);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::SetRfid(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                    uint16_t userId, uint8_t userStatus, uint8_t userType, char * id)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSetRfidCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));
    // userStatus: doorLockUserStatus
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userStatus));
    // userType: doorLockUserType
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userType));
    // id: charString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), id));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterSetRfidCommand(seqNum, mEndpoint, userId, userStatus, userType, id);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::SetUserType(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                        uint16_t userId, uint8_t userType)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSetUserTypeCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));
    // userType: doorLockUserType
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userType));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterSetUserTypeCommand(seqNum, mEndpoint, userId, userType);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::SetWeekdaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint16_t userId, uint8_t daysMask, uint8_t startHour,
                                               uint8_t startMinute, uint8_t endHour, uint8_t endMinute)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSetWeekdayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));
    // daysMask: doorLockDayOfWeek
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), daysMask));
    // startHour: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), startHour));
    // startMinute: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), startMinute));
    // endHour: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), endHour));
    // endMinute: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), endMinute));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterSetWeekdayScheduleCommand(
        seqNum, mEndpoint, scheduleId, userId, daysMask, startHour, startMinute, endHour, endMinute);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::SetYeardaySchedule(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                               uint8_t scheduleId, uint16_t userId, uint32_t localStartTime, uint32_t localEndTime)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSetYeardayScheduleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // scheduleId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), scheduleId));
    // userId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), userId));
    // localStartTime: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), localStartTime));
    // localEndTime: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), localEndTime));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterSetYeardayScheduleCommand(seqNum, mEndpoint, scheduleId, userId, localStartTime, localEndTime);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::UnlockDoor(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                       char * pin)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kUnlockDoorCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // pin: charString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), pin));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterUnlockDoorCommand(seqNum, mEndpoint, pin);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR DoorLockCluster::UnlockWithTimeout(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint16_t timeoutInSeconds, char * pin)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kUnlockWithTimeoutCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // timeoutInSeconds: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutInSeconds));
    // pin: charString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), pin));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterUnlockWithTimeoutCommand(seqNum, mEndpoint, timeoutInSeconds, pin);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// DoorLock Cluster Attributes
CHIP_ERROR DoorLockCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR DoorLockCluster::ReadAttributeLockState(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterReadLockStateAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DoorLockCluster::ConfigureAttributeLockState(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                        uint16_t maxInterval)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeDoorLockClusterConfigureLockStateAttribute(seqNum, mEndpoint, minInterval, maxInterval);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DoorLockCluster::ReportAttributeLockState(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0000, onReportCallback);
}

CHIP_ERROR DoorLockCluster::ReadAttributeLockType(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterReadLockTypeAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DoorLockCluster::ReadAttributeActuatorEnabled(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterReadActuatorEnabledAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR DoorLockCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeDoorLockClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// GeneralCommissioning Cluster Commands
CHIP_ERROR GeneralCommissioningCluster::ArmFailSafe(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback, uint16_t expiryLengthSeconds,
                                                    uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kArmFailSafeCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // expiryLengthSeconds: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), expiryLengthSeconds));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeGeneralCommissioningClusterArmFailSafeCommand(seqNum, mEndpoint, expiryLengthSeconds, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR GeneralCommissioningCluster::CommissioningComplete(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kCommissioningCompleteCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGeneralCommissioningClusterCommissioningCompleteCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR GeneralCommissioningCluster::SetFabric(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback, char * fabricId, char * fabricSecret,
                                                  uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSetFabricCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // fabricId: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), fabricId));
    // fabricSecret: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), fabricSecret));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeGeneralCommissioningClusterSetFabricCommand(seqNum, mEndpoint, fabricId, fabricSecret, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// GeneralCommissioning Cluster Attributes
CHIP_ERROR GeneralCommissioningCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGeneralCommissioningClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR GeneralCommissioningCluster::ReadAttributeFabricId(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGeneralCommissioningClusterReadFabricIdAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralCommissioningCluster::ReadAttributeBreadcrumb(Callback::Cancelable * onSuccessCallback,
                                                                Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGeneralCommissioningClusterReadBreadcrumbAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralCommissioningCluster::WriteAttributeBreadcrumb(Callback::Cancelable * onSuccessCallback,
                                                                 Callback::Cancelable * onFailureCallback, uint64_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGeneralCommissioningClusterWriteBreadcrumbAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GeneralCommissioningCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGeneralCommissioningClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// Groups Cluster Commands
CHIP_ERROR GroupsCluster::AddGroup(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                   uint16_t groupId, char * groupName)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kAddGroupCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // groupName: charString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), groupName));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGroupsClusterAddGroupCommand(seqNum, mEndpoint, groupId, groupName);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR GroupsCluster::AddGroupIfIdentifying(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                uint16_t groupId, char * groupName)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kAddGroupIfIdentifyingCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // groupName: charString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), groupName));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeGroupsClusterAddGroupIfIdentifyingCommand(seqNum, mEndpoint, groupId, groupName);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR GroupsCluster::GetGroupMembership(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             uint8_t groupCount, uint16_t groupList)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetGroupMembershipCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupCount: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupCount));
    // groupList: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupList));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeGroupsClusterGetGroupMembershipCommand(seqNum, mEndpoint, groupCount, groupList);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR GroupsCluster::RemoveAllGroups(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kRemoveAllGroupsCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGroupsClusterRemoveAllGroupsCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR GroupsCluster::RemoveGroup(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      uint16_t groupId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kRemoveGroupCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGroupsClusterRemoveGroupCommand(seqNum, mEndpoint, groupId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR GroupsCluster::ViewGroup(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                    uint16_t groupId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kViewGroupCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGroupsClusterViewGroupCommand(seqNum, mEndpoint, groupId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// Groups Cluster Attributes
CHIP_ERROR GroupsCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGroupsClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR GroupsCluster::ReadAttributeNameSupport(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGroupsClusterReadNameSupportAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR GroupsCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeGroupsClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// IasZone Cluster Commands
// IasZone Cluster Attributes
CHIP_ERROR IasZoneCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIasZoneClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR IasZoneCluster::ReadAttributeZoneState(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIasZoneClusterReadZoneStateAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IasZoneCluster::ReadAttributeZoneType(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIasZoneClusterReadZoneTypeAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IasZoneCluster::ReadAttributeZoneStatus(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIasZoneClusterReadZoneStatusAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IasZoneCluster::ReadAttributeIasCieAddress(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIasZoneClusterReadIasCieAddressAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IasZoneCluster::WriteAttributeIasCieAddress(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint64_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIasZoneClusterWriteIasCieAddressAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IasZoneCluster::ReadAttributeZoneId(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIasZoneClusterReadZoneIdAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IasZoneCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                        Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIasZoneClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// Identify Cluster Commands
CHIP_ERROR IdentifyCluster::Identify(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint16_t identifyTime)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kIdentifyCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // identifyTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), identifyTime));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIdentifyClusterIdentifyCommand(seqNum, mEndpoint, identifyTime);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR IdentifyCluster::IdentifyQuery(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kIdentifyQueryCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIdentifyClusterIdentifyQueryCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// Identify Cluster Attributes
CHIP_ERROR IdentifyCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIdentifyClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR IdentifyCluster::ReadAttributeIdentifyTime(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIdentifyClusterReadIdentifyTimeAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IdentifyCluster::WriteAttributeIdentifyTime(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, uint16_t value)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIdentifyClusterWriteIdentifyTimeAttribute(seqNum, mEndpoint, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR IdentifyCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeIdentifyClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// LevelControl Cluster Commands
CHIP_ERROR LevelControlCluster::Move(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint8_t moveMode, uint8_t rate, uint8_t optionMask, uint8_t optionOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // moveMode: moveMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), rate));
    // optionMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionMask));
    // optionOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeLevelControlClusterMoveCommand(seqNum, mEndpoint, moveMode, rate, optionMask, optionOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR LevelControlCluster::MoveToLevel(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                            uint8_t level, uint16_t transitionTime, uint8_t optionMask, uint8_t optionOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveToLevelCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // level: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), level));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionMask));
    // optionOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeLevelControlClusterMoveToLevelCommand(seqNum, mEndpoint, level, transitionTime, optionMask, optionOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR LevelControlCluster::MoveToLevelWithOnOff(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, uint8_t level,
                                                     uint16_t transitionTime)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveToLevelWithOnOffCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // level: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), level));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeLevelControlClusterMoveToLevelWithOnOffCommand(seqNum, mEndpoint, level, transitionTime);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR LevelControlCluster::MoveWithOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint8_t moveMode, uint8_t rate)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kMoveWithOnOffCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // moveMode: moveMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), moveMode));
    // rate: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), rate));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeLevelControlClusterMoveWithOnOffCommand(seqNum, mEndpoint, moveMode, rate);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR LevelControlCluster::Step(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint8_t stepMode, uint8_t stepSize, uint16_t transitionTime, uint8_t optionMask,
                                     uint8_t optionOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStepCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // stepMode: stepMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // optionMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionMask));
    // optionOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeLevelControlClusterStepCommand(seqNum, mEndpoint, stepMode, stepSize, transitionTime, optionMask, optionOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR LevelControlCluster::StepWithOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                              uint8_t stepMode, uint8_t stepSize, uint16_t transitionTime)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStepWithOnOffCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // stepMode: stepMode
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepMode));
    // stepSize: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), stepSize));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeLevelControlClusterStepWithOnOffCommand(seqNum, mEndpoint, stepMode, stepSize, transitionTime);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR LevelControlCluster::Stop(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint8_t optionMask, uint8_t optionOverride)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStopCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // optionMask: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionMask));
    // optionOverride: bitmap8
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), optionOverride));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeLevelControlClusterStopCommand(seqNum, mEndpoint, optionMask, optionOverride);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR LevelControlCluster::StopWithOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStopWithOnOffCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeLevelControlClusterStopWithOnOffCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// LevelControl Cluster Attributes
CHIP_ERROR LevelControlCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeLevelControlClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR LevelControlCluster::ReadAttributeCurrentLevel(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeLevelControlClusterReadCurrentLevelAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ConfigureAttributeCurrentLevel(Callback::Cancelable * onSuccessCallback,
                                                               Callback::Cancelable * onFailureCallback, uint16_t minInterval,
                                                               uint16_t maxInterval, uint8_t change)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeLevelControlClusterConfigureCurrentLevelAttribute(seqNum, mEndpoint, minInterval, maxInterval, change);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR LevelControlCluster::ReportAttributeCurrentLevel(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0000, onReportCallback);
}

CHIP_ERROR LevelControlCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeLevelControlClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// MediaPlayback Cluster Commands
CHIP_ERROR MediaPlaybackCluster::FastForwardRequest(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kFastForwardRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterFastForwardRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::NextRequest(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kNextRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterNextRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::PauseRequest(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kPauseRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterPauseRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::PlayRequest(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kPlayRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterPlayRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::PreviousRequest(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kPreviousRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterPreviousRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::RewindRequest(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kRewindRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterRewindRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::SkipBackwardRequest(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSkipBackwardRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterSkipBackwardRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::SkipForwardRequest(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kSkipForwardRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterSkipForwardRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::StartOverRequest(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStartOverRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterStartOverRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR MediaPlaybackCluster::StopRequest(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStopRequestCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterStopRequestCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// MediaPlayback Cluster Attributes
CHIP_ERROR MediaPlaybackCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR MediaPlaybackCluster::ReadAttributeCurrentState(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterReadCurrentStateAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR MediaPlaybackCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                              Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeMediaPlaybackClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// NetworkCommissioning Cluster Commands
CHIP_ERROR NetworkCommissioningCluster::AddThreadNetwork(Callback::Cancelable * onSuccessCallback,
                                                         Callback::Cancelable * onFailureCallback, char * operationalDataset,
                                                         uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kAddThreadNetworkCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // operationalDataset: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), operationalDataset));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterAddThreadNetworkCommand(seqNum, mEndpoint, operationalDataset, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR NetworkCommissioningCluster::AddWiFiNetwork(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, char * ssid, char * credentials,
                                                       uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kAddWiFiNetworkCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // ssid: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), ssid));
    // credentials: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), credentials));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterAddWiFiNetworkCommand(seqNum, mEndpoint, ssid, credentials, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR NetworkCommissioningCluster::DisableNetwork(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback, char * networkID,
                                                       uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kDisableNetworkCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // networkID: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), networkID));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterDisableNetworkCommand(seqNum, mEndpoint, networkID, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR NetworkCommissioningCluster::EnableNetwork(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, char * networkID,
                                                      uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kEnableNetworkCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // networkID: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), networkID));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterEnableNetworkCommand(seqNum, mEndpoint, networkID, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR NetworkCommissioningCluster::GetLastNetworkCommissioningResult(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetLastNetworkCommissioningResultCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterGetLastNetworkCommissioningResultCommand(seqNum, mEndpoint, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR NetworkCommissioningCluster::RemoveNetwork(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback, char * networkID,
                                                      uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kRemoveNetworkCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // networkID: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), networkID));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterRemoveNetworkCommand(seqNum, mEndpoint, networkID, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR NetworkCommissioningCluster::ScanNetworks(Callback::Cancelable * onSuccessCallback,
                                                     Callback::Cancelable * onFailureCallback, char * ssid, uint64_t breadcrumb,
                                                     uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kScanNetworksCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // ssid: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), ssid));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterScanNetworksCommand(seqNum, mEndpoint, ssid, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR NetworkCommissioningCluster::UpdateThreadNetwork(Callback::Cancelable * onSuccessCallback,
                                                            Callback::Cancelable * onFailureCallback, char * operationalDataset,
                                                            uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kUpdateThreadNetworkCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // operationalDataset: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), operationalDataset));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterUpdateThreadNetworkCommand(seqNum, mEndpoint, operationalDataset, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR NetworkCommissioningCluster::UpdateWiFiNetwork(Callback::Cancelable * onSuccessCallback,
                                                          Callback::Cancelable * onFailureCallback, char * ssid, char * credentials,
                                                          uint64_t breadcrumb, uint32_t timeoutMs)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kUpdateWiFiNetworkCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // ssid: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), ssid));
    // credentials: octetString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), credentials));
    // breadcrumb: int64u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), breadcrumb));
    // timeoutMs: int32u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), timeoutMs));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeNetworkCommissioningClusterUpdateWiFiNetworkCommand(seqNum, mEndpoint, ssid, credentials, breadcrumb, timeoutMs);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// NetworkCommissioning Cluster Attributes
CHIP_ERROR NetworkCommissioningCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                           Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeNetworkCommissioningClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR NetworkCommissioningCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeNetworkCommissioningClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// OnOff Cluster Commands
CHIP_ERROR OnOffCluster::Off(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kOffCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeOnOffClusterOffCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR OnOffCluster::On(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kOnCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeOnOffClusterOnCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR OnOffCluster::Toggle(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kToggleCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    // Command takes no arguments.

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeOnOffClusterToggleCommand(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// OnOff Cluster Attributes
CHIP_ERROR OnOffCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeOnOffClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR OnOffCluster::ReadAttributeOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeOnOffClusterReadOnOffAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ConfigureAttributeOnOff(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                                 uint16_t minInterval, uint16_t maxInterval)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeOnOffClusterConfigureOnOffAttribute(seqNum, mEndpoint, minInterval, maxInterval);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR OnOffCluster::ReportAttributeOnOff(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0000, onReportCallback);
}

CHIP_ERROR OnOffCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                      Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeOnOffClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// Scenes Cluster Commands
CHIP_ERROR ScenesCluster::AddScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                   uint16_t groupId, uint8_t sceneId, uint16_t transitionTime, char * sceneName,
                                   chip::ClusterId clusterId, uint8_t length, uint8_t value)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kAddSceneCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), sceneId));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));
    // sceneName: charString
    ReturnErrorOnFailure(writer.PutString(TLV::ContextTag(argSeqNumber++), sceneName));
    // clusterId: clusterId
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), clusterId));
    // length: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), length));
    // value: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), value));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterAddSceneCommand(
        seqNum, mEndpoint, groupId, sceneId, transitionTime, sceneName, clusterId, length, value);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ScenesCluster::GetSceneMembership(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                             uint16_t groupId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kGetSceneMembershipCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterGetSceneMembershipCommand(seqNum, mEndpoint, groupId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ScenesCluster::RecallScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      uint16_t groupId, uint8_t sceneId, uint16_t transitionTime)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kRecallSceneCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), sceneId));
    // transitionTime: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), transitionTime));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeScenesClusterRecallSceneCommand(seqNum, mEndpoint, groupId, sceneId, transitionTime);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ScenesCluster::RemoveAllScenes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                          uint16_t groupId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kRemoveAllScenesCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterRemoveAllScenesCommand(seqNum, mEndpoint, groupId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ScenesCluster::RemoveScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                      uint16_t groupId, uint8_t sceneId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kRemoveSceneCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), sceneId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterRemoveSceneCommand(seqNum, mEndpoint, groupId, sceneId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ScenesCluster::StoreScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                     uint16_t groupId, uint8_t sceneId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kStoreSceneCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), sceneId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterStoreSceneCommand(seqNum, mEndpoint, groupId, sceneId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

CHIP_ERROR ScenesCluster::ViewScene(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback,
                                    uint16_t groupId, uint8_t sceneId)
{
#ifdef CHIP_APP_USE_INTERACTION_MODEL
    VerifyOrReturnError(mDevice != nullptr, CHIP_ERROR_INCORRECT_STATE);
    (void) onCompletion;

    app::Command::CommandParams cmdParams = { mEndpoint, /* group id */ 0, mClusterId, kViewSceneCommandId,
                                              (chip::app::Command::kCommandPathFlag_EndpointIdValid) };
    app::Command * ZCLcommand             = mDevice->GetCommandSender();

    TLV::TLVWriter writer = ZCLcommand->CreateCommandDataElementTLVWriter();

    TLV::TLVType dummyType = TLV::kTLVType_NotSpecified;
    ReturnErrorOnFailure(writer.StartContainer(TLV::AnonymousTag, TLV::kTLVType_Structure, dummyType));

    uint8_t argSeqNumber = 0;
    // groupId: int16u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), groupId));
    // sceneId: int8u
    ReturnErrorOnFailure(writer.Put(TLV::ContextTag(argSeqNumber++), sceneId));

    ReturnErrorOnFailure(writer.EndContainer(dummyType));
    ReturnErrorOnFailure(writer.Finalize());
    ReturnErrorOnFailure(ZCLcommand->AddCommand(cmdParams));

    return mDevice->SendCommands();
#else
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterViewSceneCommand(seqNum, mEndpoint, groupId, sceneId);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
#endif
}

// Scenes Cluster Attributes
CHIP_ERROR ScenesCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback, Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR ScenesCluster::ReadAttributeSceneCount(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterReadSceneCountAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReadAttributeCurrentScene(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterReadCurrentSceneAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReadAttributeCurrentGroup(Callback::Cancelable * onSuccessCallback,
                                                    Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterReadCurrentGroupAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReadAttributeSceneValid(Callback::Cancelable * onSuccessCallback,
                                                  Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterReadSceneValidAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReadAttributeNameSupport(Callback::Cancelable * onSuccessCallback,
                                                   Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterReadNameSupportAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR ScenesCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeScenesClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

// TemperatureMeasurement Cluster Commands
// TemperatureMeasurement Cluster Attributes
CHIP_ERROR TemperatureMeasurementCluster::DiscoverAttributes(Callback::Cancelable * onSuccessCallback,
                                                             Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeTemperatureMeasurementClusterDiscoverAttributes(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}
CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                     Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeTemperatureMeasurementClusterReadMeasuredValueAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ConfigureAttributeMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                          Callback::Cancelable * onFailureCallback,
                                                                          uint16_t minInterval, uint16_t maxInterval,
                                                                          int16_t change)
{
    uint8_t seqNum = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand =
        encodeTemperatureMeasurementClusterConfigureMeasuredValueAttribute(seqNum, mEndpoint, minInterval, maxInterval, change);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReportAttributeMeasuredValue(Callback::Cancelable * onReportCallback)
{
    return RequestAttributeReporting(0x0000, onReportCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeMinMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeTemperatureMeasurementClusterReadMinMeasuredValueAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeMaxMeasuredValue(Callback::Cancelable * onSuccessCallback,
                                                                        Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeTemperatureMeasurementClusterReadMaxMeasuredValueAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

CHIP_ERROR TemperatureMeasurementCluster::ReadAttributeClusterRevision(Callback::Cancelable * onSuccessCallback,
                                                                       Callback::Cancelable * onFailureCallback)
{
    uint8_t seqNum                            = mDevice->GetNextSequenceNumber();
    System::PacketBufferHandle encodedCommand = encodeTemperatureMeasurementClusterReadClusterRevisionAttribute(seqNum, mEndpoint);
    return SendCommand(seqNum, std::move(encodedCommand), onSuccessCallback, onFailureCallback);
}

} // namespace Controller
} // namespace chip
