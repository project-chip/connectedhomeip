// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
}

struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
}

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
client cluster Identify = 3 {
  enum IdentifyEffectIdentifier : ENUM8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum IdentifyEffectVariant : ENUM8 {
    kDefault = 0;
  }

  enum IdentifyIdentifyType : ENUM8 {
    kNone = 0;
    kVisibleLight = 1;
    kVisibleLED = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute enum8 identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    INT16U identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    IdentifyEffectIdentifier effectIdentifier = 0;
    IdentifyEffectVariant effectVariant = 1;
  }

  /** Command description for Identify */
  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  /** Command description for TriggerEffect */
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** Attributes and commands for group configuration and manipulation. */
client cluster Groups = 4 {
  bitmap Feature : BITMAP32 {
    kGroupNames = 0x1;
  }

  readonly attribute bitmap8 nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    CHAR_STRING groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    ENUM8 status = 0;
    group_id groupID = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  response struct ViewGroupResponse = 1 {
    ENUM8 status = 0;
    group_id groupID = 1;
    CHAR_STRING groupName = 2;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable INT8U capacity = 0;
    group_id groupList[] = 1;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  response struct RemoveGroupResponse = 3 {
    ENUM8 status = 0;
    group_id groupID = 1;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    CHAR_STRING groupName = 1;
  }

  /** Command description for AddGroup */
  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  /** Command description for ViewGroup */
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  /** Command description for GetGroupMembership */
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  /** Command description for RemoveGroup */
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  /** Command description for RemoveAllGroups */
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  /** Command description for AddGroupIfIdentifying */
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

/** Attributes and commands for scene configuration and manipulation. */
client cluster Scenes = 5 {
  bitmap Feature : BITMAP32 {
    kSceneNames = 0x1;
  }

  bitmap ScenesCopyMode : BITMAP8 {
    kCopyAllScenes = 0x1;
  }

  struct AttributeValuePair {
    optional attrib_id attributeID = 0;
    int8u attributeValue[] = 1;
  }

  struct ExtensionFieldSet {
    cluster_id clusterID = 0;
    AttributeValuePair attributeValueList[] = 1;
  }

  readonly attribute int8u sceneCount = 0;
  readonly attribute int8u currentScene = 1;
  readonly attribute group_id currentGroup = 2;
  readonly attribute boolean sceneValid = 3;
  readonly attribute bitmap8 nameSupport = 4;
  readonly attribute optional nullable node_id lastConfiguredBy = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddSceneRequest {
    group_id groupID = 0;
    INT8U sceneID = 1;
    INT16U transitionTime = 2;
    CHAR_STRING sceneName = 3;
    ExtensionFieldSet extensionFieldSets[] = 4;
  }

  response struct AddSceneResponse = 0 {
    status status = 0;
    group_id groupID = 1;
    INT8U sceneID = 2;
  }

  request struct ViewSceneRequest {
    group_id groupID = 0;
    INT8U sceneID = 1;
  }

  response struct ViewSceneResponse = 1 {
    status status = 0;
    group_id groupID = 1;
    INT8U sceneID = 2;
    optional INT16U transitionTime = 3;
    optional CHAR_STRING sceneName = 4;
    optional ExtensionFieldSet extensionFieldSets[] = 5;
  }

  request struct RemoveSceneRequest {
    group_id groupID = 0;
    INT8U sceneID = 1;
  }

  response struct RemoveSceneResponse = 2 {
    status status = 0;
    group_id groupID = 1;
    INT8U sceneID = 2;
  }

  request struct RemoveAllScenesRequest {
    group_id groupID = 0;
  }

  response struct RemoveAllScenesResponse = 3 {
    status status = 0;
    group_id groupID = 1;
  }

  request struct StoreSceneRequest {
    group_id groupID = 0;
    INT8U sceneID = 1;
  }

  response struct StoreSceneResponse = 4 {
    status status = 0;
    group_id groupID = 1;
    INT8U sceneID = 2;
  }

  request struct RecallSceneRequest {
    group_id groupID = 0;
    INT8U sceneID = 1;
    optional nullable INT16U transitionTime = 2;
  }

  request struct GetSceneMembershipRequest {
    group_id groupID = 0;
  }

  response struct GetSceneMembershipResponse = 6 {
    status status = 0;
    nullable INT8U capacity = 1;
    group_id groupID = 2;
    optional INT8U sceneList[] = 3;
  }

  request struct EnhancedAddSceneRequest {
    group_id groupID = 0;
    INT8U sceneID = 1;
    INT16U transitionTime = 2;
    CHAR_STRING sceneName = 3;
    ExtensionFieldSet extensionFieldSets[] = 4;
  }

  response struct EnhancedAddSceneResponse = 64 {
    status status = 0;
    group_id groupID = 1;
    INT8U sceneID = 2;
  }

  request struct EnhancedViewSceneRequest {
    group_id groupID = 0;
    INT8U sceneID = 1;
  }

  response struct EnhancedViewSceneResponse = 65 {
    status status = 0;
    group_Id groupID = 1;
    INT8U sceneID = 2;
    optional INT16U transitionTime = 3;
    optional CHAR_STRING sceneName = 4;
    optional ExtensionFieldSet extensionFieldSets[] = 5;
  }

  request struct CopySceneRequest {
    ScenesCopyMode mode = 0;
    group_id groupIdentifierFrom = 1;
    INT8U sceneIdentifierFrom = 2;
    group_id groupIdentifierTo = 3;
    INT8U sceneIdentifierTo = 4;
  }

  response struct CopySceneResponse = 66 {
    status status = 0;
    group_Id groupIdentifierFrom = 1;
    INT8U sceneIdentifierFrom = 2;
  }

  /** Add a scene to the scene table. Extension field sets are supported, and are inputed as '{"ClusterID": VALUE, "AttributeValueList":[{"AttributeId": VALUE, "AttributeValue": VALUE}]}' */
  fabric command access(invoke: manage) AddScene(AddSceneRequest): AddSceneResponse = 0;
  /** Retrieves the requested scene entry from its Scene table. */
  fabric command ViewScene(ViewSceneRequest): ViewSceneResponse = 1;
  /** Removes the requested scene entry, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveScene(RemoveSceneRequest): RemoveSceneResponse = 2;
  /** Remove all scenes, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveAllScenes(RemoveAllScenesRequest): RemoveAllScenesResponse = 3;
  /** Adds the scene entry into its Scene Table along with all extension field sets corresponding to the current state of other clusters on the same endpoint */
  fabric command access(invoke: manage) StoreScene(StoreSceneRequest): StoreSceneResponse = 4;
  /** Set the attributes and corresponding state for each other cluster implemented on the endpoint accordingly to the resquested scene entry in the Scene Table */
  fabric command RecallScene(RecallSceneRequest): DefaultSuccess = 5;
  /** Get an unused scene identifier when no commissioning tool is in the network, or for a commissioning tool to get the used scene identifiers within a certain group */
  fabric command GetSceneMembership(GetSceneMembershipRequest): GetSceneMembershipResponse = 6;
  /** Allows a scene to be added using a finer scene transition time than the AddScene command. */
  fabric command EnhancedAddScene(EnhancedAddSceneRequest): EnhancedAddSceneResponse = 64;
  /** Allows a scene to be retrieved using a finer scene transition time than the ViewScene command */
  fabric command EnhancedViewScene(EnhancedViewSceneRequest): EnhancedViewSceneResponse = 65;
  /** Allows a client to efficiently copy scenes from one group/scene identifier pair to another group/scene identifier pair. */
  fabric command CopyScene(CopySceneRequest): CopySceneResponse = 66;
}

/** Attributes and commands for switching devices between 'On' and 'Off' states. */
client cluster OnOff = 6 {
  enum OnOffDelayedAllOffEffectVariant : ENUM8 {
    kFadeToOffIn0p8Seconds = 0;
    kNoFade = 1;
    k50PercentDimDownIn0p8SecondsThenFadeToOffIn12Seconds = 2;
  }

  enum OnOffDyingLightEffectVariant : ENUM8 {
    k20PercenterDimUpIn0p5SecondsThenFadeToOffIn1Second = 0;
  }

  enum OnOffEffectIdentifier : ENUM8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum OnOffStartUpOnOff : ENUM8 {
    kOff = 0;
    kOn = 1;
    kTogglePreviousOnOff = 2;
  }

  bitmap Feature : BITMAP32 {
    kLighting = 0x1;
  }

  bitmap OnOffControl : BITMAP8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute optional boolean globalSceneControl = 16384;
  attribute optional int16u onTime = 16385;
  attribute optional int16u offWaitTime = 16386;
  attribute access(write: manage) optional nullable OnOffStartUpOnOff startUpOnOff = 16387;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OffWithEffectRequest {
    OnOffEffectIdentifier effectIdentifier = 0;
    int8u effectVariant = 1;
  }

  request struct OnWithTimedOffRequest {
    OnOffControl onOffControl = 0;
    int16u onTime = 1;
    int16u offWaitTime = 2;
  }

  /** On receipt of this command, a device SHALL enter its ‘Off’ state. This state is device dependent, but it is recommended that it is used for power off or similar functions. On receipt of the Off command, the OnTime attribute SHALL be set to 0. */
  command Off(): DefaultSuccess = 0;
  /** On receipt of this command, a device SHALL enter its ‘On’ state. This state is device dependent, but it is recommended that it is used for power on or similar functions. On receipt of the On command, if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. */
  command On(): DefaultSuccess = 1;
  /** On receipt of this command, if a device is in its ‘Off’ state it SHALL enter its ‘On’ state. Otherwise, if it is in its ‘On’ state it SHALL enter its ‘Off’ state. On receipt of the Toggle command, if the value of the OnOff attribute is equal to FALSE and if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. If the value of the OnOff attribute is equal to TRUE, the OnTime attribute SHALL be set to 0. */
  command Toggle(): DefaultSuccess = 2;
  /** The OffWithEffect command allows devices to be turned off using enhanced ways of fading. */
  command OffWithEffect(OffWithEffectRequest): DefaultSuccess = 64;
  /** The OnWithRecallGlobalScene command allows the recall of the settings when the device was turned off. */
  command OnWithRecallGlobalScene(): DefaultSuccess = 65;
  /** The OnWithTimedOff command allows devices to be turned on for a specific duration with a guarded off duration so that SHOULD the device be subsequently switched off, further OnWithTimedOff commands, received during this time, are prevented from turning the devices back on. */
  command OnWithTimedOff(OnWithTimedOffRequest): DefaultSuccess = 66;
}

/** Attributes and commands for configuring On/Off switching devices. */
client cluster OnOffSwitchConfiguration = 7 {
  readonly attribute enum8 switchType = 0;
  attribute enum8 switchActions = 16;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
client cluster LevelControl = 8 {
  enum MoveMode : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepMode : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap LevelControlOptions : BITMAP8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute optional int16u remainingTime = 1;
  readonly attribute optional int8u minLevel = 2;
  readonly attribute optional int8u maxLevel = 3;
  readonly attribute optional int16u currentFrequency = 4;
  readonly attribute optional int16u minFrequency = 5;
  readonly attribute optional int16u maxFrequency = 6;
  attribute LevelControlOptions options = 15;
  attribute optional int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute optional nullable int16u onTransitionTime = 18;
  attribute optional nullable int16u offTransitionTime = 19;
  attribute optional nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) optional nullable int8u startUpCurrentLevel = 16384;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    INT8U level = 0;
    nullable INT16U transitionTime = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveMode moveMode = 0;
    nullable INT8U rate = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct StepRequest {
    StepMode stepMode = 0;
    INT8U stepSize = 1;
    nullable INT16U transitionTime = 2;
    LevelControlOptions optionsMask = 3;
    LevelControlOptions optionsOverride = 4;
  }

  request struct StopRequest {
    LevelControlOptions optionsMask = 0;
    LevelControlOptions optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    INT8U level = 0;
    nullable INT16U transitionTime = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveMode moveMode = 0;
    nullable INT8U rate = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepMode stepMode = 0;
    INT8U stepSize = 1;
    nullable INT16U transitionTime = 2;
    LevelControlOptions optionsMask = 3;
    LevelControlOptions optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    LevelControlOptions optionsMask = 0;
    LevelControlOptions optionsOverride = 1;
  }

  request struct MoveToClosestFrequencyRequest {
    INT16U frequency = 0;
  }

  /** Command description for MoveToLevel */
  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  /** Command description for Move */
  command Move(MoveRequest): DefaultSuccess = 1;
  /** Command description for Step */
  command Step(StepRequest): DefaultSuccess = 2;
  /** Command description for Stop */
  command Stop(StopRequest): DefaultSuccess = 3;
  /** Command description for MoveToLevelWithOnOff */
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  /** Command description for MoveWithOnOff */
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  /** Command description for StepWithOnOff */
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  /** Command description for StopWithOnOff */
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
  /** Change the currrent frequency to the provided one, or a close
        approximation if the exact provided one is not possible. */
  command MoveToClosestFrequency(MoveToClosestFrequencyRequest): DefaultSuccess = 8;
}

/** An interface for reading the value of a binary measurement and accessing various characteristics of that measurement. */
client cluster BinaryInputBasic = 15 {
  attribute optional char_string<16> activeText = 4;
  attribute optional char_string<16> description = 28;
  attribute optional char_string<16> inactiveText = 46;
  attribute boolean outOfService = 81;
  readonly attribute optional enum8 polarity = 84;
  attribute boolean presentValue = 85;
  attribute optional enum8 reliability = 103;
  readonly attribute bitmap8 statusFlags = 111;
  readonly attribute optional int32u applicationType = 256;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Cluster to control pulse width modulation */
client cluster PulseWidthModulation = 28 {
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
client cluster Descriptor = 29 {
  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute CLUSTER_ID serverList[] = 1;
  readonly attribute CLUSTER_ID clientList[] = 2;
  readonly attribute ENDPOINT_NO partsList[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Binding Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table. */
client cluster Binding = 30 {
  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
client cluster AccessControl = 31 {
  enum AccessControlEntryAuthModeEnum : ENUM8 {
    kPase = 1;
    kCase = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : ENUM8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum ChangeTypeEnum : ENUM8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  struct Target {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive Target targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable INT16U adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides a standardized way for a Node (typically a Bridge, but could be any Node) to expose action information. */
client cluster Actions = 37 {
  enum ActionErrorEnum : ENUM8 {
    kUnknown = 0;
    kInterrupted = 1;
  }

  enum ActionStateEnum : ENUM8 {
    kInactive = 0;
    kActive = 1;
    kPaused = 2;
    kDisabled = 3;
  }

  enum ActionTypeEnum : ENUM8 {
    kOther = 0;
    kScene = 1;
    kSequence = 2;
    kAutomation = 3;
    kException = 4;
    kNotification = 5;
    kAlarm = 6;
  }

  enum EndpointListTypeEnum : ENUM8 {
    kOther = 0;
    kRoom = 1;
    kZone = 2;
  }

  bitmap CommandBits : BITMAP16 {
    kInstantAction = 0x1;
    kInstantActionWithTransition = 0x2;
    kStartAction = 0x4;
    kStartActionWithDuration = 0x8;
    kStopAction = 0x10;
    kPauseAction = 0x20;
    kPauseActionWithDuration = 0x40;
    kResumeAction = 0x80;
    kEnableAction = 0x100;
    kEnableActionWithDuration = 0x200;
    kDisableAction = 0x400;
    kDisableActionWithDuration = 0x800;
  }

  struct ActionStruct {
    int16u actionID = 0;
    char_string<32> name = 1;
    ActionTypeEnum type = 2;
    int16u endpointListID = 3;
    CommandBits supportedCommands = 4;
    ActionStateEnum state = 5;
  }

  struct EndpointListStruct {
    int16u endpointListID = 0;
    char_string<32> name = 1;
    EndpointListTypeEnum type = 2;
    endpoint_no endpoints[] = 3;
  }

  info event StateChanged = 0 {
    INT16U actionID = 0;
    INT32U invokeID = 1;
    ActionStateEnum newState = 2;
  }

  info event ActionFailed = 1 {
    INT16U actionID = 0;
    INT32U invokeID = 1;
    ActionStateEnum newState = 2;
    ActionErrorEnum error = 3;
  }

  readonly attribute ActionStruct actionList[] = 0;
  readonly attribute EndpointListStruct endpointLists[] = 1;
  readonly attribute optional long_char_string<512> setupURL = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct InstantActionRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
  }

  request struct InstantActionWithTransitionRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
    INT16U transitionTime = 2;
  }

  request struct StartActionRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
  }

  request struct StartActionWithDurationRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
    INT32U duration = 2;
  }

  request struct StopActionRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
  }

  request struct PauseActionRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
  }

  request struct PauseActionWithDurationRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
    INT32U duration = 2;
  }

  request struct ResumeActionRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
  }

  request struct EnableActionRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
  }

  request struct EnableActionWithDurationRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
    INT32U duration = 2;
  }

  request struct DisableActionRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
  }

  request struct DisableActionWithDurationRequest {
    INT16U actionID = 0;
    optional INT32U invokeID = 1;
    INT32U duration = 2;
  }

  /** This command triggers an action (state change) on the involved endpoints. */
  command InstantAction(InstantActionRequest): DefaultSuccess = 0;
  /** This command triggers an action (state change) on the involved endpoints, with a specified time to transition from the current state to the new state. */
  command InstantActionWithTransition(InstantActionWithTransitionRequest): DefaultSuccess = 1;
  /** This command triggers the commencement of an action on the involved endpoints. */
  command StartAction(StartActionRequest): DefaultSuccess = 2;
  /** This command triggers the commencement of an action (with a duration) on the involved endpoints. */
  command StartActionWithDuration(StartActionWithDurationRequest): DefaultSuccess = 3;
  /** This command stops the ongoing action on the involved endpoints. */
  command StopAction(StopActionRequest): DefaultSuccess = 4;
  /** This command pauses an ongoing action. */
  command PauseAction(PauseActionRequest): DefaultSuccess = 5;
  /** This command pauses an ongoing action with a duration. */
  command PauseActionWithDuration(PauseActionWithDurationRequest): DefaultSuccess = 6;
  /** This command resumes a previously paused action. */
  command ResumeAction(ResumeActionRequest): DefaultSuccess = 7;
  /** This command enables a certain action or automation. */
  command EnableAction(EnableActionRequest): DefaultSuccess = 8;
  /** This command enables a certain action or automation with a duration. */
  command EnableActionWithDuration(EnableActionWithDurationRequest): DefaultSuccess = 9;
  /** This command disables a certain action or automation. */
  command DisableAction(DisableActionRequest): DefaultSuccess = 10;
  /** This command disables a certain action or automation with a duration. */
  command DisableActionWithDuration(DisableActionWithDurationRequest): DefaultSuccess = 11;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
client cluster BasicInformation = 40 {
  enum ColorEnum : ENUM8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : ENUM8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    INT32U softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  attribute access(write: manage) optional boolean localConfigDisabled = 16;
  readonly attribute optional boolean reachable = 17;
  readonly attribute optional char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command MfgSpecificPing(): DefaultSuccess = 0;
}

/** Provides an interface for providing OTA software updates */
client cluster OtaSoftwareUpdateProvider = 41 {
  enum OTAApplyUpdateAction : ENUM8 {
    kProceed = 0;
    kAwaitNextAction = 1;
    kDiscontinue = 2;
  }

  enum OTADownloadProtocol : ENUM8 {
    kBDXSynchronous = 0;
    kBDXAsynchronous = 1;
    kHttps = 2;
    kVendorSpecific = 3;
  }

  enum OTAQueryStatus : ENUM8 {
    kUpdateAvailable = 0;
    kBusy = 1;
    kNotAvailable = 2;
    kDownloadProtocolNotSupported = 3;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct QueryImageRequest {
    vendor_id vendorID = 0;
    INT16U productID = 1;
    INT32U softwareVersion = 2;
    OTADownloadProtocol protocolsSupported[] = 3;
    optional INT16U hardwareVersion = 4;
    optional CHAR_STRING<2> location = 5;
    optional BOOLEAN requestorCanConsent = 6;
    optional OCTET_STRING<512> metadataForProvider = 7;
  }

  response struct QueryImageResponse = 1 {
    OTAQueryStatus status = 0;
    optional INT32U delayedActionTime = 1;
    optional CHAR_STRING<256> imageURI = 2;
    optional INT32U softwareVersion = 3;
    optional CHAR_STRING<64> softwareVersionString = 4;
    optional OCTET_STRING<32> updateToken = 5;
    optional BOOLEAN userConsentNeeded = 6;
    optional OCTET_STRING<512> metadataForRequestor = 7;
  }

  request struct ApplyUpdateRequestRequest {
    OCTET_STRING<32> updateToken = 0;
    INT32U newVersion = 1;
  }

  response struct ApplyUpdateResponse = 3 {
    OTAApplyUpdateAction action = 0;
    INT32U delayedActionTime = 1;
  }

  request struct NotifyUpdateAppliedRequest {
    OCTET_STRING<32> updateToken = 0;
    INT32U softwareVersion = 1;
  }

  /** Determine availability of a new Software Image */
  command QueryImage(QueryImageRequest): QueryImageResponse = 0;
  /** Determine next action to take for a downloaded Software Image */
  command ApplyUpdateRequest(ApplyUpdateRequestRequest): ApplyUpdateResponse = 2;
  /** Notify OTA Provider that an update was applied */
  command NotifyUpdateApplied(NotifyUpdateAppliedRequest): DefaultSuccess = 4;
}

/** Provides an interface for downloading and applying OTA software updates */
client cluster OtaSoftwareUpdateRequestor = 42 {
  enum OTAAnnouncementReason : ENUM8 {
    kSimpleAnnouncement = 0;
    kUpdateAvailable = 1;
    kUrgentUpdateAvailable = 2;
  }

  enum OTAChangeReasonEnum : ENUM8 {
    kUnknown = 0;
    kSuccess = 1;
    kFailure = 2;
    kTimeOut = 3;
    kDelayByProvider = 4;
  }

  enum OTAUpdateStateEnum : ENUM8 {
    kUnknown = 0;
    kIdle = 1;
    kQuerying = 2;
    kDelayedOnQuery = 3;
    kDownloading = 4;
    kApplying = 5;
    kDelayedOnApply = 6;
    kRollingBack = 7;
    kDelayedOnUserConsent = 8;
  }

  fabric_scoped struct ProviderLocation {
    node_id providerNodeID = 1;
    endpoint_no endpoint = 2;
    fabric_idx fabricIndex = 254;
  }

  info event StateTransition = 0 {
    OTAUpdateStateEnum previousState = 0;
    OTAUpdateStateEnum newState = 1;
    OTAChangeReasonEnum reason = 2;
    nullable INT32U targetSoftwareVersion = 3;
  }

  critical event VersionApplied = 1 {
    INT32U softwareVersion = 0;
    INT16U productID = 1;
  }

  info event DownloadError = 2 {
    INT32U softwareVersion = 0;
    INT64U bytesDownloaded = 1;
    nullable INT8U progressPercent = 2;
    nullable INT64S platformCode = 3;
  }

  attribute ProviderLocation defaultOTAProviders[] = 0;
  readonly attribute boolean updatePossible = 1;
  readonly attribute OTAUpdateStateEnum updateState = 2;
  readonly attribute nullable int8u updateStateProgress = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AnnounceOTAProviderRequest {
    node_id providerNodeID = 0;
    vendor_id vendorID = 1;
    OTAAnnouncementReason announcementReason = 2;
    optional OCTET_STRING<512> metadataForNode = 3;
    endpoint_no endpoint = 4;
  }

  /** Announce the presence of an OTA Provider */
  command AnnounceOTAProvider(AnnounceOTAProviderRequest): DefaultSuccess = 0;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
client cluster LocalizationConfiguration = 43 {
  attribute char_string<35> activeLocale = 0;
  readonly attribute CHAR_STRING supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for how dates and times are conveyed. As such, Nodes that visually
      or audibly convey time information need a mechanism by which they can be configured to use a
      user’s preferred format. */
client cluster TimeFormatLocalization = 44 {
  enum CalendarTypeEnum : ENUM8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
  }

  enum HourFormatEnum : ENUM8 {
    k12hr = 0;
    k24hr = 1;
  }

  attribute HourFormatEnum hourFormat = 0;
  attribute optional CalendarTypeEnum activeCalendarType = 1;
  readonly attribute optional CalendarTypeEnum supportedCalendarTypes[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for the units in which values are conveyed in communication to a
      user. As such, Nodes that visually or audibly convey measurable values to the user need a
      mechanism by which they can be configured to use a user’s preferred unit. */
client cluster UnitLocalization = 45 {
  enum TempUnitEnum : ENUM8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap Feature : BITMAP32 {
    kTemperatureUnit = 0x1;
  }

  attribute optional TempUnitEnum temperatureUnit = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to describe the configuration and capabilities of a Device's power system. */
client cluster PowerSourceConfiguration = 46 {
  readonly attribute INT8U sources[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to describe the configuration and capabilities of a physical power source that provides power to the Node. */
client cluster PowerSource = 47 {
  enum BatApprovedChemistryEnum : ENUM16 {
    kUnspecified = 0;
    kAlkaline = 1;
    kLithiumCarbonFluoride = 2;
    kLithiumChromiumOxide = 3;
    kLithiumCopperOxide = 4;
    kLithiumIronDisulfide = 5;
    kLithiumManganeseDioxide = 6;
    kLithiumThionylChloride = 7;
    kMagnesium = 8;
    kMercuryOxide = 9;
    kNickelOxyhydride = 10;
    kSilverOxide = 11;
    kZincAir = 12;
    kZincCarbon = 13;
    kZincChloride = 14;
    kZincManganeseDioxide = 15;
    kLeadAcid = 16;
    kLithiumCobaltOxide = 17;
    kLithiumIon = 18;
    kLithiumIonPolymer = 19;
    kLithiumIronPhosphate = 20;
    kLithiumSulfur = 21;
    kLithiumTitanate = 22;
    kNickelCadmium = 23;
    kNickelHydrogen = 24;
    kNickelIron = 25;
    kNickelMetalHydride = 26;
    kNickelZinc = 27;
    kSilverZinc = 28;
    kSodiumIon = 29;
    kSodiumSulfur = 30;
    kZincBromide = 31;
    kZincCerium = 32;
  }

  enum BatChargeFaultEnum : ENUM8 {
    kUnspecified = 0;
    kAmbientTooHot = 1;
    kAmbientTooCold = 2;
    kBatteryTooHot = 3;
    kBatteryTooCold = 4;
    kBatteryAbsent = 5;
    kBatteryOverVoltage = 6;
    kBatteryUnderVoltage = 7;
    kChargerOverVoltage = 8;
    kChargerUnderVoltage = 9;
    kSafetyTimeout = 10;
  }

  enum BatChargeLevelEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum BatChargeStateEnum : ENUM8 {
    kUnknown = 0;
    kIsCharging = 1;
    kIsAtFullCharge = 2;
    kIsNotCharging = 3;
  }

  enum BatCommonDesignationEnum : ENUM16 {
    kUnspecified = 0;
    kAaa = 1;
    kAa = 2;
    kC = 3;
    kD = 4;
    k4v5 = 5;
    k6v0 = 6;
    k9v0 = 7;
    k12aa = 8;
    kAaaa = 9;
    kA = 10;
    kB = 11;
    kF = 12;
    kN = 13;
    kNo6 = 14;
    kSubC = 15;
    kA23 = 16;
    kA27 = 17;
    kBa5800 = 18;
    kDuplex = 19;
    k4sr44 = 20;
    k523 = 21;
    k531 = 22;
    k15v0 = 23;
    k22v5 = 24;
    k30v0 = 25;
    k45v0 = 26;
    k67v5 = 27;
    kJ = 28;
    kCr123a = 29;
    kCr2 = 30;
    k2cr5 = 31;
    kCrP2 = 32;
    kCrV3 = 33;
    kSr41 = 34;
    kSr43 = 35;
    kSr44 = 36;
    kSr45 = 37;
    kSr48 = 38;
    kSr54 = 39;
    kSr55 = 40;
    kSr57 = 41;
    kSr58 = 42;
    kSr59 = 43;
    kSr60 = 44;
    kSr63 = 45;
    kSr64 = 46;
    kSr65 = 47;
    kSr66 = 48;
    kSr67 = 49;
    kSr68 = 50;
    kSr69 = 51;
    kSr516 = 52;
    kSr731 = 53;
    kSr712 = 54;
    kLr932 = 55;
    kA5 = 56;
    kA10 = 57;
    kA13 = 58;
    kA312 = 59;
    kA675 = 60;
    kAc41e = 61;
    k10180 = 62;
    k10280 = 63;
    k10440 = 64;
    k14250 = 65;
    k14430 = 66;
    k14500 = 67;
    k14650 = 68;
    k15270 = 69;
    k16340 = 70;
    kRcr123a = 71;
    k17500 = 72;
    k17670 = 73;
    k18350 = 74;
    k18500 = 75;
    k18650 = 76;
    k19670 = 77;
    k25500 = 78;
    k26650 = 79;
    k32600 = 80;
  }

  enum BatFaultEnum : ENUM8 {
    kUnspecified = 0;
    kOverTemp = 1;
    kUnderTemp = 2;
  }

  enum BatReplaceabilityEnum : ENUM8 {
    kUnspecified = 0;
    kNotReplaceable = 1;
    kUserReplaceable = 2;
    kFactoryReplaceable = 3;
  }

  enum PowerSourceStatusEnum : ENUM8 {
    kUnspecified = 0;
    kActive = 1;
    kStandby = 2;
    kUnavailable = 3;
  }

  enum WiredCurrentTypeEnum : ENUM8 {
    kAc = 0;
    kDc = 1;
  }

  enum WiredFaultEnum : ENUM8 {
    kUnspecified = 0;
    kOverVoltage = 1;
    kUnderVoltage = 2;
  }

  bitmap Feature : BITMAP32 {
    kWired = 0x1;
    kBattery = 0x2;
    kRechargeable = 0x4;
    kReplaceable = 0x8;
  }

  struct BatChargeFaultChangeType {
    BatChargeFaultEnum current[] = 0;
    BatChargeFaultEnum previous[] = 1;
  }

  struct BatFaultChangeType {
    BatFaultEnum current[] = 0;
    BatFaultEnum previous[] = 1;
  }

  struct WiredFaultChangeType {
    WiredFaultEnum current[] = 0;
    WiredFaultEnum previous[] = 1;
  }

  info event WiredFaultChange = 0 {
    WiredFaultEnum current[] = 0;
    WiredFaultEnum previous[] = 1;
  }

  info event BatFaultChange = 1 {
    BatFaultEnum current[] = 0;
    BatFaultEnum previous[] = 1;
  }

  info event BatChargeFaultChange = 2 {
    BatChargeFaultEnum current[] = 0;
    BatChargeFaultEnum previous[] = 1;
  }

  readonly attribute PowerSourceStatusEnum status = 0;
  readonly attribute int8u order = 1;
  readonly attribute char_string<60> description = 2;
  readonly attribute optional nullable int32u wiredAssessedInputVoltage = 3;
  readonly attribute optional nullable int16u wiredAssessedInputFrequency = 4;
  readonly attribute optional WiredCurrentTypeEnum wiredCurrentType = 5;
  readonly attribute optional nullable int32u wiredAssessedCurrent = 6;
  readonly attribute optional int32u wiredNominalVoltage = 7;
  readonly attribute optional int32u wiredMaximumCurrent = 8;
  readonly attribute optional boolean wiredPresent = 9;
  readonly attribute optional WiredFaultEnum activeWiredFaults[] = 10;
  readonly attribute optional nullable int32u batVoltage = 11;
  readonly attribute optional nullable int8u batPercentRemaining = 12;
  readonly attribute optional nullable int32u batTimeRemaining = 13;
  readonly attribute optional BatChargeLevelEnum batChargeLevel = 14;
  readonly attribute optional boolean batReplacementNeeded = 15;
  readonly attribute optional BatReplaceabilityEnum batReplaceability = 16;
  readonly attribute optional boolean batPresent = 17;
  readonly attribute optional BatFaultEnum activeBatFaults[] = 18;
  readonly attribute optional char_string<60> batReplacementDescription = 19;
  readonly attribute optional BatCommonDesignationEnum batCommonDesignation = 20;
  readonly attribute optional char_string<20> batANSIDesignation = 21;
  readonly attribute optional char_string<20> batIECDesignation = 22;
  readonly attribute optional BatApprovedChemistryEnum batApprovedChemistry = 23;
  readonly attribute optional int32u batCapacity = 24;
  readonly attribute optional int8u batQuantity = 25;
  readonly attribute optional BatChargeStateEnum batChargeState = 26;
  readonly attribute optional nullable int32u batTimeToFullCharge = 27;
  readonly attribute optional boolean batFunctionalWhileCharging = 28;
  readonly attribute optional nullable int32u batChargingCurrent = 29;
  readonly attribute optional BatChargeFaultEnum activeBatChargeFaults[] = 30;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
client cluster GeneralCommissioning = 48 {
  enum CommissioningError : ENUM8 {
    kOk = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationType : ENUM8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationType regulatoryConfig = 2;
  readonly attribute RegulatoryLocationType locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    INT16U expiryLengthSeconds = 0;
    INT64U breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationType newRegulatoryConfig = 0;
    CHAR_STRING countryCode = 1;
    INT64U breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningError errorCode = 0;
    CHAR_STRING debugText = 1;
  }

  /** Arm the persistent fail-safe timer with an expiry time of now + ExpiryLengthSeconds using device clock */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** Set the regulatory configuration to be used during commissioning */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** Signals the Server that the Client has successfully completed all steps of Commissioning/Recofiguration needed during fail-safe period. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
client cluster NetworkCommissioning = 49 {
  enum NetworkCommissioningStatus : ENUM8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBand : ENUM8 {
    k2g4 = 0;
    k3g65 = 1;
    k5g = 2;
    k6g = 3;
    k60g = 4;
    k1g = 5;
  }

  bitmap Feature : BITMAP32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
  }

  bitmap WiFiSecurity : BITMAP8 {
    kUnencrypted = 0x1;
    kWep = 0x2;
    kWpaPersonal = 0x4;
    kWpa2Personal = 0x8;
    kWpa3Personal = 0x10;
  }

  struct NetworkInfo {
    octet_string<32> networkID = 0;
    boolean connected = 1;
  }

  struct ThreadInterfaceScanResult {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResult {
    WiFiSecurity security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBand wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfo networks[] = 1;
  readonly attribute optional int8u scanMaxTimeSeconds = 2;
  readonly attribute optional int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatus lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable OCTET_STRING<32> ssid = 0;
    optional INT64U breadcrumb = 1;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    optional WiFiInterfaceScanResult wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResult threadScanResults[] = 3;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    OCTET_STRING<32> ssid = 0;
    OCTET_STRING<64> credentials = 1;
    optional INT64U breadcrumb = 2;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    OCTET_STRING<254> operationalDataset = 0;
    optional INT64U breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING<512> debugText = 1;
    optional INT8U networkIndex = 2;
  }

  request struct ConnectNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    optional INT64U breadcrumb = 1;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatus networkingStatus = 0;
    optional CHAR_STRING debugText = 1;
    nullable INT32S errorValue = 2;
  }

  request struct ReorderNetworkRequest {
    OCTET_STRING<32> networkID = 0;
    INT8U networkIndex = 1;
    optional INT64U breadcrumb = 2;
  }

  /** Detemine the set of networks the device sees as available. */
  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  /** Add or update the credentials for a given Wi-Fi network. */
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  /** Add or update the credentials for a given Thread network. */
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  /** Remove the definition of a given network (including its credentials). */
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  /** Connect to the specified network, using previously-defined credentials. */
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  /** Modify the order in which networks will be presented in the Networks attribute. */
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
}

/** The cluster provides commands for retrieving unstructured diagnostic logs from a Node that may be used to aid in diagnostics. */
client cluster DiagnosticLogs = 50 {
  enum IntentEnum : ENUM8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : ENUM8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : ENUM8 {
    kResponsePayload = 0;
    kBdx = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional CHAR_STRING<32> transferFileDesignator = 2;
  }

  response struct RetrieveLogsResponse = 1 {
    StatusEnum status = 0;
    LONG_OCTET_STRING logContent = 1;
    optional epoch_us UTCTimeStamp = 2;
    optional systime_us timeSinceBoot = 3;
  }

  /** Retrieving diagnostic logs from a Node */
  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
client cluster GeneralDiagnostics = 51 {
  enum BootReasonEnum : ENUM8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : ENUM8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : ENUM8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : ENUM8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : ENUM8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute optional int64u upTime = 2;
  readonly attribute optional int32u totalOperationalHours = 3;
  readonly attribute optional BootReasonEnum bootReason = 4;
  readonly attribute optional HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute optional RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute optional NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    OCTET_STRING<16> enableKey = 0;
    INT64U eventTrigger = 1;
  }

  /** Provide a means for certification tests to trigger some test-plan-specific events */
  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
client cluster SoftwareDiagnostics = 52 {
  bitmap Feature : BITMAP32 {
    kWaterMarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    INT64U id = 0;
    optional CHAR_STRING name = 1;
    optional OCTET_STRING faultRecording = 2;
  }

  readonly attribute optional ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute optional int64u currentHeapFree = 1;
  readonly attribute optional int64u currentHeapUsed = 2;
  readonly attribute optional int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the values: The StackFreeMinimum field of the ThreadMetrics attribute, CurrentHeapHighWaterMark attribute. */
  command ResetWatermarks(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
client cluster ThreadNetworkDiagnostics = 53 {
  enum ConnectionStatusEnum : ENUM8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFault : ENUM8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRole : ENUM8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kReed = 4;
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : BITMAP32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTable {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTable {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFault current[] = 0;
    NetworkFault previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRole routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute NeighborTable neighborTable[] = 7;
  readonly attribute RouteTable routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int8u weighting = 10;
  readonly attribute nullable int8u dataVersion = 11;
  readonly attribute nullable int8u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute optional int16u detachedRoleCount = 14;
  readonly attribute optional int16u childRoleCount = 15;
  readonly attribute optional int16u routerRoleCount = 16;
  readonly attribute optional int16u leaderRoleCount = 17;
  readonly attribute optional int16u attachAttemptCount = 18;
  readonly attribute optional int16u partitionIdChangeCount = 19;
  readonly attribute optional int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute optional int16u parentChangeCount = 21;
  readonly attribute optional int32u txTotalCount = 22;
  readonly attribute optional int32u txUnicastCount = 23;
  readonly attribute optional int32u txBroadcastCount = 24;
  readonly attribute optional int32u txAckRequestedCount = 25;
  readonly attribute optional int32u txAckedCount = 26;
  readonly attribute optional int32u txNoAckRequestedCount = 27;
  readonly attribute optional int32u txDataCount = 28;
  readonly attribute optional int32u txDataPollCount = 29;
  readonly attribute optional int32u txBeaconCount = 30;
  readonly attribute optional int32u txBeaconRequestCount = 31;
  readonly attribute optional int32u txOtherCount = 32;
  readonly attribute optional int32u txRetryCount = 33;
  readonly attribute optional int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute optional int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute optional int32u txErrCcaCount = 36;
  readonly attribute optional int32u txErrAbortCount = 37;
  readonly attribute optional int32u txErrBusyChannelCount = 38;
  readonly attribute optional int32u rxTotalCount = 39;
  readonly attribute optional int32u rxUnicastCount = 40;
  readonly attribute optional int32u rxBroadcastCount = 41;
  readonly attribute optional int32u rxDataCount = 42;
  readonly attribute optional int32u rxDataPollCount = 43;
  readonly attribute optional int32u rxBeaconCount = 44;
  readonly attribute optional int32u rxBeaconRequestCount = 45;
  readonly attribute optional int32u rxOtherCount = 46;
  readonly attribute optional int32u rxAddressFilteredCount = 47;
  readonly attribute optional int32u rxDestAddrFilteredCount = 48;
  readonly attribute optional int32u rxDuplicatedCount = 49;
  readonly attribute optional int32u rxErrNoFrameCount = 50;
  readonly attribute optional int32u rxErrUnknownNeighborCount = 51;
  readonly attribute optional int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute optional int32u rxErrSecCount = 53;
  readonly attribute optional int32u rxErrFcsCount = 54;
  readonly attribute optional int32u rxErrOtherCount = 55;
  readonly attribute optional nullable int64u activeTimestamp = 56;
  readonly attribute optional nullable int64u pendingTimestamp = 57;
  readonly attribute optional nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFault activeNetworkFaultsList[] = 62;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the OverrunCount attributes to 0 */
  command ResetCounts(): DefaultSuccess = 0;
}

/** The Wi-Fi Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
client cluster WiFiNetworkDiagnostics = 54 {
  enum AssociationFailureCauseEnum : ENUM8 {
    kUnknown = 0;
    kAssociationFailed = 1;
    kAuthenticationFailed = 2;
    kSsidNotFound = 3;
  }

  enum ConnectionStatusEnum : ENUM8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum SecurityTypeEnum : ENUM8 {
    kUnspecified = 0;
    kNone = 1;
    kWep = 2;
    kWpa = 3;
    kWpa2 = 4;
    kWpa3 = 5;
  }

  enum WiFiVersionEnum : ENUM8 {
    kA = 0;
    kB = 1;
    kG = 2;
    kN = 3;
    kAc = 4;
    kAx = 5;
    kAh = 6;
  }

  bitmap Feature : BITMAP32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  info event Disconnection = 0 {
    INT16U reasonCode = 0;
  }

  info event AssociationFailure = 1 {
    AssociationFailureCauseEnum associationFailure = 0;
    INT16U status = 1;
  }

  info event ConnectionStatus = 2 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  readonly attribute nullable octet_string<6> bssid = 0;
  readonly attribute nullable SecurityTypeEnum securityType = 1;
  readonly attribute nullable WiFiVersionEnum wiFiVersion = 2;
  readonly attribute nullable int16u channelNumber = 3;
  readonly attribute nullable int8s rssi = 4;
  readonly attribute optional nullable int32u beaconLostCount = 5;
  readonly attribute optional nullable int32u beaconRxCount = 6;
  readonly attribute optional nullable int32u packetMulticastRxCount = 7;
  readonly attribute optional nullable int32u packetMulticastTxCount = 8;
  readonly attribute optional nullable int32u packetUnicastRxCount = 9;
  readonly attribute optional nullable int32u packetUnicastTxCount = 10;
  readonly attribute optional nullable int64u currentMaxRate = 11;
  readonly attribute optional nullable int64u overrunCount = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the Breacon and Packet related count attributes to 0 */
  command ResetCounts(): DefaultSuccess = 0;
}

/** The Ethernet Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
client cluster EthernetNetworkDiagnostics = 55 {
  enum PHYRateEnum : ENUM8 {
    kRate10M = 0;
    kRate100M = 1;
    kRate1G = 2;
    kRate25g = 3;
    kRate5G = 4;
    kRate10G = 5;
    kRate40G = 6;
    kRate100G = 7;
    kRate200G = 8;
    kRate400G = 9;
  }

  bitmap Feature : BITMAP32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  readonly attribute optional nullable PHYRateEnum PHYRate = 0;
  readonly attribute optional nullable boolean fullDuplex = 1;
  readonly attribute optional int64u packetRxCount = 2;
  readonly attribute optional int64u packetTxCount = 3;
  readonly attribute optional int64u txErrCount = 4;
  readonly attribute optional int64u collisionCount = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute optional nullable boolean carrierDetect = 7;
  readonly attribute optional int64u timeSinceReset = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the attributes: PacketRxCount, PacketTxCount, TxErrCount, CollisionCount, OverrunCount to 0 */
  command ResetCounts(): DefaultSuccess = 0;
}

/** Accurate time is required for a number of reasons, including scheduling, display and validating security materials. */
client cluster TimeSynchronization = 56 {
  enum GranularityEnum : ENUM8 {
    kNoTimeGranularity = 0;
    kMinutesGranularity = 1;
    kSecondsGranularity = 2;
    kMillisecondsGranularity = 3;
    kMicrosecondsGranularity = 4;
  }

  enum StatusCode : ENUM8 {
    kTimeNotAccepted = 2;
  }

  enum TimeSourceEnum : ENUM8 {
    kNone = 0;
    kUnknown = 1;
    kAdmin = 2;
    kNodeTimeCluster = 3;
    kNonMatterSNTP = 4;
    kNonMatterNTP = 5;
    kMatterSNTP = 6;
    kMatterNTP = 7;
    kMixedNTP = 8;
    kNonMatterSNTPNTS = 9;
    kNonMatterNTPNTS = 10;
    kMatterSNTPNTS = 11;
    kMatterNTPNTS = 12;
    kMixedNTPNTS = 13;
    kCloudSource = 14;
    kPtp = 15;
    kGnss = 16;
  }

  enum TimeZoneDatabaseEnum : ENUM8 {
    kFull = 0;
    kPartial = 1;
    kNone = 2;
  }

  bitmap Feature : BITMAP32 {
    kTimeZone = 0x1;
    kNTPClient = 0x2;
    kNTPServer = 0x4;
    kTimeSyncClient = 0x8;
  }

  struct DSTOffsetStruct {
    int32s offset = 0;
    epoch_us validStarting = 1;
    nullable epoch_us validUntil = 2;
  }

  struct FabricScopedTrustedTimeSourceStruct {
    node_id nodeID = 0;
    endpoint_no endpoint = 1;
  }

  struct TimeZoneStruct {
    int32s offset = 0;
    epoch_us validAt = 1;
    optional char_string<64> name = 2;
  }

  struct TrustedTimeSourceStruct {
    fabric_idx fabricIndex = 0;
    node_id nodeID = 1;
    endpoint_no endpoint = 2;
  }

  info event DSTTableEmpty = 0 {
  }

  info event DSTStatus = 1 {
    boolean DSTOffsetActive = 0;
  }

  info event TimeZoneStatus = 2 {
    INT32S offset = 0;
    optional CHAR_STRING name = 1;
  }

  info event TimeFailure = 3 {
  }

  info event MissingTrustedTimeSource = 4 {
  }

  readonly attribute nullable epoch_us UTCTime = 0;
  readonly attribute GranularityEnum granularity = 1;
  readonly attribute optional TimeSourceEnum timeSource = 2;
  readonly attribute optional nullable TrustedTimeSourceStruct trustedTimeSource = 3;
  readonly attribute optional nullable char_string<128> defaultNTP = 4;
  readonly attribute optional TimeZoneStruct timeZone[] = 5;
  readonly attribute optional DSTOffsetStruct DSTOffset[] = 6;
  readonly attribute optional nullable epoch_us localTime = 7;
  readonly attribute optional TimeZoneDatabaseEnum timeZoneDatabase = 8;
  readonly attribute optional boolean NTPServerAvailable = 9;
  readonly attribute optional int8u timeZoneListMaxSize = 10;
  readonly attribute optional int8u DSTOffsetListMaxSize = 11;
  readonly attribute optional boolean supportsDNSResolve = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetUTCTimeRequest {
    epoch_us UTCTime = 0;
    GranularityEnum granularity = 1;
    optional TimeSourceEnum timeSource = 2;
  }

  request struct SetTrustedTimeSourceRequest {
    nullable FabricScopedTrustedTimeSourceStruct trustedTimeSource = 0;
  }

  request struct SetTimeZoneRequest {
    TimeZoneStruct timeZone[] = 0;
  }

  response struct SetTimeZoneResponse = 3 {
    boolean DSTOffsetRequired = 0;
  }

  request struct SetDSTOffsetRequest {
    DSTOffsetStruct DSTOffset[] = 0;
  }

  request struct SetDefaultNTPRequest {
    nullable CHAR_STRING<128> defaultNTP = 0;
  }

  /** This command MAY be issued by Administrator to set the time. */
  command access(invoke: administer) SetUTCTime(SetUTCTimeRequest): DefaultSuccess = 0;
  /** This command SHALL set TrustedTimeSource. */
  fabric command access(invoke: administer) SetTrustedTimeSource(SetTrustedTimeSourceRequest): DefaultSuccess = 1;
  /** This command SHALL set TimeZone. */
  command access(invoke: manage) SetTimeZone(SetTimeZoneRequest): SetTimeZoneResponse = 2;
  /** This command SHALL set DSTOffset. */
  command access(invoke: manage) SetDSTOffset(SetDSTOffsetRequest): DefaultSuccess = 4;
  /** This command is used to set DefaultNTP. */
  command access(invoke: administer) SetDefaultNTP(SetDefaultNTPRequest): DefaultSuccess = 5;
}

/** This Cluster serves two purposes towards a Node communicating with a Bridge: indicate that the functionality on
          the Endpoint where it is placed (and its Parts) is bridged from a non-CHIP technology; and provide a centralized
          collection of attributes that the Node MAY collect to aid in conveying information regarding the Bridged Device to a user,
          such as the vendor name, the model name, or user-assigned name. */
client cluster BridgedDeviceBasicInformation = 57 {
  enum ColorEnum : ENUM8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : ENUM8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    INT32U softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute optional char_string<32> vendorName = 1;
  readonly attribute optional vendor_id vendorID = 2;
  readonly attribute optional char_string<32> productName = 3;
  attribute optional char_string<32> nodeLabel = 5;
  readonly attribute optional int16u hardwareVersion = 7;
  readonly attribute optional char_string<64> hardwareVersionString = 8;
  readonly attribute optional int32u softwareVersion = 9;
  readonly attribute optional char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  readonly attribute boolean reachable = 17;
  readonly attribute optional char_string<32> uniqueID = 18;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster exposes interactions with a switch device, for the purpose of using those interactions by other devices.
Two types of switch devices are supported: latching switch (e.g. rocker switch) and momentary switch (e.g. push button), distinguished with their feature flags.
Interactions with the switch device are exposed as attributes (for the latching switch) and as events (for both types of switches). An interested party MAY subscribe to these attributes/events and thus be informed of the interactions, and can perform actions based on this, for example by sending commands to perform an action such as controlling a light or a window shade. */
client cluster Switch = 59 {
  bitmap Feature : BITMAP32 {
    kLatchingSwitch = 0x1;
    kMomentarySwitch = 0x2;
    kMomentarySwitchRelease = 0x4;
    kMomentarySwitchLongPress = 0x8;
    kMomentarySwitchMultiPress = 0x10;
  }

  info event SwitchLatched = 0 {
    INT8U newPosition = 0;
  }

  info event InitialPress = 1 {
    INT8U newPosition = 0;
  }

  info event LongPress = 2 {
    INT8U newPosition = 0;
  }

  info event ShortRelease = 3 {
    INT8U previousPosition = 0;
  }

  info event LongRelease = 4 {
    INT8U previousPosition = 0;
  }

  info event MultiPressOngoing = 5 {
    INT8U newPosition = 0;
    INT8U currentNumberOfPressesCounted = 1;
  }

  info event MultiPressComplete = 6 {
    INT8U previousPosition = 0;
    INT8U totalNumberOfPressesCounted = 1;
  }

  readonly attribute int8u numberOfPositions = 0;
  readonly attribute int8u currentPosition = 1;
  readonly attribute optional int8u multiPressMax = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
client cluster AdministratorCommissioning = 60 {
  enum CommissioningWindowStatusEnum : ENUM8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : ENUM8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable int16u adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
    OCTET_STRING PAKEPasscodeVerifier = 1;
    INT16U discriminator = 2;
    INT32U iterations = 3;
    OCTET_STRING salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    INT16U commissioningTimeout = 0;
  }

  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using enhanced commissioning method. */
  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using basic commissioning method, if the node supports it. */
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  /** This command is used by a current Administrator to instruct a Node to revoke any active Open Commissioning Window or Open Basic Commissioning Window command. */
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
client cluster OperationalCredentials = 62 {
  enum CertificateChainTypeEnum : ENUM8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : ENUM8 {
    kOk = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute OCTET_STRING trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    OCTET_STRING attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    OCTET_STRING attestationElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    OCTET_STRING certificate = 0;
  }

  request struct CSRRequestRequest {
    OCTET_STRING CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    OCTET_STRING NOCSRElements = 0;
    OCTET_STRING attestationSignature = 1;
  }

  request struct AddNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
    OCTET_STRING IPKValue = 2;
    Int64u caseAdminSubject = 3;
    VENDOR_ID adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    OCTET_STRING NOCValue = 0;
    optional OCTET_STRING ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional CHAR_STRING debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    CHAR_STRING<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    OCTET_STRING rootCACertificate = 0;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** Sender is requesting to update the node operational certificates. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
client cluster GroupKeyManagement = 63 {
  enum GroupKeySecurityPolicyEnum : ENUM8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    INT16U groupKeySetID = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetRemoveRequest {
    INT16U groupKeySetID = 0;
  }

  request struct KeySetReadAllIndicesRequest {
    INT16U groupKeySetIDs[] = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    INT16U groupKeySetIDs[] = 0;
  }

  /** Write a new set of keys for the given key set id. */
  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  /** Read the keys for a given key set id. */
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  /** Revoke a Root Key from a Group */
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  /** Return the list of Group Key Sets associated with the accessing fabric */
  fabric command access(invoke: administer) KeySetReadAllIndices(KeySetReadAllIndicesRequest): KeySetReadAllIndicesResponse = 4;
}

/** The Fixed Label Cluster provides a feature for the device to tag an endpoint with zero or more read only
labels. */
client cluster FixedLabel = 64 {
  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The User Label Cluster provides a feature to tag an endpoint with zero or more labels. */
client cluster UserLabel = 65 {
  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  attribute access(write: manage) LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Cluster to control Proxy Configuration */
client cluster ProxyConfiguration = 66 {
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Cluster to control Proxy Discovery */
client cluster ProxyDiscovery = 67 {
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Cluster to control Proxy Valid */
client cluster ProxyValid = 68 {
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface to a boolean state called StateValue. */
client cluster BooleanState = 69 {
  info event StateChange = 0 {
    boolean stateValue = 0;
  }

  readonly attribute boolean stateValue = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Allows servers to ensure that listed clients are notified when a server is available for communication. */
client cluster IcdManagement = 70 {
  bitmap Feature : BITMAP32 {
    kCheckInProtocolSupport = 0x1;
  }

  fabric_scoped struct MonitoringRegistrationStruct {
    fabric_sensitive node_id checkInNodeID = 1;
    fabric_sensitive int64u monitoredSubject = 2;
    fabric_sensitive octet_string<16> key = 3;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute int32u idleModeInterval = 0;
  readonly attribute int32u activeModeInterval = 1;
  readonly attribute int16u activeModeThreshold = 2;
  readonly attribute access(read: administer) optional MonitoringRegistrationStruct registeredClients[] = 3;
  readonly attribute access(read: administer) optional int32u ICDCounter = 4;
  readonly attribute optional int16u clientsSupportedPerFabric = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RegisterClientRequest {
    node_id checkInNodeID = 0;
    INT64U monitoredSubject = 1;
    OCTET_STRING<16> key = 2;
    optional OCTET_STRING<16> verificationKey = 3;
  }

  response struct RegisterClientResponse = 1 {
    INT32U ICDCounter = 0;
  }

  request struct UnregisterClientRequest {
    node_id checkInNodeID = 0;
    optional OCTET_STRING<16> key = 1;
  }

  /** Register a client to the end device */
  fabric command access(invoke: manage) RegisterClient(RegisterClientRequest): RegisterClientResponse = 0;
  /** Unregister a client from an end device */
  fabric command access(invoke: manage) UnregisterClient(UnregisterClientRequest): DefaultSuccess = 2;
  /** Request the end device to stay in Active Mode for an additional ActiveModeThreshold */
  command access(invoke: manage) StayActiveRequest(): DefaultSuccess = 3;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
client cluster ModeSelect = 80 {
  bitmap Feature : BITMAP32 {
    kDeponoff = 0x1;
  }

  struct SemanticTagStruct {
    vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    SemanticTagStruct semanticTags[] = 2;
  }

  readonly attribute char_string<32> description = 0;
  readonly attribute nullable enum16 standardNamespace = 1;
  readonly attribute ModeOptionStruct supportedModes[] = 2;
  readonly attribute int8u currentMode = 3;
  attribute optional nullable int8u startUpMode = 4;
  attribute optional nullable int8u onMode = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    INT8U newMode = 0;
  }

  /** On receipt of this command, if the NewMode field matches the Mode field in an entry of the SupportedModes list, the server SHALL set the CurrentMode attribute to the NewMode value, otherwise, the server SHALL respond with an INVALID_COMMAND status response. */
  command ChangeToMode(ChangeToModeRequest): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the temperature control, and reporting temperature. */
client cluster TemperatureControl = 86 {
  bitmap Feature : BITMAP32 {
    kTemperatureNumber = 0x1;
    kTemperatureLevel = 0x2;
  }

  struct TemperatureLevelStruct {
    char_string<64> label = 0;
    int8u temperatureLevel = 1;
  }

  readonly attribute optional int16s temperatureSetpoint = 0;
  readonly attribute optional int16s minTemperature = 1;
  readonly attribute optional int16s maxTemperature = 2;
  readonly attribute optional int16s step = 3;
  readonly attribute optional int8u currentTemperatureLevelIndex = 4;
  readonly attribute optional TemperatureLevelStruct supportedTemperatureLevels[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetTemperatureRequest {
    optional INT16S targetTemperature = 0;
    optional INT8U targetTemperatureLevel = 1;
  }

  /** Set Temperature */
  command SetTemperature(SetTemperatureRequest): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the Refrigerator alarm. */
client cluster RefrigeratorAlarm = 87 {
  bitmap AlarmMap : BITMAP32 {
    kDoorOpen = 0x1;
  }

  info event Notify = 0 {
    AlarmMap active = 0;
    AlarmMap inactive = 1;
    AlarmMap state = 2;
    AlarmMap mask = 3;
  }

  attribute AlarmMap mask = 0;
  readonly attribute AlarmMap latch = 1;
  readonly attribute AlarmMap state = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ResetRequest {
    AlarmMap alarms = 0;
    optional AlarmMap mask = 1;
  }

  /** Reset alarm */
  command Reset(ResetRequest): DefaultSuccess = 0;
}

/** Attributes for reporting air quality classification */
client cluster AirQuality = 91 {
  enum AirQualityEnum : ENUM8 {
    kUnknown = 0;
    kGood = 1;
    kFair = 2;
    kModerate = 3;
    kPoor = 4;
    kVeryPoor = 5;
    kExtremelyPoor = 6;
  }

  bitmap Feature : BITMAP32 {
    kFair = 0x1;
    kModerate = 0x2;
    kVeryPoor = 0x4;
    kExtremelyPoor = 0x8;
  }

  readonly attribute AirQualityEnum airQuality = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for observing and managing the state of smoke and CO alarms. */
client cluster SmokeCoAlarm = 92 {
  enum AlarmStateEnum : ENUM8 {
    kUnknown = 0;
    kNormal = 1;
    kWarning = 2;
    kCritical = 3;
  }

  enum ContaminationStateEnum : ENUM8 {
    kUnknown = 0;
    kNormal = 1;
    kLow = 2;
    kWarning = 3;
    kCritical = 4;
  }

  enum EndOfServiceEnum : ENUM8 {
    kUnknown = 0;
    kExpired = 1;
    kNormal = 2;
  }

  enum ExpressedStateEnum : ENUM8 {
    kNormal = 0;
    kSmokeAlarm = 1;
    kCOAlarm = 2;
    kBatteryAlert = 3;
    kTesting = 4;
    kHardwareFault = 5;
    kEndOfService = 6;
    kInterconnectSmoke = 7;
    kInterconnectCO = 8;
  }

  enum MuteStateEnum : ENUM8 {
    kUnknown = 0;
    kNotMuted = 1;
    kMuted = 2;
  }

  enum SensitivityEnum : ENUM8 {
    kHigh = 0;
    kStandard = 1;
    kLow = 2;
  }

  bitmap Feature : BITMAP32 {
    kSmokeAlarm = 0x1;
    kCoAlarm = 0x2;
  }

  info event SmokeAlarm = 0 {
  }

  info event COAlarm = 1 {
  }

  info event LowBattery = 2 {
  }

  info event HardwareFault = 3 {
  }

  info event EndOfService = 4 {
  }

  info event SelfTestComplete = 5 {
  }

  info event AlarmMuted = 6 {
  }

  info event MuteEnded = 7 {
  }

  info event InterconnectSmokeAlarm = 8 {
  }

  info event InterconnectCOAlarm = 9 {
  }

  info event AllClear = 10 {
  }

  readonly attribute ExpressedStateEnum expressedState = 0;
  readonly attribute optional AlarmStateEnum smokeState = 1;
  readonly attribute optional AlarmStateEnum COState = 2;
  readonly attribute AlarmStateEnum batteryAlert = 3;
  readonly attribute optional MuteStateEnum deviceMuted = 4;
  readonly attribute boolean testInProgress = 5;
  readonly attribute boolean hardwareFaultAlert = 6;
  readonly attribute EndOfServiceEnum endOfServiceAlert = 7;
  readonly attribute optional AlarmStateEnum interconnectSmokeAlarm = 8;
  readonly attribute optional AlarmStateEnum interconnectCOAlarm = 9;
  readonly attribute optional ContaminationStateEnum contaminationState = 10;
  attribute optional SensitivityEnum sensitivityLevel = 11;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command SHALL initiate a device self-test. */
  command SelfTestRequest(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring HEPA filters in a device */
client cluster HepaFilterMonitoring = 113 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring activated carbon filters in a device */
client cluster ActivatedCarbonFilterMonitoring = 114 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring ceramic filters in a device */
client cluster CeramicFilterMonitoring = 115 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute percent condition = 0;
  readonly attribute DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring electrostatic filters in a device */
client cluster ElectrostaticFilterMonitoring = 116 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring UV filters in a device */
client cluster UvFilterMonitoring = 117 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring ionizing filters in a device */
client cluster IonizingFilterMonitoring = 118 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring zeolite filters in a device */
client cluster ZeoliteFilterMonitoring = 119 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring ozone filters in a device */
client cluster OzoneFilterMonitoring = 120 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring water tanks in a device */
client cluster WaterTankMonitoring = 121 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring fuel tanks in a device */
client cluster FuelTankMonitoring = 122 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring ink cartridges in a device */
client cluster InkCartridgeMonitoring = 123 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring toner cartridges in a device */
client cluster TonerCartridgeMonitoring = 124 {
  enum ChangeIndicationEnum : ENUM8 {
    kOk = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : ENUM8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : BITMAP32 {
    kCondition = 0x1;
    kWarning = 0x2;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** An interface to a generic way to secure a door */
client cluster DoorLock = 257 {
  enum AlarmCodeEnum : ENUM8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : ENUM8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : ENUM8 {
    kProgrammingPIN = 0;
    kPin = 1;
    kRfid = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
  }

  enum DataOperationTypeEnum : ENUM8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : ENUM8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : ENUM8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : ENUM8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : ENUM8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : ENUM8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : ENUM8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : ENUM8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : ENUM8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : ENUM8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : ENUM8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPin = 6;
    kRfid = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
  }

  enum LockOperationTypeEnum : ENUM8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : ENUM8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : ENUM8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : ENUM8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRfid = 8;
    kBiometric = 9;
  }

  enum UserStatusEnum : ENUM8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : ENUM8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : BITMAP8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : BITMAP8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : BITMAP8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : BITMAP16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : BITMAP8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : BITMAP16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : BITMAP16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : BITMAP16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : BITMAP8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : BITMAP32 {
    kPinCredential = 0x1;
    kRfidCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable INT16U userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable NODE_ID sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable INT16U userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable NODE_ID sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable INT16U userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable NODE_ID sourceNode = 5;
    nullable INT16U dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute optional nullable DoorStateEnum doorState = 3;
  attribute access(write: manage) optional int32u doorOpenEvents = 4;
  attribute access(write: manage) optional int32u doorClosedEvents = 5;
  attribute access(write: manage) optional int16u openPeriod = 6;
  readonly attribute optional int16u numberOfTotalUsersSupported = 17;
  readonly attribute optional int16u numberOfPINUsersSupported = 18;
  readonly attribute optional int16u numberOfRFIDUsersSupported = 19;
  readonly attribute optional int8u numberOfWeekDaySchedulesSupportedPerUser = 20;
  readonly attribute optional int8u numberOfYearDaySchedulesSupportedPerUser = 21;
  readonly attribute optional int8u numberOfHolidaySchedulesSupported = 22;
  readonly attribute optional int8u maxPINCodeLength = 23;
  readonly attribute optional int8u minPINCodeLength = 24;
  readonly attribute optional int8u maxRFIDCodeLength = 25;
  readonly attribute optional int8u minRFIDCodeLength = 26;
  readonly attribute optional DlCredentialRuleMask credentialRulesSupport = 27;
  readonly attribute optional int8u numberOfCredentialsSupportedPerUser = 28;
  attribute access(write: manage) optional char_string<3> language = 33;
  attribute access(write: manage) optional int8u LEDSettings = 34;
  attribute access(write: manage) int32u autoRelockTime = 35;
  attribute access(write: manage) optional int8u soundVolume = 36;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  readonly attribute optional DlDefaultConfigurationRegister defaultConfigurationRegister = 39;
  attribute access(write: administer) optional boolean enableLocalProgramming = 40;
  attribute access(write: manage) optional boolean enableOneTouchLocking = 41;
  attribute access(write: manage) optional boolean enableInsideStatusLED = 42;
  attribute access(write: manage) optional boolean enablePrivacyModeButton = 43;
  attribute access(write: administer) optional DlLocalProgrammingFeatures localProgrammingFeatures = 44;
  attribute access(write: administer) optional int8u wrongCodeEntryLimit = 48;
  attribute access(write: administer) optional int8u userCodeTemporaryDisableTime = 49;
  attribute access(write: administer) optional boolean sendPINOverTheAir = 50;
  attribute access(write: administer) optional boolean requirePINforRemoteOperation = 51;
  attribute access(write: administer) optional int16u expiringUserTimeout = 53;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional OCTET_STRING PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional OCTET_STRING PINCode = 0;
  }

  request struct UnlockWithTimeoutRequest {
    INT16U timeout = 0;
    optional OCTET_STRING PINCode = 1;
  }

  request struct SetWeekDayScheduleRequest {
    INT8U weekDayIndex = 0;
    INT16U userIndex = 1;
    DaysMaskMap daysMask = 2;
    INT8U startHour = 3;
    INT8U startMinute = 4;
    INT8U endHour = 5;
    INT8U endMinute = 6;
  }

  request struct GetWeekDayScheduleRequest {
    INT8U weekDayIndex = 0;
    INT16U userIndex = 1;
  }

  response struct GetWeekDayScheduleResponse = 12 {
    INT8U weekDayIndex = 0;
    INT16U userIndex = 1;
    DlStatus status = 2;
    optional DaysMaskMap daysMask = 3;
    optional INT8U startHour = 4;
    optional INT8U startMinute = 5;
    optional INT8U endHour = 6;
    optional INT8U endMinute = 7;
  }

  request struct ClearWeekDayScheduleRequest {
    INT8U weekDayIndex = 0;
    INT16U userIndex = 1;
  }

  request struct SetYearDayScheduleRequest {
    INT8U yearDayIndex = 0;
    INT16U userIndex = 1;
    epoch_s localStartTime = 2;
    epoch_s localEndTime = 3;
  }

  request struct GetYearDayScheduleRequest {
    INT8U yearDayIndex = 0;
    INT16U userIndex = 1;
  }

  response struct GetYearDayScheduleResponse = 15 {
    INT8U yearDayIndex = 0;
    INT16U userIndex = 1;
    DlStatus status = 2;
    optional epoch_s localStartTime = 3;
    optional epoch_s localEndTime = 4;
  }

  request struct ClearYearDayScheduleRequest {
    INT8U yearDayIndex = 0;
    INT16U userIndex = 1;
  }

  request struct SetHolidayScheduleRequest {
    INT8U holidayIndex = 0;
    epoch_s localStartTime = 1;
    epoch_s localEndTime = 2;
    OperatingModeEnum operatingMode = 3;
  }

  request struct GetHolidayScheduleRequest {
    INT8U holidayIndex = 0;
  }

  response struct GetHolidayScheduleResponse = 18 {
    INT8U holidayIndex = 0;
    DlStatus status = 1;
    optional epoch_s localStartTime = 2;
    optional epoch_s localEndTime = 3;
    optional OperatingModeEnum operatingMode = 4;
  }

  request struct ClearHolidayScheduleRequest {
    INT8U holidayIndex = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    INT16U userIndex = 1;
    nullable CHAR_STRING userName = 2;
    nullable INT32U userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    INT16U userIndex = 0;
  }

  response struct GetUserResponse = 28 {
    INT16U userIndex = 0;
    nullable CHAR_STRING userName = 1;
    nullable INT32U userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable INT16U nextUserIndex = 9;
  }

  request struct ClearUserRequest {
    INT16U userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    LONG_OCTET_STRING credentialData = 2;
    nullable INT16U userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable INT16U userIndex = 1;
    nullable INT16U nextCredentialIndex = 2;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable INT16U userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable INT16U nextCredentialIndex = 4;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  request struct UnboltDoorRequest {
    optional OCTET_STRING PINCode = 0;
  }

  /** This command causes the lock device to lock the door. */
  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  /** This command causes the lock device to unlock the door. */
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  /** This command causes the lock device to unlock the door with a timeout parameter. */
  timed command UnlockWithTimeout(UnlockWithTimeoutRequest): DefaultSuccess = 3;
  /** Set a weekly repeating schedule for a specified user. */
  command access(invoke: administer) SetWeekDaySchedule(SetWeekDayScheduleRequest): DefaultSuccess = 11;
  /** Retrieve the specific weekly schedule for the specific user. */
  command access(invoke: administer) GetWeekDaySchedule(GetWeekDayScheduleRequest): GetWeekDayScheduleResponse = 12;
  /** Clear the specific weekly schedule or all weekly schedules for the specific user. */
  command access(invoke: administer) ClearWeekDaySchedule(ClearWeekDayScheduleRequest): DefaultSuccess = 13;
  /** Set a time-specific schedule ID for a specified user. */
  command access(invoke: administer) SetYearDaySchedule(SetYearDayScheduleRequest): DefaultSuccess = 14;
  /** Returns the year day schedule data for the specified schedule and user indexes. */
  command access(invoke: administer) GetYearDaySchedule(GetYearDayScheduleRequest): GetYearDayScheduleResponse = 15;
  /** Clears the specific year day schedule or all year day schedules for the specific user. */
  command access(invoke: administer) ClearYearDaySchedule(ClearYearDayScheduleRequest): DefaultSuccess = 16;
  /** Set the holiday Schedule by specifying local start time and local end time with respect to any Lock Operating Mode. */
  command access(invoke: administer) SetHolidaySchedule(SetHolidayScheduleRequest): DefaultSuccess = 17;
  /** Get the holiday schedule for the specified index. */
  command access(invoke: administer) GetHolidaySchedule(GetHolidayScheduleRequest): GetHolidayScheduleResponse = 18;
  /** Clears the holiday schedule or all holiday schedules. */
  command access(invoke: administer) ClearHolidaySchedule(ClearHolidayScheduleRequest): DefaultSuccess = 19;
  /** Set User into the lock. */
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  /** Retrieve User. */
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  /** Clears a User or all Users. */
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  /** Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or ProgrammingUser. */
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  /** Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index. */
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
  /** Clear one, one type, or all credentials except ProgrammingPIN credential. */
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
  /** This command causes the lock device to unlock the door without pulling the latch. */
  timed command UnboltDoor(UnboltDoorRequest): DefaultSuccess = 39;
}

/** Provides an interface for controlling and adjusting automatic window coverings. */
client cluster WindowCovering = 258 {
  enum EndProductType : ENUM8 {
    kRollerShade = 0;
    kRomanShade = 1;
    kBalloonShade = 2;
    kWovenWood = 3;
    kPleatedShade = 4;
    kCellularShade = 5;
    kLayeredShade = 6;
    kLayeredShade2D = 7;
    kSheerShade = 8;
    kTiltOnlyInteriorBlind = 9;
    kInteriorBlind = 10;
    kVerticalBlindStripCurtain = 11;
    kInteriorVenetianBlind = 12;
    kExteriorVenetianBlind = 13;
    kLateralLeftCurtain = 14;
    kLateralRightCurtain = 15;
    kCentralCurtain = 16;
    kRollerShutter = 17;
    kExteriorVerticalScreen = 18;
    kAwningTerracePatio = 19;
    kAwningVerticalScreen = 20;
    kTiltOnlyPergola = 21;
    kSwingingShutter = 22;
    kSlidingShutter = 23;
    kUnknown = 255;
  }

  enum Type : ENUM8 {
    kRollerShade = 0;
    kRollerShade2Motor = 1;
    kRollerShadeExterior = 2;
    kRollerShadeExterior2Motor = 3;
    kDrapery = 4;
    kAwning = 5;
    kShutter = 6;
    kTiltBlindTiltOnly = 7;
    kTiltBlindLiftAndTilt = 8;
    kProjectorScreen = 9;
    kUnknown = 255;
  }

  bitmap ConfigStatus : BITMAP8 {
    kOperational = 0x1;
    kOnlineReserved = 0x2;
    kLiftMovementReversed = 0x4;
    kLiftPositionAware = 0x8;
    kTiltPositionAware = 0x10;
    kLiftEncoderControlled = 0x20;
    kTiltEncoderControlled = 0x40;
  }

  bitmap Feature : BITMAP32 {
    kLift = 0x1;
    kTilt = 0x2;
    kPositionAwareLift = 0x4;
    kAbsolutePosition = 0x8;
    kPositionAwareTilt = 0x10;
  }

  bitmap Mode : BITMAP8 {
    kMotorDirectionReversed = 0x1;
    kCalibrationMode = 0x2;
    kMaintenanceMode = 0x4;
    kLedFeedback = 0x8;
  }

  bitmap OperationalStatus : BITMAP8 {
    kGlobal = 0x3;
    kLift = 0xC;
    kTilt = 0x30;
  }

  bitmap SafetyStatus : BITMAP16 {
    kRemoteLockout = 0x1;
    kTamperDetection = 0x2;
    kFailedCommunication = 0x4;
    kPositionFailure = 0x8;
    kThermalProtection = 0x10;
    kObstacleDetected = 0x20;
    kPower = 0x40;
    kStopInput = 0x80;
    kMotorJammed = 0x100;
    kHardwareFailure = 0x200;
    kManualOperation = 0x400;
    kProtection = 0x800;
  }

  readonly attribute Type type = 0;
  readonly attribute optional int16u physicalClosedLimitLift = 1;
  readonly attribute optional int16u physicalClosedLimitTilt = 2;
  readonly attribute optional nullable int16u currentPositionLift = 3;
  readonly attribute optional nullable int16u currentPositionTilt = 4;
  readonly attribute optional int16u numberOfActuationsLift = 5;
  readonly attribute optional int16u numberOfActuationsTilt = 6;
  readonly attribute ConfigStatus configStatus = 7;
  readonly attribute optional nullable Percent currentPositionLiftPercentage = 8;
  readonly attribute optional nullable Percent currentPositionTiltPercentage = 9;
  readonly attribute OperationalStatus operationalStatus = 10;
  readonly attribute optional nullable Percent100ths targetPositionLiftPercent100ths = 11;
  readonly attribute optional nullable Percent100ths targetPositionTiltPercent100ths = 12;
  readonly attribute EndProductType endProductType = 13;
  readonly attribute optional nullable Percent100ths currentPositionLiftPercent100ths = 14;
  readonly attribute optional nullable Percent100ths currentPositionTiltPercent100ths = 15;
  readonly attribute optional int16u installedOpenLimitLift = 16;
  readonly attribute optional int16u installedClosedLimitLift = 17;
  readonly attribute optional int16u installedOpenLimitTilt = 18;
  readonly attribute optional int16u installedClosedLimitTilt = 19;
  attribute access(write: manage) Mode mode = 23;
  readonly attribute optional SafetyStatus safetyStatus = 26;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GoToLiftValueRequest {
    INT16U liftValue = 0;
  }

  request struct GoToLiftPercentageRequest {
    Percent100ths liftPercent100thsValue = 0;
  }

  request struct GoToTiltValueRequest {
    INT16U tiltValue = 0;
  }

  request struct GoToTiltPercentageRequest {
    Percent100ths tiltPercent100thsValue = 0;
  }

  /** Moves window covering to InstalledOpenLimitLift and InstalledOpenLimitTilt */
  command UpOrOpen(): DefaultSuccess = 0;
  /** Moves window covering to InstalledClosedLimitLift and InstalledCloseLimitTilt */
  command DownOrClose(): DefaultSuccess = 1;
  /** Stop any adjusting of window covering */
  command StopMotion(): DefaultSuccess = 2;
  /** Go to lift value specified */
  command GoToLiftValue(GoToLiftValueRequest): DefaultSuccess = 4;
  /** Go to lift percentage specified */
  command GoToLiftPercentage(GoToLiftPercentageRequest): DefaultSuccess = 5;
  /** Go to tilt value specified */
  command GoToTiltValue(GoToTiltValueRequest): DefaultSuccess = 7;
  /** Go to tilt percentage specified */
  command GoToTiltPercentage(GoToTiltPercentageRequest): DefaultSuccess = 8;
}

/** This cluster provides control of a barrier (garage door). */
client cluster BarrierControl = 259 {
  readonly attribute enum8 barrierMovingState = 1;
  readonly attribute bitmap16 barrierSafetyStatus = 2;
  readonly attribute bitmap8 barrierCapabilities = 3;
  attribute optional int16u barrierOpenEvents = 4;
  attribute optional int16u barrierCloseEvents = 5;
  attribute optional int16u barrierCommandOpenEvents = 6;
  attribute optional int16u barrierCommandCloseEvents = 7;
  attribute optional int16u barrierOpenPeriod = 8;
  attribute optional int16u barrierClosePeriod = 9;
  readonly attribute int8u barrierPosition = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct BarrierControlGoToPercentRequest {
    INT8U percentOpen = 0;
  }

  /** Command to instruct a barrier to go to a percent open state. */
  command BarrierControlGoToPercent(BarrierControlGoToPercentRequest): DefaultSuccess = 0;
  /** Command that instructs the barrier to stop moving. */
  command BarrierControlStop(): DefaultSuccess = 1;
}

/** An interface for configuring and controlling pumps. */
client cluster PumpConfigurationAndControl = 512 {
  enum ControlModeEnum : ENUM8 {
    kConstantSpeed = 0;
    kConstantPressure = 1;
    kProportionalPressure = 2;
    kConstantFlow = 3;
    kConstantTemperature = 5;
    kAutomatic = 7;
  }

  enum OperationModeEnum : ENUM8 {
    kNormal = 0;
    kMinimum = 1;
    kMaximum = 2;
    kLocal = 3;
  }

  bitmap Feature : BITMAP32 {
    kConstantPressure = 0x1;
    kCompensatedPressure = 0x2;
    kConstantFlow = 0x4;
    kConstantSpeed = 0x8;
    kConstantTemperature = 0x10;
    kAutomatic = 0x20;
    kLocalOperation = 0x40;
  }

  bitmap PumpStatusBitmap : BITMAP16 {
    kDeviceFault = 0x1;
    kSupplyfault = 0x2;
    kSpeedLow = 0x4;
    kSpeedHigh = 0x8;
    kLocalOverride = 0x10;
    kRunning = 0x20;
    kRemotePressure = 0x40;
    kRemoteFlow = 0x80;
    kRemoteTemperature = 0x100;
  }

  info event SupplyVoltageLow = 0 {
  }

  info event SupplyVoltageHigh = 1 {
  }

  info event PowerMissingPhase = 2 {
  }

  info event SystemPressureLow = 3 {
  }

  info event SystemPressureHigh = 4 {
  }

  critical event DryRunning = 5 {
  }

  info event MotorTemperatureHigh = 6 {
  }

  critical event PumpMotorFatalFailure = 7 {
  }

  info event ElectronicTemperatureHigh = 8 {
  }

  critical event PumpBlocked = 9 {
  }

  info event SensorFailure = 10 {
  }

  info event ElectronicNonFatalFailure = 11 {
  }

  critical event ElectronicFatalFailure = 12 {
  }

  info event GeneralFault = 13 {
  }

  info event Leakage = 14 {
  }

  info event AirDetection = 15 {
  }

  info event TurbineOperation = 16 {
  }

  readonly attribute nullable int16s maxPressure = 0;
  readonly attribute nullable int16u maxSpeed = 1;
  readonly attribute nullable int16u maxFlow = 2;
  readonly attribute optional nullable int16s minConstPressure = 3;
  readonly attribute optional nullable int16s maxConstPressure = 4;
  readonly attribute optional nullable int16s minCompPressure = 5;
  readonly attribute optional nullable int16s maxCompPressure = 6;
  readonly attribute optional nullable int16u minConstSpeed = 7;
  readonly attribute optional nullable int16u maxConstSpeed = 8;
  readonly attribute optional nullable int16u minConstFlow = 9;
  readonly attribute optional nullable int16u maxConstFlow = 10;
  readonly attribute optional nullable int16s minConstTemp = 11;
  readonly attribute optional nullable int16s maxConstTemp = 12;
  readonly attribute optional PumpStatusBitmap pumpStatus = 16;
  readonly attribute OperationModeEnum effectiveOperationMode = 17;
  readonly attribute ControlModeEnum effectiveControlMode = 18;
  readonly attribute nullable int16s capacity = 19;
  readonly attribute optional nullable int16u speed = 20;
  attribute access(write: manage) optional nullable int24u lifetimeRunningHours = 21;
  readonly attribute optional nullable int24u power = 22;
  attribute access(write: manage) optional nullable int32u lifetimeEnergyConsumed = 23;
  attribute access(write: manage) OperationModeEnum operationMode = 32;
  attribute access(write: manage) optional ControlModeEnum controlMode = 33;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** An interface for configuring and controlling the functionality of a thermostat. */
client cluster Thermostat = 513 {
  enum SetpointAdjustMode : ENUM8 {
    kHeat = 0;
    kCool = 1;
    kBoth = 2;
  }

  enum ThermostatControlSequence : ENUM8 {
    kCoolingOnly = 0;
    kCoolingWithReheat = 1;
    kHeatingOnly = 2;
    kHeatingWithReheat = 3;
    kCoolingAndHeating = 4;
    kCoolingAndHeatingWithReheat = 5;
  }

  enum ThermostatRunningMode : ENUM8 {
    kOff = 0;
    kCool = 3;
    kHeat = 4;
  }

  enum ThermostatSystemMode : ENUM8 {
    kOff = 0;
    kAuto = 1;
    kCool = 3;
    kHeat = 4;
    kEmergencyHeat = 5;
    kPrecooling = 6;
    kFanOnly = 7;
    kDry = 8;
    kSleep = 9;
  }

  bitmap DayOfWeek : BITMAP8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
    kAway = 0x80;
  }

  bitmap Feature : BITMAP32 {
    kHeating = 0x1;
    kCooling = 0x2;
    kOccupancy = 0x4;
    kScheduleConfiguration = 0x8;
    kSetback = 0x10;
    kAutoMode = 0x20;
  }

  bitmap ModeForSequence : BITMAP8 {
    kHeatSetpointPresent = 0x1;
    kCoolSetpointPresent = 0x2;
  }

  struct ThermostatScheduleTransition {
    int16u transitionTime = 0;
    nullable int16s heatSetpoint = 1;
    nullable int16s coolSetpoint = 2;
  }

  readonly attribute nullable int16s localTemperature = 0;
  readonly attribute optional nullable int16s outdoorTemperature = 1;
  readonly attribute optional bitmap8 occupancy = 2;
  readonly attribute optional int16s absMinHeatSetpointLimit = 3;
  readonly attribute optional int16s absMaxHeatSetpointLimit = 4;
  readonly attribute optional int16s absMinCoolSetpointLimit = 5;
  readonly attribute optional int16s absMaxCoolSetpointLimit = 6;
  readonly attribute optional int8u PICoolingDemand = 7;
  readonly attribute optional int8u PIHeatingDemand = 8;
  attribute access(write: manage) optional bitmap8 HVACSystemTypeConfiguration = 9;
  attribute access(write: manage) optional int8s localTemperatureCalibration = 16;
  attribute optional int16s occupiedCoolingSetpoint = 17;
  attribute optional int16s occupiedHeatingSetpoint = 18;
  attribute optional int16s unoccupiedCoolingSetpoint = 19;
  attribute optional int16s unoccupiedHeatingSetpoint = 20;
  attribute access(write: manage) optional int16s minHeatSetpointLimit = 21;
  attribute access(write: manage) optional int16s maxHeatSetpointLimit = 22;
  attribute access(write: manage) optional int16s minCoolSetpointLimit = 23;
  attribute access(write: manage) optional int16s maxCoolSetpointLimit = 24;
  attribute access(write: manage) optional int8s minSetpointDeadBand = 25;
  attribute access(write: manage) optional bitmap8 remoteSensing = 26;
  attribute access(write: manage) ThermostatControlSequence controlSequenceOfOperation = 27;
  attribute access(write: manage) enum8 systemMode = 28;
  readonly attribute optional enum8 thermostatRunningMode = 30;
  readonly attribute optional enum8 startOfWeek = 32;
  readonly attribute optional int8u numberOfWeeklyTransitions = 33;
  readonly attribute optional int8u numberOfDailyTransitions = 34;
  attribute access(write: manage) optional enum8 temperatureSetpointHold = 35;
  attribute access(write: manage) optional nullable int16u temperatureSetpointHoldDuration = 36;
  attribute access(write: manage) optional bitmap8 thermostatProgrammingOperationMode = 37;
  readonly attribute optional bitmap16 thermostatRunningState = 41;
  readonly attribute optional enum8 setpointChangeSource = 48;
  readonly attribute optional nullable int16s setpointChangeAmount = 49;
  readonly attribute optional epoch_s setpointChangeSourceTimestamp = 50;
  attribute access(write: manage) optional nullable int8u occupiedSetback = 52;
  readonly attribute optional nullable int8u occupiedSetbackMin = 53;
  readonly attribute optional nullable int8u occupiedSetbackMax = 54;
  attribute access(write: manage) optional nullable int8u unoccupiedSetback = 55;
  readonly attribute optional nullable int8u unoccupiedSetbackMin = 56;
  readonly attribute optional nullable int8u unoccupiedSetbackMax = 57;
  attribute access(write: manage) optional int8u emergencyHeatDelta = 58;
  attribute access(write: manage) optional enum8 ACType = 64;
  attribute access(write: manage) optional int16u ACCapacity = 65;
  attribute access(write: manage) optional enum8 ACRefrigerantType = 66;
  attribute access(write: manage) optional enum8 ACCompressorType = 67;
  attribute access(write: manage) optional bitmap32 ACErrorCode = 68;
  attribute access(write: manage) optional enum8 ACLouverPosition = 69;
  readonly attribute optional nullable int16s ACCoilTemperature = 70;
  attribute access(write: manage) optional enum8 ACCapacityformat = 71;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetpointRaiseLowerRequest {
    SetpointAdjustMode mode = 0;
    INT8S amount = 1;
  }

  response struct GetWeeklyScheduleResponse = 0 {
    INT8U numberOfTransitionsForSequence = 0;
    DayOfWeek dayOfWeekForSequence = 1;
    ModeForSequence modeForSequence = 2;
    ThermostatScheduleTransition transitions[] = 3;
  }

  request struct SetWeeklyScheduleRequest {
    INT8U numberOfTransitionsForSequence = 0;
    DayOfWeek dayOfWeekForSequence = 1;
    ModeForSequence modeForSequence = 2;
    ThermostatScheduleTransition transitions[] = 3;
  }

  request struct GetWeeklyScheduleRequest {
    DayOfWeek daysToReturn = 0;
    ModeForSequence modeToReturn = 1;
  }

  /** Command description for SetpointRaiseLower */
  command SetpointRaiseLower(SetpointRaiseLowerRequest): DefaultSuccess = 0;
  /** Command description for SetWeeklySchedule */
  command access(invoke: manage) SetWeeklySchedule(SetWeeklyScheduleRequest): DefaultSuccess = 1;
  /** Command description for GetWeeklySchedule */
  command GetWeeklySchedule(GetWeeklyScheduleRequest): GetWeeklyScheduleResponse = 2;
  /** The Clear Weekly Schedule command is used to clear the weekly schedule. */
  command access(invoke: manage) ClearWeeklySchedule(): DefaultSuccess = 3;
}

/** An interface for controlling a fan in a heating/cooling system. */
client cluster FanControl = 514 {
  enum FanModeSequenceType : ENUM8 {
    kOffLowMedHigh = 0;
    kOffLowHigh = 1;
    kOffLowMedHighAuto = 2;
    kOffLowHighAuto = 3;
    kOffOnAuto = 4;
    kOffOn = 5;
  }

  enum FanModeType : ENUM8 {
    kOff = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kOn = 4;
    kAuto = 5;
    kSmart = 6;
  }

  bitmap Feature : BITMAP32 {
    kMultiSpeed = 0x1;
    kAuto = 0x2;
    kRocking = 0x4;
    kWind = 0x8;
  }

  bitmap RockSupportMask : BITMAP8 {
    kRockLeftRight = 0x1;
    kRockUpDown = 0x2;
    kRockRound = 0x4;
  }

  bitmap WindSettingMask : BITMAP8 {
    kSleepWind = 0x1;
    kNaturalWind = 0x2;
  }

  bitmap WindSupportMask : BITMAP8 {
    kSleepWind = 0x1;
    kNaturalWind = 0x2;
  }

  attribute FanModeType fanMode = 0;
  attribute FanModeSequenceType fanModeSequence = 1;
  attribute nullable int8u percentSetting = 2;
  readonly attribute int8u percentCurrent = 3;
  readonly attribute optional int8u speedMax = 4;
  attribute optional nullable int8u speedSetting = 5;
  readonly attribute optional int8u speedCurrent = 6;
  readonly attribute optional bitmap8 rockSupport = 7;
  attribute optional bitmap8 rockSetting = 8;
  readonly attribute optional bitmap8 windSupport = 9;
  attribute optional bitmap8 windSetting = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** An interface for configuring the user interface of a thermostat (which may be remote from the thermostat). */
client cluster ThermostatUserInterfaceConfiguration = 516 {
  attribute enum8 temperatureDisplayMode = 0;
  attribute access(write: manage) enum8 keypadLockout = 1;
  attribute access(write: manage) optional enum8 scheduleProgrammingVisibility = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for controlling the color properties of a color-capable light. */
client cluster ColorControl = 768 {
  enum ColorLoopAction : ENUM8 {
    kDeactivate = 0;
    kActivateFromColorLoopStartEnhancedHue = 1;
    kActivateFromEnhancedCurrentHue = 2;
  }

  enum ColorLoopDirection : ENUM8 {
    kDecrementHue = 0;
    kIncrementHue = 1;
  }

  enum ColorMode : ENUM8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperature = 2;
  }

  enum HueDirection : ENUM8 {
    kShortestDistance = 0;
    kLongestDistance = 1;
    kUp = 2;
    kDown = 3;
  }

  enum HueMoveMode : ENUM8 {
    kStop = 0;
    kUp = 1;
    kDown = 3;
  }

  enum HueStepMode : ENUM8 {
    kUp = 1;
    kDown = 3;
  }

  enum SaturationMoveMode : ENUM8 {
    kStop = 0;
    kUp = 1;
    kDown = 3;
  }

  enum SaturationStepMode : ENUM8 {
    kUp = 1;
    kDown = 3;
  }

  bitmap ColorCapabilities : BITMAP16 {
    kHueSaturationSupported = 0x1;
    kEnhancedHueSupported = 0x2;
    kColorLoopSupported = 0x4;
    kXYAttributesSupported = 0x8;
    kColorTemperatureSupported = 0x10;
  }

  bitmap ColorLoopUpdateFlags : BITMAP8 {
    kUpdateAction = 0x1;
    kUpdateDirection = 0x2;
    kUpdateTime = 0x4;
    kUpdateStartHue = 0x8;
  }

  bitmap Feature : BITMAP32 {
    kHueAndSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXy = 0x8;
    kColorTemperature = 0x10;
  }

  readonly attribute optional int8u currentHue = 0;
  readonly attribute optional int8u currentSaturation = 1;
  readonly attribute optional int16u remainingTime = 2;
  readonly attribute optional int16u currentX = 3;
  readonly attribute optional int16u currentY = 4;
  readonly attribute optional enum8 driftCompensation = 5;
  readonly attribute optional char_string<254> compensationText = 6;
  readonly attribute optional int16u colorTemperatureMireds = 7;
  readonly attribute enum8 colorMode = 8;
  attribute bitmap8 options = 15;
  readonly attribute nullable int8u numberOfPrimaries = 16;
  readonly attribute optional int16u primary1X = 17;
  readonly attribute optional int16u primary1Y = 18;
  readonly attribute optional nullable int8u primary1Intensity = 19;
  readonly attribute optional int16u primary2X = 21;
  readonly attribute optional int16u primary2Y = 22;
  readonly attribute optional nullable int8u primary2Intensity = 23;
  readonly attribute optional int16u primary3X = 25;
  readonly attribute optional int16u primary3Y = 26;
  readonly attribute optional nullable int8u primary3Intensity = 27;
  readonly attribute optional int16u primary4X = 32;
  readonly attribute optional int16u primary4Y = 33;
  readonly attribute optional nullable int8u primary4Intensity = 34;
  readonly attribute optional int16u primary5X = 36;
  readonly attribute optional int16u primary5Y = 37;
  readonly attribute optional nullable int8u primary5Intensity = 38;
  readonly attribute optional int16u primary6X = 40;
  readonly attribute optional int16u primary6Y = 41;
  readonly attribute optional nullable int8u primary6Intensity = 42;
  attribute access(write: manage) optional int16u whitePointX = 48;
  attribute access(write: manage) optional int16u whitePointY = 49;
  attribute access(write: manage) optional int16u colorPointRX = 50;
  attribute access(write: manage) optional int16u colorPointRY = 51;
  attribute access(write: manage) optional nullable int8u colorPointRIntensity = 52;
  attribute access(write: manage) optional int16u colorPointGX = 54;
  attribute access(write: manage) optional int16u colorPointGY = 55;
  attribute access(write: manage) optional nullable int8u colorPointGIntensity = 56;
  attribute access(write: manage) optional int16u colorPointBX = 58;
  attribute access(write: manage) optional int16u colorPointBY = 59;
  attribute access(write: manage) optional nullable int8u colorPointBIntensity = 60;
  readonly attribute optional int16u enhancedCurrentHue = 16384;
  readonly attribute enum8 enhancedColorMode = 16385;
  readonly attribute optional int8u colorLoopActive = 16386;
  readonly attribute optional int8u colorLoopDirection = 16387;
  readonly attribute optional int16u colorLoopTime = 16388;
  readonly attribute optional int16u colorLoopStartEnhancedHue = 16389;
  readonly attribute optional int16u colorLoopStoredEnhancedHue = 16390;
  readonly attribute bitmap16 colorCapabilities = 16394;
  readonly attribute optional int16u colorTempPhysicalMinMireds = 16395;
  readonly attribute optional int16u colorTempPhysicalMaxMireds = 16396;
  readonly attribute optional int16u coupleColorTempToLevelMinMireds = 16397;
  attribute access(write: manage) optional nullable int16u startUpColorTemperatureMireds = 16400;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToHueRequest {
    INT8U hue = 0;
    HueDirection direction = 1;
    INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct MoveHueRequest {
    HueMoveMode moveMode = 0;
    INT8U rate = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct StepHueRequest {
    HueStepMode stepMode = 0;
    INT8U stepSize = 1;
    INT8U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct MoveToSaturationRequest {
    INT8U saturation = 0;
    INT16U transitionTime = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct MoveSaturationRequest {
    SaturationMoveMode moveMode = 0;
    INT8U rate = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct StepSaturationRequest {
    SaturationStepMode stepMode = 0;
    INT8U stepSize = 1;
    INT8U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct MoveToHueAndSaturationRequest {
    INT8U hue = 0;
    INT8U saturation = 1;
    INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct MoveToColorRequest {
    INT16U colorX = 0;
    INT16U colorY = 1;
    INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct MoveColorRequest {
    INT16S rateX = 0;
    INT16S rateY = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct StepColorRequest {
    INT16S stepX = 0;
    INT16S stepY = 1;
    INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct MoveToColorTemperatureRequest {
    INT16U colorTemperatureMireds = 0;
    INT16U transitionTime = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct EnhancedMoveToHueRequest {
    INT16U enhancedHue = 0;
    HueDirection direction = 1;
    INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct EnhancedMoveHueRequest {
    HueMoveMode moveMode = 0;
    INT16U rate = 1;
    BITMAP8 optionsMask = 2;
    BITMAP8 optionsOverride = 3;
  }

  request struct EnhancedStepHueRequest {
    HueStepMode stepMode = 0;
    INT16U stepSize = 1;
    INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct EnhancedMoveToHueAndSaturationRequest {
    INT16U enhancedHue = 0;
    INT8U saturation = 1;
    INT16U transitionTime = 2;
    BITMAP8 optionsMask = 3;
    BITMAP8 optionsOverride = 4;
  }

  request struct ColorLoopSetRequest {
    ColorLoopUpdateFlags updateFlags = 0;
    ColorLoopAction action = 1;
    ColorLoopDirection direction = 2;
    INT16U time = 3;
    INT16U startHue = 4;
    BITMAP8 optionsMask = 5;
    BITMAP8 optionsOverride = 6;
  }

  request struct StopMoveStepRequest {
    BITMAP8 optionsMask = 0;
    BITMAP8 optionsOverride = 1;
  }

  request struct MoveColorTemperatureRequest {
    HueMoveMode moveMode = 0;
    INT16U rate = 1;
    INT16U colorTemperatureMinimumMireds = 2;
    INT16U colorTemperatureMaximumMireds = 3;
    BITMAP8 optionsMask = 4;
    BITMAP8 optionsOverride = 5;
  }

  request struct StepColorTemperatureRequest {
    HueStepMode stepMode = 0;
    INT16U stepSize = 1;
    INT16U transitionTime = 2;
    INT16U colorTemperatureMinimumMireds = 3;
    INT16U colorTemperatureMaximumMireds = 4;
    BITMAP8 optionsMask = 5;
    BITMAP8 optionsOverride = 6;
  }

  /** Move to specified hue. */
  command MoveToHue(MoveToHueRequest): DefaultSuccess = 0;
  /** Move hue up or down at specified rate. */
  command MoveHue(MoveHueRequest): DefaultSuccess = 1;
  /** Step hue up or down by specified size at specified rate. */
  command StepHue(StepHueRequest): DefaultSuccess = 2;
  /** Move to specified saturation. */
  command MoveToSaturation(MoveToSaturationRequest): DefaultSuccess = 3;
  /** Move saturation up or down at specified rate. */
  command MoveSaturation(MoveSaturationRequest): DefaultSuccess = 4;
  /** Step saturation up or down by specified size at specified rate. */
  command StepSaturation(StepSaturationRequest): DefaultSuccess = 5;
  /** Move to hue and saturation. */
  command MoveToHueAndSaturation(MoveToHueAndSaturationRequest): DefaultSuccess = 6;
  /** Move to specified color. */
  command MoveToColor(MoveToColorRequest): DefaultSuccess = 7;
  /** Moves the color. */
  command MoveColor(MoveColorRequest): DefaultSuccess = 8;
  /** Steps the lighting to a specific color. */
  command StepColor(StepColorRequest): DefaultSuccess = 9;
  /** Move to a specific color temperature. */
  command MoveToColorTemperature(MoveToColorTemperatureRequest): DefaultSuccess = 10;
  /** Command description for EnhancedMoveToHue */
  command EnhancedMoveToHue(EnhancedMoveToHueRequest): DefaultSuccess = 64;
  /** Command description for EnhancedMoveHue */
  command EnhancedMoveHue(EnhancedMoveHueRequest): DefaultSuccess = 65;
  /** Command description for EnhancedStepHue */
  command EnhancedStepHue(EnhancedStepHueRequest): DefaultSuccess = 66;
  /** Command description for EnhancedMoveToHueAndSaturation */
  command EnhancedMoveToHueAndSaturation(EnhancedMoveToHueAndSaturationRequest): DefaultSuccess = 67;
  /** Command description for ColorLoopSet */
  command ColorLoopSet(ColorLoopSetRequest): DefaultSuccess = 68;
  /** Command description for StopMoveStep */
  command StopMoveStep(StopMoveStepRequest): DefaultSuccess = 71;
  /** Command description for MoveColorTemperature */
  command MoveColorTemperature(MoveColorTemperatureRequest): DefaultSuccess = 75;
  /** Command description for StepColorTemperature */
  command StepColorTemperature(StepColorTemperatureRequest): DefaultSuccess = 76;
}

/** Attributes and commands for configuring a lighting ballast. */
client cluster BallastConfiguration = 769 {
  readonly attribute int8u physicalMinLevel = 0;
  readonly attribute int8u physicalMaxLevel = 1;
  readonly attribute optional bitmap8 ballastStatus = 2;
  attribute int8u minLevel = 16;
  attribute int8u maxLevel = 17;
  attribute optional nullable int8u intrinsicBallastFactor = 20;
  attribute optional nullable int8u ballastFactorAdjustment = 21;
  readonly attribute int8u lampQuantity = 32;
  attribute optional char_string<16> lampType = 48;
  attribute optional char_string<16> lampManufacturer = 49;
  attribute optional nullable int24u lampRatedHours = 50;
  attribute optional nullable int24u lampBurnHours = 51;
  attribute optional bitmap8 lampAlarmMode = 52;
  attribute optional nullable int24u lampBurnHoursTripPoint = 53;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of illuminance, and reporting illuminance measurements. */
client cluster IlluminanceMeasurement = 1024 {
  enum LightSensorType : ENUM8 {
    kPhotodiode = 0;
    kCmos = 1;
  }

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable enum8 lightSensorType = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of temperature, and reporting temperature measurements. */
client cluster TemperatureMeasurement = 1026 {
  readonly attribute nullable int16s measuredValue = 0;
  readonly attribute nullable int16s minMeasuredValue = 1;
  readonly attribute nullable int16s maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of pressure, and reporting pressure measurements. */
client cluster PressureMeasurement = 1027 {
  bitmap Feature : BITMAP32 {
    kExtended = 0x1;
  }

  readonly attribute nullable int16s measuredValue = 0;
  readonly attribute nullable int16s minMeasuredValue = 1;
  readonly attribute nullable int16s maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable int16s scaledValue = 16;
  readonly attribute optional nullable int16s minScaledValue = 17;
  readonly attribute optional nullable int16s maxScaledValue = 18;
  readonly attribute optional int16u scaledTolerance = 19;
  readonly attribute optional int8s scale = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of flow, and reporting flow measurements. */
client cluster FlowMeasurement = 1028 {
  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of relative humidity, and reporting relative humidity measurements. */
client cluster RelativeHumidityMeasurement = 1029 {
  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring occupancy sensing, and reporting occupancy status. */
client cluster OccupancySensing = 1030 {
  enum OccupancySensorTypeEnum : ENUM8 {
    kPir = 0;
    kUltrasonic = 1;
    kPIRAndUltrasonic = 2;
    kPhysicalContact = 3;
  }

  bitmap OccupancyBitmap : BITMAP8 {
    kOccupied = 0x1;
  }

  bitmap OccupancySensorTypeBitmap : BITMAP8 {
    kPir = 0x1;
    kUltrasonic = 0x2;
    kPhysicalContact = 0x4;
  }

  readonly attribute OccupancyBitmap occupancy = 0;
  readonly attribute OccupancySensorTypeEnum occupancySensorType = 1;
  readonly attribute OccupancySensorTypeBitmap occupancySensorTypeBitmap = 2;
  attribute access(write: manage) optional int16u PIROccupiedToUnoccupiedDelay = 16;
  attribute access(write: manage) optional int16u PIRUnoccupiedToOccupiedDelay = 17;
  attribute access(write: manage) optional int8u PIRUnoccupiedToOccupiedThreshold = 18;
  attribute access(write: manage) optional int16u ultrasonicOccupiedToUnoccupiedDelay = 32;
  attribute access(write: manage) optional int16u ultrasonicUnoccupiedToOccupiedDelay = 33;
  attribute access(write: manage) optional int8u ultrasonicUnoccupiedToOccupiedThreshold = 34;
  attribute access(write: manage) optional int16u physicalContactOccupiedToUnoccupiedDelay = 48;
  attribute access(write: manage) optional int16u physicalContactUnoccupiedToOccupiedDelay = 49;
  attribute access(write: manage) optional int8u physicalContactUnoccupiedToOccupiedThreshold = 50;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for managing low power mode on a device that supports the Wake On LAN protocol. */
client cluster WakeOnLan = 1283 {
  readonly attribute optional char_string<32> MACAddress = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for controlling the current Channel on a device. */
client cluster Channel = 1284 {
  enum ChannelStatusEnum : ENUM8 {
    kSuccess = 0;
    kMultipleMatches = 1;
    kNoMatches = 2;
  }

  enum LineupInfoTypeEnum : ENUM8 {
    kMso = 0;
  }

  bitmap Feature : BITMAP32 {
    kChannelList = 0x1;
    kLineupInfo = 0x2;
  }

  struct ChannelInfoStruct {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
    optional char_string name = 2;
    optional char_string callSign = 3;
    optional char_string affiliateCallSign = 4;
  }

  struct LineupInfoStruct {
    char_string operatorName = 0;
    optional char_string lineupName = 1;
    optional char_string postalCode = 2;
    LineupInfoTypeEnum lineupInfoType = 3;
  }

  readonly attribute optional ChannelInfoStruct channelList[] = 0;
  readonly attribute optional nullable LineupInfoStruct lineup = 1;
  readonly attribute optional nullable ChannelInfoStruct currentChannel = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeChannelRequest {
    CHAR_STRING match = 0;
  }

  response struct ChangeChannelResponse = 1 {
    ChannelStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  request struct ChangeChannelByNumberRequest {
    INT16U majorNumber = 0;
    INT16U minorNumber = 1;
  }

  request struct SkipChannelRequest {
    INT16S count = 0;
  }

  /** Change the channel on the media player to the channel case-insensitive exact matching the value passed as an argument. */
  command ChangeChannel(ChangeChannelRequest): ChangeChannelResponse = 0;
  /** Change the channel on the media plaeyer to the channel with the given Number in the ChannelList attribute. */
  command ChangeChannelByNumber(ChangeChannelByNumberRequest): DefaultSuccess = 2;
  /** This command provides channel up and channel down functionality, but allows channel index jumps of size Count. When the value of the increase or decrease is larger than the number of channels remaining in the given direction, then the behavior SHALL be to return to the beginning (or end) of the channel list and continue. For example, if the current channel is at index 0 and count value of -1 is given, then the current channel should change to the last channel. */
  command SkipChannel(SkipChannelRequest): DefaultSuccess = 3;
}

/** This cluster provides an interface for UX navigation within a set of targets on a device or endpoint. */
client cluster TargetNavigator = 1285 {
  enum TargetNavigatorStatusEnum : ENUM8 {
    kSuccess = 0;
    kTargetNotFound = 1;
    kNotAllowed = 2;
  }

  struct TargetInfoStruct {
    int8u identifier = 0;
    char_string<32> name = 1;
  }

  readonly attribute TargetInfoStruct targetList[] = 0;
  readonly attribute optional int8u currentTarget = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct NavigateTargetRequest {
    INT8U target = 0;
    optional CHAR_STRING data = 1;
  }

  response struct NavigateTargetResponse = 1 {
    TargetNavigatorStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  /** Upon receipt, this SHALL navigation the UX to the target identified. */
  command NavigateTarget(NavigateTargetRequest): NavigateTargetResponse = 0;
}

/** This cluster provides an interface for controlling Media Playback (PLAY, PAUSE, etc) on a media device such as a TV or Speaker. */
client cluster MediaPlayback = 1286 {
  enum MediaPlaybackStatusEnum : ENUM8 {
    kSuccess = 0;
    kInvalidStateForCommand = 1;
    kNotAllowed = 2;
    kNotActive = 3;
    kSpeedOutOfRange = 4;
    kSeekOutOfRange = 5;
  }

  enum PlaybackStateEnum : ENUM8 {
    kPlaying = 0;
    kPaused = 1;
    kNotPlaying = 2;
    kBuffering = 3;
  }

  bitmap Feature : BITMAP32 {
    kAdvancedSeek = 0x1;
    kVariableSpeed = 0x2;
  }

  struct PlaybackPositionStruct {
    epoch_us updatedAt = 0;
    nullable int64u position = 1;
  }

  readonly attribute PlaybackStateEnum currentState = 0;
  readonly attribute optional nullable epoch_us startTime = 1;
  readonly attribute optional nullable int64u duration = 2;
  readonly attribute optional nullable PlaybackPositionStruct sampledPosition = 3;
  readonly attribute optional single playbackSpeed = 4;
  readonly attribute optional nullable int64u seekRangeEnd = 5;
  readonly attribute optional nullable int64u seekRangeStart = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SkipForwardRequest {
    INT64U deltaPositionMilliseconds = 0;
  }

  request struct SkipBackwardRequest {
    INT64U deltaPositionMilliseconds = 0;
  }

  response struct PlaybackResponse = 10 {
    MediaPlaybackStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  request struct SeekRequest {
    INT64U position = 0;
  }

  /** Upon receipt, this SHALL play media. */
  command Play(): PlaybackResponse = 0;
  /** Upon receipt, this SHALL pause media. */
  command Pause(): PlaybackResponse = 1;
  /** Upon receipt, this SHALL stop media. User experience is context-specific. This will often navigate the user back to the location where media was originally launched. */
  command Stop(): PlaybackResponse = 2;
  /** Upon receipt, this SHALL Start Over with the current media playback item. */
  command StartOver(): PlaybackResponse = 3;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Previous". User experience is context-specific. This will often Go back to the previous media playback item. */
  command Previous(): PlaybackResponse = 4;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Next". User experience is context-specific. This will often Go forward to the next media playback item. */
  command Next(): PlaybackResponse = 5;
  /** Upon receipt, this SHALL Rewind through media. Different Rewind speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command Rewind(): PlaybackResponse = 6;
  /** Upon receipt, this SHALL Advance through media. Different FF speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command FastForward(): PlaybackResponse = 7;
  /** Upon receipt, this SHALL Skip forward in the media by the given number of seconds, using the data as follows: */
  command SkipForward(SkipForwardRequest): PlaybackResponse = 8;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command SkipBackward(SkipBackwardRequest): PlaybackResponse = 9;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command Seek(SeekRequest): PlaybackResponse = 11;
}

/** This cluster provides an interface for controlling the Input Selector on a media device such as a TV. */
client cluster MediaInput = 1287 {
  enum InputTypeEnum : ENUM8 {
    kInternal = 0;
    kAux = 1;
    kCoax = 2;
    kComposite = 3;
    kHdmi = 4;
    kInput = 5;
    kLine = 6;
    kOptical = 7;
    kVideo = 8;
    kScart = 9;
    kUsb = 10;
    kOther = 11;
  }

  bitmap Feature : BITMAP32 {
    kNameUpdates = 0x1;
  }

  struct InputInfoStruct {
    int8u index = 0;
    InputTypeEnum inputType = 1;
    char_string<32> name = 2;
    char_string<32> description = 3;
  }

  readonly attribute InputInfoStruct inputList[] = 0;
  readonly attribute int8u currentInput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectInputRequest {
    INT8U index = 0;
  }

  request struct RenameInputRequest {
    INT8U index = 0;
    CHAR_STRING name = 1;
  }

  /** Upon receipt, this SHALL change the input on the media device to the input at a specific index in the Input List. */
  command SelectInput(SelectInputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL display the active status of the input list on screen. */
  command ShowInputStatus(): DefaultSuccess = 1;
  /** Upon receipt, this SHALL hide the input list from the screen. */
  command HideInputStatus(): DefaultSuccess = 2;
  /** Upon receipt, this SHALL rename the input at a specific index in the Input List. Updates to the input name SHALL appear in the TV settings menus. */
  command RenameInput(RenameInputRequest): DefaultSuccess = 3;
}

/** This cluster provides an interface for managing low power mode on a device. */
client cluster LowPower = 1288 {
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command shall put the device into low power mode. */
  command Sleep(): DefaultSuccess = 0;
}

/** This cluster provides an interface for controlling a device like a TV using action commands such as UP, DOWN, and SELECT. */
client cluster KeypadInput = 1289 {
  enum CecKeyCode : ENUM8 {
    kSelect = 0;
    kUp = 1;
    kDown = 2;
    kLeft = 3;
    kRight = 4;
    kRightUp = 5;
    kRightDown = 6;
    kLeftUp = 7;
    kLeftDown = 8;
    kRootMenu = 9;
    kSetupMenu = 10;
    kContentsMenu = 11;
    kFavoriteMenu = 12;
    kExit = 13;
    kMediaTopMenu = 16;
    kMediaContextSensitiveMenu = 17;
    kNumberEntryMode = 29;
    kNumber11 = 30;
    kNumber12 = 31;
    kNumber0OrNumber10 = 32;
    kNumbers1 = 33;
    kNumbers2 = 34;
    kNumbers3 = 35;
    kNumbers4 = 36;
    kNumbers5 = 37;
    kNumbers6 = 38;
    kNumbers7 = 39;
    kNumbers8 = 40;
    kNumbers9 = 41;
    kDot = 42;
    kEnter = 43;
    kClear = 44;
    kNextFavorite = 47;
    kChannelUp = 48;
    kChannelDown = 49;
    kPreviousChannel = 50;
    kSoundSelect = 51;
    kInputSelect = 52;
    kDisplayInformation = 53;
    kHelp = 54;
    kPageUp = 55;
    kPageDown = 56;
    kPower = 64;
    kVolumeUp = 65;
    kVolumeDown = 66;
    kMute = 67;
    kPlay = 68;
    kStop = 69;
    kPause = 70;
    kRecord = 71;
    kRewind = 72;
    kFastForward = 73;
    kEject = 74;
    kForward = 75;
    kBackward = 76;
    kStopRecord = 77;
    kPauseRecord = 78;
    kReserved = 79;
    kAngle = 80;
    kSubPicture = 81;
    kVideoOnDemand = 82;
    kElectronicProgramGuide = 83;
    kTimerProgramming = 84;
    kInitialConfiguration = 85;
    kSelectBroadcastType = 86;
    kSelectSoundPresentation = 87;
    kPlayFunction = 96;
    kPausePlayFunction = 97;
    kRecordFunction = 98;
    kPauseRecordFunction = 99;
    kStopFunction = 100;
    kMuteFunction = 101;
    kRestoreVolumeFunction = 102;
    kTuneFunction = 103;
    kSelectMediaFunction = 104;
    kSelectAvInputFunction = 105;
    kSelectAudioInputFunction = 106;
    kPowerToggleFunction = 107;
    kPowerOffFunction = 108;
    kPowerOnFunction = 109;
    kF1Blue = 113;
    kF2Red = 114;
    kF3Green = 115;
    kF4Yellow = 116;
    kF5 = 117;
    kData = 118;
  }

  enum KeypadInputStatusEnum : ENUM8 {
    kSuccess = 0;
    kUnsupportedKey = 1;
    kInvalidKeyInCurrentState = 2;
  }

  bitmap Feature : BITMAP32 {
    kNavigationKeyCodes = 0x1;
    kLocationKeys = 0x2;
    kNumberKeys = 0x4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SendKeyRequest {
    CecKeyCode keyCode = 0;
  }

  response struct SendKeyResponse = 1 {
    KeypadInputStatusEnum status = 0;
  }

  /** Upon receipt, this SHALL process a keycode as input to the media device. */
  command SendKey(SendKeyRequest): SendKeyResponse = 0;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
client cluster ContentLauncher = 1290 {
  enum ContentLaunchStatusEnum : ENUM8 {
    kSuccess = 0;
    kUrlNotAvailable = 1;
    kAuthFailed = 2;
  }

  enum MetricTypeEnum : ENUM8 {
    kPixels = 0;
    kPercentage = 1;
  }

  enum ParameterEnum : ENUM8 {
    kActor = 0;
    kChannel = 1;
    kCharacter = 2;
    kDirector = 3;
    kEvent = 4;
    kFranchise = 5;
    kGenre = 6;
    kLeague = 7;
    kPopularity = 8;
    kProvider = 9;
    kSport = 10;
    kSportsTeam = 11;
    kType = 12;
    kVideo = 13;
  }

  bitmap Feature : BITMAP32 {
    kContentSearch = 0x1;
    kURLPlayback = 0x2;
  }

  bitmap SupportedStreamingProtocol : BITMAP32 {
    kDash = 0x1;
    kHls = 0x2;
  }

  struct DimensionStruct {
    double width = 0;
    double height = 1;
    MetricTypeEnum metric = 2;
  }

  struct AdditionalInfoStruct {
    char_string name = 0;
    char_string value = 1;
  }

  struct ParameterStruct {
    ParameterEnum type = 0;
    char_string value = 1;
    optional AdditionalInfoStruct externalIDList[] = 2;
  }

  struct ContentSearchStruct {
    ParameterStruct parameterList[] = 0;
  }

  struct StyleInformationStruct {
    optional char_string imageURL = 0;
    optional char_string color = 1;
    optional DimensionStruct size = 2;
  }

  struct BrandingInformationStruct {
    char_string providerName = 0;
    optional StyleInformationStruct background = 1;
    optional StyleInformationStruct logo = 2;
    optional StyleInformationStruct progressBar = 3;
    optional StyleInformationStruct splash = 4;
    optional StyleInformationStruct waterMark = 5;
  }

  readonly attribute optional CHAR_STRING acceptHeader[] = 0;
  attribute optional bitmap32 supportedStreamingProtocols = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchContentRequest {
    ContentSearchStruct search = 0;
    BOOLEAN autoPlay = 1;
    optional CHAR_STRING data = 2;
  }

  request struct LaunchURLRequest {
    CHAR_STRING contentURL = 0;
    optional CHAR_STRING displayString = 1;
    optional BrandingInformationStruct brandingInformation = 2;
  }

  response struct LauncherResponse = 2 {
    ContentLaunchStatusEnum status = 0;
    optional CHAR_STRING data = 1;
  }

  /** Upon receipt, this SHALL launch the specified content with optional search criteria. */
  command LaunchContent(LaunchContentRequest): LauncherResponse = 0;
  /** Upon receipt, this SHALL launch content from the specified URL. */
  command LaunchURL(LaunchURLRequest): LauncherResponse = 1;
}

/** This cluster provides an interface for controlling the Output on a media device such as a TV. */
client cluster AudioOutput = 1291 {
  enum OutputTypeEnum : ENUM8 {
    kHdmi = 0;
    kBt = 1;
    kOptical = 2;
    kHeadphone = 3;
    kInternal = 4;
    kOther = 5;
  }

  bitmap Feature : BITMAP32 {
    kNameUpdates = 0x1;
  }

  struct OutputInfoStruct {
    int8u index = 0;
    OutputTypeEnum outputType = 1;
    char_string<32> name = 2;
  }

  readonly attribute OutputInfoStruct outputList[] = 0;
  readonly attribute optional int8u currentOutput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectOutputRequest {
    INT8U index = 0;
  }

  request struct RenameOutputRequest {
    INT8U index = 0;
    CHAR_STRING name = 1;
  }

  /** Upon receipt, this SHALL change the output on the media device to the output at a specific index in the Output List. */
  command SelectOutput(SelectOutputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL rename the output at a specific index in the Output List. Updates to the output name SHALL appear in the TV settings menus. */
  command RenameOutput(RenameOutputRequest): DefaultSuccess = 1;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
client cluster ApplicationLauncher = 1292 {
  enum ApplicationLauncherStatusEnum : ENUM8 {
    kSuccess = 0;
    kAppNotAvailable = 1;
    kSystemBusy = 2;
  }

  bitmap Feature : BITMAP32 {
    kApplicationPlatform = 0x1;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  struct ApplicationEPStruct {
    ApplicationStruct application = 0;
    optional endpoint_no endpoint = 1;
  }

  readonly attribute optional INT16U catalogList[] = 0;
  attribute optional nullable ApplicationEPStruct currentApp = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchAppRequest {
    optional ApplicationStruct application = 0;
    optional OCTET_STRING data = 1;
  }

  request struct StopAppRequest {
    optional ApplicationStruct application = 0;
  }

  request struct HideAppRequest {
    optional ApplicationStruct application = 0;
  }

  response struct LauncherResponse = 3 {
    ApplicationLauncherStatusEnum status = 0;
    optional OCTET_STRING data = 1;
  }

  /** Upon receipt, this SHALL launch the specified app with optional data. The TV Device SHALL launch and bring to foreground the identified application in the command if the application is not already launched and in foreground. The TV Device SHALL update state attribute on the Application Basic cluster of the Endpoint corresponding to the launched application. This command returns a Launch Response. */
  command LaunchApp(LaunchAppRequest): LauncherResponse = 0;
  /** Upon receipt on a Video Player endpoint this SHALL stop the specified application if it is running. */
  command StopApp(StopAppRequest): LauncherResponse = 1;
  /** Upon receipt on a Video Player endpoint this SHALL hide the specified application if it is running and visible. */
  command HideApp(HideAppRequest): LauncherResponse = 2;
}

/** This cluster provides information about an application running on a TV or media player device which is represented as an endpoint. */
client cluster ApplicationBasic = 1293 {
  enum ApplicationStatusEnum : ENUM8 {
    kStopped = 0;
    kActiveVisibleFocus = 1;
    kActiveHidden = 2;
    kActiveVisibleNotFocus = 3;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  readonly attribute optional char_string<32> vendorName = 0;
  readonly attribute optional vendor_id vendorID = 1;
  readonly attribute char_string<32> applicationName = 2;
  readonly attribute optional int16u productID = 3;
  readonly attribute ApplicationStruct application = 4;
  readonly attribute ApplicationStatusEnum status = 5;
  readonly attribute char_string<32> applicationVersion = 6;
  readonly attribute vendor_id allowedVendorList[] = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides commands that facilitate user account login on a Content App or a node. For example, a Content App running on a Video Player device, which is represented as an endpoint (see [TV Architecture]), can use this cluster to help make the user account on the Content App match the user account on the Client. */
client cluster AccountLogin = 1294 {
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GetSetupPINRequest {
    CHAR_STRING<100> tempAccountIdentifier = 0;
  }

  response struct GetSetupPINResponse = 1 {
    CHAR_STRING setupPIN = 0;
  }

  request struct LoginRequest {
    CHAR_STRING<100> tempAccountIdentifier = 0;
    CHAR_STRING setupPIN = 1;
  }

  /** Upon receipt, the Content App checks if the account associated with the client Temp Account Identifier Rotating ID is the same acount that is active on the given Content App. If the accounts are the same, then the Content App includes the Setup PIN in the GetSetupPIN Response. */
  timed command GetSetupPIN(GetSetupPINRequest): GetSetupPINResponse = 0;
  /** Upon receipt, the Content App checks if the account associated with the client’s Temp Account Identifier (Rotating ID) has a current active Setup PIN with the given value. If the Setup PIN is valid for the user account associated with the Temp Account Identifier, then the Content App MAY make that user account active. */
  timed command Login(LoginRequest): DefaultSuccess = 2;
  /** The purpose of this command is to instruct the Content App to clear the current user account. This command SHOULD be used by clients of a Content App to indicate the end of a user session. */
  timed command Logout(): DefaultSuccess = 3;
}

/** Attributes related to the electrical properties of a device. This cluster is used by power outlets and other devices that need to provide instantaneous data as opposed to metrology data which should be retrieved from the metering cluster.. */
client cluster ElectricalMeasurement = 2820 {
  readonly attribute optional bitmap32 measurementType = 0;
  readonly attribute optional int16s dcVoltage = 256;
  readonly attribute optional int16s dcVoltageMin = 257;
  readonly attribute optional int16s dcVoltageMax = 258;
  readonly attribute optional int16s dcCurrent = 259;
  readonly attribute optional int16s dcCurrentMin = 260;
  readonly attribute optional int16s dcCurrentMax = 261;
  readonly attribute optional int16s dcPower = 262;
  readonly attribute optional int16s dcPowerMin = 263;
  readonly attribute optional int16s dcPowerMax = 264;
  readonly attribute optional int16u dcVoltageMultiplier = 512;
  readonly attribute optional int16u dcVoltageDivisor = 513;
  readonly attribute optional int16u dcCurrentMultiplier = 514;
  readonly attribute optional int16u dcCurrentDivisor = 515;
  readonly attribute optional int16u dcPowerMultiplier = 516;
  readonly attribute optional int16u dcPowerDivisor = 517;
  readonly attribute optional int16u acFrequency = 768;
  readonly attribute optional int16u acFrequencyMin = 769;
  readonly attribute optional int16u acFrequencyMax = 770;
  readonly attribute optional int16u neutralCurrent = 771;
  readonly attribute optional int32s totalActivePower = 772;
  readonly attribute optional int32s totalReactivePower = 773;
  readonly attribute optional int32u totalApparentPower = 774;
  readonly attribute optional int16s measured1stHarmonicCurrent = 775;
  readonly attribute optional int16s measured3rdHarmonicCurrent = 776;
  readonly attribute optional int16s measured5thHarmonicCurrent = 777;
  readonly attribute optional int16s measured7thHarmonicCurrent = 778;
  readonly attribute optional int16s measured9thHarmonicCurrent = 779;
  readonly attribute optional int16s measured11thHarmonicCurrent = 780;
  readonly attribute optional int16s measuredPhase1stHarmonicCurrent = 781;
  readonly attribute optional int16s measuredPhase3rdHarmonicCurrent = 782;
  readonly attribute optional int16s measuredPhase5thHarmonicCurrent = 783;
  readonly attribute optional int16s measuredPhase7thHarmonicCurrent = 784;
  readonly attribute optional int16s measuredPhase9thHarmonicCurrent = 785;
  readonly attribute optional int16s measuredPhase11thHarmonicCurrent = 786;
  readonly attribute optional int16u acFrequencyMultiplier = 1024;
  readonly attribute optional int16u acFrequencyDivisor = 1025;
  readonly attribute optional int32u powerMultiplier = 1026;
  readonly attribute optional int32u powerDivisor = 1027;
  readonly attribute optional int8s harmonicCurrentMultiplier = 1028;
  readonly attribute optional int8s phaseHarmonicCurrentMultiplier = 1029;
  readonly attribute optional int16s instantaneousVoltage = 1280;
  readonly attribute optional int16u instantaneousLineCurrent = 1281;
  readonly attribute optional int16s instantaneousActiveCurrent = 1282;
  readonly attribute optional int16s instantaneousReactiveCurrent = 1283;
  readonly attribute optional int16s instantaneousPower = 1284;
  readonly attribute optional int16u rmsVoltage = 1285;
  readonly attribute optional int16u rmsVoltageMin = 1286;
  readonly attribute optional int16u rmsVoltageMax = 1287;
  readonly attribute optional int16u rmsCurrent = 1288;
  readonly attribute optional int16u rmsCurrentMin = 1289;
  readonly attribute optional int16u rmsCurrentMax = 1290;
  readonly attribute optional int16s activePower = 1291;
  readonly attribute optional int16s activePowerMin = 1292;
  readonly attribute optional int16s activePowerMax = 1293;
  readonly attribute optional int16s reactivePower = 1294;
  readonly attribute optional int16u apparentPower = 1295;
  readonly attribute optional int8s powerFactor = 1296;
  attribute optional int16u averageRmsVoltageMeasurementPeriod = 1297;
  attribute optional int16u averageRmsUnderVoltageCounter = 1299;
  attribute optional int16u rmsExtremeOverVoltagePeriod = 1300;
  attribute optional int16u rmsExtremeUnderVoltagePeriod = 1301;
  attribute optional int16u rmsVoltageSagPeriod = 1302;
  attribute optional int16u rmsVoltageSwellPeriod = 1303;
  readonly attribute optional int16u acVoltageMultiplier = 1536;
  readonly attribute optional int16u acVoltageDivisor = 1537;
  readonly attribute optional int16u acCurrentMultiplier = 1538;
  readonly attribute optional int16u acCurrentDivisor = 1539;
  readonly attribute optional int16u acPowerMultiplier = 1540;
  readonly attribute optional int16u acPowerDivisor = 1541;
  attribute optional bitmap8 overloadAlarmsMask = 1792;
  readonly attribute optional int16s voltageOverload = 1793;
  readonly attribute optional int16s currentOverload = 1794;
  attribute optional bitmap16 acOverloadAlarmsMask = 2048;
  readonly attribute optional int16s acVoltageOverload = 2049;
  readonly attribute optional int16s acCurrentOverload = 2050;
  readonly attribute optional int16s acActivePowerOverload = 2051;
  readonly attribute optional int16s acReactivePowerOverload = 2052;
  readonly attribute optional int16s averageRmsOverVoltage = 2053;
  readonly attribute optional int16s averageRmsUnderVoltage = 2054;
  readonly attribute optional int16s rmsExtremeOverVoltage = 2055;
  readonly attribute optional int16s rmsExtremeUnderVoltage = 2056;
  readonly attribute optional int16s rmsVoltageSag = 2057;
  readonly attribute optional int16s rmsVoltageSwell = 2058;
  readonly attribute optional int16u lineCurrentPhaseB = 2305;
  readonly attribute optional int16s activeCurrentPhaseB = 2306;
  readonly attribute optional int16s reactiveCurrentPhaseB = 2307;
  readonly attribute optional int16u rmsVoltagePhaseB = 2309;
  readonly attribute optional int16u rmsVoltageMinPhaseB = 2310;
  readonly attribute optional int16u rmsVoltageMaxPhaseB = 2311;
  readonly attribute optional int16u rmsCurrentPhaseB = 2312;
  readonly attribute optional int16u rmsCurrentMinPhaseB = 2313;
  readonly attribute optional int16u rmsCurrentMaxPhaseB = 2314;
  readonly attribute optional int16s activePowerPhaseB = 2315;
  readonly attribute optional int16s activePowerMinPhaseB = 2316;
  readonly attribute optional int16s activePowerMaxPhaseB = 2317;
  readonly attribute optional int16s reactivePowerPhaseB = 2318;
  readonly attribute optional int16u apparentPowerPhaseB = 2319;
  readonly attribute optional int8s powerFactorPhaseB = 2320;
  readonly attribute optional int16u averageRmsVoltageMeasurementPeriodPhaseB = 2321;
  readonly attribute optional int16u averageRmsOverVoltageCounterPhaseB = 2322;
  readonly attribute optional int16u averageRmsUnderVoltageCounterPhaseB = 2323;
  readonly attribute optional int16u rmsExtremeOverVoltagePeriodPhaseB = 2324;
  readonly attribute optional int16u rmsExtremeUnderVoltagePeriodPhaseB = 2325;
  readonly attribute optional int16u rmsVoltageSagPeriodPhaseB = 2326;
  readonly attribute optional int16u rmsVoltageSwellPeriodPhaseB = 2327;
  readonly attribute optional int16u lineCurrentPhaseC = 2561;
  readonly attribute optional int16s activeCurrentPhaseC = 2562;
  readonly attribute optional int16s reactiveCurrentPhaseC = 2563;
  readonly attribute optional int16u rmsVoltagePhaseC = 2565;
  readonly attribute optional int16u rmsVoltageMinPhaseC = 2566;
  readonly attribute optional int16u rmsVoltageMaxPhaseC = 2567;
  readonly attribute optional int16u rmsCurrentPhaseC = 2568;
  readonly attribute optional int16u rmsCurrentMinPhaseC = 2569;
  readonly attribute optional int16u rmsCurrentMaxPhaseC = 2570;
  readonly attribute optional int16s activePowerPhaseC = 2571;
  readonly attribute optional int16s activePowerMinPhaseC = 2572;
  readonly attribute optional int16s activePowerMaxPhaseC = 2573;
  readonly attribute optional int16s reactivePowerPhaseC = 2574;
  readonly attribute optional int16u apparentPowerPhaseC = 2575;
  readonly attribute optional int8s powerFactorPhaseC = 2576;
  readonly attribute optional int16u averageRmsVoltageMeasurementPeriodPhaseC = 2577;
  readonly attribute optional int16u averageRmsOverVoltageCounterPhaseC = 2578;
  readonly attribute optional int16u averageRmsUnderVoltageCounterPhaseC = 2579;
  readonly attribute optional int16u rmsExtremeOverVoltagePeriodPhaseC = 2580;
  readonly attribute optional int16u rmsExtremeUnderVoltagePeriodPhaseC = 2581;
  readonly attribute optional int16u rmsVoltageSagPeriodPhaseC = 2582;
  readonly attribute optional int16u rmsVoltageSwellPeriodPhaseC = 2583;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct GetProfileInfoResponseCommand = 0 {
    INT8U profileCount = 0;
    ENUM8 profileIntervalPeriod = 1;
    INT8U maxNumberOfIntervals = 2;
    INT16U listOfAttributes[] = 3;
  }

  response struct GetMeasurementProfileResponseCommand = 1 {
    INT32U startTime = 0;
    ENUM8 status = 1;
    ENUM8 profileIntervalPeriod = 2;
    INT8U numberOfIntervalsDelivered = 3;
    INT16U attributeId = 4;
    INT8U intervals[] = 5;
  }

  request struct GetMeasurementProfileCommandRequest {
    INT16U attributeId = 0;
    INT32U startTime = 1;
    ENUM8 numberOfIntervals = 2;
  }

  /** A function which retrieves the power profiling information from the electrical measurement server. */
  command GetProfileInfoCommand(): DefaultSuccess = 0;
  /** A function which retrieves an electricity measurement profile from the electricity measurement server for a specific attribute Id requested. */
  command GetMeasurementProfileCommand(GetMeasurementProfileCommandRequest): DefaultSuccess = 1;
}

/** The Test Cluster is meant to validate the generated code */
client cluster UnitTesting = 4294048773 {
  enum SimpleEnum : ENUM8 {
    kUnspecified = 0;
    kValueA = 1;
    kValueB = 2;
    kValueC = 3;
  }

  bitmap Bitmap16MaskMap : BITMAP16 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x4000;
  }

  bitmap Bitmap32MaskMap : BITMAP32 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x40000000;
  }

  bitmap Bitmap64MaskMap : BITMAP64 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x4000000000000000;
  }

  bitmap Bitmap8MaskMap : BITMAP8 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x40;
  }

  bitmap SimpleBitmap : BITMAP8 {
    kValueA = 0x1;
    kValueB = 0x2;
    kValueC = 0x4;
  }

  struct SimpleStruct {
    int8u a = 0;
    boolean b = 1;
    SimpleEnum c = 2;
    octet_string d = 3;
    char_string e = 4;
    SimpleBitmap f = 5;
    single g = 6;
    double h = 7;
  }

  fabric_scoped struct TestFabricScoped {
    fabric_sensitive int8u fabricSensitiveInt8u = 1;
    optional fabric_sensitive int8u optionalFabricSensitiveInt8u = 2;
    nullable fabric_sensitive int8u nullableFabricSensitiveInt8u = 3;
    optional nullable fabric_sensitive int8u nullableOptionalFabricSensitiveInt8u = 4;
    fabric_sensitive char_string fabricSensitiveCharString = 5;
    fabric_sensitive SimpleStruct fabricSensitiveStruct = 6;
    fabric_sensitive int8u fabricSensitiveInt8uList[] = 7;
    fabric_idx fabricIndex = 254;
  }

  struct NullablesAndOptionalsStruct {
    nullable int16u nullableInt = 0;
    optional int16u optionalInt = 1;
    optional nullable int16u nullableOptionalInt = 2;
    nullable char_string nullableString = 3;
    optional char_string optionalString = 4;
    optional nullable char_string nullableOptionalString = 5;
    nullable SimpleStruct nullableStruct = 6;
    optional SimpleStruct optionalStruct = 7;
    optional nullable SimpleStruct nullableOptionalStruct = 8;
    nullable SimpleEnum nullableList[] = 9;
    optional SimpleEnum optionalList[] = 10;
    optional nullable SimpleEnum nullableOptionalList[] = 11;
  }

  struct NestedStruct {
    int8u a = 0;
    boolean b = 1;
    SimpleStruct c = 2;
  }

  struct NestedStructList {
    int8u a = 0;
    boolean b = 1;
    SimpleStruct c = 2;
    SimpleStruct d[] = 3;
    int32u e[] = 4;
    octet_string f[] = 5;
    int8u g[] = 6;
  }

  struct DoubleNestedStructList {
    NestedStructList a[] = 0;
  }

  struct TestListStructOctet {
    int64u member1 = 0;
    octet_string<32> member2 = 1;
  }

  info event TestEvent = 1 {
    INT8U arg1 = 1;
    SimpleEnum arg2 = 2;
    BOOLEAN arg3 = 3;
    SimpleStruct arg4 = 4;
    SimpleStruct arg5[] = 5;
    SimpleEnum arg6[] = 6;
  }

  fabric_sensitive info event TestFabricScopedEvent = 2 {
    fabric_idx fabricIndex = 254;
  }

  attribute boolean boolean = 0;
  attribute Bitmap8MaskMap bitmap8 = 1;
  attribute Bitmap16MaskMap bitmap16 = 2;
  attribute Bitmap32MaskMap bitmap32 = 3;
  attribute Bitmap64MaskMap bitmap64 = 4;
  attribute int8u int8u = 5;
  attribute int16u int16u = 6;
  attribute int24u int24u = 7;
  attribute int32u int32u = 8;
  attribute int40u int40u = 9;
  attribute int48u int48u = 10;
  attribute int56u int56u = 11;
  attribute int64u int64u = 12;
  attribute int8s int8s = 13;
  attribute int16s int16s = 14;
  attribute int24s int24s = 15;
  attribute int32s int32s = 16;
  attribute int40s int40s = 17;
  attribute int48s int48s = 18;
  attribute int56s int56s = 19;
  attribute int64s int64s = 20;
  attribute enum8 enum8 = 21;
  attribute enum16 enum16 = 22;
  attribute single floatSingle = 23;
  attribute double floatDouble = 24;
  attribute octet_string<10> octetString = 25;
  attribute INT8U listInt8u[] = 26;
  attribute OCTET_STRING listOctetString[] = 27;
  attribute TestListStructOctet listStructOctetString[] = 28;
  attribute long_octet_string<1000> longOctetString = 29;
  attribute char_string<10> charString = 30;
  attribute long_char_string<1000> longCharString = 31;
  attribute epoch_us epochUs = 32;
  attribute epoch_s epochS = 33;
  attribute vendor_id vendorId = 34;
  attribute NullablesAndOptionalsStruct listNullablesAndOptionalsStruct[] = 35;
  attribute SimpleEnum enumAttr = 36;
  attribute SimpleStruct structAttr = 37;
  attribute int8u rangeRestrictedInt8u = 38;
  attribute int8s rangeRestrictedInt8s = 39;
  attribute int16u rangeRestrictedInt16u = 40;
  attribute int16s rangeRestrictedInt16s = 41;
  attribute LONG_OCTET_STRING listLongOctetString[] = 42;
  attribute TestFabricScoped listFabricScoped[] = 43;
  timedwrite attribute boolean timedWriteBoolean = 48;
  attribute boolean generalErrorBoolean = 49;
  attribute boolean clusterErrorBoolean = 50;
  attribute optional boolean unsupported = 255;
  attribute nullable boolean nullableBoolean = 16384;
  attribute nullable Bitmap8MaskMap nullableBitmap8 = 16385;
  attribute nullable Bitmap16MaskMap nullableBitmap16 = 16386;
  attribute nullable Bitmap32MaskMap nullableBitmap32 = 16387;
  attribute nullable Bitmap64MaskMap nullableBitmap64 = 16388;
  attribute nullable int8u nullableInt8u = 16389;
  attribute nullable int16u nullableInt16u = 16390;
  attribute nullable int24u nullableInt24u = 16391;
  attribute nullable int32u nullableInt32u = 16392;
  attribute nullable int40u nullableInt40u = 16393;
  attribute nullable int48u nullableInt48u = 16394;
  attribute nullable int56u nullableInt56u = 16395;
  attribute nullable int64u nullableInt64u = 16396;
  attribute nullable int8s nullableInt8s = 16397;
  attribute nullable int16s nullableInt16s = 16398;
  attribute nullable int24s nullableInt24s = 16399;
  attribute nullable int32s nullableInt32s = 16400;
  attribute nullable int40s nullableInt40s = 16401;
  attribute nullable int48s nullableInt48s = 16402;
  attribute nullable int56s nullableInt56s = 16403;
  attribute nullable int64s nullableInt64s = 16404;
  attribute nullable enum8 nullableEnum8 = 16405;
  attribute nullable enum16 nullableEnum16 = 16406;
  attribute nullable single nullableFloatSingle = 16407;
  attribute nullable double nullableFloatDouble = 16408;
  attribute nullable octet_string<10> nullableOctetString = 16409;
  attribute nullable char_string<10> nullableCharString = 16414;
  attribute nullable SimpleEnum nullableEnumAttr = 16420;
  attribute nullable SimpleStruct nullableStruct = 16421;
  attribute nullable int8u nullableRangeRestrictedInt8u = 16422;
  attribute nullable int8s nullableRangeRestrictedInt8s = 16423;
  attribute nullable int16u nullableRangeRestrictedInt16u = 16424;
  attribute nullable int16s nullableRangeRestrictedInt16s = 16425;
  attribute optional int8u writeOnlyInt8u = 16426;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct TestSpecificResponse = 0 {
    INT8U returnValue = 0;
  }

  response struct TestAddArgumentsResponse = 1 {
    INT8U returnValue = 0;
  }

  response struct TestSimpleArgumentResponse = 2 {
    BOOLEAN returnValue = 0;
  }

  response struct TestStructArrayArgumentResponse = 3 {
    NestedStructList arg1[] = 0;
    SimpleStruct arg2[] = 1;
    SimpleEnum arg3[] = 2;
    BOOLEAN arg4[] = 3;
    SimpleEnum arg5 = 4;
    BOOLEAN arg6 = 5;
  }

  request struct TestAddArgumentsRequest {
    INT8U arg1 = 0;
    INT8U arg2 = 1;
  }

  response struct TestListInt8UReverseResponse = 4 {
    INT8U arg1[] = 0;
  }

  request struct TestSimpleArgumentRequestRequest {
    BOOLEAN arg1 = 0;
  }

  response struct TestEnumsResponse = 5 {
    vendor_id arg1 = 0;
    SimpleEnum arg2 = 1;
  }

  request struct TestStructArrayArgumentRequestRequest {
    NestedStructList arg1[] = 0;
    SimpleStruct arg2[] = 1;
    SimpleEnum arg3[] = 2;
    BOOLEAN arg4[] = 3;
    SimpleEnum arg5 = 4;
    BOOLEAN arg6 = 5;
  }

  response struct TestNullableOptionalResponse = 6 {
    BOOLEAN wasPresent = 0;
    optional BOOLEAN wasNull = 1;
    optional INT8U value = 2;
    optional nullable INT8U originalValue = 3;
  }

  request struct TestStructArgumentRequestRequest {
    SimpleStruct arg1 = 0;
  }

  response struct TestComplexNullableOptionalResponse = 7 {
    BOOLEAN nullableIntWasNull = 0;
    optional INT16U nullableIntValue = 1;
    BOOLEAN optionalIntWasPresent = 2;
    optional INT16U optionalIntValue = 3;
    BOOLEAN nullableOptionalIntWasPresent = 4;
    optional BOOLEAN nullableOptionalIntWasNull = 5;
    optional INT16U nullableOptionalIntValue = 6;
    BOOLEAN nullableStringWasNull = 7;
    optional CHAR_STRING nullableStringValue = 8;
    BOOLEAN optionalStringWasPresent = 9;
    optional CHAR_STRING optionalStringValue = 10;
    BOOLEAN nullableOptionalStringWasPresent = 11;
    optional BOOLEAN nullableOptionalStringWasNull = 12;
    optional CHAR_STRING nullableOptionalStringValue = 13;
    BOOLEAN nullableStructWasNull = 14;
    optional SimpleStruct nullableStructValue = 15;
    BOOLEAN optionalStructWasPresent = 16;
    optional SimpleStruct optionalStructValue = 17;
    BOOLEAN nullableOptionalStructWasPresent = 18;
    optional BOOLEAN nullableOptionalStructWasNull = 19;
    optional SimpleStruct nullableOptionalStructValue = 20;
    BOOLEAN nullableListWasNull = 21;
    optional SimpleEnum nullableListValue[] = 22;
    BOOLEAN optionalListWasPresent = 23;
    optional SimpleEnum optionalListValue[] = 24;
    BOOLEAN nullableOptionalListWasPresent = 25;
    optional BOOLEAN nullableOptionalListWasNull = 26;
    optional SimpleEnum nullableOptionalListValue[] = 27;
  }

  request struct TestNestedStructArgumentRequestRequest {
    NestedStruct arg1 = 0;
  }

  response struct BooleanResponse = 8 {
    BOOLEAN value = 0;
  }

  request struct TestListStructArgumentRequestRequest {
    SimpleStruct arg1[] = 0;
  }

  response struct SimpleStructResponse = 9 {
    SimpleStruct arg1 = 0;
  }

  request struct TestListInt8UArgumentRequestRequest {
    INT8U arg1[] = 0;
  }

  response struct TestEmitTestEventResponse = 10 {
    INT64U value = 0;
  }

  request struct TestNestedStructListArgumentRequestRequest {
    NestedStructList arg1 = 0;
  }

  response struct TestEmitTestFabricScopedEventResponse = 11 {
    INT64U value = 0;
  }

  request struct TestListNestedStructListArgumentRequestRequest {
    NestedStructList arg1[] = 0;
  }

  request struct TestListInt8UReverseRequestRequest {
    INT8U arg1[] = 0;
  }

  request struct TestEnumsRequestRequest {
    vendor_id arg1 = 0;
    SimpleEnum arg2 = 1;
  }

  request struct TestNullableOptionalRequestRequest {
    optional nullable INT8U arg1 = 0;
  }

  request struct TestComplexNullableOptionalRequestRequest {
    nullable INT16U nullableInt = 0;
    optional INT16U optionalInt = 1;
    optional nullable INT16U nullableOptionalInt = 2;
    nullable CHAR_STRING nullableString = 3;
    optional CHAR_STRING optionalString = 4;
    optional nullable CHAR_STRING nullableOptionalString = 5;
    nullable SimpleStruct nullableStruct = 6;
    optional SimpleStruct optionalStruct = 7;
    optional nullable SimpleStruct nullableOptionalStruct = 8;
    nullable SimpleEnum nullableList[] = 9;
    optional SimpleEnum optionalList[] = 10;
    optional nullable SimpleEnum nullableOptionalList[] = 11;
  }

  request struct SimpleStructEchoRequestRequest {
    SimpleStruct arg1 = 0;
  }

  request struct TestSimpleOptionalArgumentRequestRequest {
    optional BOOLEAN arg1 = 0;
  }

  request struct TestEmitTestEventRequestRequest {
    INT8U arg1 = 0;
    SimpleEnum arg2 = 1;
    BOOLEAN arg3 = 2;
  }

  request struct TestEmitTestFabricScopedEventRequestRequest {
    INT8U arg1 = 0;
  }

  /** Simple command without any parameters and without a specific response */
  command Test(): DefaultSuccess = 0;
  /** Simple command without any parameters and without a specific response not handled by the server */
  command TestNotHandled(): DefaultSuccess = 1;
  /** Simple command without any parameters and with a specific response */
  command TestSpecific(): TestSpecificResponse = 2;
  /** Simple command that should not be added to the server. */
  command TestUnknownCommand(): DefaultSuccess = 3;
  /** Command that takes two arguments and returns their sum. */
  command TestAddArguments(TestAddArgumentsRequest): TestAddArgumentsResponse = 4;
  /** Command that takes an argument which is bool */
  command TestSimpleArgumentRequest(TestSimpleArgumentRequestRequest): TestSimpleArgumentResponse = 5;
  /** Command that takes various arguments that are arrays, including an array of structs which have a list member. */
  command TestStructArrayArgumentRequest(TestStructArrayArgumentRequestRequest): TestStructArrayArgumentResponse = 6;
  /** Command that takes an argument which is struct.  The response echoes the
        'b' field of the single arg. */
  command TestStructArgumentRequest(TestStructArgumentRequestRequest): BooleanResponse = 7;
  /** Command that takes an argument which is nested struct.  The response
        echoes the 'b' field of ar1.c. */
  command TestNestedStructArgumentRequest(TestNestedStructArgumentRequestRequest): BooleanResponse = 8;
  /** Command that takes an argument which is a list of structs.  The response
        returns false if there is some struct in the list whose 'b' field is
        false, and true otherwise (including if the list is empty). */
  command TestListStructArgumentRequest(TestListStructArgumentRequestRequest): BooleanResponse = 9;
  /** Command that takes an argument which is a list of INT8U.  The response
        returns false if the list contains a 0 in it, true otherwise (including
        if the list is empty). */
  command TestListInt8UArgumentRequest(TestListInt8UArgumentRequestRequest): BooleanResponse = 10;
  /** Command that takes an argument which is a Nested Struct List.  The
        response returns false if there is some struct in arg1 (either directly
        in arg1.c or in the arg1.d list) whose 'b' field is false, and true
        otherwise. */
  command TestNestedStructListArgumentRequest(TestNestedStructListArgumentRequestRequest): BooleanResponse = 11;
  /** Command that takes an argument which is a list of Nested Struct List.
        The response returns false if there is some struct in arg1 (either
        directly in as the 'c' field of an entry 'd' list of an entry) whose 'b'
        field is false, and true otherwise (including if the list is empty). */
  command TestListNestedStructListArgumentRequest(TestListNestedStructListArgumentRequestRequest): BooleanResponse = 12;
  /** Command that takes an argument which is a list of INT8U and expects a
        response that reverses the list. */
  command TestListInt8UReverseRequest(TestListInt8UReverseRequestRequest): TestListInt8UReverseResponse = 13;
  /** Command that sends a vendor id and an enum.  The server is expected to
        echo them back. */
  command TestEnumsRequest(TestEnumsRequestRequest): TestEnumsResponse = 14;
  /** Command that takes an argument which is nullable and optional.  The
        response returns a boolean indicating whether the argument was present,
        if that's true a boolean indicating whether the argument was null, and
        if that' false the argument it received. */
  command TestNullableOptionalRequest(TestNullableOptionalRequestRequest): TestNullableOptionalResponse = 15;
  /** Command that takes various arguments which can be nullable and/or optional.  The
        response returns information about which things were received and what
        their state was. */
  command TestComplexNullableOptionalRequest(TestComplexNullableOptionalRequestRequest): TestComplexNullableOptionalResponse = 16;
  /** Command that takes an argument which is a struct.  The response echoes
        the struct back. */
  command SimpleStructEchoRequest(SimpleStructEchoRequestRequest): SimpleStructResponse = 17;
  /** Command that just responds with a success status if the timed invoke
        conditions are met. */
  timed command TimedInvokeRequest(): DefaultSuccess = 18;
  /** Command that takes an optional argument which is bool. It responds with a success value if the optional is set to any value. */
  command TestSimpleOptionalArgumentRequest(TestSimpleOptionalArgumentRequestRequest): DefaultSuccess = 19;
  /** Command that takes identical arguments to the fields of the TestEvent and logs the TestEvent to the buffer.  Command returns an event ID as the response. */
  command TestEmitTestEventRequest(TestEmitTestEventRequestRequest): TestEmitTestEventResponse = 20;
  /** Command that takes identical arguments to the fields of the TestFabricScopedEvent and logs the TestFabricScopedEvent to the buffer.  Command returns an event ID as the response. */
  command TestEmitTestFabricScopedEventRequest(TestEmitTestFabricScopedEventRequestRequest): TestEmitTestFabricScopedEventResponse = 21;
}

/** The Fault Injection Cluster provide a means for a test harness to configure faults(for example triggering a fault in the system). */
client cluster FaultInjection = 4294048774 {
  enum FaultType : ENUM8 {
    kUnspecified = 0;
    kSystemFault = 1;
    kInetFault = 2;
    kChipFault = 3;
    kCertFault = 4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct FailAtFaultRequest {
    FaultType type = 0;
    INT32U id = 1;
    INT32U numCallsToSkip = 2;
    INT32U numCallsToFail = 3;
    BOOLEAN takeMutex = 4;
  }

  request struct FailRandomlyAtFaultRequest {
    FaultType type = 0;
    INT32U id = 1;
    INT8U percentage = 2;
  }

  /** Configure a fault to be triggered deterministically */
  command access(invoke: manage) FailAtFault(FailAtFaultRequest): DefaultSuccess = 0;
  /** Configure a fault to be triggered randomly, with a given probability defined as a percentage */
  command access(invoke: manage) FailRandomlyAtFault(FailRandomlyAtFaultRequest): DefaultSuccess = 1;
}

