// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
cluster Identify = 3 {
  revision 4;

  enum EffectIdentifierEnum : enum8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum EffectVariantEnum : enum8 {
    kDefault = 0;
  }

  enum IdentifyTypeEnum : enum8 {
    kNone = 0;
    kLightOutput = 1;
    kVisibleIndicator = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute IdentifyTypeEnum identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    int16u identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    EffectVariantEnum effectVariant = 1;
  }

  /** Command description for Identify */
  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  /** Command description for TriggerEffect */
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** Attributes and commands for group configuration and manipulation. */
cluster Groups = 4 {
  revision 4;

  bitmap Feature : bitmap32 {
    kGroupNames = 0x1;
  }

  bitmap NameSupportBitmap : bitmap8 {
    kGroupNames = 0x80;
  }

  readonly attribute NameSupportBitmap nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  response struct ViewGroupResponse = 1 {
    enum8 status = 0;
    group_id groupID = 1;
    char_string<16> groupName = 2;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable int8u capacity = 0;
    group_id groupList[] = 1;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  response struct RemoveGroupResponse = 3 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  /** Command description for AddGroup */
  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  /** Command description for ViewGroup */
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  /** Command description for GetGroupMembership */
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  /** Command description for RemoveGroup */
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  /** Command description for RemoveAllGroups */
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  /** Command description for AddGroupIfIdentifying */
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

/** Attributes and commands for switching devices between 'On' and 'Off' states. */
cluster OnOff = 6 {
  revision 6;

  enum DelayedAllOffEffectVariantEnum : enum8 {
    kDelayedOffFastFade = 0;
    kNoFade = 1;
    kDelayedOffSlowFade = 2;
  }

  enum DyingLightEffectVariantEnum : enum8 {
    kDyingLightFadeOff = 0;
  }

  enum EffectIdentifierEnum : enum8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum StartUpOnOffEnum : enum8 {
    kOff = 0;
    kOn = 1;
    kToggle = 2;
  }

  bitmap Feature : bitmap32 {
    kLighting = 0x1;
    kDeadFrontBehavior = 0x2;
    kOffOnly = 0x4;
  }

  bitmap OnOffControlBitmap : bitmap8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute optional boolean globalSceneControl = 16384;
  attribute optional int16u onTime = 16385;
  attribute optional int16u offWaitTime = 16386;
  attribute access(write: manage) optional nullable StartUpOnOffEnum startUpOnOff = 16387;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OffWithEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    enum8 effectVariant = 1;
  }

  request struct OnWithTimedOffRequest {
    OnOffControlBitmap onOffControl = 0;
    int16u onTime = 1;
    int16u offWaitTime = 2;
  }

  /** On receipt of this command, a device SHALL enter its ‘Off’ state. This state is device dependent, but it is recommended that it is used for power off or similar functions. On receipt of the Off command, the OnTime attribute SHALL be set to 0. */
  command Off(): DefaultSuccess = 0;
  /** On receipt of this command, a device SHALL enter its ‘On’ state. This state is device dependent, but it is recommended that it is used for power on or similar functions. On receipt of the On command, if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. */
  command On(): DefaultSuccess = 1;
  /** On receipt of this command, if a device is in its ‘Off’ state it SHALL enter its ‘On’ state. Otherwise, if it is in its ‘On’ state it SHALL enter its ‘Off’ state. On receipt of the Toggle command, if the value of the OnOff attribute is equal to FALSE and if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. If the value of the OnOff attribute is equal to TRUE, the OnTime attribute SHALL be set to 0. */
  command Toggle(): DefaultSuccess = 2;
  /** The OffWithEffect command allows devices to be turned off using enhanced ways of fading. */
  command OffWithEffect(OffWithEffectRequest): DefaultSuccess = 64;
  /** The OnWithRecallGlobalScene command allows the recall of the settings when the device was turned off. */
  command OnWithRecallGlobalScene(): DefaultSuccess = 65;
  /** The OnWithTimedOff command allows devices to be turned on for a specific duration with a guarded off duration so that SHOULD the device be subsequently switched off, further OnWithTimedOff commands, received during this time, are prevented from turning the devices back on. */
  command OnWithTimedOff(OnWithTimedOffRequest): DefaultSuccess = 66;
}

/** Attributes and commands for configuring On/Off switching devices. */
deprecated cluster OnOffSwitchConfiguration = 7 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute enum8 switchType = 0;
  attribute enum8 switchActions = 16;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
cluster LevelControl = 8 {
  revision 5;

  enum MoveModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute optional int16u remainingTime = 1;
  readonly attribute optional int8u minLevel = 2;
  readonly attribute optional int8u maxLevel = 3;
  readonly attribute optional int16u currentFrequency = 4;
  readonly attribute optional int16u minFrequency = 5;
  readonly attribute optional int16u maxFrequency = 6;
  attribute OptionsBitmap options = 15;
  attribute optional int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute optional nullable int16u onTransitionTime = 18;
  attribute optional nullable int16u offTransitionTime = 19;
  attribute optional nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) optional nullable int8u startUpCurrentLevel = 16384;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToClosestFrequencyRequest {
    int16u frequency = 0;
  }

  /** Command description for MoveToLevel */
  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  /** Command description for Move */
  command Move(MoveRequest): DefaultSuccess = 1;
  /** Command description for Step */
  command Step(StepRequest): DefaultSuccess = 2;
  /** Command description for Stop */
  command Stop(StopRequest): DefaultSuccess = 3;
  /** Command description for MoveToLevelWithOnOff */
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  /** Command description for MoveWithOnOff */
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  /** Command description for StepWithOnOff */
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  /** Command description for StopWithOnOff */
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
  /** Change the currrent frequency to the provided one, or a close
        approximation if the exact provided one is not possible. */
  command MoveToClosestFrequency(MoveToClosestFrequencyRequest): DefaultSuccess = 8;
}

/** An interface for reading the value of a binary measurement and accessing various characteristics of that measurement. */
deprecated cluster BinaryInputBasic = 15 {
  revision 1; // NOTE: Default/not specifically set

  attribute optional char_string<16> activeText = 4;
  attribute optional char_string<16> description = 28;
  attribute optional char_string<16> inactiveText = 46;
  attribute boolean outOfService = 81;
  readonly attribute optional enum8 polarity = 84;
  attribute boolean presentValue = 85;
  attribute optional enum8 reliability = 103;
  readonly attribute bitmap8 statusFlags = 111;
  readonly attribute optional int32u applicationType = 256;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Cluster to control pulse width modulation */
deprecated cluster PulseWidthModulation = 28 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
cluster Descriptor = 29 {
  revision 2;

  bitmap Feature : bitmap32 {
    kTagList = 0x1;
  }

  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  struct SemanticTagStruct {
    nullable vendor_id mfgCode = 0;
    enum8 namespaceID = 1;
    enum8 tag = 2;
    optional nullable char_string label = 3;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute cluster_id serverList[] = 1;
  readonly attribute cluster_id clientList[] = 2;
  readonly attribute endpoint_no partsList[] = 3;
  readonly attribute optional SemanticTagStruct tagList[] = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Binding Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table. */
cluster Binding = 30 {
  revision 1; // NOTE: Default/not specifically set

  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(write: manage) TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
cluster AccessControl = 31 {
  revision 1; // NOTE: Default/not specifically set

  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1;
    kCASE = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides a standardized way for a Node (typically a Bridge, but could be any Node) to expose action information. */
cluster Actions = 37 {
  revision 1; // NOTE: Default/not specifically set

  enum ActionErrorEnum : enum8 {
    kUnknown = 0;
    kInterrupted = 1;
  }

  enum ActionStateEnum : enum8 {
    kInactive = 0;
    kActive = 1;
    kPaused = 2;
    kDisabled = 3;
  }

  enum ActionTypeEnum : enum8 {
    kOther = 0;
    kScene = 1;
    kSequence = 2;
    kAutomation = 3;
    kException = 4;
    kNotification = 5;
    kAlarm = 6;
  }

  enum EndpointListTypeEnum : enum8 {
    kOther = 0;
    kRoom = 1;
    kZone = 2;
  }

  bitmap CommandBits : bitmap16 {
    kInstantAction = 0x1;
    kInstantActionWithTransition = 0x2;
    kStartAction = 0x4;
    kStartActionWithDuration = 0x8;
    kStopAction = 0x10;
    kPauseAction = 0x20;
    kPauseActionWithDuration = 0x40;
    kResumeAction = 0x80;
    kEnableAction = 0x100;
    kEnableActionWithDuration = 0x200;
    kDisableAction = 0x400;
    kDisableActionWithDuration = 0x800;
  }

  struct ActionStruct {
    int16u actionID = 0;
    char_string<32> name = 1;
    ActionTypeEnum type = 2;
    int16u endpointListID = 3;
    CommandBits supportedCommands = 4;
    ActionStateEnum state = 5;
  }

  struct EndpointListStruct {
    int16u endpointListID = 0;
    char_string<32> name = 1;
    EndpointListTypeEnum type = 2;
    endpoint_no endpoints[] = 3;
  }

  info event StateChanged = 0 {
    int16u actionID = 0;
    int32u invokeID = 1;
    ActionStateEnum newState = 2;
  }

  info event ActionFailed = 1 {
    int16u actionID = 0;
    int32u invokeID = 1;
    ActionStateEnum newState = 2;
    ActionErrorEnum error = 3;
  }

  readonly attribute ActionStruct actionList[] = 0;
  readonly attribute EndpointListStruct endpointLists[] = 1;
  readonly attribute optional long_char_string<512> setupURL = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct InstantActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct InstantActionWithTransitionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int16u transitionTime = 2;
  }

  request struct StartActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct StartActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct StopActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct PauseActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct PauseActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct ResumeActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct EnableActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct EnableActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct DisableActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct DisableActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  /** This command triggers an action (state change) on the involved endpoints. */
  command InstantAction(InstantActionRequest): DefaultSuccess = 0;
  /** This command triggers an action (state change) on the involved endpoints, with a specified time to transition from the current state to the new state. */
  command InstantActionWithTransition(InstantActionWithTransitionRequest): DefaultSuccess = 1;
  /** This command triggers the commencement of an action on the involved endpoints. */
  command StartAction(StartActionRequest): DefaultSuccess = 2;
  /** This command triggers the commencement of an action (with a duration) on the involved endpoints. */
  command StartActionWithDuration(StartActionWithDurationRequest): DefaultSuccess = 3;
  /** This command stops the ongoing action on the involved endpoints. */
  command StopAction(StopActionRequest): DefaultSuccess = 4;
  /** This command pauses an ongoing action. */
  command PauseAction(PauseActionRequest): DefaultSuccess = 5;
  /** This command pauses an ongoing action with a duration. */
  command PauseActionWithDuration(PauseActionWithDurationRequest): DefaultSuccess = 6;
  /** This command resumes a previously paused action. */
  command ResumeAction(ResumeActionRequest): DefaultSuccess = 7;
  /** This command enables a certain action or automation. */
  command EnableAction(EnableActionRequest): DefaultSuccess = 8;
  /** This command enables a certain action or automation with a duration. */
  command EnableActionWithDuration(EnableActionWithDurationRequest): DefaultSuccess = 9;
  /** This command disables a certain action or automation. */
  command DisableAction(DisableActionRequest): DefaultSuccess = 10;
  /** This command disables a certain action or automation with a duration. */
  command DisableActionWithDuration(DisableActionWithDurationRequest): DefaultSuccess = 11;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
cluster BasicInformation = 40 {
  revision 3;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  attribute access(write: manage) optional boolean localConfigDisabled = 16;
  readonly attribute optional boolean reachable = 17;
  readonly attribute optional char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute int32u specificationVersion = 21;
  readonly attribute int16u maxPathsPerInvoke = 22;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command MfgSpecificPing(): DefaultSuccess = 0;
}

/** Provides an interface for providing OTA software updates */
cluster OtaSoftwareUpdateProvider = 41 {
  revision 1; // NOTE: Default/not specifically set

  enum ApplyUpdateActionEnum : enum8 {
    kProceed = 0;
    kAwaitNextAction = 1;
    kDiscontinue = 2;
  }

  enum DownloadProtocolEnum : enum8 {
    kBDXSynchronous = 0;
    kBDXAsynchronous = 1;
    kHTTPS = 2;
    kVendorSpecific = 3;
  }

  enum StatusEnum : enum8 {
    kUpdateAvailable = 0;
    kBusy = 1;
    kNotAvailable = 2;
    kDownloadProtocolNotSupported = 3;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct QueryImageRequest {
    vendor_id vendorID = 0;
    int16u productID = 1;
    int32u softwareVersion = 2;
    DownloadProtocolEnum protocolsSupported[] = 3;
    optional int16u hardwareVersion = 4;
    optional char_string<2> location = 5;
    optional boolean requestorCanConsent = 6;
    optional octet_string<512> metadataForProvider = 7;
  }

  response struct QueryImageResponse = 1 {
    StatusEnum status = 0;
    optional int32u delayedActionTime = 1;
    optional char_string<256> imageURI = 2;
    optional int32u softwareVersion = 3;
    optional char_string<64> softwareVersionString = 4;
    optional octet_string<32> updateToken = 5;
    optional boolean userConsentNeeded = 6;
    optional octet_string<512> metadataForRequestor = 7;
  }

  request struct ApplyUpdateRequestRequest {
    octet_string<32> updateToken = 0;
    int32u newVersion = 1;
  }

  response struct ApplyUpdateResponse = 3 {
    ApplyUpdateActionEnum action = 0;
    int32u delayedActionTime = 1;
  }

  request struct NotifyUpdateAppliedRequest {
    octet_string<32> updateToken = 0;
    int32u softwareVersion = 1;
  }

  /** Determine availability of a new Software Image */
  command QueryImage(QueryImageRequest): QueryImageResponse = 0;
  /** Determine next action to take for a downloaded Software Image */
  command ApplyUpdateRequest(ApplyUpdateRequestRequest): ApplyUpdateResponse = 2;
  /** Notify OTA Provider that an update was applied */
  command NotifyUpdateApplied(NotifyUpdateAppliedRequest): DefaultSuccess = 4;
}

/** Provides an interface for downloading and applying OTA software updates */
cluster OtaSoftwareUpdateRequestor = 42 {
  revision 1; // NOTE: Default/not specifically set

  enum AnnouncementReasonEnum : enum8 {
    kSimpleAnnouncement = 0;
    kUpdateAvailable = 1;
    kUrgentUpdateAvailable = 2;
  }

  enum ChangeReasonEnum : enum8 {
    kUnknown = 0;
    kSuccess = 1;
    kFailure = 2;
    kTimeOut = 3;
    kDelayByProvider = 4;
  }

  enum UpdateStateEnum : enum8 {
    kUnknown = 0;
    kIdle = 1;
    kQuerying = 2;
    kDelayedOnQuery = 3;
    kDownloading = 4;
    kApplying = 5;
    kDelayedOnApply = 6;
    kRollingBack = 7;
    kDelayedOnUserConsent = 8;
  }

  fabric_scoped struct ProviderLocation {
    node_id providerNodeID = 1;
    endpoint_no endpoint = 2;
    fabric_idx fabricIndex = 254;
  }

  info event StateTransition = 0 {
    UpdateStateEnum previousState = 0;
    UpdateStateEnum newState = 1;
    ChangeReasonEnum reason = 2;
    nullable int32u targetSoftwareVersion = 3;
  }

  critical event VersionApplied = 1 {
    int32u softwareVersion = 0;
    int16u productID = 1;
  }

  info event DownloadError = 2 {
    int32u softwareVersion = 0;
    int64u bytesDownloaded = 1;
    nullable int8u progressPercent = 2;
    nullable int64s platformCode = 3;
  }

  attribute access(write: administer) ProviderLocation defaultOTAProviders[] = 0;
  readonly attribute boolean updatePossible = 1;
  readonly attribute UpdateStateEnum updateState = 2;
  readonly attribute nullable int8u updateStateProgress = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AnnounceOTAProviderRequest {
    node_id providerNodeID = 0;
    vendor_id vendorID = 1;
    AnnouncementReasonEnum announcementReason = 2;
    optional octet_string<512> metadataForNode = 3;
    endpoint_no endpoint = 4;
  }

  /** Announce the presence of an OTA Provider */
  command AnnounceOTAProvider(AnnounceOTAProviderRequest): DefaultSuccess = 0;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
cluster LocalizationConfiguration = 43 {
  revision 1; // NOTE: Default/not specifically set

  attribute access(write: manage) char_string<35> activeLocale = 0;
  readonly attribute char_string supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for how dates and times are conveyed. As such, Nodes that visually
      or audibly convey time information need a mechanism by which they can be configured to use a
      user’s preferred format. */
cluster TimeFormatLocalization = 44 {
  revision 1; // NOTE: Default/not specifically set

  enum CalendarTypeEnum : enum8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
    kUseActiveLocale = 255;
  }

  enum HourFormatEnum : enum8 {
    k12hr = 0;
    k24hr = 1;
    kUseActiveLocale = 255;
  }

  bitmap Feature : bitmap32 {
    kCalendarFormat = 0x1;
  }

  attribute access(write: manage) HourFormatEnum hourFormat = 0;
  attribute access(write: manage) optional CalendarTypeEnum activeCalendarType = 1;
  readonly attribute optional CalendarTypeEnum supportedCalendarTypes[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for the units in which values are conveyed in communication to a
      user. As such, Nodes that visually or audibly convey measurable values to the user need a
      mechanism by which they can be configured to use a user’s preferred unit. */
cluster UnitLocalization = 45 {
  revision 1;

  enum TempUnitEnum : enum8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap Feature : bitmap32 {
    kTemperatureUnit = 0x1;
  }

  attribute access(write: manage) optional TempUnitEnum temperatureUnit = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to describe the configuration and capabilities of a Device's power system. */
cluster PowerSourceConfiguration = 46 {
  revision 1;

  readonly attribute endpoint_no sources[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to describe the configuration and capabilities of a physical power source that provides power to the Node. */
cluster PowerSource = 47 {
  revision 1; // NOTE: Default/not specifically set

  enum BatApprovedChemistryEnum : enum16 {
    kUnspecified = 0;
    kAlkaline = 1;
    kLithiumCarbonFluoride = 2;
    kLithiumChromiumOxide = 3;
    kLithiumCopperOxide = 4;
    kLithiumIronDisulfide = 5;
    kLithiumManganeseDioxide = 6;
    kLithiumThionylChloride = 7;
    kMagnesium = 8;
    kMercuryOxide = 9;
    kNickelOxyhydride = 10;
    kSilverOxide = 11;
    kZincAir = 12;
    kZincCarbon = 13;
    kZincChloride = 14;
    kZincManganeseDioxide = 15;
    kLeadAcid = 16;
    kLithiumCobaltOxide = 17;
    kLithiumIon = 18;
    kLithiumIonPolymer = 19;
    kLithiumIronPhosphate = 20;
    kLithiumSulfur = 21;
    kLithiumTitanate = 22;
    kNickelCadmium = 23;
    kNickelHydrogen = 24;
    kNickelIron = 25;
    kNickelMetalHydride = 26;
    kNickelZinc = 27;
    kSilverZinc = 28;
    kSodiumIon = 29;
    kSodiumSulfur = 30;
    kZincBromide = 31;
    kZincCerium = 32;
  }

  enum BatChargeFaultEnum : enum8 {
    kUnspecified = 0;
    kAmbientTooHot = 1;
    kAmbientTooCold = 2;
    kBatteryTooHot = 3;
    kBatteryTooCold = 4;
    kBatteryAbsent = 5;
    kBatteryOverVoltage = 6;
    kBatteryUnderVoltage = 7;
    kChargerOverVoltage = 8;
    kChargerUnderVoltage = 9;
    kSafetyTimeout = 10;
  }

  enum BatChargeLevelEnum : enum8 {
    kOK = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum BatChargeStateEnum : enum8 {
    kUnknown = 0;
    kIsCharging = 1;
    kIsAtFullCharge = 2;
    kIsNotCharging = 3;
  }

  enum BatCommonDesignationEnum : enum16 {
    kUnspecified = 0;
    kAAA = 1;
    kAA = 2;
    kC = 3;
    kD = 4;
    k4v5 = 5;
    k6v0 = 6;
    k9v0 = 7;
    k12AA = 8;
    kAAAA = 9;
    kA = 10;
    kB = 11;
    kF = 12;
    kN = 13;
    kNo6 = 14;
    kSubC = 15;
    kA23 = 16;
    kA27 = 17;
    kBA5800 = 18;
    kDuplex = 19;
    k4SR44 = 20;
    k523 = 21;
    k531 = 22;
    k15v0 = 23;
    k22v5 = 24;
    k30v0 = 25;
    k45v0 = 26;
    k67v5 = 27;
    kJ = 28;
    kCR123A = 29;
    kCR2 = 30;
    k2CR5 = 31;
    kCRP2 = 32;
    kCRV3 = 33;
    kSR41 = 34;
    kSR43 = 35;
    kSR44 = 36;
    kSR45 = 37;
    kSR48 = 38;
    kSR54 = 39;
    kSR55 = 40;
    kSR57 = 41;
    kSR58 = 42;
    kSR59 = 43;
    kSR60 = 44;
    kSR63 = 45;
    kSR64 = 46;
    kSR65 = 47;
    kSR66 = 48;
    kSR67 = 49;
    kSR68 = 50;
    kSR69 = 51;
    kSR516 = 52;
    kSR731 = 53;
    kSR712 = 54;
    kLR932 = 55;
    kA5 = 56;
    kA10 = 57;
    kA13 = 58;
    kA312 = 59;
    kA675 = 60;
    kAC41E = 61;
    k10180 = 62;
    k10280 = 63;
    k10440 = 64;
    k14250 = 65;
    k14430 = 66;
    k14500 = 67;
    k14650 = 68;
    k15270 = 69;
    k16340 = 70;
    kRCR123A = 71;
    k17500 = 72;
    k17670 = 73;
    k18350 = 74;
    k18500 = 75;
    k18650 = 76;
    k19670 = 77;
    k25500 = 78;
    k26650 = 79;
    k32600 = 80;
  }

  enum BatFaultEnum : enum8 {
    kUnspecified = 0;
    kOverTemp = 1;
    kUnderTemp = 2;
  }

  enum BatReplaceabilityEnum : enum8 {
    kUnspecified = 0;
    kNotReplaceable = 1;
    kUserReplaceable = 2;
    kFactoryReplaceable = 3;
  }

  enum PowerSourceStatusEnum : enum8 {
    kUnspecified = 0;
    kActive = 1;
    kStandby = 2;
    kUnavailable = 3;
  }

  enum WiredCurrentTypeEnum : enum8 {
    kAC = 0;
    kDC = 1;
  }

  enum WiredFaultEnum : enum8 {
    kUnspecified = 0;
    kOverVoltage = 1;
    kUnderVoltage = 2;
  }

  bitmap Feature : bitmap32 {
    kWired = 0x1;
    kBattery = 0x2;
    kRechargeable = 0x4;
    kReplaceable = 0x8;
  }

  struct BatChargeFaultChangeType {
    BatChargeFaultEnum current[] = 0;
    BatChargeFaultEnum previous[] = 1;
  }

  struct BatFaultChangeType {
    BatFaultEnum current[] = 0;
    BatFaultEnum previous[] = 1;
  }

  struct WiredFaultChangeType {
    WiredFaultEnum current[] = 0;
    WiredFaultEnum previous[] = 1;
  }

  info event WiredFaultChange = 0 {
    WiredFaultEnum current[] = 0;
    WiredFaultEnum previous[] = 1;
  }

  info event BatFaultChange = 1 {
    BatFaultEnum current[] = 0;
    BatFaultEnum previous[] = 1;
  }

  info event BatChargeFaultChange = 2 {
    BatChargeFaultEnum current[] = 0;
    BatChargeFaultEnum previous[] = 1;
  }

  readonly attribute PowerSourceStatusEnum status = 0;
  readonly attribute int8u order = 1;
  readonly attribute char_string<60> description = 2;
  readonly attribute optional nullable int32u wiredAssessedInputVoltage = 3;
  readonly attribute optional nullable int16u wiredAssessedInputFrequency = 4;
  readonly attribute optional WiredCurrentTypeEnum wiredCurrentType = 5;
  readonly attribute optional nullable int32u wiredAssessedCurrent = 6;
  readonly attribute optional int32u wiredNominalVoltage = 7;
  readonly attribute optional int32u wiredMaximumCurrent = 8;
  readonly attribute optional boolean wiredPresent = 9;
  readonly attribute optional WiredFaultEnum activeWiredFaults[] = 10;
  readonly attribute optional nullable int32u batVoltage = 11;
  readonly attribute optional nullable int8u batPercentRemaining = 12;
  readonly attribute optional nullable int32u batTimeRemaining = 13;
  readonly attribute optional BatChargeLevelEnum batChargeLevel = 14;
  readonly attribute optional boolean batReplacementNeeded = 15;
  readonly attribute optional BatReplaceabilityEnum batReplaceability = 16;
  readonly attribute optional boolean batPresent = 17;
  readonly attribute optional BatFaultEnum activeBatFaults[] = 18;
  readonly attribute optional char_string<60> batReplacementDescription = 19;
  readonly attribute optional BatCommonDesignationEnum batCommonDesignation = 20;
  readonly attribute optional char_string<20> batANSIDesignation = 21;
  readonly attribute optional char_string<20> batIECDesignation = 22;
  readonly attribute optional BatApprovedChemistryEnum batApprovedChemistry = 23;
  readonly attribute optional int32u batCapacity = 24;
  readonly attribute optional int8u batQuantity = 25;
  readonly attribute optional BatChargeStateEnum batChargeState = 26;
  readonly attribute optional nullable int32u batTimeToFullCharge = 27;
  readonly attribute optional boolean batFunctionalWhileCharging = 28;
  readonly attribute optional nullable int32u batChargingCurrent = 29;
  readonly attribute optional BatChargeFaultEnum activeBatChargeFaults[] = 30;
  readonly attribute endpoint_no endpointList[] = 31;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
cluster GeneralCommissioning = 48 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningErrorEnum : enum8 {
    kOK = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string<128> debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string<2> countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  /** Arm the persistent fail-safe timer with an expiry time of now + ExpiryLengthSeconds using device clock */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** Set the regulatory configuration to be used during commissioning */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** Signals the Server that the Client has successfully completed all steps of Commissioning/Recofiguration needed during fail-safe period. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
cluster NetworkCommissioning = 49 {
  revision 1; // NOTE: Default/not specifically set

  enum NetworkCommissioningStatusEnum : enum8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBandEnum : enum8 {
    k2G4 = 0;
    k3G65 = 1;
    k5G = 2;
    k6G = 3;
    k60G = 4;
    k1G = 5;
  }

  bitmap Feature : bitmap32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
    kPerDeviceCredentials = 0x8;
  }

  bitmap ThreadCapabilitiesBitmap : bitmap16 {
    kIsBorderRouterCapable = 0x1;
    kIsRouterCapable = 0x2;
    kIsSleepyEndDeviceCapable = 0x4;
    kIsFullThreadDevice = 0x8;
    kIsSynchronizedSleepyEndDeviceCapable = 0x10;
  }

  bitmap WiFiSecurityBitmap : bitmap8 {
    kUnencrypted = 0x1;
    kWEP = 0x2;
    kWPAPersonal = 0x4;
    kWPA2Personal = 0x8;
    kWPA3Personal = 0x10;
    kWPA3MatterPDC = 0x20;
  }

  struct NetworkInfoStruct {
    octet_string<32> networkID = 0;
    boolean connected = 1;
    optional nullable octet_string<20> networkIdentifier = 2;
    optional nullable octet_string<20> clientIdentifier = 3;
  }

  struct ThreadInterfaceScanResultStruct {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResultStruct {
    WiFiSecurityBitmap security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBandEnum wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfoStruct networks[] = 1;
  readonly attribute optional int8u scanMaxTimeSeconds = 2;
  readonly attribute optional int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatusEnum lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute optional WiFiBandEnum supportedWiFiBands[] = 8;
  readonly attribute optional ThreadCapabilitiesBitmap supportedThreadFeatures = 9;
  readonly attribute optional int16u threadVersion = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable octet_string<32> ssid = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    optional WiFiInterfaceScanResultStruct wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResultStruct threadScanResults[] = 3;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    octet_string<32> ssid = 0;
    octet_string<64> credentials = 1;
    optional int64u breadcrumb = 2;
    optional octet_string<140> networkIdentity = 3;
    optional octet_string<20> clientIdentifier = 4;
    optional octet_string<32> possessionNonce = 5;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    octet_string<254> operationalDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string<512> debugText = 1;
    optional int8u networkIndex = 2;
    optional octet_string<140> clientIdentity = 3;
    optional octet_string<64> possessionSignature = 4;
  }

  request struct ConnectNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    nullable int32s errorValue = 2;
  }

  request struct ReorderNetworkRequest {
    octet_string<32> networkID = 0;
    int8u networkIndex = 1;
    optional int64u breadcrumb = 2;
  }

  request struct QueryIdentityRequest {
    octet_string<20> keyIdentifier = 0;
    optional octet_string<32> possessionNonce = 1;
  }

  response struct QueryIdentityResponse = 10 {
    octet_string<140> identity = 0;
    optional octet_string<64> possessionSignature = 1;
  }

  /** Detemine the set of networks the device sees as available. */
  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  /** Add or update the credentials for a given Wi-Fi network. */
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  /** Add or update the credentials for a given Thread network. */
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  /** Remove the definition of a given network (including its credentials). */
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  /** Connect to the specified network, using previously-defined credentials. */
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  /** Modify the order in which networks will be presented in the Networks attribute. */
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
  /** Retrieve details about and optionally proof of possession of a network client identity. */
  command access(invoke: administer) QueryIdentity(QueryIdentityRequest): QueryIdentityResponse = 9;
}

/** The cluster provides commands for retrieving unstructured diagnostic logs from a Node that may be used to aid in diagnostics. */
cluster DiagnosticLogs = 50 {
  revision 1; // NOTE: Default/not specifically set

  enum IntentEnum : enum8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : enum8 {
    kResponsePayload = 0;
    kBDX = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional char_string<32> transferFileDesignator = 2;
  }

  response struct RetrieveLogsResponse = 1 {
    StatusEnum status = 0;
    long_octet_string logContent = 1;
    optional epoch_us UTCTimeStamp = 2;
    optional systime_us timeSinceBoot = 3;
  }

  /** Retrieving diagnostic logs from a Node */
  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster GeneralDiagnostics = 51 {
  revision 2;

  enum BootReasonEnum : enum8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : enum8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : enum8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : enum8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  bitmap Feature : bitmap32 {
    kDataModelTest = 0x1;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute optional int64u upTime = 2;
  readonly attribute optional int32u totalOperationalHours = 3;
  readonly attribute optional BootReasonEnum bootReason = 4;
  readonly attribute optional HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute optional RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute optional NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    octet_string<16> enableKey = 0;
    int64u eventTrigger = 1;
  }

  response struct TimeSnapshotResponse = 2 {
    systime_ms systemTimeMs = 0;
    nullable posix_ms posixTimeMs = 1;
  }

  request struct PayloadTestRequestRequest {
    octet_string<16> enableKey = 0;
    int8u value = 1;
    int16u count = 2;
  }

  response struct PayloadTestResponse = 4 {
    octet_string payload = 0;
  }

  /** Provide a means for certification tests to trigger some test-plan-specific events */
  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
  /** Take a snapshot of system time and epoch time. */
  command TimeSnapshot(): TimeSnapshotResponse = 1;
  /** Request a variable length payload response. */
  command PayloadTestRequest(PayloadTestRequestRequest): PayloadTestResponse = 3;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster SoftwareDiagnostics = 52 {
  revision 1; // NOTE: Default/not specifically set

  bitmap Feature : bitmap32 {
    kWatermarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    int64u id = 0;
    optional char_string name = 1;
    optional octet_string faultRecording = 2;
  }

  readonly attribute optional ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute optional int64u currentHeapFree = 1;
  readonly attribute optional int64u currentHeapUsed = 2;
  readonly attribute optional int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the values: The StackFreeMinimum field of the ThreadMetrics attribute, CurrentHeapHighWaterMark attribute. */
  command access(invoke: manage) ResetWatermarks(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
cluster ThreadNetworkDiagnostics = 53 {
  revision 2;

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRoleEnum : enum8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kREED = 4;
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTableStruct {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTableStruct {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRoleEnum routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute NeighborTableStruct neighborTable[] = 7;
  readonly attribute RouteTableStruct routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int16u weighting = 10;
  readonly attribute nullable int16u dataVersion = 11;
  readonly attribute nullable int16u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute optional int16u detachedRoleCount = 14;
  readonly attribute optional int16u childRoleCount = 15;
  readonly attribute optional int16u routerRoleCount = 16;
  readonly attribute optional int16u leaderRoleCount = 17;
  readonly attribute optional int16u attachAttemptCount = 18;
  readonly attribute optional int16u partitionIdChangeCount = 19;
  readonly attribute optional int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute optional int16u parentChangeCount = 21;
  readonly attribute optional int32u txTotalCount = 22;
  readonly attribute optional int32u txUnicastCount = 23;
  readonly attribute optional int32u txBroadcastCount = 24;
  readonly attribute optional int32u txAckRequestedCount = 25;
  readonly attribute optional int32u txAckedCount = 26;
  readonly attribute optional int32u txNoAckRequestedCount = 27;
  readonly attribute optional int32u txDataCount = 28;
  readonly attribute optional int32u txDataPollCount = 29;
  readonly attribute optional int32u txBeaconCount = 30;
  readonly attribute optional int32u txBeaconRequestCount = 31;
  readonly attribute optional int32u txOtherCount = 32;
  readonly attribute optional int32u txRetryCount = 33;
  readonly attribute optional int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute optional int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute optional int32u txErrCcaCount = 36;
  readonly attribute optional int32u txErrAbortCount = 37;
  readonly attribute optional int32u txErrBusyChannelCount = 38;
  readonly attribute optional int32u rxTotalCount = 39;
  readonly attribute optional int32u rxUnicastCount = 40;
  readonly attribute optional int32u rxBroadcastCount = 41;
  readonly attribute optional int32u rxDataCount = 42;
  readonly attribute optional int32u rxDataPollCount = 43;
  readonly attribute optional int32u rxBeaconCount = 44;
  readonly attribute optional int32u rxBeaconRequestCount = 45;
  readonly attribute optional int32u rxOtherCount = 46;
  readonly attribute optional int32u rxAddressFilteredCount = 47;
  readonly attribute optional int32u rxDestAddrFilteredCount = 48;
  readonly attribute optional int32u rxDuplicatedCount = 49;
  readonly attribute optional int32u rxErrNoFrameCount = 50;
  readonly attribute optional int32u rxErrUnknownNeighborCount = 51;
  readonly attribute optional int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute optional int32u rxErrSecCount = 53;
  readonly attribute optional int32u rxErrFcsCount = 54;
  readonly attribute optional int32u rxErrOtherCount = 55;
  readonly attribute optional nullable int64u activeTimestamp = 56;
  readonly attribute optional nullable int64u pendingTimestamp = 57;
  readonly attribute optional nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFaultEnum activeNetworkFaultsList[] = 62;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the OverrunCount attributes to 0 */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** The Wi-Fi Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster WiFiNetworkDiagnostics = 54 {
  revision 1; // NOTE: Default/not specifically set

  enum AssociationFailureCauseEnum : enum8 {
    kUnknown = 0;
    kAssociationFailed = 1;
    kAuthenticationFailed = 2;
    kSsidNotFound = 3;
  }

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum SecurityTypeEnum : enum8 {
    kUnspecified = 0;
    kNone = 1;
    kWEP = 2;
    kWPA = 3;
    kWPA2 = 4;
    kWPA3 = 5;
  }

  enum WiFiVersionEnum : enum8 {
    kA = 0;
    kB = 1;
    kG = 2;
    kN = 3;
    kAc = 4;
    kAx = 5;
    kAh = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  info event Disconnection = 0 {
    int16u reasonCode = 0;
  }

  info event AssociationFailure = 1 {
    AssociationFailureCauseEnum associationFailureCause = 0;
    int16u status = 1;
  }

  info event ConnectionStatus = 2 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  readonly attribute nullable octet_string<6> bssid = 0;
  readonly attribute nullable SecurityTypeEnum securityType = 1;
  readonly attribute nullable WiFiVersionEnum wiFiVersion = 2;
  readonly attribute nullable int16u channelNumber = 3;
  readonly attribute nullable int8s rssi = 4;
  readonly attribute optional nullable int32u beaconLostCount = 5;
  readonly attribute optional nullable int32u beaconRxCount = 6;
  readonly attribute optional nullable int32u packetMulticastRxCount = 7;
  readonly attribute optional nullable int32u packetMulticastTxCount = 8;
  readonly attribute optional nullable int32u packetUnicastRxCount = 9;
  readonly attribute optional nullable int32u packetUnicastTxCount = 10;
  readonly attribute optional nullable int64u currentMaxRate = 11;
  readonly attribute optional nullable int64u overrunCount = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the Breacon and Packet related count attributes to 0 */
  command ResetCounts(): DefaultSuccess = 0;
}

/** The Ethernet Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster EthernetNetworkDiagnostics = 55 {
  revision 1; // NOTE: Default/not specifically set

  enum PHYRateEnum : enum8 {
    kRate10M = 0;
    kRate100M = 1;
    kRate1G = 2;
    kRate25G = 3;
    kRate5G = 4;
    kRate10G = 5;
    kRate40G = 6;
    kRate100G = 7;
    kRate200G = 8;
    kRate400G = 9;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  readonly attribute optional nullable PHYRateEnum PHYRate = 0;
  readonly attribute optional nullable boolean fullDuplex = 1;
  readonly attribute optional int64u packetRxCount = 2;
  readonly attribute optional int64u packetTxCount = 3;
  readonly attribute optional int64u txErrCount = 4;
  readonly attribute optional int64u collisionCount = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute optional nullable boolean carrierDetect = 7;
  readonly attribute optional int64u timeSinceReset = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the attributes: PacketRxCount, PacketTxCount, TxErrCount, CollisionCount, OverrunCount to 0 */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** Accurate time is required for a number of reasons, including scheduling, display and validating security materials. */
cluster TimeSynchronization = 56 {
  revision 2;

  enum GranularityEnum : enum8 {
    kNoTimeGranularity = 0;
    kMinutesGranularity = 1;
    kSecondsGranularity = 2;
    kMillisecondsGranularity = 3;
    kMicrosecondsGranularity = 4;
  }

  enum StatusCode : enum8 {
    kTimeNotAccepted = 2;
  }

  enum TimeSourceEnum : enum8 {
    kNone = 0;
    kUnknown = 1;
    kAdmin = 2;
    kNodeTimeCluster = 3;
    kNonMatterSNTP = 4;
    kNonMatterNTP = 5;
    kMatterSNTP = 6;
    kMatterNTP = 7;
    kMixedNTP = 8;
    kNonMatterSNTPNTS = 9;
    kNonMatterNTPNTS = 10;
    kMatterSNTPNTS = 11;
    kMatterNTPNTS = 12;
    kMixedNTPNTS = 13;
    kCloudSource = 14;
    kPTP = 15;
    kGNSS = 16;
  }

  enum TimeZoneDatabaseEnum : enum8 {
    kFull = 0;
    kPartial = 1;
    kNone = 2;
  }

  bitmap Feature : bitmap32 {
    kTimeZone = 0x1;
    kNTPClient = 0x2;
    kNTPServer = 0x4;
    kTimeSyncClient = 0x8;
  }

  struct DSTOffsetStruct {
    int32s offset = 0;
    epoch_us validStarting = 1;
    nullable epoch_us validUntil = 2;
  }

  struct FabricScopedTrustedTimeSourceStruct {
    node_id nodeID = 0;
    endpoint_no endpoint = 1;
  }

  struct TimeZoneStruct {
    int32s offset = 0;
    epoch_us validAt = 1;
    optional char_string<64> name = 2;
  }

  struct TrustedTimeSourceStruct {
    fabric_idx fabricIndex = 0;
    node_id nodeID = 1;
    endpoint_no endpoint = 2;
  }

  info event DSTTableEmpty = 0 {
  }

  info event DSTStatus = 1 {
    boolean DSTOffsetActive = 0;
  }

  info event TimeZoneStatus = 2 {
    int32s offset = 0;
    optional char_string name = 1;
  }

  info event TimeFailure = 3 {
  }

  info event MissingTrustedTimeSource = 4 {
  }

  readonly attribute nullable epoch_us UTCTime = 0;
  readonly attribute GranularityEnum granularity = 1;
  readonly attribute optional TimeSourceEnum timeSource = 2;
  readonly attribute optional nullable TrustedTimeSourceStruct trustedTimeSource = 3;
  readonly attribute optional nullable char_string<128> defaultNTP = 4;
  readonly attribute optional TimeZoneStruct timeZone[] = 5;
  readonly attribute optional DSTOffsetStruct DSTOffset[] = 6;
  readonly attribute optional nullable epoch_us localTime = 7;
  readonly attribute optional TimeZoneDatabaseEnum timeZoneDatabase = 8;
  readonly attribute optional boolean NTPServerAvailable = 9;
  readonly attribute optional int8u timeZoneListMaxSize = 10;
  readonly attribute optional int8u DSTOffsetListMaxSize = 11;
  readonly attribute optional boolean supportsDNSResolve = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetUTCTimeRequest {
    epoch_us UTCTime = 0;
    GranularityEnum granularity = 1;
    optional TimeSourceEnum timeSource = 2;
  }

  request struct SetTrustedTimeSourceRequest {
    nullable FabricScopedTrustedTimeSourceStruct trustedTimeSource = 0;
  }

  request struct SetTimeZoneRequest {
    TimeZoneStruct timeZone[] = 0;
  }

  response struct SetTimeZoneResponse = 3 {
    boolean DSTOffsetRequired = 0;
  }

  request struct SetDSTOffsetRequest {
    DSTOffsetStruct DSTOffset[] = 0;
  }

  request struct SetDefaultNTPRequest {
    nullable char_string<128> defaultNTP = 0;
  }

  /** This command MAY be issued by Administrator to set the time. */
  command access(invoke: administer) SetUTCTime(SetUTCTimeRequest): DefaultSuccess = 0;
  /** This command SHALL set TrustedTimeSource. */
  fabric command access(invoke: administer) SetTrustedTimeSource(SetTrustedTimeSourceRequest): DefaultSuccess = 1;
  /** This command SHALL set TimeZone. */
  command access(invoke: manage) SetTimeZone(SetTimeZoneRequest): SetTimeZoneResponse = 2;
  /** This command SHALL set DSTOffset. */
  command access(invoke: manage) SetDSTOffset(SetDSTOffsetRequest): DefaultSuccess = 4;
  /** This command is used to set DefaultNTP. */
  command access(invoke: administer) SetDefaultNTP(SetDefaultNTPRequest): DefaultSuccess = 5;
}

/** This Cluster serves two purposes towards a Node communicating with a Bridge: indicate that the functionality on
          the Endpoint where it is placed (and its Parts) is bridged from a non-CHIP technology; and provide a centralized
          collection of attributes that the Node MAY collect to aid in conveying information regarding the Bridged Device to a user,
          such as the vendor name, the model name, or user-assigned name. */
cluster BridgedDeviceBasicInformation = 57 {
  revision 3;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute optional char_string<32> vendorName = 1;
  readonly attribute optional vendor_id vendorID = 2;
  readonly attribute optional char_string<32> productName = 3;
  attribute optional char_string<32> nodeLabel = 5;
  readonly attribute optional int16u hardwareVersion = 7;
  readonly attribute optional char_string<64> hardwareVersionString = 8;
  readonly attribute optional int32u softwareVersion = 9;
  readonly attribute optional char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  readonly attribute boolean reachable = 17;
  readonly attribute optional char_string<32> uniqueID = 18;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster exposes interactions with a switch device, for the purpose of using those interactions by other devices.
Two types of switch devices are supported: latching switch (e.g. rocker switch) and momentary switch (e.g. push button), distinguished with their feature flags.
Interactions with the switch device are exposed as attributes (for the latching switch) and as events (for both types of switches). An interested party MAY subscribe to these attributes/events and thus be informed of the interactions, and can perform actions based on this, for example by sending commands to perform an action such as controlling a light or a window shade. */
cluster Switch = 59 {
  revision 1;

  bitmap Feature : bitmap32 {
    kLatchingSwitch = 0x1;
    kMomentarySwitch = 0x2;
    kMomentarySwitchRelease = 0x4;
    kMomentarySwitchLongPress = 0x8;
    kMomentarySwitchMultiPress = 0x10;
  }

  info event SwitchLatched = 0 {
    int8u newPosition = 0;
  }

  info event InitialPress = 1 {
    int8u newPosition = 0;
  }

  info event LongPress = 2 {
    int8u newPosition = 0;
  }

  info event ShortRelease = 3 {
    int8u previousPosition = 0;
  }

  info event LongRelease = 4 {
    int8u previousPosition = 0;
  }

  info event MultiPressOngoing = 5 {
    int8u newPosition = 0;
    int8u currentNumberOfPressesCounted = 1;
  }

  info event MultiPressComplete = 6 {
    int8u previousPosition = 0;
    int8u totalNumberOfPressesCounted = 1;
  }

  readonly attribute int8u numberOfPositions = 0;
  readonly attribute int8u currentPosition = 1;
  readonly attribute optional int8u multiPressMax = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
cluster AdministratorCommissioning = 60 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningWindowStatusEnum : enum8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : enum8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  bitmap Feature : bitmap32 {
    kBasic = 0x1;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable vendor_id adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
    octet_string PAKEPasscodeVerifier = 1;
    int16u discriminator = 2;
    int32u iterations = 3;
    octet_string<32> salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
  }

  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using enhanced commissioning method. */
  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using basic commissioning method, if the node supports it. */
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  /** This command is used by a current Administrator to instruct a Node to revoke any active Open Commissioning Window or Open Basic Commissioning Window command. */
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
cluster OperationalCredentials = 62 {
  revision 1; // NOTE: Default/not specifically set

  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string<900> attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string attestationSignature = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string NOCValue = 0;
    optional octet_string ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string rootCACertificate = 0;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** Sender is requesting to update the node operational certificates. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
cluster GroupKeyManagement = 63 {
  revision 1; // NOTE: Default/not specifically set

  enum GroupKeySecurityPolicyEnum : enum8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  bitmap Feature : bitmap32 {
    kCacheAndSync = 0x1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetRemoveRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    int16u groupKeySetIDs[] = 0;
  }

  /** Write a new set of keys for the given key set id. */
  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  /** Read the keys for a given key set id. */
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  /** Revoke a Root Key from a Group */
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  /** Return the list of Group Key Sets associated with the accessing fabric */
  fabric command access(invoke: administer) KeySetReadAllIndices(): KeySetReadAllIndicesResponse = 4;
}

/** The Fixed Label Cluster provides a feature for the device to tag an endpoint with zero or more read only
labels. */
cluster FixedLabel = 64 {
  revision 1; // NOTE: Default/not specifically set

  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The User Label Cluster provides a feature to tag an endpoint with zero or more labels. */
cluster UserLabel = 65 {
  revision 1; // NOTE: Default/not specifically set

  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  attribute access(write: manage) LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Cluster to control Proxy Configuration */
cluster ProxyConfiguration = 66 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Cluster to control Proxy Discovery */
cluster ProxyDiscovery = 67 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Cluster to control Proxy Valid */
cluster ProxyValid = 68 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface to a boolean state called StateValue. */
cluster BooleanState = 69 {
  revision 1;

  info event StateChange = 0 {
    boolean stateValue = 0;
  }

  readonly attribute boolean stateValue = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Allows servers to ensure that listed clients are notified when a server is available for communication. */
cluster IcdManagement = 70 {
  revision 2;

  enum OperatingModeEnum : enum8 {
    kSIT = 0;
    kLIT = 1;
  }

  bitmap Feature : bitmap32 {
    kCheckInProtocolSupport = 0x1;
    kUserActiveModeTrigger = 0x2;
    kLongIdleTimeSupport = 0x4;
  }

  bitmap UserActiveModeTriggerBitmap : bitmap32 {
    kPowerCycle = 0x1;
    kSettingsMenu = 0x2;
    kCustomInstruction = 0x4;
    kDeviceManual = 0x8;
    kActuateSensor = 0x10;
    kActuateSensorSeconds = 0x20;
    kActuateSensorTimes = 0x40;
    kActuateSensorLightsBlink = 0x80;
    kResetButton = 0x100;
    kResetButtonLightsBlink = 0x200;
    kResetButtonSeconds = 0x400;
    kResetButtonTimes = 0x800;
    kSetupButton = 0x1000;
    kSetupButtonSeconds = 0x2000;
    kSetupButtonLightsBlink = 0x4000;
    kSetupButtonTimes = 0x8000;
    kAppDefinedButton = 0x10000;
  }

  fabric_scoped struct MonitoringRegistrationStruct {
    fabric_sensitive node_id checkInNodeID = 1;
    fabric_sensitive int64u monitoredSubject = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute int32u idleModeDuration = 0;
  readonly attribute int32u activeModeDuration = 1;
  readonly attribute int16u activeModeThreshold = 2;
  readonly attribute access(read: administer) optional MonitoringRegistrationStruct registeredClients[] = 3;
  readonly attribute access(read: administer) optional int32u ICDCounter = 4;
  readonly attribute optional int16u clientsSupportedPerFabric = 5;
  readonly attribute optional UserActiveModeTriggerBitmap userActiveModeTriggerHint = 6;
  readonly attribute optional char_string<128> userActiveModeTriggerInstruction = 7;
  readonly attribute optional OperatingModeEnum operatingMode = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RegisterClientRequest {
    node_id checkInNodeID = 0;
    int64u monitoredSubject = 1;
    octet_string<16> key = 2;
    optional octet_string<16> verificationKey = 3;
  }

  response struct RegisterClientResponse = 1 {
    int32u ICDCounter = 0;
  }

  request struct UnregisterClientRequest {
    node_id checkInNodeID = 0;
    optional octet_string<16> verificationKey = 1;
  }

  request struct StayActiveRequestRequest {
    int32u stayActiveDuration = 0;
  }

  response struct StayActiveResponse = 4 {
    int32u promisedActiveDuration = 0;
  }

  /** Register a client to the end device */
  fabric command access(invoke: manage) RegisterClient(RegisterClientRequest): RegisterClientResponse = 0;
  /** Unregister a client from an end device */
  fabric command access(invoke: manage) UnregisterClient(UnregisterClientRequest): DefaultSuccess = 2;
  /** Request the end device to stay in Active Mode for an additional ActiveModeThreshold */
  command access(invoke: manage) StayActiveRequest(StayActiveRequestRequest): StayActiveResponse = 3;
}

/** This cluster supports creating a simple timer functionality. */
provisional cluster Timer = 71 {
  revision 1;

  enum TimerStatusEnum : enum8 {
    kRunning = 0;
    kPaused = 1;
    kExpired = 2;
    kReady = 3;
  }

  bitmap Feature : bitmap32 {
    kReset = 0x1;
  }

  readonly attribute elapsed_s setTime = 0;
  readonly attribute elapsed_s timeRemaining = 1;
  readonly attribute TimerStatusEnum timerState = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetTimerRequest {
    elapsed_s newTime = 0;
  }

  request struct AddTimeRequest {
    elapsed_s additionalTime = 0;
  }

  request struct ReduceTimeRequest {
    elapsed_s timeReduction = 0;
  }

  /** This command is used to set the timer. */
  command SetTimer(SetTimerRequest): DefaultSuccess = 0;
  /** This command is used to reset the timer to the original value. */
  command ResetTimer(): DefaultSuccess = 1;
  /** This command is used to add time to the existing timer. */
  command AddTime(AddTimeRequest): DefaultSuccess = 2;
  /** This command is used to reduce time on the existing timer. */
  command ReduceTime(ReduceTimeRequest): DefaultSuccess = 3;
}

/** This cluster supports remotely monitoring and, where supported, changing the operational state of an Oven. */
cluster OvenCavityOperationalState = 72 {
  revision 1;

  enum ErrorStateEnum : enum8 {
    kNoError = 0;
    kUnableToStartOrResume = 1;
    kUnableToCompleteOperation = 2;
    kCommandInvalidInState = 3;
  }

  enum OperationalStateEnum : enum8 {
    kStopped = 0;
    kRunning = 1;
    kPaused = 2;
    kError = 3;
  }

  struct ErrorStateStruct {
    enum8 errorStateID = 0;
    optional char_string<64> errorStateLabel = 1;
    optional char_string<64> errorStateDetails = 2;
  }

  struct OperationalStateStruct {
    enum8 operationalStateID = 0;
    optional char_string<64> operationalStateLabel = 1;
  }

  critical event OperationalError = 0 {
    ErrorStateStruct errorState = 0;
  }

  info event OperationCompletion = 1 {
    enum8 completionErrorCode = 0;
    optional nullable elapsed_s totalOperationalTime = 1;
    optional nullable elapsed_s pausedTime = 2;
  }

  readonly attribute nullable char_string phaseList[] = 0;
  readonly attribute nullable int8u currentPhase = 1;
  readonly attribute optional nullable elapsed_s countdownTime = 2;
  readonly attribute OperationalStateStruct operationalStateList[] = 3;
  readonly attribute OperationalStateEnum operationalState = 4;
  readonly attribute ErrorStateStruct operationalError = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct OperationalCommandResponse = 4 {
    ErrorStateStruct commandResponseState = 0;
  }

  /** Upon receipt, the device SHALL pause its operation if it is possible based on the current function of the server. */
  command Pause(): OperationalCommandResponse = 0;
  /** Upon receipt, the device SHALL stop its operation if it is at a position where it is safe to do so and/or permitted. */
  command Stop(): OperationalCommandResponse = 1;
  /** Upon receipt, the device SHALL start its operation if it is safe to do so and the device is in an operational state from which it can be started. */
  command Start(): OperationalCommandResponse = 2;
  /** Upon receipt, the device SHALL resume its operation from the point it was at when it received the Pause command, or from the point when it was paused by means outside of this cluster (for example by manual button press). */
  command Resume(): OperationalCommandResponse = 3;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster OvenMode = 73 {
  revision 1;

  enum ModeTag : enum16 {
    kBake = 16384;
    kConvection = 16385;
    kGrill = 16386;
    kRoast = 16387;
    kClean = 16388;
    kConvectionBake = 16389;
    kConvectionRoast = 16390;
    kWarming = 16391;
    kProofing = 16392;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** This cluster supports remotely monitoring and controling the different typs of
            functionality available to a drying device, such as a laundry dryer. */
provisional cluster LaundryDryerControls = 74 {
  revision 1;

  enum DrynessLevelEnum : enum8 {
    kLow = 0;
    kNormal = 1;
    kExtra = 2;
    kMax = 3;
  }

  readonly attribute DrynessLevelEnum supportedDrynessLevels[] = 0;
  attribute nullable DrynessLevelEnum selectedDrynessLevel = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster ModeSelect = 80 {
  revision 2;

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct SemanticTagStruct {
    vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    SemanticTagStruct semanticTags[] = 2;
  }

  readonly attribute char_string<64> description = 0;
  readonly attribute nullable enum16 standardNamespace = 1;
  readonly attribute ModeOptionStruct supportedModes[] = 2;
  readonly attribute int8u currentMode = 3;
  attribute optional nullable int8u startUpMode = 4;
  attribute optional nullable int8u onMode = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  /** On receipt of this command, if the NewMode field matches the Mode field in an entry of the SupportedModes list, the server SHALL set the CurrentMode attribute to the NewMode value, otherwise, the server SHALL respond with an INVALID_COMMAND status response. */
  command ChangeToMode(ChangeToModeRequest): DefaultSuccess = 0;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster LaundryWasherMode = 81 {
  revision 2;

  enum ModeTag : enum16 {
    kNormal = 16384;
    kDelicate = 16385;
    kHeavy = 16386;
    kWhites = 16387;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster RefrigeratorAndTemperatureControlledCabinetMode = 82 {
  revision 2;

  enum ModeTag : enum16 {
    kRapidCool = 16384;
    kRapidFreeze = 16385;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** This cluster supports remotely monitoring and controlling the different types of functionality available to a washing device, such as a washing machine. */
cluster LaundryWasherControls = 83 {
  revision 1;

  enum NumberOfRinsesEnum : enum8 {
    kNone = 0;
    kNormal = 1;
    kExtra = 2;
    kMax = 3;
  }

  bitmap Feature : bitmap32 {
    kSpin = 0x1;
    kRinse = 0x2;
  }

  readonly attribute optional char_string spinSpeeds[] = 0;
  attribute optional nullable int8u spinSpeedCurrent = 1;
  attribute optional NumberOfRinsesEnum numberOfRinses = 2;
  readonly attribute optional NumberOfRinsesEnum supportedRinses[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster RvcRunMode = 84 {
  revision 2;

  enum ModeTag : enum16 {
    kIdle = 16384;
    kCleaning = 16385;
    kMapping = 16386;
  }

  enum StatusCode : enum8 {
    kStuck = 65;
    kDustBinMissing = 66;
    kDustBinFull = 67;
    kWaterTankEmpty = 68;
    kWaterTankMissing = 69;
    kWaterTankLidOpen = 70;
    kMopCleaningPadMissing = 71;
    kBatteryLow = 72;
  }

  bitmap Feature : bitmap32 {
    kNoFeatures = 0x0;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster RvcCleanMode = 85 {
  revision 2;

  enum ModeTag : enum16 {
    kDeepClean = 16384;
    kVacuum = 16385;
    kMop = 16386;
  }

  enum StatusCode : enum8 {
    kCleaningInProgress = 64;
  }

  bitmap Feature : bitmap32 {
    kNoFeatures = 0x0;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes and commands for configuring the temperature control, and reporting temperature. */
cluster TemperatureControl = 86 {
  revision 1; // NOTE: Default/not specifically set

  bitmap Feature : bitmap32 {
    kTemperatureNumber = 0x1;
    kTemperatureLevel = 0x2;
    kTemperatureStep = 0x4;
  }

  readonly attribute optional temperature temperatureSetpoint = 0;
  readonly attribute optional temperature minTemperature = 1;
  readonly attribute optional temperature maxTemperature = 2;
  readonly attribute optional temperature step = 3;
  readonly attribute optional int8u selectedTemperatureLevel = 4;
  readonly attribute optional char_string supportedTemperatureLevels[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetTemperatureRequest {
    optional temperature targetTemperature = 0;
    optional int8u targetTemperatureLevel = 1;
  }

  /** Set Temperature */
  command SetTemperature(SetTemperatureRequest): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the Refrigerator alarm. */
cluster RefrigeratorAlarm = 87 {
  revision 1; // NOTE: Default/not specifically set

  bitmap AlarmBitmap : bitmap32 {
    kDoorOpen = 0x1;
  }

  info event Notify = 0 {
    AlarmBitmap active = 0;
    AlarmBitmap inactive = 1;
    AlarmBitmap state = 2;
    AlarmBitmap mask = 3;
  }

  readonly attribute AlarmBitmap mask = 0;
  readonly attribute AlarmBitmap state = 2;
  readonly attribute AlarmBitmap supported = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster DishwasherMode = 89 {
  revision 2;

  enum ModeTag : enum16 {
    kNormal = 16384;
    kHeavy = 16385;
    kLight = 16386;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes for reporting air quality classification */
cluster AirQuality = 91 {
  revision 1; // NOTE: Default/not specifically set

  enum AirQualityEnum : enum8 {
    kUnknown = 0;
    kGood = 1;
    kFair = 2;
    kModerate = 3;
    kPoor = 4;
    kVeryPoor = 5;
    kExtremelyPoor = 6;
  }

  bitmap Feature : bitmap32 {
    kFair = 0x1;
    kModerate = 0x2;
    kVeryPoor = 0x4;
    kExtremelyPoor = 0x8;
  }

  readonly attribute AirQualityEnum airQuality = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for observing and managing the state of smoke and CO alarms. */
cluster SmokeCoAlarm = 92 {
  revision 1;

  enum AlarmStateEnum : enum8 {
    kNormal = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum ContaminationStateEnum : enum8 {
    kNormal = 0;
    kLow = 1;
    kWarning = 2;
    kCritical = 3;
  }

  enum EndOfServiceEnum : enum8 {
    kNormal = 0;
    kExpired = 1;
  }

  enum ExpressedStateEnum : enum8 {
    kNormal = 0;
    kSmokeAlarm = 1;
    kCOAlarm = 2;
    kBatteryAlert = 3;
    kTesting = 4;
    kHardwareFault = 5;
    kEndOfService = 6;
    kInterconnectSmoke = 7;
    kInterconnectCO = 8;
  }

  enum MuteStateEnum : enum8 {
    kNotMuted = 0;
    kMuted = 1;
  }

  enum SensitivityEnum : enum8 {
    kHigh = 0;
    kStandard = 1;
    kLow = 2;
  }

  bitmap Feature : bitmap32 {
    kSmokeAlarm = 0x1;
    kCOAlarm = 0x2;
  }

  critical event SmokeAlarm = 0 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  critical event COAlarm = 1 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event LowBattery = 2 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event HardwareFault = 3 {
  }

  info event EndOfService = 4 {
  }

  info event SelfTestComplete = 5 {
  }

  info event AlarmMuted = 6 {
  }

  info event MuteEnded = 7 {
  }

  critical event InterconnectSmokeAlarm = 8 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  critical event InterconnectCOAlarm = 9 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event AllClear = 10 {
  }

  readonly attribute ExpressedStateEnum expressedState = 0;
  readonly attribute optional AlarmStateEnum smokeState = 1;
  readonly attribute optional AlarmStateEnum COState = 2;
  readonly attribute AlarmStateEnum batteryAlert = 3;
  readonly attribute optional MuteStateEnum deviceMuted = 4;
  readonly attribute boolean testInProgress = 5;
  readonly attribute boolean hardwareFaultAlert = 6;
  readonly attribute EndOfServiceEnum endOfServiceAlert = 7;
  readonly attribute optional AlarmStateEnum interconnectSmokeAlarm = 8;
  readonly attribute optional AlarmStateEnum interconnectCOAlarm = 9;
  readonly attribute optional ContaminationStateEnum contaminationState = 10;
  attribute access(write: manage) optional SensitivityEnum smokeSensitivityLevel = 11;
  readonly attribute optional epoch_s expiryDate = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command SHALL initiate a device self-test. */
  command SelfTestRequest(): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the Dishwasher alarm. */
cluster DishwasherAlarm = 93 {
  revision 1; // NOTE: Default/not specifically set

  bitmap AlarmBitmap : bitmap32 {
    kInflowError = 0x1;
    kDrainError = 0x2;
    kDoorError = 0x4;
    kTempTooLow = 0x8;
    kTempTooHigh = 0x10;
    kWaterLevelError = 0x20;
  }

  bitmap Feature : bitmap32 {
    kReset = 0x1;
  }

  info event Notify = 0 {
    AlarmBitmap active = 0;
    AlarmBitmap inactive = 1;
    AlarmBitmap state = 2;
    AlarmBitmap mask = 3;
  }

  readonly attribute AlarmBitmap mask = 0;
  readonly attribute optional AlarmBitmap latch = 1;
  readonly attribute AlarmBitmap state = 2;
  readonly attribute AlarmBitmap supported = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ResetRequest {
    AlarmBitmap alarms = 0;
  }

  request struct ModifyEnabledAlarmsRequest {
    AlarmBitmap mask = 0;
  }

  /** Reset alarm */
  command Reset(ResetRequest): DefaultSuccess = 0;
  /** Modify enabled alarms */
  command ModifyEnabledAlarms(ModifyEnabledAlarmsRequest): DefaultSuccess = 1;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster MicrowaveOvenMode = 94 {
  revision 1;

  enum ModeTag : enum16 {
    kNormal = 16384;
    kDefrost = 16385;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the microwave oven control, and reporting cooking stats. */
cluster MicrowaveOvenControl = 95 {
  revision 1; // NOTE: Default/not specifically set

  bitmap Feature : bitmap32 {
    kPowerAsNumber = 0x1;
    kPowerInWatts = 0x2;
    kPowerNumberLimits = 0x4;
  }

  readonly attribute elapsed_s cookTime = 0;
  readonly attribute elapsed_s maxCookTime = 1;
  readonly attribute optional int8u powerSetting = 2;
  readonly attribute optional int8u minPower = 3;
  readonly attribute optional int8u maxPower = 4;
  readonly attribute optional int8u powerStep = 5;
  readonly attribute optional int16u supportedWatts[] = 6;
  readonly attribute optional int8u selectedWattIndex = 7;
  readonly attribute optional int16u wattRating = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetCookingParametersRequest {
    optional int8u cookMode = 0;
    optional elapsed_s cookTime = 1;
    optional int8u powerSetting = 2;
    optional int8u wattSettingIndex = 3;
    optional boolean startAfterSetting = 4;
  }

  request struct AddMoreTimeRequest {
    elapsed_s timeToAdd = 0;
  }

  /** Set Cooking Parameters */
  command SetCookingParameters(SetCookingParametersRequest): DefaultSuccess = 0;
  /** Add More Cooking Time */
  command AddMoreTime(AddMoreTimeRequest): DefaultSuccess = 1;
}

/** This cluster supports remotely monitoring and, where supported, changing the operational state of any device where a state machine is a part of the operation. */
cluster OperationalState = 96 {
  revision 1;

  enum ErrorStateEnum : enum8 {
    kNoError = 0;
    kUnableToStartOrResume = 1;
    kUnableToCompleteOperation = 2;
    kCommandInvalidInState = 3;
  }

  enum OperationalStateEnum : enum8 {
    kStopped = 0;
    kRunning = 1;
    kPaused = 2;
    kError = 3;
  }

  struct ErrorStateStruct {
    enum8 errorStateID = 0;
    optional char_string<64> errorStateLabel = 1;
    optional char_string<64> errorStateDetails = 2;
  }

  struct OperationalStateStruct {
    enum8 operationalStateID = 0;
    optional char_string<64> operationalStateLabel = 1;
  }

  critical event OperationalError = 0 {
    ErrorStateStruct errorState = 0;
  }

  info event OperationCompletion = 1 {
    enum8 completionErrorCode = 0;
    optional nullable elapsed_s totalOperationalTime = 1;
    optional nullable elapsed_s pausedTime = 2;
  }

  readonly attribute nullable char_string phaseList[] = 0;
  readonly attribute nullable int8u currentPhase = 1;
  readonly attribute optional nullable elapsed_s countdownTime = 2;
  readonly attribute OperationalStateStruct operationalStateList[] = 3;
  readonly attribute OperationalStateEnum operationalState = 4;
  readonly attribute ErrorStateStruct operationalError = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct OperationalCommandResponse = 4 {
    ErrorStateStruct commandResponseState = 0;
  }

  /** Upon receipt, the device SHALL pause its operation if it is possible based on the current function of the server. */
  command Pause(): OperationalCommandResponse = 0;
  /** Upon receipt, the device SHALL stop its operation if it is at a position where it is safe to do so and/or permitted. */
  command Stop(): OperationalCommandResponse = 1;
  /** Upon receipt, the device SHALL start its operation if it is safe to do so and the device is in an operational state from which it can be started. */
  command Start(): OperationalCommandResponse = 2;
  /** Upon receipt, the device SHALL resume its operation from the point it was at when it received the Pause command, or from the point when it was paused by means outside of this cluster (for example by manual button press). */
  command Resume(): OperationalCommandResponse = 3;
}

/** This cluster supports remotely monitoring and, where supported, changing the operational state of a Robotic Vacuum. */
cluster RvcOperationalState = 97 {
  revision 1;

  enum ErrorStateEnum : enum8 {
    kFailedToFindChargingDock = 64;
    kStuck = 65;
    kDustBinMissing = 66;
    kDustBinFull = 67;
    kWaterTankEmpty = 68;
    kWaterTankMissing = 69;
    kWaterTankLidOpen = 70;
    kMopCleaningPadMissing = 71;
  }

  enum OperationalStateEnum : enum8 {
    kSeekingCharger = 64;
    kCharging = 65;
    kDocked = 66;
  }

  struct ErrorStateStruct {
    enum8 errorStateID = 0;
    optional char_string<64> errorStateLabel = 1;
    optional char_string<64> errorStateDetails = 2;
  }

  struct OperationalStateStruct {
    enum8 operationalStateID = 0;
    optional char_string<64> operationalStateLabel = 1;
  }

  critical event OperationalError = 0 {
    ErrorStateStruct errorState = 0;
  }

  info event OperationCompletion = 1 {
    enum8 completionErrorCode = 0;
    optional nullable elapsed_s totalOperationalTime = 1;
    optional nullable elapsed_s pausedTime = 2;
  }

  readonly attribute nullable char_string phaseList[] = 0;
  readonly attribute nullable int8u currentPhase = 1;
  readonly attribute optional nullable elapsed_s countdownTime = 2;
  readonly attribute OperationalStateStruct operationalStateList[] = 3;
  readonly attribute enum8 operationalState = 4;
  readonly attribute ErrorStateStruct operationalError = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct OperationalCommandResponse = 4 {
    ErrorStateStruct commandResponseState = 0;
  }

  /** Upon receipt, the device SHALL pause its operation if it is possible based on the current function of the server. */
  command Pause(): OperationalCommandResponse = 0;
  /** Upon receipt, the device SHALL resume its operation from the point it was at when it received the Pause command, or from the point when it was paused by means outside of this cluster (for example by manual button press). */
  command Resume(): OperationalCommandResponse = 3;
  /** On receipt of this command, the device SHALL start seeking the charging dock, if possible in the current state of the device. */
  command GoHome(): OperationalCommandResponse = 128;
}

/** Attributes and commands for scene configuration and manipulation. */
provisional cluster ScenesManagement = 98 {
  revision 1;

  bitmap CopyModeBitmap : bitmap8 {
    kCopyAllScenes = 0x1;
  }

  bitmap Feature : bitmap32 {
    kSceneNames = 0x1;
  }

  struct AttributeValuePair {
    attrib_id attributeID = 0;
    int32u attributeValue = 1;
  }

  struct ExtensionFieldSet {
    cluster_id clusterID = 0;
    AttributeValuePair attributeValueList[] = 1;
  }

  fabric_scoped struct SceneInfoStruct {
    int8u sceneCount = 0;
    fabric_sensitive int8u currentScene = 1;
    fabric_sensitive group_id currentGroup = 2;
    fabric_sensitive boolean sceneValid = 3;
    int8u remainingCapacity = 4;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute optional nullable node_id lastConfiguredBy = 0;
  readonly attribute int16u sceneTableSize = 1;
  readonly attribute SceneInfoStruct fabricSceneInfo[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
    int32u transitionTime = 2;
    char_string sceneName = 3;
    ExtensionFieldSet extensionFieldSets[] = 4;
  }

  response struct AddSceneResponse = 0 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct ViewSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct ViewSceneResponse = 1 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
    optional int32u transitionTime = 3;
    optional char_string sceneName = 4;
    optional ExtensionFieldSet extensionFieldSets[] = 5;
  }

  request struct RemoveSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct RemoveSceneResponse = 2 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct RemoveAllScenesRequest {
    group_id groupID = 0;
  }

  response struct RemoveAllScenesResponse = 3 {
    status status = 0;
    group_id groupID = 1;
  }

  request struct StoreSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct StoreSceneResponse = 4 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct RecallSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
    optional nullable int32u transitionTime = 2;
  }

  request struct GetSceneMembershipRequest {
    group_id groupID = 0;
  }

  response struct GetSceneMembershipResponse = 6 {
    status status = 0;
    nullable int8u capacity = 1;
    group_id groupID = 2;
    optional int8u sceneList[] = 3;
  }

  request struct CopySceneRequest {
    CopyModeBitmap mode = 0;
    group_id groupIdentifierFrom = 1;
    int8u sceneIdentifierFrom = 2;
    group_id groupIdentifierTo = 3;
    int8u sceneIdentifierTo = 4;
  }

  response struct CopySceneResponse = 64 {
    status status = 0;
    group_id groupIdentifierFrom = 1;
    int8u sceneIdentifierFrom = 2;
  }

  /** Add a scene to the scene table. Extension field sets are supported, and are inputed as '{"ClusterID": VALUE, "AttributeValueList":[{"AttributeId": VALUE, "AttributeValue": VALUE}]}' */
  fabric command access(invoke: manage) AddScene(AddSceneRequest): AddSceneResponse = 0;
  /** Retrieves the requested scene entry from its Scene table. */
  fabric command ViewScene(ViewSceneRequest): ViewSceneResponse = 1;
  /** Removes the requested scene entry, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveScene(RemoveSceneRequest): RemoveSceneResponse = 2;
  /** Remove all scenes, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveAllScenes(RemoveAllScenesRequest): RemoveAllScenesResponse = 3;
  /** Adds the scene entry into its Scene Table along with all extension field sets corresponding to the current state of other clusters on the same endpoint */
  fabric command access(invoke: manage) StoreScene(StoreSceneRequest): StoreSceneResponse = 4;
  /** Set the attributes and corresponding state for each other cluster implemented on the endpoint accordingly to the resquested scene entry in the Scene Table */
  fabric command RecallScene(RecallSceneRequest): DefaultSuccess = 5;
  /** Get an unused scene identifier when no commissioning tool is in the network, or for a commissioning tool to get the used scene identifiers within a certain group */
  fabric command GetSceneMembership(GetSceneMembershipRequest): GetSceneMembershipResponse = 6;
  /** Allows a client to efficiently copy scenes from one group/scene identifier pair to another group/scene identifier pair. */
  fabric command CopyScene(CopySceneRequest): CopySceneResponse = 64;
}

/** Attributes and commands for monitoring HEPA filters in a device */
cluster HepaFilterMonitoring = 113 {
  revision 1; // NOTE: Default/not specifically set

  enum ChangeIndicationEnum : enum8 {
    kOK = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum ProductIdentifierTypeEnum : enum8 {
    kUPC = 0;
    kGTIN8 = 1;
    kEAN = 2;
    kGTIN14 = 3;
    kOEM = 4;
  }

  bitmap Feature : bitmap32 {
    kCondition = 0x1;
    kWarning = 0x2;
    kReplacementProductList = 0x4;
  }

  struct ReplacementProductStruct {
    ProductIdentifierTypeEnum productIdentifierType = 0;
    char_string<20> productIdentifierValue = 1;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  attribute optional nullable epoch_s lastChangedTime = 4;
  readonly attribute optional ReplacementProductStruct replacementProductList[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring activated carbon filters in a device */
cluster ActivatedCarbonFilterMonitoring = 114 {
  revision 1; // NOTE: Default/not specifically set

  enum ChangeIndicationEnum : enum8 {
    kOK = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum ProductIdentifierTypeEnum : enum8 {
    kUPC = 0;
    kGTIN8 = 1;
    kEAN = 2;
    kGTIN14 = 3;
    kOEM = 4;
  }

  bitmap Feature : bitmap32 {
    kCondition = 0x1;
    kWarning = 0x2;
    kReplacementProductList = 0x4;
  }

  struct ReplacementProductStruct {
    ProductIdentifierTypeEnum productIdentifierType = 0;
    char_string<20> productIdentifierValue = 1;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  attribute optional nullable epoch_s lastChangedTime = 4;
  readonly attribute optional ReplacementProductStruct replacementProductList[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** This cluster is used to configure a boolean sensor. */
cluster BooleanStateConfiguration = 128 {
  revision 1;

  bitmap AlarmModeBitmap : bitmap8 {
    kVisual = 0x1;
    kAudible = 0x2;
  }

  bitmap Feature : bitmap32 {
    kVisual = 0x1;
    kAudible = 0x2;
    kAlarmSuppress = 0x4;
    kSensitivityLevel = 0x8;
  }

  bitmap SensorFaultBitmap : bitmap16 {
    kGeneralFault = 0x1;
  }

  info event AlarmsStateChanged = 0 {
    AlarmModeBitmap alarmsActive = 0;
    optional AlarmModeBitmap alarmsSuppressed = 1;
  }

  info event SensorFault = 1 {
    SensorFaultBitmap sensorFault = 0;
  }

  attribute optional int8u currentSensitivityLevel = 0;
  readonly attribute optional int8u supportedSensitivityLevels = 1;
  readonly attribute optional int8u defaultSensitivityLevel = 2;
  readonly attribute optional AlarmModeBitmap alarmsActive = 3;
  readonly attribute optional AlarmModeBitmap alarmsSuppressed = 4;
  readonly attribute optional AlarmModeBitmap alarmsEnabled = 5;
  readonly attribute optional AlarmModeBitmap alarmsSupported = 6;
  readonly attribute optional SensorFaultBitmap sensorFault = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SuppressAlarmRequest {
    AlarmModeBitmap alarmsToSuppress = 0;
  }

  request struct EnableDisableAlarmRequest {
    AlarmModeBitmap alarmsToEnableDisable = 0;
  }

  /** This command is used to suppress the specified alarm mode. */
  command SuppressAlarm(SuppressAlarmRequest): DefaultSuccess = 0;
  /** This command is used to enable or disable the specified alarm mode. */
  command EnableDisableAlarm(EnableDisableAlarmRequest): DefaultSuccess = 1;
}

/** This cluster is used to configure a valve. */
cluster ValveConfigurationAndControl = 129 {
  revision 1;

  enum StatusCodeEnum : enum8 {
    kFailureDueToFault = 2;
  }

  enum ValveStateEnum : enum8 {
    kClosed = 0;
    kOpen = 1;
    kTransitioning = 2;
  }

  bitmap Feature : bitmap32 {
    kTimeSync = 0x1;
    kLevel = 0x2;
  }

  bitmap ValveFaultBitmap : bitmap16 {
    kGeneralFault = 0x1;
    kBlocked = 0x2;
    kLeaking = 0x4;
    kNotConnected = 0x8;
    kShortCircuit = 0x10;
    kCurrentExceeded = 0x20;
  }

  info event ValveStateChanged = 0 {
    ValveStateEnum valveState = 0;
    optional percent valveLevel = 1;
  }

  info event ValveFault = 1 {
    ValveFaultBitmap valveFault = 0;
  }

  readonly attribute nullable elapsed_s openDuration = 0;
  attribute nullable elapsed_s defaultOpenDuration = 1;
  readonly attribute optional nullable epoch_us autoCloseTime = 2;
  readonly attribute nullable elapsed_s remainingDuration = 3;
  readonly attribute nullable ValveStateEnum currentState = 4;
  readonly attribute nullable ValveStateEnum targetState = 5;
  readonly attribute optional nullable percent currentLevel = 6;
  readonly attribute optional nullable percent targetLevel = 7;
  attribute optional percent defaultOpenLevel = 8;
  readonly attribute optional ValveFaultBitmap valveFault = 9;
  readonly attribute optional int8u levelStep = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenRequest {
    optional nullable elapsed_s openDuration = 0;
    optional percent targetLevel = 1;
  }

  /** This command is used to set the valve to its open position. */
  command Open(OpenRequest): DefaultSuccess = 0;
  /** This command is used to set the valve to its closed position. */
  command Close(): DefaultSuccess = 1;
}

/** This cluster provides a mechanism for querying data about electrical power as measured by the server. */
cluster ElectricalPowerMeasurement = 144 {
  revision 1;

  enum MeasurementTypeEnum : enum16 {
    kUnspecified = 0;
    kVoltage = 1;
    kActiveCurrent = 2;
    kReactiveCurrent = 3;
    kApparentCurrent = 4;
    kActivePower = 5;
    kReactivePower = 6;
    kApparentPower = 7;
    kRMSVoltage = 8;
    kRMSCurrent = 9;
    kRMSPower = 10;
    kFrequency = 11;
    kPowerFactor = 12;
    kNeutralCurrent = 13;
    kElectricalEnergy = 14;
  }

  enum PowerModeEnum : enum8 {
    kUnknown = 0;
    kDC = 1;
    kAC = 2;
  }

  bitmap Feature : bitmap32 {
    kDirectCurrent = 0x1;
    kAlternatingCurrent = 0x2;
    kPolyphasePower = 0x4;
    kHarmonics = 0x8;
    kPowerQuality = 0x10;
  }

  struct MeasurementAccuracyRangeStruct {
    int64s rangeMin = 0;
    int64s rangeMax = 1;
    optional percent100ths percentMax = 2;
    optional percent100ths percentMin = 3;
    optional percent100ths percentTypical = 4;
    optional int64u fixedMax = 5;
    optional int64u fixedMin = 6;
    optional int64u fixedTypical = 7;
  }

  struct MeasurementAccuracyStruct {
    MeasurementTypeEnum measurementType = 0;
    boolean measured = 1;
    int64s minMeasuredValue = 2;
    int64s maxMeasuredValue = 3;
    MeasurementAccuracyRangeStruct accuracyRanges[] = 4;
  }

  struct HarmonicMeasurementStruct {
    int8u order = 0;
    nullable int64s measurement = 1;
  }

  struct MeasurementRangeStruct {
    MeasurementTypeEnum measurementType = 0;
    int64s min = 1;
    int64s max = 2;
    optional epoch_s startTimestamp = 3;
    optional epoch_s endTimestamp = 4;
    optional epoch_s minTimestamp = 5;
    optional epoch_s maxTimestamp = 6;
    optional systime_ms startSystime = 7;
    optional systime_ms endSystime = 8;
    optional systime_ms minSystime = 9;
    optional systime_ms maxSystime = 10;
  }

  info event MeasurementPeriodRanges = 0 {
    MeasurementRangeStruct ranges[] = 0;
  }

  readonly attribute PowerModeEnum powerMode = 0;
  readonly attribute int8u numberOfMeasurementTypes = 1;
  readonly attribute MeasurementAccuracyStruct accuracy[] = 2;
  readonly attribute optional MeasurementRangeStruct ranges[] = 3;
  readonly attribute optional nullable voltage_mv voltage = 4;
  readonly attribute optional nullable amperage_ma activeCurrent = 5;
  readonly attribute optional nullable amperage_ma reactiveCurrent = 6;
  readonly attribute optional nullable amperage_ma apparentCurrent = 7;
  readonly attribute nullable power_mw activePower = 8;
  readonly attribute optional nullable power_mw reactivePower = 9;
  readonly attribute optional nullable power_mw apparentPower = 10;
  readonly attribute optional nullable voltage_mv RMSVoltage = 11;
  readonly attribute optional nullable amperage_ma RMSCurrent = 12;
  readonly attribute optional nullable power_mw RMSPower = 13;
  readonly attribute optional nullable int64s frequency = 14;
  readonly attribute optional nullable HarmonicMeasurementStruct harmonicCurrents[] = 15;
  readonly attribute optional nullable HarmonicMeasurementStruct harmonicPhases[] = 16;
  readonly attribute optional nullable int64s powerFactor = 17;
  readonly attribute optional nullable amperage_ma neutralCurrent = 18;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides a mechanism for querying data about the electrical energy imported or provided by the server. */
cluster ElectricalEnergyMeasurement = 145 {
  revision 1;

  enum MeasurementTypeEnum : enum16 {
    kUnspecified = 0;
    kVoltage = 1;
    kActiveCurrent = 2;
    kReactiveCurrent = 3;
    kApparentCurrent = 4;
    kActivePower = 5;
    kReactivePower = 6;
    kApparentPower = 7;
    kRMSVoltage = 8;
    kRMSCurrent = 9;
    kRMSPower = 10;
    kFrequency = 11;
    kPowerFactor = 12;
    kNeutralCurrent = 13;
    kElectricalEnergy = 14;
  }

  bitmap Feature : bitmap32 {
    kImportedEnergy = 0x1;
    kExportedEnergy = 0x2;
    kCumulativeEnergy = 0x4;
    kPeriodicEnergy = 0x8;
  }

  struct MeasurementAccuracyRangeStruct {
    int64s rangeMin = 0;
    int64s rangeMax = 1;
    optional percent100ths percentMax = 2;
    optional percent100ths percentMin = 3;
    optional percent100ths percentTypical = 4;
    optional int64u fixedMax = 5;
    optional int64u fixedMin = 6;
    optional int64u fixedTypical = 7;
  }

  struct MeasurementAccuracyStruct {
    MeasurementTypeEnum measurementType = 0;
    boolean measured = 1;
    int64s minMeasuredValue = 2;
    int64s maxMeasuredValue = 3;
    MeasurementAccuracyRangeStruct accuracyRanges[] = 4;
  }

  struct CumulativeEnergyResetStruct {
    optional nullable epoch_s importedResetTimestamp = 0;
    optional nullable epoch_s exportedResetTimestamp = 1;
    optional nullable systime_ms importedResetSystime = 2;
    optional nullable systime_ms exportedResetSystime = 3;
  }

  struct EnergyMeasurementStruct {
    energy_mwh energy = 0;
    optional epoch_s startTimestamp = 1;
    optional epoch_s endTimestamp = 2;
    optional systime_ms startSystime = 3;
    optional systime_ms endSystime = 4;
  }

  info event CumulativeEnergyMeasured = 0 {
    optional EnergyMeasurementStruct energyImported = 0;
    optional EnergyMeasurementStruct energyExported = 1;
  }

  info event PeriodicEnergyMeasured = 1 {
    optional EnergyMeasurementStruct energyImported = 0;
    optional EnergyMeasurementStruct energyExported = 1;
  }

  readonly attribute MeasurementAccuracyStruct accuracy = 0;
  readonly attribute optional nullable EnergyMeasurementStruct cumulativeEnergyImported = 1;
  readonly attribute optional nullable EnergyMeasurementStruct cumulativeEnergyExported = 2;
  readonly attribute optional nullable EnergyMeasurementStruct periodicEnergyImported = 3;
  readonly attribute optional nullable EnergyMeasurementStruct periodicEnergyExported = 4;
  readonly attribute optional nullable CumulativeEnergyResetStruct cumulativeEnergyReset = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface to the functionality of Smart Energy Demand Response and Load Control. */
provisional cluster DemandResponseLoadControl = 150 {
  revision 4;

  enum CriticalityLevelEnum : enum8 {
    kUnknown = 0;
    kGreen = 1;
    kLevel1 = 2;
    kLevel2 = 3;
    kLevel3 = 4;
    kLevel4 = 5;
    kLevel5 = 6;
    kEmergency = 7;
    kPlannedOutage = 8;
    kServiceDisconnect = 9;
  }

  enum HeatingSourceEnum : enum8 {
    kAny = 0;
    kElectric = 1;
    kNonElectric = 2;
  }

  enum LoadControlEventChangeSourceEnum : enum8 {
    kAutomatic = 0;
    kUserAction = 1;
  }

  enum LoadControlEventStatusEnum : enum8 {
    kUnknown = 0;
    kReceived = 1;
    kInProgress = 2;
    kCompleted = 3;
    kOptedOut = 4;
    kOptedIn = 5;
    kCanceled = 6;
    kSuperseded = 7;
    kPartialOptedOut = 8;
    kPartialOptedIn = 9;
    kNoParticipation = 10;
    kUnavailable = 11;
    kFailed = 12;
  }

  bitmap CancelControlBitmap : bitmap16 {
    kRandomEnd = 0x1;
  }

  bitmap DeviceClassBitmap : bitmap32 {
    kHVAC = 0x1;
    kStripHeater = 0x2;
    kWaterHeater = 0x4;
    kPoolPump = 0x8;
    kSmartAppliance = 0x10;
    kIrrigationPump = 0x20;
    kCommercialLoad = 0x40;
    kResidentialLoad = 0x80;
    kExteriorLighting = 0x100;
    kInteriorLighting = 0x200;
    kEV = 0x400;
    kGenerationSystem = 0x800;
    kSmartInverter = 0x1000;
    kEVSE = 0x2000;
    kRESU = 0x4000;
    kEMS = 0x8000;
    kSEM = 0x10000;
  }

  bitmap EventControlBitmap : bitmap16 {
    kRandomStart = 0x1;
  }

  bitmap EventTransitionControlBitmap : bitmap16 {
    kRandomDuration = 0x1;
    kIgnoreOptOut = 0x2;
  }

  bitmap Feature : bitmap32 {
    kEnrollmentGroups = 0x1;
    kTemperatureOffset = 0x2;
    kTemperatureSetpoint = 0x4;
    kLoadAdjustment = 0x8;
    kDutyCycle = 0x10;
    kPowerSavings = 0x20;
    kHeatingSource = 0x40;
  }

  struct HeatingSourceControlStruct {
    HeatingSourceEnum heatingSource = 0;
  }

  struct PowerSavingsControlStruct {
    percent powerSavings = 0;
  }

  struct DutyCycleControlStruct {
    percent dutyCycle = 0;
  }

  struct AverageLoadControlStruct {
    int8s loadAdjustment = 0;
  }

  struct TemperatureControlStruct {
    optional nullable int16u coolingTempOffset = 0;
    optional nullable int16u heatingtTempOffset = 1;
    optional nullable temperature coolingTempSetpoint = 2;
    optional nullable temperature heatingTempSetpoint = 3;
  }

  struct LoadControlEventTransitionStruct {
    int16u duration = 0;
    EventTransitionControlBitmap control = 1;
    optional TemperatureControlStruct temperatureControl = 2;
    optional AverageLoadControlStruct averageLoadControl = 3;
    optional DutyCycleControlStruct dutyCycleControl = 4;
    optional PowerSavingsControlStruct powerSavingsControl = 5;
    optional HeatingSourceControlStruct heatingSourceControl = 6;
  }

  struct LoadControlEventStruct {
    octet_string<16> eventID = 0;
    nullable octet_string<16> programID = 1;
    EventControlBitmap control = 2;
    DeviceClassBitmap deviceClass = 3;
    optional int8u enrollmentGroup = 4;
    CriticalityLevelEnum criticality = 5;
    nullable epoch_s startTime = 6;
    LoadControlEventTransitionStruct transitions[] = 7;
  }

  struct LoadControlProgramStruct {
    octet_string<16> programID = 0;
    long_char_string<32> name = 1;
    nullable int8u enrollmentGroup = 2;
    nullable int8u randomStartMinutes = 3;
    nullable int8u randomDurationMinutes = 4;
  }

  info event LoadControlEventStatusChange = 0 {
    octet_string eventID = 0;
    nullable int8u transitionIndex = 1;
    LoadControlEventStatusEnum status = 2;
    CriticalityLevelEnum criticality = 3;
    EventControlBitmap control = 4;
    optional nullable TemperatureControlStruct temperatureControl = 5;
    optional nullable AverageLoadControlStruct averageLoadControl = 6;
    optional nullable DutyCycleControlStruct dutyCycleControl = 7;
    optional nullable PowerSavingsControlStruct powerSavingsControl = 8;
    optional nullable HeatingSourceControlStruct heatingSourceControl = 9;
  }

  readonly attribute LoadControlProgramStruct loadControlPrograms[] = 0;
  readonly attribute int8u numberOfLoadControlPrograms = 1;
  readonly attribute LoadControlEventStruct events[] = 2;
  readonly attribute LoadControlEventStruct activeEvents[] = 3;
  readonly attribute int8u numberOfEventsPerProgram = 4;
  readonly attribute int8u numberOfTransitions = 5;
  attribute access(write: manage) int8u defaultRandomStart = 6;
  attribute access(write: manage) int8u defaultRandomDuration = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RegisterLoadControlProgramRequestRequest {
    LoadControlProgramStruct loadControlProgram = 0;
  }

  request struct UnregisterLoadControlProgramRequestRequest {
    octet_string<16> loadControlProgramID = 0;
  }

  request struct AddLoadControlEventRequestRequest {
    LoadControlEventStruct event = 0;
  }

  request struct RemoveLoadControlEventRequestRequest {
    octet_string<16> eventID = 0;
    CancelControlBitmap cancelControl = 1;
  }

  /** Upon receipt, this SHALL insert a new LoadControlProgramStruct into LoadControlPrograms, or if the ProgramID matches an existing LoadControlProgramStruct, then the provider SHALL be updated with the provided values. */
  command RegisterLoadControlProgramRequest(RegisterLoadControlProgramRequestRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL remove a the LoadControlProgramStruct from LoadControlPrograms with the matching ProgramID. */
  command UnregisterLoadControlProgramRequest(UnregisterLoadControlProgramRequestRequest): DefaultSuccess = 1;
  /** On receipt of the AddLoadControlEventsRequest command, the server SHALL add a load control event. */
  command AddLoadControlEventRequest(AddLoadControlEventRequestRequest): DefaultSuccess = 2;
  /** Upon receipt, this SHALL remove the LoadControlEventStruct with the matching EventID from LoadEventPrograms. */
  command RemoveLoadControlEventRequest(RemoveLoadControlEventRequestRequest): DefaultSuccess = 3;
  /** Upon receipt, this SHALL clear all the load control events. */
  command ClearLoadControlEventsRequest(): DefaultSuccess = 4;
}

/** This cluster provides an interface for passing messages to be presented by a device. */
provisional cluster Messages = 151 {
  revision 3;

  enum FutureMessagePreferenceEnum : enum8 {
    kAllowed = 0;
    kIncreased = 1;
    kReduced = 2;
    kDisallowed = 3;
    kBanned = 4;
  }

  enum MessagePriorityEnum : enum8 {
    kLow = 0;
    kMedium = 1;
    kHigh = 2;
    kCritical = 3;
  }

  bitmap Feature : bitmap32 {
    kReceivedConfirmation = 0x1;
    kConfirmationResponse = 0x2;
    kConfirmationReply = 0x4;
    kProtectedMessages = 0x8;
  }

  bitmap MessageControlBitmap : bitmap8 {
    kConfirmationRequired = 0x1;
    kResponseRequired = 0x2;
    kReplyMessage = 0x4;
    kMessageConfirmed = 0x8;
    kMessageProtected = 0x10;
  }

  struct MessageResponseOptionStruct {
    optional int32u messageResponseID = 0;
    optional char_string<32> label = 1;
  }

  struct MessageStruct {
    octet_string<16> messageID = 0;
    MessagePriorityEnum priority = 1;
    MessageControlBitmap messageControl = 2;
    nullable epoch_s startTime = 3;
    nullable int64u duration = 4;
    char_string<256> messageText = 5;
    optional MessageResponseOptionStruct responses[] = 6;
  }

  info event MessageQueued = 0 {
    octet_string messageID = 0;
  }

  info event MessagePresented = 1 {
    octet_string messageID = 0;
  }

  info event MessageComplete = 2 {
    octet_string messageID = 0;
    optional nullable int32u responseID = 1;
    optional nullable char_string reply = 2;
    nullable FutureMessagePreferenceEnum futureMessagesPreference = 3;
  }

  readonly attribute MessageStruct messages[] = 0;
  readonly attribute octet_string activeMessageIDs[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct PresentMessagesRequestRequest {
    octet_string<16> messageID = 0;
    MessagePriorityEnum priority = 1;
    MessageControlBitmap messageControl = 2;
    nullable epoch_s startTime = 3;
    nullable int64u duration = 4;
    char_string<256> messageText = 5;
    optional MessageResponseOptionStruct responses[] = 6;
  }

  request struct CancelMessagesRequestRequest {
    octet_string messageIDs[] = 0;
  }

  /** Command for requesting messages be presented */
  fabric command PresentMessagesRequest(PresentMessagesRequestRequest): DefaultSuccess = 0;
  /** Command for cancelling message present requests */
  fabric command CancelMessagesRequest(CancelMessagesRequestRequest): DefaultSuccess = 1;
}

/** This cluster allows a client to manage the power draw of a device. An example of such a client could be an Energy Management System (EMS) which controls an Energy Smart Appliance (ESA). */
provisional cluster DeviceEnergyManagement = 152 {
  revision 3;

  enum AdjustmentCauseEnum : enum8 {
    kLocalOptimization = 0;
    kGridOptimization = 1;
  }

  enum CauseEnum : enum8 {
    kNormalCompletion = 0;
    kOffline = 1;
    kFault = 2;
    kUserOptOut = 3;
    kCancelled = 4;
  }

  enum CostTypeEnum : enum8 {
    kFinancial = 0;
    kGHGEmissions = 1;
    kComfort = 2;
    kTemperature = 3;
  }

  enum ESAStateEnum : enum8 {
    kOffline = 0;
    kOnline = 1;
    kFault = 2;
    kPowerAdjustActive = 3;
    kPaused = 4;
  }

  enum ESATypeEnum : enum8 {
    kEVSE = 0;
    kSpaceHeating = 1;
    kWaterHeating = 2;
    kSpaceCooling = 3;
    kSpaceHeatingCooling = 4;
    kBatteryStorage = 5;
    kSolarPV = 6;
    kFridgeFreezer = 7;
    kWashingMachine = 8;
    kDishwasher = 9;
    kCooking = 10;
    kHomeWaterPump = 11;
    kIrrigationWaterPump = 12;
    kPoolPump = 13;
    kOther = 255;
  }

  enum ForecastUpdateReasonEnum : enum8 {
    kInternalOptimization = 0;
    kLocalOptimization = 1;
    kGridOptimization = 2;
  }

  enum OptOutStateEnum : enum8 {
    kNoOptOut = 0;
    kLocalOptOut = 1;
    kGridOptOut = 2;
    kOptOut = 3;
  }

  bitmap Feature : bitmap32 {
    kPowerAdjustment = 0x1;
    kPowerForecastReporting = 0x2;
    kStateForecastReporting = 0x4;
    kStartTimeAdjustment = 0x8;
    kPausable = 0x10;
    kForecastAdjustment = 0x20;
    kConstraintBasedAdjustment = 0x40;
  }

  struct CostStruct {
    CostTypeEnum costType = 0;
    int32s value = 1;
    int8u decimalPoints = 2;
    optional int16u currency = 3;
  }

  struct SlotStruct {
    elapsed_s minDuration = 0;
    elapsed_s maxDuration = 1;
    elapsed_s defaultDuration = 2;
    elapsed_s elapsedSlotTime = 3;
    elapsed_s remainingSlotTime = 4;
    optional boolean slotIsPauseable = 5;
    optional elapsed_s minPauseDuration = 6;
    optional elapsed_s maxPauseDuration = 7;
    optional int16u manufacturerESAState = 8;
    optional power_mw nominalPower = 9;
    optional power_mw minPower = 10;
    optional power_mw maxPower = 11;
    optional energy_mwh nominalEnergy = 12;
    optional CostStruct costs[] = 13;
    optional power_mw minPowerAdjustment = 14;
    optional power_mw maxPowerAdjustment = 15;
    optional elapsed_s minDurationAdjustment = 16;
    optional elapsed_s maxDurationAdjustment = 17;
  }

  struct ForecastStruct {
    int16u forecastId = 0;
    nullable int16u activeSlotNumber = 1;
    epoch_s startTime = 2;
    epoch_s endTime = 3;
    optional nullable epoch_s earliestStartTime = 4;
    optional epoch_s latestEndTime = 5;
    boolean isPauseable = 6;
    SlotStruct slots[] = 7;
    ForecastUpdateReasonEnum forecastUpdateReason = 8;
  }

  struct ConstraintsStruct {
    epoch_s startTime = 0;
    elapsed_s duration = 1;
    optional power_mw nominalPower = 2;
    optional energy_mwh maximumEnergy = 3;
    optional int8s loadControl = 4;
  }

  struct PowerAdjustStruct {
    power_mw minPower = 0;
    power_mw maxPower = 1;
    elapsed_s minDuration = 2;
    elapsed_s maxDuration = 3;
  }

  struct SlotAdjustmentStruct {
    int8u slotIndex = 0;
    power_mw nominalPower = 1;
    elapsed_s duration = 2;
  }

  info event PowerAdjustStart = 0 {
  }

  info event PowerAdjustEnd = 1 {
    CauseEnum cause = 0;
    elapsed_s duration = 1;
    energy_mwh energyUse = 2;
  }

  info event Paused = 2 {
  }

  info event Resumed = 3 {
    CauseEnum cause = 0;
  }

  readonly attribute ESATypeEnum ESAType = 0;
  readonly attribute boolean ESACanGenerate = 1;
  readonly attribute ESAStateEnum ESAState = 2;
  readonly attribute power_mw absMinPower = 3;
  readonly attribute power_mw absMaxPower = 4;
  readonly attribute optional nullable PowerAdjustStruct powerAdjustmentCapability[] = 5;
  readonly attribute optional nullable ForecastStruct forecast = 6;
  readonly attribute optional OptOutStateEnum optOutState = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct PowerAdjustRequestRequest {
    power_mw power = 0;
    elapsed_s duration = 1;
    AdjustmentCauseEnum cause = 2;
  }

  request struct StartTimeAdjustRequestRequest {
    epoch_s requestedStartTime = 0;
    AdjustmentCauseEnum cause = 1;
  }

  request struct PauseRequestRequest {
    elapsed_s duration = 0;
    AdjustmentCauseEnum cause = 1;
  }

  request struct ModifyForecastRequestRequest {
    int32u forecastId = 0;
    SlotAdjustmentStruct slotAdjustments[] = 1;
    AdjustmentCauseEnum cause = 2;
  }

  request struct RequestConstraintBasedForecastRequest {
    ConstraintsStruct constraints[] = 0;
    AdjustmentCauseEnum cause = 1;
  }

  /** Allows a client to request an adjustment in the power consumption of an ESA for a specified duration. */
  command PowerAdjustRequest(PowerAdjustRequestRequest): DefaultSuccess = 0;
  /** Allows a client to cancel an ongoing PowerAdjustmentRequest operation. */
  command CancelPowerAdjustRequest(): DefaultSuccess = 1;
  /** Allows a client to adjust the start time of a Forecast sequence that has not yet started operation (i.e. where the current Forecast StartTime is in the future). */
  command StartTimeAdjustRequest(StartTimeAdjustRequestRequest): DefaultSuccess = 2;
  /** Allows a client to temporarily pause an operation and reduce the ESAs energy demand. */
  command PauseRequest(PauseRequestRequest): DefaultSuccess = 3;
  /** Allows a client to cancel the PauseRequest command and enable earlier resumption of operation. */
  command ResumeRequest(): DefaultSuccess = 4;
  /** Allows a client to modify a Forecast within the limits allowed by the ESA. */
  command ModifyForecastRequest(ModifyForecastRequestRequest): DefaultSuccess = 5;
  /** Allows a client to ask the ESA to recompute its Forecast based on power and time constraints. */
  command RequestConstraintBasedForecast(RequestConstraintBasedForecastRequest): DefaultSuccess = 6;
  /** Allows a client to request cancellation of a previous adjustment request in a StartTimeAdjustRequest, ModifyForecastRequest or RequestConstraintBasedForecast command */
  command CancelRequest(): DefaultSuccess = 7;
}

/** Electric Vehicle Supply Equipment (EVSE) is equipment used to charge an Electric Vehicle (EV) or Plug-In Hybrid Electric Vehicle. This cluster provides an interface to the functionality of Electric Vehicle Supply Equipment (EVSE) management. */
cluster EnergyEvse = 153 {
  revision 2;

  enum EnergyTransferStoppedReasonEnum : enum8 {
    kEVStopped = 0;
    kEVSEStopped = 1;
    kOther = 2;
  }

  enum FaultStateEnum : enum8 {
    kNoError = 0;
    kMeterFailure = 1;
    kOverVoltage = 2;
    kUnderVoltage = 3;
    kOverCurrent = 4;
    kContactWetFailure = 5;
    kContactDryFailure = 6;
    kGroundFault = 7;
    kPowerLoss = 8;
    kPowerQuality = 9;
    kPilotShortCircuit = 10;
    kEmergencyStop = 11;
    kEVDisconnected = 12;
    kWrongPowerSupply = 13;
    kLiveNeutralSwap = 14;
    kOverTemperature = 15;
    kOther = 255;
  }

  enum StateEnum : enum8 {
    kNotPluggedIn = 0;
    kPluggedInNoDemand = 1;
    kPluggedInDemand = 2;
    kPluggedInCharging = 3;
    kPluggedInDischarging = 4;
    kSessionEnding = 5;
    kFault = 6;
  }

  enum SupplyStateEnum : enum8 {
    kDisabled = 0;
    kChargingEnabled = 1;
    kDischargingEnabled = 2;
    kDisabledError = 3;
    kDisabledDiagnostics = 4;
  }

  bitmap Feature : bitmap32 {
    kChargingPreferences = 0x1;
    kSoCReporting = 0x2;
    kPlugAndCharge = 0x4;
    kRFID = 0x8;
    kV2X = 0x10;
  }

  bitmap TargetDayOfWeekBitmap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  struct ChargingTargetStruct {
    int16u targetTimeMinutesPastMidnight = 0;
    optional percent targetSoC = 1;
    optional energy_mwh addedEnergy = 2;
  }

  struct ChargingTargetScheduleStruct {
    TargetDayOfWeekBitmap dayOfWeekForSequence = 0;
    ChargingTargetStruct chargingTargets[] = 1;
  }

  info event EVConnected = 0 {
    int32u sessionID = 0;
  }

  info event EVNotDetected = 1 {
    int32u sessionID = 0;
    StateEnum state = 1;
    elapsed_s sessionDuration = 2;
    energy_mwh sessionEnergyCharged = 3;
    optional energy_mwh sessionEnergyDischarged = 4;
  }

  info event EnergyTransferStarted = 2 {
    int32u sessionID = 0;
    StateEnum state = 1;
    amperage_ma maximumCurrent = 2;
  }

  info event EnergyTransferStopped = 3 {
    int32u sessionID = 0;
    StateEnum state = 1;
    EnergyTransferStoppedReasonEnum reason = 2;
    energy_mwh energyTransferred = 4;
  }

  critical event Fault = 4 {
    nullable int32u sessionID = 0;
    StateEnum state = 1;
    FaultStateEnum faultStatePreviousState = 2;
    FaultStateEnum faultStateCurrentState = 4;
  }

  info event RFID = 5 {
    octet_string uid = 0;
  }

  readonly attribute nullable StateEnum state = 0;
  readonly attribute SupplyStateEnum supplyState = 1;
  readonly attribute FaultStateEnum faultState = 2;
  readonly attribute nullable epoch_s chargingEnabledUntil = 3;
  readonly attribute optional nullable epoch_s dischargingEnabledUntil = 4;
  readonly attribute amperage_ma circuitCapacity = 5;
  readonly attribute amperage_ma minimumChargeCurrent = 6;
  readonly attribute amperage_ma maximumChargeCurrent = 7;
  readonly attribute optional amperage_ma maximumDischargeCurrent = 8;
  attribute access(write: manage) optional amperage_ma userMaximumChargeCurrent = 9;
  attribute access(write: manage) optional elapsed_s randomizationDelayWindow = 10;
  readonly attribute optional nullable epoch_s nextChargeStartTime = 35;
  readonly attribute optional nullable epoch_s nextChargeTargetTime = 36;
  readonly attribute optional nullable energy_mwh nextChargeRequiredEnergy = 37;
  readonly attribute optional nullable percent nextChargeTargetSoC = 38;
  attribute access(write: manage) optional nullable int16u approximateEVEfficiency = 39;
  readonly attribute optional nullable percent stateOfCharge = 48;
  readonly attribute optional nullable energy_mwh batteryCapacity = 49;
  readonly attribute optional nullable char_string<32> vehicleID = 50;
  readonly attribute nullable int32u sessionID = 64;
  readonly attribute nullable elapsed_s sessionDuration = 65;
  readonly attribute nullable energy_mwh sessionEnergyCharged = 66;
  readonly attribute optional nullable energy_mwh sessionEnergyDischarged = 67;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct GetTargetsResponse = 0 {
    ChargingTargetScheduleStruct chargingTargetSchedules[] = 0;
  }

  request struct EnableChargingRequest {
    nullable epoch_s chargingEnabledUntil = 0;
    amperage_ma minimumChargeCurrent = 1;
    amperage_ma maximumChargeCurrent = 2;
  }

  request struct EnableDischargingRequest {
    nullable epoch_s dischargingEnabledUntil = 0;
    amperage_ma maximumDischargeCurrent = 1;
  }

  request struct SetTargetsRequest {
    ChargingTargetScheduleStruct chargingTargetSchedules[] = 0;
  }

  /** Allows a client to disable the EVSE from charging and discharging. */
  timed command Disable(): DefaultSuccess = 1;
  /** Allows a client to enable the EVSE to charge an EV. */
  timed command EnableCharging(EnableChargingRequest): DefaultSuccess = 2;
  /** Allows a client to enable the EVSE to discharge an EV. */
  timed command EnableDischarging(EnableDischargingRequest): DefaultSuccess = 3;
  /** Allows a client to put the EVSE into a self-diagnostics mode. */
  timed command StartDiagnostics(): DefaultSuccess = 4;
  /** Allows a client to set the user specified charging targets. */
  timed command SetTargets(SetTargetsRequest): DefaultSuccess = 5;
  /** Allows a client to retrieve the user specified charging targets. */
  timed command GetTargets(): GetTargetsResponse = 6;
  /** Allows a client to clear all stored charging targets. */
  timed command ClearTargets(): DefaultSuccess = 7;
}

/** This cluster provides an interface to specify preferences for how devices should consume energy. */
provisional cluster EnergyPreference = 155 {
  revision 1;

  enum EnergyPriorityEnum : enum8 {
    kComfort = 0;
    kSpeed = 1;
    kEfficiency = 2;
    kWaterConsumption = 3;
  }

  bitmap Feature : bitmap32 {
    kEnergyBalance = 0x1;
    kLowPowerModeSensitivity = 0x2;
  }

  struct BalanceStruct {
    percent step = 0;
    optional char_string<64> label = 1;
  }

  readonly attribute optional BalanceStruct energyBalances[] = 0;
  attribute optional int8u currentEnergyBalance = 1;
  readonly attribute optional EnergyPriorityEnum energyPriorities[] = 2;
  readonly attribute optional BalanceStruct lowPowerModeSensitivities[] = 3;
  attribute optional int8u currentLowPowerModeSensitivity = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Power Topology Cluster provides a mechanism for expressing how power is flowing between endpoints. */
cluster PowerTopology = 156 {
  revision 1;

  bitmap Feature : bitmap32 {
    kNodeTopology = 0x1;
    kTreeTopology = 0x2;
    kSetTopology = 0x4;
    kDynamicPowerFlow = 0x8;
  }

  readonly attribute optional endpoint_no availableEndpoints[] = 0;
  readonly attribute optional endpoint_no activeEndpoints[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster EnergyEvseMode = 157 {
  revision 1;

  enum ModeTag : enum16 {
    kManual = 16384;
    kTimeOfUse = 16385;
    kSolarCharging = 16386;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string<64> statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
provisional cluster DeviceEnergyManagementMode = 159 {
  revision 1;

  enum ModeTag : enum16 {
    kNoOptimization = 16384;
    kDeviceOptimization = 16385;
    kLocalOptimization = 16386;
    kGridOptimization = 16387;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string<64> statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** An interface to a generic way to secure a door */
cluster DoorLock = 257 {
  revision 7;

  enum AlarmCodeEnum : enum8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : enum8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : enum8 {
    kProgrammingPIN = 0;
    kPIN = 1;
    kRFID = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
    kAliroCredentialIssuerKey = 6;
    kAliroEvictableEndpointKey = 7;
    kAliroNonEvictableEndpointKey = 8;
  }

  enum DataOperationTypeEnum : enum8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : enum8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : enum8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : enum8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : enum8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : enum8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : enum8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : enum8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPIN = 6;
    kRFID = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
    kAliroCredentialIssuerKey = 11;
    kAliroEvictableEndpointKey = 12;
    kAliroNonEvictableEndpointKey = 13;
  }

  enum LockOperationTypeEnum : enum8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : enum8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : enum8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : enum8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRFID = 8;
    kBiometric = 9;
    kAliro = 10;
  }

  enum UserStatusEnum : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : enum8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : bitmap16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : bitmap8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : bitmap16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : bitmap32 {
    kPINCredential = 0x1;
    kRFIDCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
    kAliroProvisioning = 0x2000;
    kAliroBLEUWB = 0x4000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable int16u userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable node_id sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    nullable int16u dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute optional nullable DoorStateEnum doorState = 3;
  attribute access(write: manage) optional int32u doorOpenEvents = 4;
  attribute access(write: manage) optional int32u doorClosedEvents = 5;
  attribute access(write: manage) optional int16u openPeriod = 6;
  readonly attribute optional int16u numberOfTotalUsersSupported = 17;
  readonly attribute optional int16u numberOfPINUsersSupported = 18;
  readonly attribute optional int16u numberOfRFIDUsersSupported = 19;
  readonly attribute optional int8u numberOfWeekDaySchedulesSupportedPerUser = 20;
  readonly attribute optional int8u numberOfYearDaySchedulesSupportedPerUser = 21;
  readonly attribute optional int8u numberOfHolidaySchedulesSupported = 22;
  readonly attribute optional int8u maxPINCodeLength = 23;
  readonly attribute optional int8u minPINCodeLength = 24;
  readonly attribute optional int8u maxRFIDCodeLength = 25;
  readonly attribute optional int8u minRFIDCodeLength = 26;
  readonly attribute optional DlCredentialRuleMask credentialRulesSupport = 27;
  readonly attribute optional int8u numberOfCredentialsSupportedPerUser = 28;
  attribute access(write: manage) optional char_string<3> language = 33;
  attribute access(write: manage) optional int8u LEDSettings = 34;
  attribute access(write: manage) int32u autoRelockTime = 35;
  attribute access(write: manage) optional int8u soundVolume = 36;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  readonly attribute optional DlDefaultConfigurationRegister defaultConfigurationRegister = 39;
  attribute access(write: administer) optional boolean enableLocalProgramming = 40;
  attribute access(write: manage) optional boolean enableOneTouchLocking = 41;
  attribute access(write: manage) optional boolean enableInsideStatusLED = 42;
  attribute access(write: manage) optional boolean enablePrivacyModeButton = 43;
  attribute access(write: administer) optional DlLocalProgrammingFeatures localProgrammingFeatures = 44;
  attribute access(write: administer) optional int8u wrongCodeEntryLimit = 48;
  attribute access(write: administer) optional int8u userCodeTemporaryDisableTime = 49;
  attribute access(write: administer) optional boolean sendPINOverTheAir = 50;
  attribute access(write: administer) optional boolean requirePINforRemoteOperation = 51;
  attribute access(write: administer) optional int16u expiringUserTimeout = 53;
  readonly attribute access(read: administer) optional nullable octet_string<65> aliroReaderVerificationKey = 128;
  readonly attribute access(read: administer) optional nullable octet_string<16> aliroReaderGroupIdentifier = 129;
  readonly attribute access(read: administer) optional octet_string<16> aliroReaderGroupSubIdentifier = 130;
  readonly attribute access(read: administer) optional octet_string aliroExpeditedTransactionSupportedProtocolVersions[] = 131;
  readonly attribute access(read: administer) optional nullable octet_string<16> aliroGroupResolvingKey = 132;
  readonly attribute access(read: administer) optional octet_string aliroSupportedBLEUWBProtocolVersions[] = 133;
  readonly attribute access(read: administer) optional int8u aliroBLEAdvertisingVersion = 134;
  readonly attribute optional int16u numberOfAliroCredentialIssuerKeysSupported = 135;
  readonly attribute optional int16u numberOfAliroEndpointKeysSupported = 136;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockWithTimeoutRequest {
    int16u timeout = 0;
    optional octet_string PINCode = 1;
  }

  request struct SetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DaysMaskMap daysMask = 2;
    int8u startHour = 3;
    int8u startMinute = 4;
    int8u endHour = 5;
    int8u endMinute = 6;
  }

  request struct GetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetWeekDayScheduleResponse = 12 {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional DaysMaskMap daysMask = 3;
    optional int8u startHour = 4;
    optional int8u startMinute = 5;
    optional int8u endHour = 6;
    optional int8u endMinute = 7;
  }

  request struct ClearWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    epoch_s localStartTime = 2;
    epoch_s localEndTime = 3;
  }

  request struct GetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetYearDayScheduleResponse = 15 {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional epoch_s localStartTime = 3;
    optional epoch_s localEndTime = 4;
  }

  request struct ClearYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetHolidayScheduleRequest {
    int8u holidayIndex = 0;
    epoch_s localStartTime = 1;
    epoch_s localEndTime = 2;
    OperatingModeEnum operatingMode = 3;
  }

  request struct GetHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  response struct GetHolidayScheduleResponse = 18 {
    int8u holidayIndex = 0;
    DlStatus status = 1;
    optional epoch_s localStartTime = 2;
    optional epoch_s localEndTime = 3;
    optional OperatingModeEnum operatingMode = 4;
  }

  request struct ClearHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    int16u userIndex = 1;
    nullable char_string userName = 2;
    nullable int32u userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    int16u userIndex = 0;
  }

  response struct GetUserResponse = 28 {
    int16u userIndex = 0;
    nullable char_string userName = 1;
    nullable int32u userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable int16u nextUserIndex = 9;
  }

  request struct ClearUserRequest {
    int16u userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    long_octet_string credentialData = 2;
    nullable int16u userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable int16u userIndex = 1;
    nullable int16u nextCredentialIndex = 2;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable int16u userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable int16u nextCredentialIndex = 4;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  request struct UnboltDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct SetAliroReaderConfigRequest {
    octet_string<32> signingKey = 0;
    octet_string<65> verificationKey = 1;
    octet_string<16> groupIdentifier = 2;
    optional octet_string<16> groupResolvingKey = 3;
  }

  /** This command causes the lock device to lock the door. */
  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  /** This command causes the lock device to unlock the door. */
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  /** This command causes the lock device to unlock the door with a timeout parameter. */
  timed command UnlockWithTimeout(UnlockWithTimeoutRequest): DefaultSuccess = 3;
  /** Set a weekly repeating schedule for a specified user. */
  command access(invoke: administer) SetWeekDaySchedule(SetWeekDayScheduleRequest): DefaultSuccess = 11;
  /** Retrieve the specific weekly schedule for the specific user. */
  command access(invoke: administer) GetWeekDaySchedule(GetWeekDayScheduleRequest): GetWeekDayScheduleResponse = 12;
  /** Clear the specific weekly schedule or all weekly schedules for the specific user. */
  command access(invoke: administer) ClearWeekDaySchedule(ClearWeekDayScheduleRequest): DefaultSuccess = 13;
  /** Set a time-specific schedule ID for a specified user. */
  command access(invoke: administer) SetYearDaySchedule(SetYearDayScheduleRequest): DefaultSuccess = 14;
  /** Returns the year day schedule data for the specified schedule and user indexes. */
  command access(invoke: administer) GetYearDaySchedule(GetYearDayScheduleRequest): GetYearDayScheduleResponse = 15;
  /** Clears the specific year day schedule or all year day schedules for the specific user. */
  command access(invoke: administer) ClearYearDaySchedule(ClearYearDayScheduleRequest): DefaultSuccess = 16;
  /** Set the holiday Schedule by specifying local start time and local end time with respect to any Lock Operating Mode. */
  command access(invoke: administer) SetHolidaySchedule(SetHolidayScheduleRequest): DefaultSuccess = 17;
  /** Get the holiday schedule for the specified index. */
  command access(invoke: administer) GetHolidaySchedule(GetHolidayScheduleRequest): GetHolidayScheduleResponse = 18;
  /** Clears the holiday schedule or all holiday schedules. */
  command access(invoke: administer) ClearHolidaySchedule(ClearHolidayScheduleRequest): DefaultSuccess = 19;
  /** Set User into the lock. */
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  /** Retrieve User. */
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  /** Clears a User or all Users. */
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  /** Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or ProgrammingUser. */
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  /** Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index. */
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
  /** Clear one, one type, or all credentials except ProgrammingPIN credential. */
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
  /** This command causes the lock device to unlock the door without pulling the latch. */
  timed command UnboltDoor(UnboltDoorRequest): DefaultSuccess = 39;
  /** This command communicates an Aliro Reader configuration to the lock. */
  timed command access(invoke: administer) SetAliroReaderConfig(SetAliroReaderConfigRequest): DefaultSuccess = 40;
  /** This command clears an existing Aliro Reader configuration for the lock. */
  timed command access(invoke: administer) ClearAliroReaderConfig(): DefaultSuccess = 41;
}

/** Provides an interface for controlling and adjusting automatic window coverings. */
cluster WindowCovering = 258 {
  revision 5;

  enum EndProductType : enum8 {
    kRollerShade = 0;
    kRomanShade = 1;
    kBalloonShade = 2;
    kWovenWood = 3;
    kPleatedShade = 4;
    kCellularShade = 5;
    kLayeredShade = 6;
    kLayeredShade2D = 7;
    kSheerShade = 8;
    kTiltOnlyInteriorBlind = 9;
    kInteriorBlind = 10;
    kVerticalBlindStripCurtain = 11;
    kInteriorVenetianBlind = 12;
    kExteriorVenetianBlind = 13;
    kLateralLeftCurtain = 14;
    kLateralRightCurtain = 15;
    kCentralCurtain = 16;
    kRollerShutter = 17;
    kExteriorVerticalScreen = 18;
    kAwningTerracePatio = 19;
    kAwningVerticalScreen = 20;
    kTiltOnlyPergola = 21;
    kSwingingShutter = 22;
    kSlidingShutter = 23;
    kUnknown = 255;
  }

  enum Type : enum8 {
    kRollerShade = 0;
    kRollerShade2Motor = 1;
    kRollerShadeExterior = 2;
    kRollerShadeExterior2Motor = 3;
    kDrapery = 4;
    kAwning = 5;
    kShutter = 6;
    kTiltBlindTiltOnly = 7;
    kTiltBlindLiftAndTilt = 8;
    kProjectorScreen = 9;
    kUnknown = 255;
  }

  bitmap ConfigStatus : bitmap8 {
    kOperational = 0x1;
    kOnlineReserved = 0x2;
    kLiftMovementReversed = 0x4;
    kLiftPositionAware = 0x8;
    kTiltPositionAware = 0x10;
    kLiftEncoderControlled = 0x20;
    kTiltEncoderControlled = 0x40;
  }

  bitmap Feature : bitmap32 {
    kLift = 0x1;
    kTilt = 0x2;
    kPositionAwareLift = 0x4;
    kAbsolutePosition = 0x8;
    kPositionAwareTilt = 0x10;
  }

  bitmap Mode : bitmap8 {
    kMotorDirectionReversed = 0x1;
    kCalibrationMode = 0x2;
    kMaintenanceMode = 0x4;
    kLedFeedback = 0x8;
  }

  bitmap OperationalStatus : bitmap8 {
    kGlobal = 0x3;
    kLift = 0xC;
    kTilt = 0x30;
  }

  bitmap SafetyStatus : bitmap16 {
    kRemoteLockout = 0x1;
    kTamperDetection = 0x2;
    kFailedCommunication = 0x4;
    kPositionFailure = 0x8;
    kThermalProtection = 0x10;
    kObstacleDetected = 0x20;
    kPower = 0x40;
    kStopInput = 0x80;
    kMotorJammed = 0x100;
    kHardwareFailure = 0x200;
    kManualOperation = 0x400;
    kProtection = 0x800;
  }

  readonly attribute Type type = 0;
  readonly attribute optional int16u physicalClosedLimitLift = 1;
  readonly attribute optional int16u physicalClosedLimitTilt = 2;
  readonly attribute optional nullable int16u currentPositionLift = 3;
  readonly attribute optional nullable int16u currentPositionTilt = 4;
  readonly attribute optional int16u numberOfActuationsLift = 5;
  readonly attribute optional int16u numberOfActuationsTilt = 6;
  readonly attribute ConfigStatus configStatus = 7;
  readonly attribute optional nullable percent currentPositionLiftPercentage = 8;
  readonly attribute optional nullable percent currentPositionTiltPercentage = 9;
  readonly attribute OperationalStatus operationalStatus = 10;
  readonly attribute optional nullable percent100ths targetPositionLiftPercent100ths = 11;
  readonly attribute optional nullable percent100ths targetPositionTiltPercent100ths = 12;
  readonly attribute EndProductType endProductType = 13;
  readonly attribute optional nullable percent100ths currentPositionLiftPercent100ths = 14;
  readonly attribute optional nullable percent100ths currentPositionTiltPercent100ths = 15;
  readonly attribute optional int16u installedOpenLimitLift = 16;
  readonly attribute optional int16u installedClosedLimitLift = 17;
  readonly attribute optional int16u installedOpenLimitTilt = 18;
  readonly attribute optional int16u installedClosedLimitTilt = 19;
  attribute access(write: manage) Mode mode = 23;
  readonly attribute optional SafetyStatus safetyStatus = 26;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GoToLiftValueRequest {
    int16u liftValue = 0;
  }

  request struct GoToLiftPercentageRequest {
    percent100ths liftPercent100thsValue = 0;
  }

  request struct GoToTiltValueRequest {
    int16u tiltValue = 0;
  }

  request struct GoToTiltPercentageRequest {
    percent100ths tiltPercent100thsValue = 0;
  }

  /** Moves window covering to InstalledOpenLimitLift and InstalledOpenLimitTilt */
  command UpOrOpen(): DefaultSuccess = 0;
  /** Moves window covering to InstalledClosedLimitLift and InstalledCloseLimitTilt */
  command DownOrClose(): DefaultSuccess = 1;
  /** Stop any adjusting of window covering */
  command StopMotion(): DefaultSuccess = 2;
  /** Go to lift value specified */
  command GoToLiftValue(GoToLiftValueRequest): DefaultSuccess = 4;
  /** Go to lift percentage specified */
  command GoToLiftPercentage(GoToLiftPercentageRequest): DefaultSuccess = 5;
  /** Go to tilt value specified */
  command GoToTiltValue(GoToTiltValueRequest): DefaultSuccess = 7;
  /** Go to tilt percentage specified */
  command GoToTiltPercentage(GoToTiltPercentageRequest): DefaultSuccess = 8;
}

/** This cluster provides control of a barrier (garage door). */
deprecated cluster BarrierControl = 259 {
  revision 1; // NOTE: Default/not specifically set

  bitmap BarrierControlCapabilities : bitmap8 {
    kPartialBarrier = 0x1;
  }

  bitmap BarrierControlSafetyStatus : bitmap16 {
    kRemoteLockout = 0x1;
    kTemperDetected = 0x2;
    kFailedCommunication = 0x4;
    kPositionFailure = 0x8;
  }

  readonly attribute enum8 barrierMovingState = 1;
  readonly attribute bitmap16 barrierSafetyStatus = 2;
  readonly attribute bitmap8 barrierCapabilities = 3;
  attribute optional int16u barrierOpenEvents = 4;
  attribute optional int16u barrierCloseEvents = 5;
  attribute optional int16u barrierCommandOpenEvents = 6;
  attribute optional int16u barrierCommandCloseEvents = 7;
  attribute optional int16u barrierOpenPeriod = 8;
  attribute optional int16u barrierClosePeriod = 9;
  readonly attribute int8u barrierPosition = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct BarrierControlGoToPercentRequest {
    int8u percentOpen = 0;
  }

  /** Command to instruct a barrier to go to a percent open state. */
  command BarrierControlGoToPercent(BarrierControlGoToPercentRequest): DefaultSuccess = 0;
  /** Command that instructs the barrier to stop moving. */
  command BarrierControlStop(): DefaultSuccess = 1;
}

/** An interface for configuring and controlling pumps. */
cluster PumpConfigurationAndControl = 512 {
  revision 3;

  enum ControlModeEnum : enum8 {
    kConstantSpeed = 0;
    kConstantPressure = 1;
    kProportionalPressure = 2;
    kConstantFlow = 3;
    kConstantTemperature = 5;
    kAutomatic = 7;
  }

  enum OperationModeEnum : enum8 {
    kNormal = 0;
    kMinimum = 1;
    kMaximum = 2;
    kLocal = 3;
  }

  bitmap Feature : bitmap32 {
    kConstantPressure = 0x1;
    kCompensatedPressure = 0x2;
    kConstantFlow = 0x4;
    kConstantSpeed = 0x8;
    kConstantTemperature = 0x10;
    kAutomatic = 0x20;
    kLocalOperation = 0x40;
  }

  bitmap PumpStatusBitmap : bitmap16 {
    kDeviceFault = 0x1;
    kSupplyFault = 0x2;
    kSpeedLow = 0x4;
    kSpeedHigh = 0x8;
    kLocalOverride = 0x10;
    kRunning = 0x20;
    kRemotePressure = 0x40;
    kRemoteFlow = 0x80;
    kRemoteTemperature = 0x100;
  }

  info event SupplyVoltageLow = 0 {
  }

  info event SupplyVoltageHigh = 1 {
  }

  info event PowerMissingPhase = 2 {
  }

  info event SystemPressureLow = 3 {
  }

  info event SystemPressureHigh = 4 {
  }

  critical event DryRunning = 5 {
  }

  info event MotorTemperatureHigh = 6 {
  }

  critical event PumpMotorFatalFailure = 7 {
  }

  info event ElectronicTemperatureHigh = 8 {
  }

  critical event PumpBlocked = 9 {
  }

  info event SensorFailure = 10 {
  }

  info event ElectronicNonFatalFailure = 11 {
  }

  critical event ElectronicFatalFailure = 12 {
  }

  info event GeneralFault = 13 {
  }

  info event Leakage = 14 {
  }

  info event AirDetection = 15 {
  }

  info event TurbineOperation = 16 {
  }

  readonly attribute nullable int16s maxPressure = 0;
  readonly attribute nullable int16u maxSpeed = 1;
  readonly attribute nullable int16u maxFlow = 2;
  readonly attribute optional nullable int16s minConstPressure = 3;
  readonly attribute optional nullable int16s maxConstPressure = 4;
  readonly attribute optional nullable int16s minCompPressure = 5;
  readonly attribute optional nullable int16s maxCompPressure = 6;
  readonly attribute optional nullable int16u minConstSpeed = 7;
  readonly attribute optional nullable int16u maxConstSpeed = 8;
  readonly attribute optional nullable int16u minConstFlow = 9;
  readonly attribute optional nullable int16u maxConstFlow = 10;
  readonly attribute optional nullable int16s minConstTemp = 11;
  readonly attribute optional nullable int16s maxConstTemp = 12;
  readonly attribute optional PumpStatusBitmap pumpStatus = 16;
  readonly attribute OperationModeEnum effectiveOperationMode = 17;
  readonly attribute ControlModeEnum effectiveControlMode = 18;
  readonly attribute nullable int16s capacity = 19;
  readonly attribute optional nullable int16u speed = 20;
  attribute access(write: manage) optional nullable int24u lifetimeRunningHours = 21;
  readonly attribute optional nullable int24u power = 22;
  attribute access(write: manage) optional nullable int32u lifetimeEnergyConsumed = 23;
  attribute access(write: manage) OperationModeEnum operationMode = 32;
  attribute access(write: manage) optional ControlModeEnum controlMode = 33;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** An interface for configuring and controlling the functionality of a thermostat. */
cluster Thermostat = 513 {
  revision 6;

  enum ACCapacityFormatEnum : enum8 {
    kBTUh = 0;
  }

  enum ACCompressorTypeEnum : enum8 {
    kUnknown = 0;
    kT1 = 1;
    kT2 = 2;
    kT3 = 3;
  }

  enum ACLouverPositionEnum : enum8 {
    kClosed = 1;
    kOpen = 2;
    kQuarter = 3;
    kHalf = 4;
    kThreeQuarters = 5;
  }

  enum ACRefrigerantTypeEnum : enum8 {
    kUnknown = 0;
    kR22 = 1;
    kR410a = 2;
    kR407c = 3;
  }

  enum ACTypeEnum : enum8 {
    kUnknown = 0;
    kCoolingFixed = 1;
    kHeatPumpFixed = 2;
    kCoolingInverter = 3;
    kHeatPumpInverter = 4;
  }

  enum ControlSequenceOfOperationEnum : enum8 {
    kCoolingOnly = 0;
    kCoolingWithReheat = 1;
    kHeatingOnly = 2;
    kHeatingWithReheat = 3;
    kCoolingAndHeating = 4;
    kCoolingAndHeatingWithReheat = 5;
  }

  enum PresetScenarioEnum : enum8 {
    kUnspecified = 0;
    kOccupied = 1;
    kUnoccupied = 2;
    kSleep = 3;
    kWake = 4;
    kVacation = 5;
    kUserDefined = 6;
  }

  enum SetpointChangeSourceEnum : enum8 {
    kManual = 0;
    kSchedule = 1;
    kExternal = 2;
  }

  enum SetpointRaiseLowerModeEnum : enum8 {
    kHeat = 0;
    kCool = 1;
    kBoth = 2;
  }

  enum StartOfWeekEnum : enum8 {
    kSunday = 0;
    kMonday = 1;
    kTuesday = 2;
    kWednesday = 3;
    kThursday = 4;
    kFriday = 5;
    kSaturday = 6;
  }

  enum SystemModeEnum : enum8 {
    kOff = 0;
    kAuto = 1;
    kCool = 3;
    kHeat = 4;
    kEmergencyHeat = 5;
    kPrecooling = 6;
    kFanOnly = 7;
    kDry = 8;
    kSleep = 9;
  }

  enum TemperatureSetpointHoldEnum : enum8 {
    kSetpointHoldOff = 0;
    kSetpointHoldOn = 1;
  }

  enum ThermostatRunningModeEnum : enum8 {
    kOff = 0;
    kCool = 3;
    kHeat = 4;
  }

  bitmap ACErrorCodeBitmap : bitmap32 {
    kCompressorFail = 0x1;
    kRoomSensorFail = 0x2;
    kOutdoorSensorFail = 0x4;
    kCoilSensorFail = 0x8;
    kFanFail = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHeating = 0x1;
    kCooling = 0x2;
    kOccupancy = 0x4;
    kScheduleConfiguration = 0x8;
    kSetback = 0x10;
    kAutoMode = 0x20;
    kLocalTemperatureNotExposed = 0x40;
    kMatterScheduleConfiguration = 0x80;
    kPresets = 0x100;
    kSetpoints = 0x200;
    kQueuedPresetsSupported = 0x400;
  }

  bitmap HVACSystemTypeBitmap : bitmap8 {
    kCoolingStage = 0x3;
    kHeatingStage = 0xC;
    kHeatingIsHeatPump = 0x10;
    kHeatingUsesFuel = 0x20;
  }

  bitmap PresetTypeFeaturesBitmap : bitmap16 {
    kAutomatic = 0x1;
    kSupportsNames = 0x2;
  }

  bitmap ProgrammingOperationModeBitmap : bitmap8 {
    kScheduleActive = 0x1;
    kAutoRecovery = 0x2;
    kEconomy = 0x4;
  }

  bitmap RelayStateBitmap : bitmap16 {
    kHeat = 0x1;
    kCool = 0x2;
    kFan = 0x4;
    kHeatStage2 = 0x8;
    kCoolStage2 = 0x10;
    kFanStage2 = 0x20;
    kFanStage3 = 0x40;
  }

  bitmap RemoteSensingBitmap : bitmap8 {
    kLocalTemperature = 0x1;
    kOutdoorTemperature = 0x2;
    kOccupancy = 0x4;
  }

  bitmap ScheduleDayOfWeekBitmap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
    kAway = 0x80;
  }

  bitmap ScheduleModeBitmap : bitmap8 {
    kHeatSetpointPresent = 0x1;
    kCoolSetpointPresent = 0x2;
  }

  bitmap ScheduleTypeFeaturesBitmap : bitmap16 {
    kSupportsPresets = 0x1;
    kSupportsSetpoints = 0x2;
    kSupportsNames = 0x4;
    kSupportsOff = 0x8;
  }

  bitmap TemperatureSetpointHoldPolicyBitmap : bitmap8 {
    kHoldDurationElapsed = 0x1;
    kHoldDurationElapsedOrPresetChanged = 0x2;
  }

  struct ScheduleTransitionStruct {
    ScheduleDayOfWeekBitmap dayOfWeek = 0;
    int16u transitionTime = 1;
    optional octet_string<16> presetHandle = 2;
    optional SystemModeEnum systemMode = 3;
    optional temperature coolingSetpoint = 4;
    optional temperature heatingSetpoint = 5;
  }

  struct ScheduleStruct {
    nullable octet_string<16> scheduleHandle = 0;
    SystemModeEnum systemMode = 1;
    optional char_string<64> name = 2;
    optional octet_string<16> presetHandle = 3;
    ScheduleTransitionStruct transitions[] = 4;
    optional nullable boolean builtIn = 5;
  }

  struct PresetStruct {
    nullable octet_string<16> presetHandle = 0;
    PresetScenarioEnum presetScenario = 1;
    optional nullable char_string<64> name = 2;
    optional temperature coolingSetpoint = 3;
    optional temperature heatingSetpoint = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetTypeStruct {
    PresetScenarioEnum presetScenario = 0;
    int8u numberOfPresets = 1;
    PresetTypeFeaturesBitmap presetTypeFeatures = 2;
  }

  struct QueuedPresetStruct {
    nullable octet_string<16> presetHandle = 0;
    nullable epoch_s transitionTimestamp = 1;
  }

  struct ScheduleTypeStruct {
    SystemModeEnum systemMode = 0;
    int8u numberOfSchedules = 1;
    ScheduleTypeFeaturesBitmap scheduleTypeFeatures = 2;
  }

  struct WeeklyScheduleTransitionStruct {
    int16u transitionTime = 0;
    nullable temperature heatSetpoint = 1;
    nullable temperature coolSetpoint = 2;
  }

  readonly attribute nullable temperature localTemperature = 0;
  readonly attribute optional nullable temperature outdoorTemperature = 1;
  readonly attribute optional bitmap8 occupancy = 2;
  readonly attribute optional temperature absMinHeatSetpointLimit = 3;
  readonly attribute optional temperature absMaxHeatSetpointLimit = 4;
  readonly attribute optional temperature absMinCoolSetpointLimit = 5;
  readonly attribute optional temperature absMaxCoolSetpointLimit = 6;
  readonly attribute optional int8u PICoolingDemand = 7;
  readonly attribute optional int8u PIHeatingDemand = 8;
  attribute access(write: manage) optional bitmap8 HVACSystemTypeConfiguration = 9;
  attribute access(write: manage) optional int8s localTemperatureCalibration = 16;
  attribute optional int16s occupiedCoolingSetpoint = 17;
  attribute optional int16s occupiedHeatingSetpoint = 18;
  attribute optional int16s unoccupiedCoolingSetpoint = 19;
  attribute optional int16s unoccupiedHeatingSetpoint = 20;
  attribute access(write: manage) optional int16s minHeatSetpointLimit = 21;
  attribute access(write: manage) optional int16s maxHeatSetpointLimit = 22;
  attribute access(write: manage) optional int16s minCoolSetpointLimit = 23;
  attribute access(write: manage) optional int16s maxCoolSetpointLimit = 24;
  attribute access(write: manage) optional int8s minSetpointDeadBand = 25;
  attribute access(write: manage) optional RemoteSensingBitmap remoteSensing = 26;
  attribute access(write: manage) ControlSequenceOfOperationEnum controlSequenceOfOperation = 27;
  attribute access(write: manage) SystemModeEnum systemMode = 28;
  readonly attribute optional ThermostatRunningModeEnum thermostatRunningMode = 30;
  readonly attribute optional StartOfWeekEnum startOfWeek = 32;
  readonly attribute optional int8u numberOfWeeklyTransitions = 33;
  readonly attribute optional int8u numberOfDailyTransitions = 34;
  attribute access(write: manage) optional TemperatureSetpointHoldEnum temperatureSetpointHold = 35;
  attribute access(write: manage) optional nullable int16u temperatureSetpointHoldDuration = 36;
  attribute access(write: manage) optional ProgrammingOperationModeBitmap thermostatProgrammingOperationMode = 37;
  readonly attribute optional RelayStateBitmap thermostatRunningState = 41;
  readonly attribute optional SetpointChangeSourceEnum setpointChangeSource = 48;
  readonly attribute optional nullable int16s setpointChangeAmount = 49;
  readonly attribute optional epoch_s setpointChangeSourceTimestamp = 50;
  attribute access(write: manage) optional nullable int8u occupiedSetback = 52;
  readonly attribute optional nullable int8u occupiedSetbackMin = 53;
  readonly attribute optional nullable int8u occupiedSetbackMax = 54;
  attribute access(write: manage) optional nullable int8u unoccupiedSetback = 55;
  readonly attribute optional nullable int8u unoccupiedSetbackMin = 56;
  readonly attribute optional nullable int8u unoccupiedSetbackMax = 57;
  attribute access(write: manage) optional int8u emergencyHeatDelta = 58;
  attribute access(write: manage) optional ACTypeEnum ACType = 64;
  attribute access(write: manage) optional int16u ACCapacity = 65;
  attribute access(write: manage) optional ACRefrigerantTypeEnum ACRefrigerantType = 66;
  attribute access(write: manage) optional ACCompressorTypeEnum ACCompressorType = 67;
  attribute access(write: manage) optional ACErrorCodeBitmap ACErrorCode = 68;
  attribute access(write: manage) optional ACLouverPositionEnum ACLouverPosition = 69;
  readonly attribute optional nullable temperature ACCoilTemperature = 70;
  attribute access(write: manage) optional ACCapacityFormatEnum ACCapacityformat = 71;
  readonly attribute optional PresetTypeStruct presetTypes[] = 72;
  readonly attribute optional ScheduleTypeStruct scheduleTypes[] = 73;
  readonly attribute optional int8u numberOfPresets = 74;
  readonly attribute optional int8u numberOfSchedules = 75;
  readonly attribute optional int8u numberOfScheduleTransitions = 76;
  readonly attribute optional nullable int8u numberOfScheduleTransitionPerDay = 77;
  readonly attribute optional nullable octet_string<16> activePresetHandle = 78;
  readonly attribute optional nullable octet_string<16> activeScheduleHandle = 79;
  attribute access(write: manage) optional PresetStruct presets[] = 80;
  attribute access(write: manage) optional ScheduleStruct schedules[] = 81;
  readonly attribute optional boolean presetsSchedulesEditable = 82;
  readonly attribute optional TemperatureSetpointHoldPolicyBitmap temperatureSetpointHoldPolicy = 83;
  readonly attribute optional nullable epoch_s setpointHoldExpiryTimestamp = 84;
  readonly attribute optional nullable QueuedPresetStruct queuedPreset = 85;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetpointRaiseLowerRequest {
    SetpointRaiseLowerModeEnum mode = 0;
    int8s amount = 1;
  }

  response struct GetWeeklyScheduleResponse = 0 {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct SetWeeklyScheduleRequest {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct GetWeeklyScheduleRequest {
    ScheduleDayOfWeekBitmap daysToReturn = 0;
    ScheduleModeBitmap modeToReturn = 1;
  }

  request struct SetActiveScheduleRequestRequest {
    octet_string<16> scheduleHandle = 0;
  }

  request struct SetActivePresetRequestRequest {
    octet_string<16> presetHandle = 0;
    optional int16u delayMinutes = 1;
  }

  request struct StartPresetsSchedulesEditRequestRequest {
    int16u timeoutSeconds = 0;
  }

  request struct SetTemperatureSetpointHoldPolicyRequest {
    TemperatureSetpointHoldPolicyBitmap temperatureSetpointHoldPolicy = 0;
  }

  /** Command description for SetpointRaiseLower */
  command SetpointRaiseLower(SetpointRaiseLowerRequest): DefaultSuccess = 0;
  /** Command description for SetWeeklySchedule */
  command access(invoke: manage) SetWeeklySchedule(SetWeeklyScheduleRequest): DefaultSuccess = 1;
  /** Command description for GetWeeklySchedule */
  command GetWeeklySchedule(GetWeeklyScheduleRequest): GetWeeklyScheduleResponse = 2;
  /** This command is used to clear the weekly schedule. The ClearWeeklySchedule command has no payload. */
  command access(invoke: manage) ClearWeeklySchedule(): DefaultSuccess = 3;
  /** This command is used to set the active schedule. */
  command SetActiveScheduleRequest(SetActiveScheduleRequestRequest): DefaultSuccess = 5;
  /** This command is used to set the active preset. */
  command SetActivePresetRequest(SetActivePresetRequestRequest): DefaultSuccess = 6;
  /** This command is used to start editing the presets and schedules. */
  command access(invoke: manage) StartPresetsSchedulesEditRequest(StartPresetsSchedulesEditRequestRequest): DefaultSuccess = 7;
  /** This command is used to cancel editing presets and schedules. */
  command access(invoke: manage) CancelPresetsSchedulesEditRequest(): DefaultSuccess = 8;
  /** This command is used to notify the server that all edits are done and should be committed. */
  command access(invoke: manage) CommitPresetsSchedulesRequest(): DefaultSuccess = 9;
  /** This command is sent to cancel a queued preset. */
  command access(invoke: manage) CancelSetActivePresetRequest(): DefaultSuccess = 10;
  /** This command sets the set point hold policy. */
  command SetTemperatureSetpointHoldPolicy(SetTemperatureSetpointHoldPolicyRequest): DefaultSuccess = 11;
}

/** An interface for controlling a fan in a heating/cooling system. */
cluster FanControl = 514 {
  revision 4;

  enum AirflowDirectionEnum : enum8 {
    kForward = 0;
    kReverse = 1;
  }

  enum FanModeEnum : enum8 {
    kOff = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kOn = 4;
    kAuto = 5;
    kSmart = 6;
  }

  enum FanModeSequenceEnum : enum8 {
    kOffLowMedHigh = 0;
    kOffLowHigh = 1;
    kOffLowMedHighAuto = 2;
    kOffLowHighAuto = 3;
    kOffHighAuto = 4;
    kOffHigh = 5;
  }

  enum StepDirectionEnum : enum8 {
    kIncrease = 0;
    kDecrease = 1;
  }

  bitmap Feature : bitmap32 {
    kMultiSpeed = 0x1;
    kAuto = 0x2;
    kRocking = 0x4;
    kWind = 0x8;
    kStep = 0x10;
    kAirflowDirection = 0x20;
  }

  bitmap RockBitmap : bitmap8 {
    kRockLeftRight = 0x1;
    kRockUpDown = 0x2;
    kRockRound = 0x4;
  }

  bitmap WindBitmap : bitmap8 {
    kSleepWind = 0x1;
    kNaturalWind = 0x2;
  }

  attribute FanModeEnum fanMode = 0;
  readonly attribute FanModeSequenceEnum fanModeSequence = 1;
  attribute nullable percent percentSetting = 2;
  readonly attribute percent percentCurrent = 3;
  readonly attribute optional int8u speedMax = 4;
  attribute optional nullable int8u speedSetting = 5;
  readonly attribute optional int8u speedCurrent = 6;
  readonly attribute optional RockBitmap rockSupport = 7;
  attribute optional RockBitmap rockSetting = 8;
  readonly attribute optional WindBitmap windSupport = 9;
  attribute optional WindBitmap windSetting = 10;
  attribute optional AirflowDirectionEnum airflowDirection = 11;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct StepRequest {
    StepDirectionEnum direction = 0;
    optional boolean wrap = 1;
    optional boolean lowestOff = 2;
  }

  /** The Step command speeds up or slows down the fan, in steps. */
  command Step(StepRequest): DefaultSuccess = 0;
}

/** An interface for configuring the user interface of a thermostat (which may be remote from the thermostat). */
cluster ThermostatUserInterfaceConfiguration = 516 {
  revision 2;

  enum KeypadLockoutEnum : enum8 {
    kNoLockout = 0;
    kLockout1 = 1;
    kLockout2 = 2;
    kLockout3 = 3;
    kLockout4 = 4;
    kLockout5 = 5;
  }

  enum ScheduleProgrammingVisibilityEnum : enum8 {
    kScheduleProgrammingPermitted = 0;
    kScheduleProgrammingDenied = 1;
  }

  enum TemperatureDisplayModeEnum : enum8 {
    kCelsius = 0;
    kFahrenheit = 1;
  }

  attribute TemperatureDisplayModeEnum temperatureDisplayMode = 0;
  attribute access(write: manage) KeypadLockoutEnum keypadLockout = 1;
  attribute access(write: manage) optional ScheduleProgrammingVisibilityEnum scheduleProgrammingVisibility = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for controlling the color properties of a color-capable light. */
cluster ColorControl = 768 {
  revision 6;

  enum ColorLoopAction : enum8 {
    kDeactivate = 0;
    kActivateFromColorLoopStartEnhancedHue = 1;
    kActivateFromEnhancedCurrentHue = 2;
  }

  enum ColorLoopDirection : enum8 {
    kDecrementHue = 0;
    kIncrementHue = 1;
  }

  enum ColorMode : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperature = 2;
  }

  enum HueDirection : enum8 {
    kShortestDistance = 0;
    kLongestDistance = 1;
    kUp = 2;
    kDown = 3;
  }

  enum HueMoveMode : enum8 {
    kStop = 0;
    kUp = 1;
    kDown = 3;
  }

  enum HueStepMode : enum8 {
    kUp = 1;
    kDown = 3;
  }

  enum SaturationMoveMode : enum8 {
    kStop = 0;
    kUp = 1;
    kDown = 3;
  }

  enum SaturationStepMode : enum8 {
    kUp = 1;
    kDown = 3;
  }

  bitmap ColorCapabilities : bitmap16 {
    kHueSaturationSupported = 0x1;
    kEnhancedHueSupported = 0x2;
    kColorLoopSupported = 0x4;
    kXYAttributesSupported = 0x8;
    kColorTemperatureSupported = 0x10;
  }

  bitmap ColorLoopUpdateFlags : bitmap8 {
    kUpdateAction = 0x1;
    kUpdateDirection = 0x2;
    kUpdateTime = 0x4;
    kUpdateStartHue = 0x8;
  }

  bitmap Feature : bitmap32 {
    kHueAndSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8;
    kColorTemperature = 0x10;
  }

  readonly attribute optional int8u currentHue = 0;
  readonly attribute optional int8u currentSaturation = 1;
  readonly attribute optional int16u remainingTime = 2;
  readonly attribute optional int16u currentX = 3;
  readonly attribute optional int16u currentY = 4;
  readonly attribute optional enum8 driftCompensation = 5;
  readonly attribute optional char_string<254> compensationText = 6;
  readonly attribute optional int16u colorTemperatureMireds = 7;
  readonly attribute enum8 colorMode = 8;
  attribute bitmap8 options = 15;
  readonly attribute nullable int8u numberOfPrimaries = 16;
  readonly attribute optional int16u primary1X = 17;
  readonly attribute optional int16u primary1Y = 18;
  readonly attribute optional nullable int8u primary1Intensity = 19;
  readonly attribute optional int16u primary2X = 21;
  readonly attribute optional int16u primary2Y = 22;
  readonly attribute optional nullable int8u primary2Intensity = 23;
  readonly attribute optional int16u primary3X = 25;
  readonly attribute optional int16u primary3Y = 26;
  readonly attribute optional nullable int8u primary3Intensity = 27;
  readonly attribute optional int16u primary4X = 32;
  readonly attribute optional int16u primary4Y = 33;
  readonly attribute optional nullable int8u primary4Intensity = 34;
  readonly attribute optional int16u primary5X = 36;
  readonly attribute optional int16u primary5Y = 37;
  readonly attribute optional nullable int8u primary5Intensity = 38;
  readonly attribute optional int16u primary6X = 40;
  readonly attribute optional int16u primary6Y = 41;
  readonly attribute optional nullable int8u primary6Intensity = 42;
  attribute access(write: manage) optional int16u whitePointX = 48;
  attribute access(write: manage) optional int16u whitePointY = 49;
  attribute access(write: manage) optional int16u colorPointRX = 50;
  attribute access(write: manage) optional int16u colorPointRY = 51;
  attribute access(write: manage) optional nullable int8u colorPointRIntensity = 52;
  attribute access(write: manage) optional int16u colorPointGX = 54;
  attribute access(write: manage) optional int16u colorPointGY = 55;
  attribute access(write: manage) optional nullable int8u colorPointGIntensity = 56;
  attribute access(write: manage) optional int16u colorPointBX = 58;
  attribute access(write: manage) optional int16u colorPointBY = 59;
  attribute access(write: manage) optional nullable int8u colorPointBIntensity = 60;
  readonly attribute optional int16u enhancedCurrentHue = 16384;
  readonly attribute enum8 enhancedColorMode = 16385;
  readonly attribute optional int8u colorLoopActive = 16386;
  readonly attribute optional int8u colorLoopDirection = 16387;
  readonly attribute optional int16u colorLoopTime = 16388;
  readonly attribute optional int16u colorLoopStartEnhancedHue = 16389;
  readonly attribute optional int16u colorLoopStoredEnhancedHue = 16390;
  readonly attribute bitmap16 colorCapabilities = 16394;
  readonly attribute optional int16u colorTempPhysicalMinMireds = 16395;
  readonly attribute optional int16u colorTempPhysicalMaxMireds = 16396;
  readonly attribute optional int16u coupleColorTempToLevelMinMireds = 16397;
  attribute access(write: manage) optional nullable int16u startUpColorTemperatureMireds = 16400;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToHueRequest {
    int8u hue = 0;
    HueDirection direction = 1;
    int16u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct MoveHueRequest {
    HueMoveMode moveMode = 0;
    int8u rate = 1;
    bitmap8 optionsMask = 2;
    bitmap8 optionsOverride = 3;
  }

  request struct StepHueRequest {
    HueStepMode stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct MoveToSaturationRequest {
    int8u saturation = 0;
    int16u transitionTime = 1;
    bitmap8 optionsMask = 2;
    bitmap8 optionsOverride = 3;
  }

  request struct MoveSaturationRequest {
    SaturationMoveMode moveMode = 0;
    int8u rate = 1;
    bitmap8 optionsMask = 2;
    bitmap8 optionsOverride = 3;
  }

  request struct StepSaturationRequest {
    SaturationStepMode stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct MoveToHueAndSaturationRequest {
    int8u hue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct MoveToColorRequest {
    int16u colorX = 0;
    int16u colorY = 1;
    int16u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct MoveColorRequest {
    int16s rateX = 0;
    int16s rateY = 1;
    bitmap8 optionsMask = 2;
    bitmap8 optionsOverride = 3;
  }

  request struct StepColorRequest {
    int16s stepX = 0;
    int16s stepY = 1;
    int16u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct MoveToColorTemperatureRequest {
    int16u colorTemperatureMireds = 0;
    int16u transitionTime = 1;
    bitmap8 optionsMask = 2;
    bitmap8 optionsOverride = 3;
  }

  request struct EnhancedMoveToHueRequest {
    int16u enhancedHue = 0;
    HueDirection direction = 1;
    int16u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct EnhancedMoveHueRequest {
    HueMoveMode moveMode = 0;
    int16u rate = 1;
    bitmap8 optionsMask = 2;
    bitmap8 optionsOverride = 3;
  }

  request struct EnhancedStepHueRequest {
    HueStepMode stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct EnhancedMoveToHueAndSaturationRequest {
    int16u enhancedHue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    bitmap8 optionsMask = 3;
    bitmap8 optionsOverride = 4;
  }

  request struct ColorLoopSetRequest {
    ColorLoopUpdateFlags updateFlags = 0;
    ColorLoopAction action = 1;
    ColorLoopDirection direction = 2;
    int16u time = 3;
    int16u startHue = 4;
    bitmap8 optionsMask = 5;
    bitmap8 optionsOverride = 6;
  }

  request struct StopMoveStepRequest {
    bitmap8 optionsMask = 0;
    bitmap8 optionsOverride = 1;
  }

  request struct MoveColorTemperatureRequest {
    HueMoveMode moveMode = 0;
    int16u rate = 1;
    int16u colorTemperatureMinimumMireds = 2;
    int16u colorTemperatureMaximumMireds = 3;
    bitmap8 optionsMask = 4;
    bitmap8 optionsOverride = 5;
  }

  request struct StepColorTemperatureRequest {
    HueStepMode stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    int16u colorTemperatureMinimumMireds = 3;
    int16u colorTemperatureMaximumMireds = 4;
    bitmap8 optionsMask = 5;
    bitmap8 optionsOverride = 6;
  }

  /** Move to specified hue. */
  command MoveToHue(MoveToHueRequest): DefaultSuccess = 0;
  /** Move hue up or down at specified rate. */
  command MoveHue(MoveHueRequest): DefaultSuccess = 1;
  /** Step hue up or down by specified size at specified rate. */
  command StepHue(StepHueRequest): DefaultSuccess = 2;
  /** Move to specified saturation. */
  command MoveToSaturation(MoveToSaturationRequest): DefaultSuccess = 3;
  /** Move saturation up or down at specified rate. */
  command MoveSaturation(MoveSaturationRequest): DefaultSuccess = 4;
  /** Step saturation up or down by specified size at specified rate. */
  command StepSaturation(StepSaturationRequest): DefaultSuccess = 5;
  /** Move to hue and saturation. */
  command MoveToHueAndSaturation(MoveToHueAndSaturationRequest): DefaultSuccess = 6;
  /** Move to specified color. */
  command MoveToColor(MoveToColorRequest): DefaultSuccess = 7;
  /** Moves the color. */
  command MoveColor(MoveColorRequest): DefaultSuccess = 8;
  /** Steps the lighting to a specific color. */
  command StepColor(StepColorRequest): DefaultSuccess = 9;
  /** Move to a specific color temperature. */
  command MoveToColorTemperature(MoveToColorTemperatureRequest): DefaultSuccess = 10;
  /** Command description for EnhancedMoveToHue */
  command EnhancedMoveToHue(EnhancedMoveToHueRequest): DefaultSuccess = 64;
  /** Command description for EnhancedMoveHue */
  command EnhancedMoveHue(EnhancedMoveHueRequest): DefaultSuccess = 65;
  /** Command description for EnhancedStepHue */
  command EnhancedStepHue(EnhancedStepHueRequest): DefaultSuccess = 66;
  /** Command description for EnhancedMoveToHueAndSaturation */
  command EnhancedMoveToHueAndSaturation(EnhancedMoveToHueAndSaturationRequest): DefaultSuccess = 67;
  /** Command description for ColorLoopSet */
  command ColorLoopSet(ColorLoopSetRequest): DefaultSuccess = 68;
  /** Command description for StopMoveStep */
  command StopMoveStep(StopMoveStepRequest): DefaultSuccess = 71;
  /** Command description for MoveColorTemperature */
  command MoveColorTemperature(MoveColorTemperatureRequest): DefaultSuccess = 75;
  /** Command description for StepColorTemperature */
  command StepColorTemperature(StepColorTemperatureRequest): DefaultSuccess = 76;
}

/** Attributes and commands for configuring a lighting ballast. */
provisional cluster BallastConfiguration = 769 {
  revision 4;

  bitmap BallastStatusBitmap : bitmap8 {
    kBallastNonOperational = 0x1;
    kLampFailure = 0x2;
  }

  bitmap LampAlarmModeBitmap : bitmap8 {
    kLampBurnHours = 0x1;
  }

  readonly attribute int8u physicalMinLevel = 0;
  readonly attribute int8u physicalMaxLevel = 1;
  readonly attribute optional BallastStatusBitmap ballastStatus = 2;
  attribute access(write: manage) int8u minLevel = 16;
  attribute access(write: manage) int8u maxLevel = 17;
  attribute access(write: manage) optional nullable int8u intrinsicBallastFactor = 20;
  attribute access(write: manage) optional nullable int8u ballastFactorAdjustment = 21;
  readonly attribute int8u lampQuantity = 32;
  attribute access(write: manage) optional char_string<16> lampType = 48;
  attribute access(write: manage) optional char_string<16> lampManufacturer = 49;
  attribute access(write: manage) optional nullable int24u lampRatedHours = 50;
  attribute access(write: manage) optional nullable int24u lampBurnHours = 51;
  attribute access(write: manage) optional LampAlarmModeBitmap lampAlarmMode = 52;
  attribute access(write: manage) optional nullable int24u lampBurnHoursTripPoint = 53;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of illuminance, and reporting illuminance measurements. */
cluster IlluminanceMeasurement = 1024 {
  revision 3;

  enum LightSensorTypeEnum : enum8 {
    kPhotodiode = 0;
    kCMOS = 1;
  }

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable LightSensorTypeEnum lightSensorType = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of temperature, and reporting temperature measurements. */
cluster TemperatureMeasurement = 1026 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute nullable temperature measuredValue = 0;
  readonly attribute nullable temperature minMeasuredValue = 1;
  readonly attribute nullable temperature maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of pressure, and reporting pressure measurements. */
cluster PressureMeasurement = 1027 {
  revision 3;

  bitmap Feature : bitmap32 {
    kExtended = 0x1;
  }

  readonly attribute nullable int16s measuredValue = 0;
  readonly attribute nullable int16s minMeasuredValue = 1;
  readonly attribute nullable int16s maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable int16s scaledValue = 16;
  readonly attribute optional nullable int16s minScaledValue = 17;
  readonly attribute optional nullable int16s maxScaledValue = 18;
  readonly attribute optional int16u scaledTolerance = 19;
  readonly attribute optional int8s scale = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of flow, and reporting flow measurements. */
cluster FlowMeasurement = 1028 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of relative humidity, and reporting relative humidity measurements. */
cluster RelativeHumidityMeasurement = 1029 {
  revision 3;

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring occupancy sensing, and reporting occupancy status. */
cluster OccupancySensing = 1030 {
  revision 4;

  enum OccupancySensorTypeEnum : enum8 {
    kPIR = 0;
    kUltrasonic = 1;
    kPIRAndUltrasonic = 2;
    kPhysicalContact = 3;
  }

  bitmap OccupancyBitmap : bitmap8 {
    kOccupied = 0x1;
  }

  bitmap OccupancySensorTypeBitmap : bitmap8 {
    kPIR = 0x1;
    kUltrasonic = 0x2;
    kPhysicalContact = 0x4;
  }

  readonly attribute OccupancyBitmap occupancy = 0;
  readonly attribute OccupancySensorTypeEnum occupancySensorType = 1;
  readonly attribute OccupancySensorTypeBitmap occupancySensorTypeBitmap = 2;
  attribute access(write: manage) optional int16u PIROccupiedToUnoccupiedDelay = 16;
  attribute access(write: manage) optional int16u PIRUnoccupiedToOccupiedDelay = 17;
  attribute access(write: manage) optional int8u PIRUnoccupiedToOccupiedThreshold = 18;
  attribute access(write: manage) optional int16u ultrasonicOccupiedToUnoccupiedDelay = 32;
  attribute access(write: manage) optional int16u ultrasonicUnoccupiedToOccupiedDelay = 33;
  attribute access(write: manage) optional int8u ultrasonicUnoccupiedToOccupiedThreshold = 34;
  attribute access(write: manage) optional int16u physicalContactOccupiedToUnoccupiedDelay = 48;
  attribute access(write: manage) optional int16u physicalContactUnoccupiedToOccupiedDelay = 49;
  attribute access(write: manage) optional int8u physicalContactUnoccupiedToOccupiedThreshold = 50;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting carbon monoxide concentration measurements */
cluster CarbonMonoxideConcentrationMeasurement = 1036 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting carbon dioxide concentration measurements */
cluster CarbonDioxideConcentrationMeasurement = 1037 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting nitrogen dioxide concentration measurements */
cluster NitrogenDioxideConcentrationMeasurement = 1043 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting ozone concentration measurements */
cluster OzoneConcentrationMeasurement = 1045 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM2.5 concentration measurements */
cluster Pm25ConcentrationMeasurement = 1066 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting formaldehyde concentration measurements */
cluster FormaldehydeConcentrationMeasurement = 1067 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM1 concentration measurements */
cluster Pm1ConcentrationMeasurement = 1068 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM10 concentration measurements */
cluster Pm10ConcentrationMeasurement = 1069 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting total volatile organic compounds concentration measurements */
cluster TotalVolatileOrganicCompoundsConcentrationMeasurement = 1070 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting radon concentration measurements */
cluster RadonConcentrationMeasurement = 1071 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Functionality to retrieve operational information about a managed Wi-Fi network. */
cluster WiFiNetworkManagement = 1105 {
  revision 1;

  readonly attribute nullable octet_string<32> ssid = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct NetworkPassphraseResponse = 1 {
    octet_string<64> passphrase = 0;
  }

  /** Request the current WPA-Personal passphrase or PSK associated with the managed Wi-Fi network. */
  command access(invoke: administer) NetworkPassphraseRequest(): NetworkPassphraseResponse = 0;
}

/** This cluster provides an interface for managing low power mode on a device that supports the Wake On LAN protocol. */
cluster WakeOnLan = 1283 {
  revision 1;

  readonly attribute optional char_string<12> MACAddress = 0;
  readonly attribute optional octet_string<16> linkLocalAddress = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for controlling the current Channel on a device. */
cluster Channel = 1284 {
  revision 2;

  enum ChannelTypeEnum : enum8 {
    kSatellite = 0;
    kCable = 1;
    kTerrestrial = 2;
    kOTT = 3;
  }

  enum LineupInfoTypeEnum : enum8 {
    kMSO = 0;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kMultipleMatches = 1;
    kNoMatches = 2;
  }

  bitmap Feature : bitmap32 {
    kChannelList = 0x1;
    kLineupInfo = 0x2;
    kElectronicGuide = 0x4;
    kRecordProgram = 0x8;
  }

  bitmap RecordingFlagBitmap : bitmap32 {
    kScheduled = 0x1;
    kRecordSeries = 0x2;
    kRecorded = 0x4;
  }

  struct ProgramCastStruct {
    char_string name = 0;
    char_string role = 1;
  }

  struct ProgramCategoryStruct {
    char_string category = 0;
    optional char_string subCategory = 1;
  }

  struct SeriesInfoStruct {
    char_string season = 0;
    char_string episode = 1;
  }

  struct ChannelInfoStruct {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
    optional char_string name = 2;
    optional char_string callSign = 3;
    optional char_string affiliateCallSign = 4;
    optional char_string identifier = 5;
    optional ChannelTypeEnum type = 6;
  }

  struct ProgramStruct {
    char_string identifier = 0;
    ChannelInfoStruct channel = 1;
    epoch_s startTime = 2;
    epoch_s endTime = 3;
    char_string title = 4;
    optional char_string subtitle = 5;
    optional char_string description = 6;
    optional char_string audioLanguages[] = 7;
    optional char_string ratings[] = 8;
    optional char_string thumbnailUrl = 9;
    optional char_string posterArtUrl = 10;
    optional char_string dvbiUrl = 11;
    optional char_string releaseDate = 12;
    optional char_string parentalGuidanceText = 13;
    optional RecordingFlagBitmap recordingFlag = 14;
    optional nullable SeriesInfoStruct seriesInfo = 15;
    optional ProgramCategoryStruct categoryList[] = 16;
    optional ProgramCastStruct castList[] = 17;
    optional ProgramCastStruct externalIDList[] = 18;
  }

  struct PageTokenStruct {
    optional int16u limit = 0;
    optional char_string after = 1;
    optional char_string before = 2;
  }

  struct ChannelPagingStruct {
    optional nullable PageTokenStruct previousToken = 0;
    optional nullable PageTokenStruct nextToken = 1;
  }

  struct AdditionalInfoStruct {
    char_string name = 0;
    char_string value = 1;
  }

  struct LineupInfoStruct {
    char_string operatorName = 0;
    optional char_string lineupName = 1;
    optional char_string postalCode = 2;
    LineupInfoTypeEnum lineupInfoType = 3;
  }

  readonly attribute optional ChannelInfoStruct channelList[] = 0;
  readonly attribute optional nullable LineupInfoStruct lineup = 1;
  readonly attribute optional nullable ChannelInfoStruct currentChannel = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeChannelRequest {
    char_string match = 0;
  }

  response struct ChangeChannelResponse = 1 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  request struct ChangeChannelByNumberRequest {
    int16u majorNumber = 0;
    int16u minorNumber = 1;
  }

  request struct SkipChannelRequest {
    int16s count = 0;
  }

  request struct GetProgramGuideRequest {
    optional epoch_s startTime = 0;
    optional epoch_s endTime = 1;
    optional ChannelInfoStruct channelList[] = 2;
    optional PageTokenStruct pageToken = 3;
    optional RecordingFlagBitmap recordingFlag = 4;
    optional AdditionalInfoStruct externalIDList[] = 5;
    optional octet_string data = 6;
  }

  response struct ProgramGuideResponse = 5 {
    ChannelPagingStruct paging = 0;
    ProgramStruct programList[] = 1;
  }

  request struct RecordProgramRequest {
    char_string programIdentifier = 0;
    boolean shouldRecordSeries = 1;
    AdditionalInfoStruct externalIDList[] = 2;
    octet_string data = 3;
  }

  request struct CancelRecordProgramRequest {
    char_string programIdentifier = 0;
    boolean shouldRecordSeries = 1;
    AdditionalInfoStruct externalIDList[] = 2;
    octet_string data = 3;
  }

  /** Change the channel on the media player to the channel case-insensitive exact matching the value passed as an argument. */
  command ChangeChannel(ChangeChannelRequest): ChangeChannelResponse = 0;
  /** Change the channel on the media plaeyer to the channel with the given Number in the ChannelList attribute. */
  command ChangeChannelByNumber(ChangeChannelByNumberRequest): DefaultSuccess = 2;
  /** This command provides channel up and channel down functionality, but allows channel index jumps of size Count. When the value of the increase or decrease is larger than the number of channels remaining in the given direction, then the behavior SHALL be to return to the beginning (or end) of the channel list and continue. For example, if the current channel is at index 0 and count value of -1 is given, then the current channel should change to the last channel. */
  command SkipChannel(SkipChannelRequest): DefaultSuccess = 3;
  /** This command retrieves the program guide. It accepts several filter parameters to return specific schedule and program information from a content app. The command shall receive in response a ProgramGuideResponse. */
  command GetProgramGuide(GetProgramGuideRequest): ProgramGuideResponse = 4;
  /** Record a specific program or series when it goes live. This functionality enables DVR recording features. */
  command RecordProgram(RecordProgramRequest): DefaultSuccess = 6;
  /** Cancel recording for a specific program or series. */
  command CancelRecordProgram(CancelRecordProgramRequest): DefaultSuccess = 7;
}

/** This cluster provides an interface for UX navigation within a set of targets on a device or endpoint. */
cluster TargetNavigator = 1285 {
  revision 2;

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kTargetNotFound = 1;
    kNotAllowed = 2;
  }

  struct TargetInfoStruct {
    int8u identifier = 0;
    char_string name = 1;
  }

  info event TargetUpdated = 0 {
    TargetInfoStruct targetList[] = 0;
    int8u currentTarget = 1;
    octet_string data = 2;
  }

  readonly attribute TargetInfoStruct targetList[] = 0;
  readonly attribute optional int8u currentTarget = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct NavigateTargetRequest {
    int8u target = 0;
    optional char_string data = 1;
  }

  response struct NavigateTargetResponse = 1 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  /** Upon receipt, this SHALL navigation the UX to the target identified. */
  command NavigateTarget(NavigateTargetRequest): NavigateTargetResponse = 0;
}

/** This cluster provides an interface for controlling Media Playback (PLAY, PAUSE, etc) on a media device such as a TV or Speaker. */
cluster MediaPlayback = 1286 {
  revision 2;

  enum CharacteristicEnum : enum8 {
    kForcedSubtitles = 0;
    kDescribesVideo = 1;
    kEasyToRead = 2;
    kFrameBased = 3;
    kMainProgram = 4;
    kOriginalContent = 5;
    kVoiceOverTranslation = 6;
    kCaption = 7;
    kSubtitle = 8;
    kAlternate = 9;
    kSupplementary = 10;
    kCommentary = 11;
    kDubbedTranslation = 12;
    kDescription = 13;
    kMetadata = 14;
    kEnhancedAudioIntelligibility = 15;
    kEmergency = 16;
    kKaraoke = 17;
  }

  enum PlaybackStateEnum : enum8 {
    kPlaying = 0;
    kPaused = 1;
    kNotPlaying = 2;
    kBuffering = 3;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kInvalidStateForCommand = 1;
    kNotAllowed = 2;
    kNotActive = 3;
    kSpeedOutOfRange = 4;
    kSeekOutOfRange = 5;
  }

  bitmap Feature : bitmap32 {
    kAdvancedSeek = 0x1;
    kVariableSpeed = 0x2;
    kTextTracks = 0x4;
    kAudioTracks = 0x8;
    kAudioAdvance = 0x10;
  }

  struct TrackAttributesStruct {
    char_string<32> languageCode = 0;
    optional nullable char_string displayName = 1;
  }

  struct TrackStruct {
    char_string<32> id = 0;
    nullable TrackAttributesStruct trackAttributes = 1;
  }

  struct PlaybackPositionStruct {
    epoch_us updatedAt = 0;
    nullable int64u position = 1;
  }

  info event StateChanged = 0 {
    PlaybackStateEnum currentState = 0;
    EPOCH_US startTime = 1;
    INT64U duration = 2;
    PlaybackPositionStruct sampledPosition = 3;
    single playbackSpeed = 4;
    INT64U seekRangeEnd = 5;
    INT64U seekRangeStart = 6;
    optional OCTET_STRING data = 7;
    boolean audioAdvanceUnmuted = 8;
  }

  readonly attribute PlaybackStateEnum currentState = 0;
  readonly attribute optional nullable epoch_us startTime = 1;
  readonly attribute optional nullable int64u duration = 2;
  readonly attribute optional nullable PlaybackPositionStruct sampledPosition = 3;
  readonly attribute optional single playbackSpeed = 4;
  readonly attribute optional nullable int64u seekRangeEnd = 5;
  readonly attribute optional nullable int64u seekRangeStart = 6;
  readonly attribute optional nullable TrackStruct activeAudioTrack = 7;
  readonly attribute optional nullable TrackStruct availableAudioTracks[] = 8;
  readonly attribute optional nullable TrackStruct activeTextTrack = 9;
  readonly attribute optional nullable TrackStruct availableTextTracks[] = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RewindRequest {
    optional boolean audioAdvanceUnmuted = 0;
  }

  request struct FastForwardRequest {
    optional boolean audioAdvanceUnmuted = 0;
  }

  request struct SkipForwardRequest {
    int64u deltaPositionMilliseconds = 0;
  }

  request struct SkipBackwardRequest {
    int64u deltaPositionMilliseconds = 0;
  }

  response struct PlaybackResponse = 10 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  request struct SeekRequest {
    int64u position = 0;
  }

  request struct ActivateAudioTrackRequest {
    CHAR_STRING trackID = 0;
    INT8U audioOutputIndex = 1;
  }

  request struct ActivateTextTrackRequest {
    CHAR_STRING trackID = 0;
  }

  /** Upon receipt, this SHALL play media. */
  command Play(): PlaybackResponse = 0;
  /** Upon receipt, this SHALL pause media. */
  command Pause(): PlaybackResponse = 1;
  /** Upon receipt, this SHALL stop media. User experience is context-specific. This will often navigate the user back to the location where media was originally launched. */
  command Stop(): PlaybackResponse = 2;
  /** Upon receipt, this SHALL Start Over with the current media playback item. */
  command StartOver(): PlaybackResponse = 3;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Previous". User experience is context-specific. This will often Go back to the previous media playback item. */
  command Previous(): PlaybackResponse = 4;
  /** Upon receipt, this SHALL cause the handler to be invoked for "Next". User experience is context-specific. This will often Go forward to the next media playback item. */
  command Next(): PlaybackResponse = 5;
  /** Upon receipt, this SHALL Rewind through media. Different Rewind speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command Rewind(RewindRequest): PlaybackResponse = 6;
  /** Upon receipt, this SHALL Advance through media. Different FF speeds can be used on the TV based upon the number of sequential calls to this function. This is to avoid needing to define every speed now (multiple fast, slow motion, etc). */
  command FastForward(FastForwardRequest): PlaybackResponse = 7;
  /** Upon receipt, this SHALL Skip forward in the media by the given number of seconds, using the data as follows: */
  command SkipForward(SkipForwardRequest): PlaybackResponse = 8;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command SkipBackward(SkipBackwardRequest): PlaybackResponse = 9;
  /** Upon receipt, this SHALL Skip backward in the media by the given number of seconds, using the data as follows: */
  command Seek(SeekRequest): PlaybackResponse = 11;
  /** Upon receipt, the server SHALL set the active Audio Track to the one identified by the TrackID in the Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does not correspond to the streaming media OR no media is being streamed at the time of receipt of this command, the server will return an error status of INVALID_ARGUMENT. */
  command ActivateAudioTrack(ActivateAudioTrackRequest): DefaultSuccess = 12;
  /** Upon receipt, the server SHALL set the active Text Track to the one identified by the TrackID in the Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does not correspond to the streaming media OR no media is being streamed at the time of receipt of this command, the server SHALL return an error status of INVALID_ARGUMENT. */
  command ActivateTextTrack(ActivateTextTrackRequest): DefaultSuccess = 13;
  /** If a Text Track is active (i.e. being displayed), upon receipt of this command, the server SHALL stop displaying it. */
  command DeactivateTextTrack(): DefaultSuccess = 14;
}

/** This cluster provides an interface for controlling the Input Selector on a media device such as a TV. */
cluster MediaInput = 1287 {
  revision 1; // NOTE: Default/not specifically set

  enum InputTypeEnum : enum8 {
    kInternal = 0;
    kAux = 1;
    kCoax = 2;
    kComposite = 3;
    kHDMI = 4;
    kInput = 5;
    kLine = 6;
    kOptical = 7;
    kVideo = 8;
    kSCART = 9;
    kUSB = 10;
    kOther = 11;
  }

  bitmap Feature : bitmap32 {
    kNameUpdates = 0x1;
  }

  struct InputInfoStruct {
    int8u index = 0;
    InputTypeEnum inputType = 1;
    char_string name = 2;
    char_string description = 3;
  }

  readonly attribute InputInfoStruct inputList[] = 0;
  readonly attribute int8u currentInput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectInputRequest {
    int8u index = 0;
  }

  request struct RenameInputRequest {
    int8u index = 0;
    char_string name = 1;
  }

  /** Upon receipt, this SHALL change the input on the media device to the input at a specific index in the Input List. */
  command SelectInput(SelectInputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL display the active status of the input list on screen. */
  command ShowInputStatus(): DefaultSuccess = 1;
  /** Upon receipt, this SHALL hide the input list from the screen. */
  command HideInputStatus(): DefaultSuccess = 2;
  /** Upon receipt, this SHALL rename the input at a specific index in the Input List. Updates to the input name SHALL appear in the TV settings menus. */
  command access(invoke: manage) RenameInput(RenameInputRequest): DefaultSuccess = 3;
}

/** This cluster provides an interface for managing low power mode on a device. */
cluster LowPower = 1288 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command shall put the device into low power mode. */
  command Sleep(): DefaultSuccess = 0;
}

/** This cluster provides an interface for controlling a device like a TV using action commands such as UP, DOWN, and SELECT. */
cluster KeypadInput = 1289 {
  revision 1; // NOTE: Default/not specifically set

  enum CECKeyCodeEnum : enum8 {
    kSelect = 0;
    kUp = 1;
    kDown = 2;
    kLeft = 3;
    kRight = 4;
    kRightUp = 5;
    kRightDown = 6;
    kLeftUp = 7;
    kLeftDown = 8;
    kRootMenu = 9;
    kSetupMenu = 10;
    kContentsMenu = 11;
    kFavoriteMenu = 12;
    kExit = 13;
    kMediaTopMenu = 16;
    kMediaContextSensitiveMenu = 17;
    kNumberEntryMode = 29;
    kNumber11 = 30;
    kNumber12 = 31;
    kNumber0OrNumber10 = 32;
    kNumbers1 = 33;
    kNumbers2 = 34;
    kNumbers3 = 35;
    kNumbers4 = 36;
    kNumbers5 = 37;
    kNumbers6 = 38;
    kNumbers7 = 39;
    kNumbers8 = 40;
    kNumbers9 = 41;
    kDot = 42;
    kEnter = 43;
    kClear = 44;
    kNextFavorite = 47;
    kChannelUp = 48;
    kChannelDown = 49;
    kPreviousChannel = 50;
    kSoundSelect = 51;
    kInputSelect = 52;
    kDisplayInformation = 53;
    kHelp = 54;
    kPageUp = 55;
    kPageDown = 56;
    kPower = 64;
    kVolumeUp = 65;
    kVolumeDown = 66;
    kMute = 67;
    kPlay = 68;
    kStop = 69;
    kPause = 70;
    kRecord = 71;
    kRewind = 72;
    kFastForward = 73;
    kEject = 74;
    kForward = 75;
    kBackward = 76;
    kStopRecord = 77;
    kPauseRecord = 78;
    kReserved = 79;
    kAngle = 80;
    kSubPicture = 81;
    kVideoOnDemand = 82;
    kElectronicProgramGuide = 83;
    kTimerProgramming = 84;
    kInitialConfiguration = 85;
    kSelectBroadcastType = 86;
    kSelectSoundPresentation = 87;
    kPlayFunction = 96;
    kPausePlayFunction = 97;
    kRecordFunction = 98;
    kPauseRecordFunction = 99;
    kStopFunction = 100;
    kMuteFunction = 101;
    kRestoreVolumeFunction = 102;
    kTuneFunction = 103;
    kSelectMediaFunction = 104;
    kSelectAvInputFunction = 105;
    kSelectAudioInputFunction = 106;
    kPowerToggleFunction = 107;
    kPowerOffFunction = 108;
    kPowerOnFunction = 109;
    kF1Blue = 113;
    kF2Red = 114;
    kF3Green = 115;
    kF4Yellow = 116;
    kF5 = 117;
    kData = 118;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kUnsupportedKey = 1;
    kInvalidKeyInCurrentState = 2;
  }

  bitmap Feature : bitmap32 {
    kNavigationKeyCodes = 0x1;
    kLocationKeys = 0x2;
    kNumberKeys = 0x4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SendKeyRequest {
    CECKeyCodeEnum keyCode = 0;
  }

  response struct SendKeyResponse = 1 {
    StatusEnum status = 0;
  }

  /** Upon receipt, this SHALL process a keycode as input to the media device. */
  command SendKey(SendKeyRequest): SendKeyResponse = 0;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
cluster ContentLauncher = 1290 {
  revision 1;

  enum CharacteristicEnum : enum8 {
    kForcedSubtitles = 0;
    kDescribesVideo = 1;
    kEasyToRead = 2;
    kFrameBased = 3;
    kMainProgram = 4;
    kOriginalContent = 5;
    kVoiceOverTranslation = 6;
    kCaption = 7;
    kSubtitle = 8;
    kAlternate = 9;
    kSupplementary = 10;
    kCommentary = 11;
    kDubbedTranslation = 12;
    kDescription = 13;
    kMetadata = 14;
    kEnhancedAudioIntelligibility = 15;
    kEmergency = 16;
    kKaraoke = 17;
  }

  enum MetricTypeEnum : enum8 {
    kPixels = 0;
    kPercentage = 1;
  }

  enum ParameterEnum : enum8 {
    kActor = 0;
    kChannel = 1;
    kCharacter = 2;
    kDirector = 3;
    kEvent = 4;
    kFranchise = 5;
    kGenre = 6;
    kLeague = 7;
    kPopularity = 8;
    kProvider = 9;
    kSport = 10;
    kSportsTeam = 11;
    kType = 12;
    kVideo = 13;
    kSeason = 14;
    kEpisode = 15;
    kAny = 16;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kURLNotAvailable = 1;
    kAuthFailed = 2;
    kTextTrackNotAvailable = 3;
    kAudioTrackNotAvailable = 4;
  }

  bitmap Feature : bitmap32 {
    kContentSearch = 0x1;
    kURLPlayback = 0x2;
    kAdvancedSeek = 0x3;
    kTextTracks = 0x4;
    kAudioTracks = 0x5;
  }

  bitmap SupportedProtocolsBitmap : bitmap32 {
    kDASH = 0x1;
    kHLS = 0x2;
  }

  struct DimensionStruct {
    double width = 0;
    double height = 1;
    MetricTypeEnum metric = 2;
  }

  struct TrackPreferenceStruct {
    char_string<32> languageCode = 0;
    optional CharacteristicEnum characteristics[] = 1;
    int8u audioOutputIndex = 2;
  }

  struct PlaybackPreferencesStruct {
    int64u playbackPosition = 0;
    TrackPreferenceStruct textTrack = 1;
    optional TrackPreferenceStruct audioTracks[] = 2;
  }

  struct AdditionalInfoStruct {
    char_string<256> name = 0;
    char_string<8192> value = 1;
  }

  struct ParameterStruct {
    ParameterEnum type = 0;
    char_string<1024> value = 1;
    optional AdditionalInfoStruct externalIDList[] = 2;
  }

  struct ContentSearchStruct {
    ParameterStruct parameterList[] = 0;
  }

  struct StyleInformationStruct {
    optional char_string<8192> imageURL = 0;
    optional char_string<9> color = 1;
    optional DimensionStruct size = 2;
  }

  struct BrandingInformationStruct {
    char_string<256> providerName = 0;
    optional StyleInformationStruct background = 1;
    optional StyleInformationStruct logo = 2;
    optional StyleInformationStruct progressBar = 3;
    optional StyleInformationStruct splash = 4;
    optional StyleInformationStruct waterMark = 5;
  }

  readonly attribute optional char_string acceptHeader[] = 0;
  readonly attribute optional SupportedProtocolsBitmap supportedStreamingProtocols = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchContentRequest {
    ContentSearchStruct search = 0;
    boolean autoPlay = 1;
    optional char_string data = 2;
    optional PlaybackPreferencesStruct playbackPreferences = 3;
    optional boolean useCurrentContext = 4;
  }

  request struct LaunchURLRequest {
    char_string contentURL = 0;
    optional char_string displayString = 1;
    optional BrandingInformationStruct brandingInformation = 2;
  }

  response struct LauncherResponse = 2 {
    StatusEnum status = 0;
    optional char_string data = 1;
  }

  /** Upon receipt, this SHALL launch the specified content with optional search criteria. */
  command LaunchContent(LaunchContentRequest): LauncherResponse = 0;
  /** Upon receipt, this SHALL launch content from the specified URL. */
  command LaunchURL(LaunchURLRequest): LauncherResponse = 1;
}

/** This cluster provides an interface for controlling the Output on a media device such as a TV. */
cluster AudioOutput = 1291 {
  revision 1; // NOTE: Default/not specifically set

  enum OutputTypeEnum : enum8 {
    kHDMI = 0;
    kBT = 1;
    kOptical = 2;
    kHeadphone = 3;
    kInternal = 4;
    kOther = 5;
  }

  bitmap Feature : bitmap32 {
    kNameUpdates = 0x1;
  }

  struct OutputInfoStruct {
    int8u index = 0;
    OutputTypeEnum outputType = 1;
    char_string name = 2;
  }

  readonly attribute OutputInfoStruct outputList[] = 0;
  readonly attribute int8u currentOutput = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SelectOutputRequest {
    int8u index = 0;
  }

  request struct RenameOutputRequest {
    int8u index = 0;
    char_string name = 1;
  }

  /** Upon receipt, this SHALL change the output on the media device to the output at a specific index in the Output List. */
  command SelectOutput(SelectOutputRequest): DefaultSuccess = 0;
  /** Upon receipt, this SHALL rename the output at a specific index in the Output List. Updates to the output name SHALL appear in the TV settings menus. */
  command access(invoke: manage) RenameOutput(RenameOutputRequest): DefaultSuccess = 1;
}

/** This cluster provides an interface for launching content on a media player device such as a TV or Speaker. */
cluster ApplicationLauncher = 1292 {
  revision 1; // NOTE: Default/not specifically set

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kAppNotAvailable = 1;
    kSystemBusy = 2;
  }

  bitmap Feature : bitmap32 {
    kApplicationPlatform = 0x1;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  struct ApplicationEPStruct {
    ApplicationStruct application = 0;
    optional endpoint_no endpoint = 1;
  }

  readonly attribute optional int16u catalogList[] = 0;
  readonly attribute optional nullable ApplicationEPStruct currentApp = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LaunchAppRequest {
    optional ApplicationStruct application = 0;
    optional octet_string data = 1;
  }

  request struct StopAppRequest {
    optional ApplicationStruct application = 0;
  }

  request struct HideAppRequest {
    optional ApplicationStruct application = 0;
  }

  response struct LauncherResponse = 3 {
    StatusEnum status = 0;
    optional octet_string data = 1;
  }

  /** Upon receipt, this SHALL launch the specified app with optional data. The TV Device SHALL launch and bring to foreground the identified application in the command if the application is not already launched and in foreground. The TV Device SHALL update state attribute on the Application Basic cluster of the Endpoint corresponding to the launched application. This command returns a Launch Response. */
  command LaunchApp(LaunchAppRequest): LauncherResponse = 0;
  /** Upon receipt on a Video Player endpoint this SHALL stop the specified application if it is running. */
  command StopApp(StopAppRequest): LauncherResponse = 1;
  /** Upon receipt on a Video Player endpoint this SHALL hide the specified application if it is running and visible. */
  command HideApp(HideAppRequest): LauncherResponse = 2;
}

/** This cluster provides information about an application running on a TV or media player device which is represented as an endpoint. */
cluster ApplicationBasic = 1293 {
  revision 1; // NOTE: Default/not specifically set

  enum ApplicationStatusEnum : enum8 {
    kStopped = 0;
    kActiveVisibleFocus = 1;
    kActiveHidden = 2;
    kActiveVisibleNotFocus = 3;
  }

  struct ApplicationStruct {
    int16u catalogVendorID = 0;
    char_string applicationID = 1;
  }

  readonly attribute optional char_string<32> vendorName = 0;
  readonly attribute optional vendor_id vendorID = 1;
  readonly attribute long_char_string<256> applicationName = 2;
  readonly attribute optional int16u productID = 3;
  readonly attribute ApplicationStruct application = 4;
  readonly attribute ApplicationStatusEnum status = 5;
  readonly attribute char_string<32> applicationVersion = 6;
  readonly attribute access(read: administer) vendor_id allowedVendorList[] = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides commands that facilitate user account login on a Content App or a node. For example, a Content App running on a Video Player device, which is represented as an endpoint (see [TV Architecture]), can use this cluster to help make the user account on the Content App match the user account on the Client. */
cluster AccountLogin = 1294 {
  revision 2;

  critical event LoggedOut = 0 {
    optional node_id node = 0;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GetSetupPINRequest {
    char_string<100> tempAccountIdentifier = 0;
  }

  response struct GetSetupPINResponse = 1 {
    char_string setupPIN = 0;
  }

  request struct LoginRequest {
    char_string<100> tempAccountIdentifier = 0;
    char_string setupPIN = 1;
    optional node_id node = 2;
  }

  request struct LogoutRequest {
    optional node_id node = 0;
  }

  /** Upon receipt, the Content App checks if the account associated with the client Temp Account Identifier Rotating ID is the same acount that is active on the given Content App. If the accounts are the same, then the Content App includes the Setup PIN in the GetSetupPIN Response. */
  fabric timed command access(invoke: administer) GetSetupPIN(GetSetupPINRequest): GetSetupPINResponse = 0;
  /** Upon receipt, the Content App checks if the account associated with the client’s Temp Account Identifier (Rotating ID) has a current active Setup PIN with the given value. If the Setup PIN is valid for the user account associated with the Temp Account Identifier, then the Content App MAY make that user account active. */
  fabric timed command access(invoke: administer) Login(LoginRequest): DefaultSuccess = 2;
  /** The purpose of this command is to instruct the Content App to clear the current user account. This command SHOULD be used by clients of a Content App to indicate the end of a user session. */
  fabric timed command Logout(LogoutRequest): DefaultSuccess = 3;
}

/** This cluster is used for managing the content control (including "parental control") settings on a media device such as a TV, or Set-top Box. */
provisional cluster ContentControl = 1295 {
  revision 1; // NOTE: Default/not specifically set

  bitmap Feature : bitmap32 {
    kScreenTime = 0x1;
    kPINManagement = 0x2;
    kBlockUnrated = 0x4;
    kOnDemandContentRating = 0x8;
    kScheduledContentRating = 0x10;
  }

  struct RatingNameStruct {
    char_string ratingName = 0;
    optional char_string ratingNameDesc = 1;
  }

  info event RemainingScreenTimeExpired = 0 {
  }

  readonly attribute boolean enabled = 0;
  readonly attribute optional RatingNameStruct onDemandRatings[] = 1;
  readonly attribute optional char_string<8> onDemandRatingThreshold = 2;
  readonly attribute optional RatingNameStruct scheduledContentRatings[] = 3;
  readonly attribute optional char_string<8> scheduledContentRatingThreshold = 4;
  readonly attribute optional elapsed_s screenDailyTime = 5;
  readonly attribute optional elapsed_s remainingScreenTime = 6;
  readonly attribute boolean blockUnrated = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct UpdatePINRequest {
    optional char_string oldPIN = 0;
    char_string newPIN = 1;
  }

  response struct ResetPINResponse = 2 {
    char_string PINCode = 0;
  }

  request struct AddBonusTimeRequest {
    optional char_string PINCode = 0;
    optional elapsed_s bonusTime = 1;
  }

  request struct SetScreenDailyTimeRequest {
    elapsed_s screenTime = 0;
  }

  request struct SetOnDemandRatingThresholdRequest {
    char_string rating = 0;
  }

  request struct SetScheduledContentRatingThresholdRequest {
    char_string rating = 0;
  }

  /** The purpose of this command is to update the PIN used for protecting configuration of the content control settings. Upon success, the old PIN SHALL no longer work. The PIN is used to ensure that only the Node (or User) with the PIN code can make changes to the Content Control settings, for example, turn off Content Controls or modify the ScreenDailyTime. The PIN is composed of a numeric string of up to 6 human readable characters (displayable) . Upon receipt of this command, the media device SHALL check if the OldPIN field of this command is the same as the current PIN. If the PINs are the same, then the PIN code SHALL be set to NewPIN. Otherwise a response with InvalidPINCode error status SHALL be returned. The media device MAY provide a default PIN to the User via an out of band mechanism. For security reasons, it is recommended that a client encourage the user to update the PIN from its default value when performing configuration of the Content Control settings exposed by this cluster. The ResetPIN command can also be used to obtain the default PIN. */
  command UpdatePIN(UpdatePINRequest): DefaultSuccess = 0;
  /** The purpose of this command is to reset the PIN. If this command is executed successfully, a ResetPINResponse command with a new PIN SHALL be returned. */
  command ResetPIN(): ResetPINResponse = 1;
  /** The purpose of this command is to turn on the Content Control feature on a media device. On receipt of the Enable command, the media device SHALL set the Enabled attribute to TRUE. */
  command Enable(): DefaultSuccess = 3;
  /** The purpose of this command is to turn off the Content Control feature on a media device. On receipt of the Disable command, the media device SHALL set the Enabled attribute to FALSE. */
  command Disable(): DefaultSuccess = 4;
  /** The purpose of this command is to add the extra screen time for the user. If a client with Operate privilege invokes this command, the media device SHALL check whether the PINCode passed in the command matches the current PINCode value. If these match, then the RemainingScreenTime attribute SHALL be increased by the specified BonusTime value. If the PINs do not match, then a response with InvalidPINCode error status SHALL be returned, and no changes SHALL be made to RemainingScreenTime. If a client with Manage privilege or greater invokes this command, the media device SHALL ignore the PINCode field and directly increase the RemainingScreenTime attribute by the specified BonusTime value. A server that does not support the PM feature SHALL respond with InvalidPINCode to clients that only have Operate privilege unless: It has been provided with the PIN value to expect via an out of band mechanism, and The client has provided a PINCode that matches the expected PIN value. */
  command AddBonusTime(AddBonusTimeRequest): DefaultSuccess = 5;
  /** The purpose of this command is to set the ScreenDailyTime attribute. On receipt of the SetScreenDailyTime command, the media device SHALL set the ScreenDailyTime attribute to the ScreenTime value. */
  command SetScreenDailyTime(SetScreenDailyTimeRequest): DefaultSuccess = 6;
  /** The purpose of this command is to specify whether programs with no Content rating must be blocked by this media device. On receipt of the BlockUnratedContent command, the media device SHALL set the BlockUnrated attribute to TRUE. */
  command BlockUnratedContent(): DefaultSuccess = 7;
  /** The purpose of this command is to specify whether programs with no Content rating must be blocked by this media device. On receipt of the UnblockUnratedContent command, the media device SHALL set the BlockUnrated attribute to FALSE. */
  command UnblockUnratedContent(): DefaultSuccess = 8;
  /** The purpose of this command is to set the OnDemandRatingThreshold attribute. On receipt of the SetOnDemandRatingThreshold command, the media device SHALL check if the Rating field is one of values present in the OnDemandRatings attribute. If not, then a response with InvalidRating error status SHALL be returned. */
  command SetOnDemandRatingThreshold(SetOnDemandRatingThresholdRequest): DefaultSuccess = 9;
  /** The purpose of this command is to set ScheduledContentRatingThreshold attribute. On receipt of the SetScheduledContentRatingThreshold command, the media device SHALL check if the Rating field is one of values present in the ScheduledContentRatings attribute. If not, then a response with InvalidRating error status SHALL be returned. */
  command SetScheduledContentRatingThreshold(SetScheduledContentRatingThresholdRequest): DefaultSuccess = 10;
}

/** This cluster provides an interface for sending targeted commands to an Observer of a Content App on a Video Player device such as a Streaming Media Player, Smart TV or Smart Screen. The cluster server for Content App Observer is implemented by an endpoint that communicates with a Content App, such as a Casting Video Client. The cluster client for Content App Observer is implemented by a Content App endpoint. A Content App is informed of the NodeId of an Observer when a binding is set on the Content App. The Content App can then send the ContentAppMessage to the Observer (server cluster), and the Observer responds with a ContentAppMessageResponse. */
provisional cluster ContentAppObserver = 1296 {
  revision 1; // NOTE: Default/not specifically set

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kUnexpectedData = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ContentAppMessageRequest {
    optional char_string data = 0;
    char_string encodingHint = 1;
  }

  response struct ContentAppMessageResponse = 1 {
    StatusEnum status = 0;
    optional char_string data = 1;
    optional char_string encodingHint = 2;
  }

  /** Upon receipt, the data field MAY be parsed and interpreted. Message encoding is specific to the Content App. A Content App MAY when possible read attributes from the Basic Information Cluster on the Observer and use this to determine the Message encoding. */
  command ContentAppMessage(ContentAppMessageRequest): ContentAppMessageResponse = 0;
}

/** Attributes related to the electrical properties of a device. This cluster is used by power outlets and other devices that need to provide instantaneous data as opposed to metrology data which should be retrieved from the metering cluster.. */
deprecated cluster ElectricalMeasurement = 2820 {
  revision 3;

  readonly attribute optional bitmap32 measurementType = 0;
  readonly attribute optional int16s dcVoltage = 256;
  readonly attribute optional int16s dcVoltageMin = 257;
  readonly attribute optional int16s dcVoltageMax = 258;
  readonly attribute optional int16s dcCurrent = 259;
  readonly attribute optional int16s dcCurrentMin = 260;
  readonly attribute optional int16s dcCurrentMax = 261;
  readonly attribute optional int16s dcPower = 262;
  readonly attribute optional int16s dcPowerMin = 263;
  readonly attribute optional int16s dcPowerMax = 264;
  readonly attribute optional int16u dcVoltageMultiplier = 512;
  readonly attribute optional int16u dcVoltageDivisor = 513;
  readonly attribute optional int16u dcCurrentMultiplier = 514;
  readonly attribute optional int16u dcCurrentDivisor = 515;
  readonly attribute optional int16u dcPowerMultiplier = 516;
  readonly attribute optional int16u dcPowerDivisor = 517;
  readonly attribute optional int16u acFrequency = 768;
  readonly attribute optional int16u acFrequencyMin = 769;
  readonly attribute optional int16u acFrequencyMax = 770;
  readonly attribute optional int16u neutralCurrent = 771;
  readonly attribute optional int32s totalActivePower = 772;
  readonly attribute optional int32s totalReactivePower = 773;
  readonly attribute optional int32u totalApparentPower = 774;
  readonly attribute optional int16s measured1stHarmonicCurrent = 775;
  readonly attribute optional int16s measured3rdHarmonicCurrent = 776;
  readonly attribute optional int16s measured5thHarmonicCurrent = 777;
  readonly attribute optional int16s measured7thHarmonicCurrent = 778;
  readonly attribute optional int16s measured9thHarmonicCurrent = 779;
  readonly attribute optional int16s measured11thHarmonicCurrent = 780;
  readonly attribute optional int16s measuredPhase1stHarmonicCurrent = 781;
  readonly attribute optional int16s measuredPhase3rdHarmonicCurrent = 782;
  readonly attribute optional int16s measuredPhase5thHarmonicCurrent = 783;
  readonly attribute optional int16s measuredPhase7thHarmonicCurrent = 784;
  readonly attribute optional int16s measuredPhase9thHarmonicCurrent = 785;
  readonly attribute optional int16s measuredPhase11thHarmonicCurrent = 786;
  readonly attribute optional int16u acFrequencyMultiplier = 1024;
  readonly attribute optional int16u acFrequencyDivisor = 1025;
  readonly attribute optional int32u powerMultiplier = 1026;
  readonly attribute optional int32u powerDivisor = 1027;
  readonly attribute optional int8s harmonicCurrentMultiplier = 1028;
  readonly attribute optional int8s phaseHarmonicCurrentMultiplier = 1029;
  readonly attribute optional int16s instantaneousVoltage = 1280;
  readonly attribute optional int16u instantaneousLineCurrent = 1281;
  readonly attribute optional int16s instantaneousActiveCurrent = 1282;
  readonly attribute optional int16s instantaneousReactiveCurrent = 1283;
  readonly attribute optional int16s instantaneousPower = 1284;
  readonly attribute optional int16u rmsVoltage = 1285;
  readonly attribute optional int16u rmsVoltageMin = 1286;
  readonly attribute optional int16u rmsVoltageMax = 1287;
  readonly attribute optional int16u rmsCurrent = 1288;
  readonly attribute optional int16u rmsCurrentMin = 1289;
  readonly attribute optional int16u rmsCurrentMax = 1290;
  readonly attribute optional int16s activePower = 1291;
  readonly attribute optional int16s activePowerMin = 1292;
  readonly attribute optional int16s activePowerMax = 1293;
  readonly attribute optional int16s reactivePower = 1294;
  readonly attribute optional int16u apparentPower = 1295;
  readonly attribute optional int8s powerFactor = 1296;
  attribute optional int16u averageRmsVoltageMeasurementPeriod = 1297;
  attribute optional int16u averageRmsUnderVoltageCounter = 1299;
  attribute optional int16u rmsExtremeOverVoltagePeriod = 1300;
  attribute optional int16u rmsExtremeUnderVoltagePeriod = 1301;
  attribute optional int16u rmsVoltageSagPeriod = 1302;
  attribute optional int16u rmsVoltageSwellPeriod = 1303;
  readonly attribute optional int16u acVoltageMultiplier = 1536;
  readonly attribute optional int16u acVoltageDivisor = 1537;
  readonly attribute optional int16u acCurrentMultiplier = 1538;
  readonly attribute optional int16u acCurrentDivisor = 1539;
  readonly attribute optional int16u acPowerMultiplier = 1540;
  readonly attribute optional int16u acPowerDivisor = 1541;
  attribute optional bitmap8 overloadAlarmsMask = 1792;
  readonly attribute optional int16s voltageOverload = 1793;
  readonly attribute optional int16s currentOverload = 1794;
  attribute optional bitmap16 acOverloadAlarmsMask = 2048;
  readonly attribute optional int16s acVoltageOverload = 2049;
  readonly attribute optional int16s acCurrentOverload = 2050;
  readonly attribute optional int16s acActivePowerOverload = 2051;
  readonly attribute optional int16s acReactivePowerOverload = 2052;
  readonly attribute optional int16s averageRmsOverVoltage = 2053;
  readonly attribute optional int16s averageRmsUnderVoltage = 2054;
  readonly attribute optional int16s rmsExtremeOverVoltage = 2055;
  readonly attribute optional int16s rmsExtremeUnderVoltage = 2056;
  readonly attribute optional int16s rmsVoltageSag = 2057;
  readonly attribute optional int16s rmsVoltageSwell = 2058;
  readonly attribute optional int16u lineCurrentPhaseB = 2305;
  readonly attribute optional int16s activeCurrentPhaseB = 2306;
  readonly attribute optional int16s reactiveCurrentPhaseB = 2307;
  readonly attribute optional int16u rmsVoltagePhaseB = 2309;
  readonly attribute optional int16u rmsVoltageMinPhaseB = 2310;
  readonly attribute optional int16u rmsVoltageMaxPhaseB = 2311;
  readonly attribute optional int16u rmsCurrentPhaseB = 2312;
  readonly attribute optional int16u rmsCurrentMinPhaseB = 2313;
  readonly attribute optional int16u rmsCurrentMaxPhaseB = 2314;
  readonly attribute optional int16s activePowerPhaseB = 2315;
  readonly attribute optional int16s activePowerMinPhaseB = 2316;
  readonly attribute optional int16s activePowerMaxPhaseB = 2317;
  readonly attribute optional int16s reactivePowerPhaseB = 2318;
  readonly attribute optional int16u apparentPowerPhaseB = 2319;
  readonly attribute optional int8s powerFactorPhaseB = 2320;
  readonly attribute optional int16u averageRmsVoltageMeasurementPeriodPhaseB = 2321;
  readonly attribute optional int16u averageRmsOverVoltageCounterPhaseB = 2322;
  readonly attribute optional int16u averageRmsUnderVoltageCounterPhaseB = 2323;
  readonly attribute optional int16u rmsExtremeOverVoltagePeriodPhaseB = 2324;
  readonly attribute optional int16u rmsExtremeUnderVoltagePeriodPhaseB = 2325;
  readonly attribute optional int16u rmsVoltageSagPeriodPhaseB = 2326;
  readonly attribute optional int16u rmsVoltageSwellPeriodPhaseB = 2327;
  readonly attribute optional int16u lineCurrentPhaseC = 2561;
  readonly attribute optional int16s activeCurrentPhaseC = 2562;
  readonly attribute optional int16s reactiveCurrentPhaseC = 2563;
  readonly attribute optional int16u rmsVoltagePhaseC = 2565;
  readonly attribute optional int16u rmsVoltageMinPhaseC = 2566;
  readonly attribute optional int16u rmsVoltageMaxPhaseC = 2567;
  readonly attribute optional int16u rmsCurrentPhaseC = 2568;
  readonly attribute optional int16u rmsCurrentMinPhaseC = 2569;
  readonly attribute optional int16u rmsCurrentMaxPhaseC = 2570;
  readonly attribute optional int16s activePowerPhaseC = 2571;
  readonly attribute optional int16s activePowerMinPhaseC = 2572;
  readonly attribute optional int16s activePowerMaxPhaseC = 2573;
  readonly attribute optional int16s reactivePowerPhaseC = 2574;
  readonly attribute optional int16u apparentPowerPhaseC = 2575;
  readonly attribute optional int8s powerFactorPhaseC = 2576;
  readonly attribute optional int16u averageRmsVoltageMeasurementPeriodPhaseC = 2577;
  readonly attribute optional int16u averageRmsOverVoltageCounterPhaseC = 2578;
  readonly attribute optional int16u averageRmsUnderVoltageCounterPhaseC = 2579;
  readonly attribute optional int16u rmsExtremeOverVoltagePeriodPhaseC = 2580;
  readonly attribute optional int16u rmsExtremeUnderVoltagePeriodPhaseC = 2581;
  readonly attribute optional int16u rmsVoltageSagPeriodPhaseC = 2582;
  readonly attribute optional int16u rmsVoltageSwellPeriodPhaseC = 2583;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct GetProfileInfoResponseCommand = 0 {
    int8u profileCount = 0;
    enum8 profileIntervalPeriod = 1;
    int8u maxNumberOfIntervals = 2;
    int16u listOfAttributes[] = 3;
  }

  response struct GetMeasurementProfileResponseCommand = 1 {
    int32u startTime = 0;
    enum8 status = 1;
    enum8 profileIntervalPeriod = 2;
    int8u numberOfIntervalsDelivered = 3;
    int16u attributeId = 4;
    int8u intervals[] = 5;
  }

  request struct GetMeasurementProfileCommandRequest {
    int16u attributeId = 0;
    int32u startTime = 1;
    enum8 numberOfIntervals = 2;
  }

  /** A function which retrieves the power profiling information from the electrical measurement server. */
  command GetProfileInfoCommand(): DefaultSuccess = 0;
  /** A function which retrieves an electricity measurement profile from the electricity measurement server for a specific attribute Id requested. */
  command GetMeasurementProfileCommand(GetMeasurementProfileCommandRequest): DefaultSuccess = 1;
}

/** The Test Cluster is meant to validate the generated code */
internal cluster UnitTesting = 4294048773 {
  revision 1; // NOTE: Default/not specifically set

  enum SimpleEnum : enum8 {
    kUnspecified = 0;
    kValueA = 1;
    kValueB = 2;
    kValueC = 3;
  }

  bitmap Bitmap16MaskMap : bitmap16 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x4000;
  }

  bitmap Bitmap32MaskMap : bitmap32 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x40000000;
  }

  bitmap Bitmap64MaskMap : bitmap64 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x4000000000000000;
  }

  bitmap Bitmap8MaskMap : bitmap8 {
    kMaskVal1 = 0x1;
    kMaskVal2 = 0x2;
    kMaskVal3 = 0x4;
    kMaskVal4 = 0x40;
  }

  bitmap SimpleBitmap : bitmap8 {
    kValueA = 0x1;
    kValueB = 0x2;
    kValueC = 0x4;
  }

  struct SimpleStruct {
    int8u a = 0;
    boolean b = 1;
    SimpleEnum c = 2;
    octet_string d = 3;
    char_string e = 4;
    SimpleBitmap f = 5;
    single g = 6;
    double h = 7;
  }

  fabric_scoped struct TestFabricScoped {
    fabric_sensitive int8u fabricSensitiveInt8u = 1;
    optional fabric_sensitive int8u optionalFabricSensitiveInt8u = 2;
    nullable fabric_sensitive int8u nullableFabricSensitiveInt8u = 3;
    optional nullable fabric_sensitive int8u nullableOptionalFabricSensitiveInt8u = 4;
    fabric_sensitive char_string fabricSensitiveCharString = 5;
    fabric_sensitive SimpleStruct fabricSensitiveStruct = 6;
    fabric_sensitive int8u fabricSensitiveInt8uList[] = 7;
    fabric_idx fabricIndex = 254;
  }

  struct NullablesAndOptionalsStruct {
    nullable int16u nullableInt = 0;
    optional int16u optionalInt = 1;
    optional nullable int16u nullableOptionalInt = 2;
    nullable char_string nullableString = 3;
    optional char_string optionalString = 4;
    optional nullable char_string nullableOptionalString = 5;
    nullable SimpleStruct nullableStruct = 6;
    optional SimpleStruct optionalStruct = 7;
    optional nullable SimpleStruct nullableOptionalStruct = 8;
    nullable SimpleEnum nullableList[] = 9;
    optional SimpleEnum optionalList[] = 10;
    optional nullable SimpleEnum nullableOptionalList[] = 11;
  }

  struct NestedStruct {
    int8u a = 0;
    boolean b = 1;
    SimpleStruct c = 2;
  }

  struct NestedStructList {
    int8u a = 0;
    boolean b = 1;
    SimpleStruct c = 2;
    SimpleStruct d[] = 3;
    int32u e[] = 4;
    octet_string f[] = 5;
    int8u g[] = 6;
  }

  struct DoubleNestedStructList {
    NestedStructList a[] = 0;
  }

  struct TestListStructOctet {
    int64u member1 = 0;
    octet_string<32> member2 = 1;
  }

  info event TestEvent = 1 {
    int8u arg1 = 1;
    SimpleEnum arg2 = 2;
    boolean arg3 = 3;
    SimpleStruct arg4 = 4;
    SimpleStruct arg5[] = 5;
    SimpleEnum arg6[] = 6;
  }

  fabric_sensitive info event TestFabricScopedEvent = 2 {
    fabric_idx fabricIndex = 254;
  }

  info event TestDifferentVendorMeiEvent = 4294050030 {
    int8u arg1 = 1;
  }

  attribute boolean boolean = 0;
  attribute Bitmap8MaskMap bitmap8 = 1;
  attribute Bitmap16MaskMap bitmap16 = 2;
  attribute Bitmap32MaskMap bitmap32 = 3;
  attribute Bitmap64MaskMap bitmap64 = 4;
  attribute int8u int8u = 5;
  attribute int16u int16u = 6;
  attribute int24u int24u = 7;
  attribute int32u int32u = 8;
  attribute int40u int40u = 9;
  attribute int48u int48u = 10;
  attribute int56u int56u = 11;
  attribute int64u int64u = 12;
  attribute int8s int8s = 13;
  attribute int16s int16s = 14;
  attribute int24s int24s = 15;
  attribute int32s int32s = 16;
  attribute int40s int40s = 17;
  attribute int48s int48s = 18;
  attribute int56s int56s = 19;
  attribute int64s int64s = 20;
  attribute enum8 enum8 = 21;
  attribute enum16 enum16 = 22;
  attribute single floatSingle = 23;
  attribute double floatDouble = 24;
  attribute octet_string<10> octetString = 25;
  attribute int8u listInt8u[] = 26;
  attribute octet_string listOctetString[] = 27;
  attribute TestListStructOctet listStructOctetString[] = 28;
  attribute long_octet_string<1000> longOctetString = 29;
  attribute char_string<10> charString = 30;
  attribute long_char_string<1000> longCharString = 31;
  attribute epoch_us epochUs = 32;
  attribute epoch_s epochS = 33;
  attribute vendor_id vendorId = 34;
  attribute NullablesAndOptionalsStruct listNullablesAndOptionalsStruct[] = 35;
  attribute SimpleEnum enumAttr = 36;
  attribute SimpleStruct structAttr = 37;
  attribute int8u rangeRestrictedInt8u = 38;
  attribute int8s rangeRestrictedInt8s = 39;
  attribute int16u rangeRestrictedInt16u = 40;
  attribute int16s rangeRestrictedInt16s = 41;
  attribute long_octet_string listLongOctetString[] = 42;
  attribute TestFabricScoped listFabricScoped[] = 43;
  timedwrite attribute boolean timedWriteBoolean = 48;
  attribute boolean generalErrorBoolean = 49;
  attribute boolean clusterErrorBoolean = 50;
  attribute optional boolean unsupported = 255;
  attribute nullable boolean nullableBoolean = 16384;
  attribute nullable Bitmap8MaskMap nullableBitmap8 = 16385;
  attribute nullable Bitmap16MaskMap nullableBitmap16 = 16386;
  attribute nullable Bitmap32MaskMap nullableBitmap32 = 16387;
  attribute nullable Bitmap64MaskMap nullableBitmap64 = 16388;
  attribute nullable int8u nullableInt8u = 16389;
  attribute nullable int16u nullableInt16u = 16390;
  attribute nullable int24u nullableInt24u = 16391;
  attribute nullable int32u nullableInt32u = 16392;
  attribute nullable int40u nullableInt40u = 16393;
  attribute nullable int48u nullableInt48u = 16394;
  attribute nullable int56u nullableInt56u = 16395;
  attribute nullable int64u nullableInt64u = 16396;
  attribute nullable int8s nullableInt8s = 16397;
  attribute nullable int16s nullableInt16s = 16398;
  attribute nullable int24s nullableInt24s = 16399;
  attribute nullable int32s nullableInt32s = 16400;
  attribute nullable int40s nullableInt40s = 16401;
  attribute nullable int48s nullableInt48s = 16402;
  attribute nullable int56s nullableInt56s = 16403;
  attribute nullable int64s nullableInt64s = 16404;
  attribute nullable enum8 nullableEnum8 = 16405;
  attribute nullable enum16 nullableEnum16 = 16406;
  attribute nullable single nullableFloatSingle = 16407;
  attribute nullable double nullableFloatDouble = 16408;
  attribute nullable octet_string<10> nullableOctetString = 16409;
  attribute nullable char_string<10> nullableCharString = 16414;
  attribute nullable SimpleEnum nullableEnumAttr = 16420;
  attribute nullable SimpleStruct nullableStruct = 16421;
  attribute nullable int8u nullableRangeRestrictedInt8u = 16422;
  attribute nullable int8s nullableRangeRestrictedInt8s = 16423;
  attribute nullable int16u nullableRangeRestrictedInt16u = 16424;
  attribute nullable int16s nullableRangeRestrictedInt16s = 16425;
  attribute optional int8u writeOnlyInt8u = 16426;
  attribute int8u meiInt8u = 4294070017;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct TestSpecificResponse = 0 {
    int8u returnValue = 0;
  }

  response struct TestAddArgumentsResponse = 1 {
    int8u returnValue = 0;
  }

  response struct TestSimpleArgumentResponse = 2 {
    boolean returnValue = 0;
  }

  response struct TestStructArrayArgumentResponse = 3 {
    NestedStructList arg1[] = 0;
    SimpleStruct arg2[] = 1;
    SimpleEnum arg3[] = 2;
    boolean arg4[] = 3;
    SimpleEnum arg5 = 4;
    boolean arg6 = 5;
  }

  request struct TestAddArgumentsRequest {
    int8u arg1 = 0;
    int8u arg2 = 1;
  }

  response struct TestListInt8UReverseResponse = 4 {
    int8u arg1[] = 0;
  }

  request struct TestSimpleArgumentRequestRequest {
    boolean arg1 = 0;
  }

  response struct TestEnumsResponse = 5 {
    vendor_id arg1 = 0;
    SimpleEnum arg2 = 1;
  }

  request struct TestStructArrayArgumentRequestRequest {
    NestedStructList arg1[] = 0;
    SimpleStruct arg2[] = 1;
    SimpleEnum arg3[] = 2;
    boolean arg4[] = 3;
    SimpleEnum arg5 = 4;
    boolean arg6 = 5;
  }

  response struct TestNullableOptionalResponse = 6 {
    boolean wasPresent = 0;
    optional boolean wasNull = 1;
    optional int8u value = 2;
    optional nullable int8u originalValue = 3;
  }

  request struct TestStructArgumentRequestRequest {
    SimpleStruct arg1 = 0;
  }

  response struct TestComplexNullableOptionalResponse = 7 {
    boolean nullableIntWasNull = 0;
    optional int16u nullableIntValue = 1;
    boolean optionalIntWasPresent = 2;
    optional int16u optionalIntValue = 3;
    boolean nullableOptionalIntWasPresent = 4;
    optional boolean nullableOptionalIntWasNull = 5;
    optional int16u nullableOptionalIntValue = 6;
    boolean nullableStringWasNull = 7;
    optional char_string nullableStringValue = 8;
    boolean optionalStringWasPresent = 9;
    optional char_string optionalStringValue = 10;
    boolean nullableOptionalStringWasPresent = 11;
    optional boolean nullableOptionalStringWasNull = 12;
    optional char_string nullableOptionalStringValue = 13;
    boolean nullableStructWasNull = 14;
    optional SimpleStruct nullableStructValue = 15;
    boolean optionalStructWasPresent = 16;
    optional SimpleStruct optionalStructValue = 17;
    boolean nullableOptionalStructWasPresent = 18;
    optional boolean nullableOptionalStructWasNull = 19;
    optional SimpleStruct nullableOptionalStructValue = 20;
    boolean nullableListWasNull = 21;
    optional SimpleEnum nullableListValue[] = 22;
    boolean optionalListWasPresent = 23;
    optional SimpleEnum optionalListValue[] = 24;
    boolean nullableOptionalListWasPresent = 25;
    optional boolean nullableOptionalListWasNull = 26;
    optional SimpleEnum nullableOptionalListValue[] = 27;
  }

  request struct TestNestedStructArgumentRequestRequest {
    NestedStruct arg1 = 0;
  }

  response struct BooleanResponse = 8 {
    boolean value = 0;
  }

  request struct TestListStructArgumentRequestRequest {
    SimpleStruct arg1[] = 0;
  }

  response struct SimpleStructResponse = 9 {
    SimpleStruct arg1 = 0;
  }

  request struct TestListInt8UArgumentRequestRequest {
    int8u arg1[] = 0;
  }

  response struct TestEmitTestEventResponse = 10 {
    int64u value = 0;
  }

  request struct TestNestedStructListArgumentRequestRequest {
    NestedStructList arg1 = 0;
  }

  response struct TestEmitTestFabricScopedEventResponse = 11 {
    int64u value = 0;
  }

  request struct TestListNestedStructListArgumentRequestRequest {
    NestedStructList arg1[] = 0;
  }

  response struct TestBatchHelperResponse = 12 {
    octet_string<800> buffer = 0;
  }

  request struct TestListInt8UReverseRequestRequest {
    int8u arg1[] = 0;
  }

  request struct TestEnumsRequestRequest {
    vendor_id arg1 = 0;
    SimpleEnum arg2 = 1;
  }

  request struct TestNullableOptionalRequestRequest {
    optional nullable int8u arg1 = 0;
  }

  request struct TestComplexNullableOptionalRequestRequest {
    nullable int16u nullableInt = 0;
    optional int16u optionalInt = 1;
    optional nullable int16u nullableOptionalInt = 2;
    nullable char_string nullableString = 3;
    optional char_string optionalString = 4;
    optional nullable char_string nullableOptionalString = 5;
    nullable SimpleStruct nullableStruct = 6;
    optional SimpleStruct optionalStruct = 7;
    optional nullable SimpleStruct nullableOptionalStruct = 8;
    nullable SimpleEnum nullableList[] = 9;
    optional SimpleEnum optionalList[] = 10;
    optional nullable SimpleEnum nullableOptionalList[] = 11;
  }

  request struct SimpleStructEchoRequestRequest {
    SimpleStruct arg1 = 0;
  }

  request struct TestSimpleOptionalArgumentRequestRequest {
    optional boolean arg1 = 0;
  }

  request struct TestEmitTestEventRequestRequest {
    int8u arg1 = 0;
    SimpleEnum arg2 = 1;
    boolean arg3 = 2;
  }

  request struct TestEmitTestFabricScopedEventRequestRequest {
    int8u arg1 = 0;
  }

  request struct TestBatchHelperRequestRequest {
    int16u sleepBeforeResponseTimeMs = 0;
    int16u sizeOfResponseBuffer = 1;
    int8u fillCharacter = 2;
  }

  request struct TestSecondBatchHelperRequestRequest {
    int16u sleepBeforeResponseTimeMs = 0;
    int16u sizeOfResponseBuffer = 1;
    int8u fillCharacter = 2;
  }

  request struct TestDifferentVendorMeiRequestRequest {
    int8u arg1 = 0;
  }

  response struct TestDifferentVendorMeiResponse = 4294049979 {
    int8u arg1 = 0;
    int64u eventNumber = 1;
  }

  /** Simple command without any parameters and without a specific response.
        To aid in unit testing, this command will re-initialize attribute storage to defaults. */
  command Test(): DefaultSuccess = 0;
  /** Simple command without any parameters and without a specific response not handled by the server */
  command TestNotHandled(): DefaultSuccess = 1;
  /** Simple command without any parameters and with a specific response */
  command TestSpecific(): TestSpecificResponse = 2;
  /** Simple command that should not be added to the server. */
  command TestUnknownCommand(): DefaultSuccess = 3;
  /** Command that takes two arguments and returns their sum. */
  command TestAddArguments(TestAddArgumentsRequest): TestAddArgumentsResponse = 4;
  /** Command that takes an argument which is bool */
  command TestSimpleArgumentRequest(TestSimpleArgumentRequestRequest): TestSimpleArgumentResponse = 5;
  /** Command that takes various arguments that are arrays, including an array of structs which have a list member. */
  command TestStructArrayArgumentRequest(TestStructArrayArgumentRequestRequest): TestStructArrayArgumentResponse = 6;
  /** Command that takes an argument which is struct.  The response echoes the
        'b' field of the single arg. */
  command TestStructArgumentRequest(TestStructArgumentRequestRequest): BooleanResponse = 7;
  /** Command that takes an argument which is nested struct.  The response
        echoes the 'b' field of ar1.c. */
  command TestNestedStructArgumentRequest(TestNestedStructArgumentRequestRequest): BooleanResponse = 8;
  /** Command that takes an argument which is a list of structs.  The response
        returns false if there is some struct in the list whose 'b' field is
        false, and true otherwise (including if the list is empty). */
  command TestListStructArgumentRequest(TestListStructArgumentRequestRequest): BooleanResponse = 9;
  /** Command that takes an argument which is a list of INT8U.  The response
        returns false if the list contains a 0 in it, true otherwise (including
        if the list is empty). */
  command TestListInt8UArgumentRequest(TestListInt8UArgumentRequestRequest): BooleanResponse = 10;
  /** Command that takes an argument which is a Nested Struct List.  The
        response returns false if there is some struct in arg1 (either directly
        in arg1.c or in the arg1.d list) whose 'b' field is false, and true
        otherwise. */
  command TestNestedStructListArgumentRequest(TestNestedStructListArgumentRequestRequest): BooleanResponse = 11;
  /** Command that takes an argument which is a list of Nested Struct List.
        The response returns false if there is some struct in arg1 (either
        directly in as the 'c' field of an entry 'd' list of an entry) whose 'b'
        field is false, and true otherwise (including if the list is empty). */
  command TestListNestedStructListArgumentRequest(TestListNestedStructListArgumentRequestRequest): BooleanResponse = 12;
  /** Command that takes an argument which is a list of INT8U and expects a
        response that reverses the list. */
  command TestListInt8UReverseRequest(TestListInt8UReverseRequestRequest): TestListInt8UReverseResponse = 13;
  /** Command that sends a vendor id and an enum.  The server is expected to
        echo them back. */
  command TestEnumsRequest(TestEnumsRequestRequest): TestEnumsResponse = 14;
  /** Command that takes an argument which is nullable and optional.  The
        response returns a boolean indicating whether the argument was present,
        if that's true a boolean indicating whether the argument was null, and
        if that' false the argument it received. */
  command TestNullableOptionalRequest(TestNullableOptionalRequestRequest): TestNullableOptionalResponse = 15;
  /** Command that takes various arguments which can be nullable and/or optional.  The
        response returns information about which things were received and what
        their state was. */
  command TestComplexNullableOptionalRequest(TestComplexNullableOptionalRequestRequest): TestComplexNullableOptionalResponse = 16;
  /** Command that takes an argument which is a struct.  The response echoes
        the struct back. */
  command SimpleStructEchoRequest(SimpleStructEchoRequestRequest): SimpleStructResponse = 17;
  /** Command that just responds with a success status if the timed invoke
        conditions are met. */
  timed command TimedInvokeRequest(): DefaultSuccess = 18;
  /** Command that takes an optional argument which is bool. It responds with a success value if the optional is set to any value. */
  command TestSimpleOptionalArgumentRequest(TestSimpleOptionalArgumentRequestRequest): DefaultSuccess = 19;
  /** Command that takes identical arguments to the fields of the TestEvent and logs the TestEvent to the buffer.  Command returns an event ID as the response. */
  command TestEmitTestEventRequest(TestEmitTestEventRequestRequest): TestEmitTestEventResponse = 20;
  /** Command that takes identical arguments to the fields of the TestFabricScopedEvent and logs the TestFabricScopedEvent to the buffer.  Command returns an event ID as the response. */
  command TestEmitTestFabricScopedEventRequest(TestEmitTestFabricScopedEventRequestRequest): TestEmitTestFabricScopedEventResponse = 21;
  /** Command that responds after sleepBeforeResponseTimeMs with an octet_string the size requested with fillCharacter. */
  command TestBatchHelperRequest(TestBatchHelperRequestRequest): TestBatchHelperResponse = 22;
  /** Second command that responds after sleepBeforeResponseTimeMs with an octet_string the size requested with fillCharacter. */
  command TestSecondBatchHelperRequest(TestSecondBatchHelperRequestRequest): TestBatchHelperResponse = 23;
  /** Command having a different MEI vendor ID than the cluster. Also emits TestDifferentVendorMeiEvent. */
  command TestDifferentVendorMeiRequest(TestDifferentVendorMeiRequestRequest): TestDifferentVendorMeiResponse = 4294049962;
}

/** The Fault Injection Cluster provide a means for a test harness to configure faults(for example triggering a fault in the system). */
internal cluster FaultInjection = 4294048774 {
  revision 1; // NOTE: Default/not specifically set

  enum FaultType : enum8 {
    kUnspecified = 0;
    kSystemFault = 1;
    kInetFault = 2;
    kChipFault = 3;
    kCertFault = 4;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct FailAtFaultRequest {
    FaultType type = 0;
    int32u id = 1;
    int32u numCallsToSkip = 2;
    int32u numCallsToFail = 3;
    boolean takeMutex = 4;
  }

  request struct FailRandomlyAtFaultRequest {
    FaultType type = 0;
    int32u id = 1;
    int8u percentage = 2;
  }

  /** Configure a fault to be triggered deterministically */
  command access(invoke: manage) FailAtFault(FailAtFaultRequest): DefaultSuccess = 0;
  /** Configure a fault to be triggered randomly, with a given probability defined as a percentage */
  command access(invoke: manage) FailRandomlyAtFault(FailRandomlyAtFaultRequest): DefaultSuccess = 1;
}

/** The Sample MEI cluster showcases a cluster manufacturer extensions */
cluster SampleMei = 4294048800 {
  revision 1; // NOTE: Default/not specifically set

  fabric_sensitive info event PingCountEvent = 0 {
    int32u count = 1;
    fabric_idx fabricIndex = 254;
  }

  attribute boolean flipFlop = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  response struct AddArgumentsResponse = 1 {
    int8u returnValue = 0;
  }

  request struct AddArgumentsRequest {
    int8u arg1 = 0;
    int8u arg2 = 1;
  }

  /** Simple command without any parameters and without a response. */
  command Ping(): DefaultSuccess = 0;
  /** Command that takes two uint8 arguments and returns their sum. */
  command AddArguments(AddArgumentsRequest): AddArgumentsResponse = 2;
}

