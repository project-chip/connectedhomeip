/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPReadCallbacks.h"

#include <zap-generated/CHIPClientCallbacks.h>

#include <jni.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/JniReferences.h>
#include <lib/support/JniTypeWrappers.h>
#include <platform/PlatformManager.h>

CHIPBooleanAttributeCallback::CHIPBooleanAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<BooleanAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPBooleanAttributeCallback::~CHIPBooleanAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPBooleanAttributeCallback::CallbackFn(void * context, bool value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPBooleanAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPBooleanAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Z)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jboolean>(value));
}

CHIPCharStringAttributeCallback::CHIPCharStringAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<CharStringAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPCharStringAttributeCallback::~CHIPCharStringAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPCharStringAttributeCallback::CallbackFn(void * context, const chip::CharSpan value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPCharStringAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPCharStringAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;

    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));

    chip::UtfString valueStr(env, value);
    env->CallVoidMethod(javaCallbackRef, javaMethod, valueStr.jniValue());
}

CHIPInt8sAttributeCallback::CHIPInt8sAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<Int8sAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPInt8sAttributeCallback::~CHIPInt8sAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPInt8sAttributeCallback::CallbackFn(void * context, int8_t value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPInt8sAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPInt8sAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(value));
}

CHIPInt8uAttributeCallback::CHIPInt8uAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<Int8uAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPInt8uAttributeCallback::~CHIPInt8uAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPInt8uAttributeCallback::CallbackFn(void * context, uint8_t value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPInt8uAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPInt8uAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(value));
}

CHIPInt16sAttributeCallback::CHIPInt16sAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<Int16sAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPInt16sAttributeCallback::~CHIPInt16sAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPInt16sAttributeCallback::CallbackFn(void * context, int16_t value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPInt16sAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPInt16sAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(value));
}

CHIPInt16uAttributeCallback::CHIPInt16uAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<Int16uAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPInt16uAttributeCallback::~CHIPInt16uAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPInt16uAttributeCallback::CallbackFn(void * context, uint16_t value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPInt16uAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPInt16uAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(value));
}

CHIPInt32sAttributeCallback::CHIPInt32sAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<Int32sAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPInt32sAttributeCallback::~CHIPInt32sAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPInt32sAttributeCallback::CallbackFn(void * context, int32_t value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPInt32sAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPInt32sAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(value));
}

CHIPInt32uAttributeCallback::CHIPInt32uAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<Int32uAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPInt32uAttributeCallback::~CHIPInt32uAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPInt32uAttributeCallback::CallbackFn(void * context, uint32_t value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPInt32uAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPInt32uAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(value));
}

CHIPInt64sAttributeCallback::CHIPInt64sAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<Int64sAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPInt64sAttributeCallback::~CHIPInt64sAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPInt64sAttributeCallback::CallbackFn(void * context, int64_t value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPInt64sAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPInt64sAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(value));
}

CHIPInt64uAttributeCallback::CHIPInt64uAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<Int64uAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPInt64uAttributeCallback::~CHIPInt64uAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPInt64uAttributeCallback::CallbackFn(void * context, uint64_t value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPInt64uAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPInt64uAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(J)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));
    env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jlong>(value));
}

CHIPOctetStringAttributeCallback::CHIPOctetStringAttributeCallback(jobject javaCallback, bool keepAlive) :
    chip::Callback::Callback<OctetStringAttributeCallback>(CallbackFn, this), keepAlive(keepAlive)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }
    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPOctetStringAttributeCallback::~CHIPOctetStringAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPOctetStringAttributeCallback::CallbackFn(void * context, const chip::ByteSpan value)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;

    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPOctetStringAttributeCallback, decltype(&maybeDestroy)> cppCallback(
        reinterpret_cast<CHIPOctetStringAttributeCallback *>(context), maybeDestroy);

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    jobject javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogDetail(Zcl, "Early return from attribute callback since Java callback is null"));

    jmethodID javaMethod;

    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess method"));

    jbyteArray valueArr = env->NewByteArray(value.size());
    env->ExceptionClear();
    env->SetByteArrayRegion(valueArr, 0, value.size(), reinterpret_cast<const jbyte *>(value.data()));

    env->CallVoidMethod(javaCallbackRef, javaMethod, valueArr);
}

CHIPApplicationLauncherApplicationLauncherListAttributeCallback::CHIPApplicationLauncherApplicationLauncherListAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<ApplicationLauncherApplicationLauncherListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPApplicationLauncherApplicationLauncherListAttributeCallback::~CHIPApplicationLauncherApplicationLauncherListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPApplicationLauncherApplicationLauncherListAttributeCallback::CallbackFn(
    void * context, const chip::app::DataModel::DecodableList<uint16_t> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPApplicationLauncherApplicationLauncherListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPApplicationLauncherApplicationLauncherListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry        = iter.GetValue();
        bool entryNull      = false;
        uint16_t entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ApplicationLauncherListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPAudioOutputAudioOutputListAttributeCallback::CHIPAudioOutputAudioOutputListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<AudioOutputAudioOutputListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPAudioOutputAudioOutputListAttributeCallback::~CHIPAudioOutputAudioOutputListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPAudioOutputAudioOutputListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPAudioOutputAudioOutputListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPAudioOutputAudioOutputListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$AudioOutputCluster$AudioOutputListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$AudioOutputCluster$AudioOutputListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/String;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find AudioOutputListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool indexNull     = false;
        bool indexHasValue = true;

        uint8_t indexValue = entry.index;

        jobject index = nullptr;
        if (!indexNull && indexHasValue)
        {
            jclass indexEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", indexEntryCls);
            chip::JniClass indexJniClass(indexEntryCls);
            jmethodID indexEntryTypeCtor = env->GetMethodID(indexEntryCls, "<init>", "(I)V");
            index                        = env->NewObject(indexEntryCls, indexEntryTypeCtor, indexValue);
        }

        bool outputTypeNull     = false;
        bool outputTypeHasValue = true;

        uint8_t outputTypeValue = entry.outputType;

        jobject outputType = nullptr;
        if (!outputTypeNull && outputTypeHasValue)
        {
            jclass outputTypeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", outputTypeEntryCls);
            chip::JniClass outputTypeJniClass(outputTypeEntryCls);
            jmethodID outputTypeEntryTypeCtor = env->GetMethodID(outputTypeEntryCls, "<init>", "(I)V");
            outputType                        = env->NewObject(outputTypeEntryCls, outputTypeEntryTypeCtor, outputTypeValue);
        }

        bool nameNull     = false;
        bool nameHasValue = true;

        chip::CharSpan nameValue = entry.name;

        jstring name = nullptr;
        chip::UtfString nameStr(env, nameValue);
        if (!nameNull && nameHasValue)
        {
            name = jstring(nameStr.jniValue());
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, index, outputType, name);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create AudioOutputListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding AudioOutputListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPBridgedActionsActionListAttributeCallback::CHIPBridgedActionsActionListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<BridgedActionsActionListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPBridgedActionsActionListAttributeCallback::~CHIPBridgedActionsActionListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPBridgedActionsActionListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPBridgedActionsActionListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPBridgedActionsActionListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$BridgedActionsCluster$ActionListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$BridgedActionsCluster$ActionListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(
        attributeClass, "<init>",
        "(Ljava/lang/Integer;Ljava/lang/String;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Integer;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find ActionListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool actionIDNull     = false;
        bool actionIDHasValue = true;

        uint16_t actionIDValue = entry.actionID;

        jobject actionID = nullptr;
        if (!actionIDNull && actionIDHasValue)
        {
            jclass actionIDEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", actionIDEntryCls);
            chip::JniClass actionIDJniClass(actionIDEntryCls);
            jmethodID actionIDEntryTypeCtor = env->GetMethodID(actionIDEntryCls, "<init>", "(I)V");
            actionID                        = env->NewObject(actionIDEntryCls, actionIDEntryTypeCtor, actionIDValue);
        }

        bool nameNull     = false;
        bool nameHasValue = true;

        chip::CharSpan nameValue = entry.name;

        jstring name = nullptr;
        chip::UtfString nameStr(env, nameValue);
        if (!nameNull && nameHasValue)
        {
            name = jstring(nameStr.jniValue());
        }

        bool typeNull     = false;
        bool typeHasValue = true;

        uint8_t typeValue = entry.type;

        jobject type = nullptr;
        if (!typeNull && typeHasValue)
        {
            jclass typeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", typeEntryCls);
            chip::JniClass typeJniClass(typeEntryCls);
            jmethodID typeEntryTypeCtor = env->GetMethodID(typeEntryCls, "<init>", "(I)V");
            type                        = env->NewObject(typeEntryCls, typeEntryTypeCtor, typeValue);
        }

        bool endpointListIDNull     = false;
        bool endpointListIDHasValue = true;

        uint16_t endpointListIDValue = entry.endpointListID;

        jobject endpointListID = nullptr;
        if (!endpointListIDNull && endpointListIDHasValue)
        {
            jclass endpointListIDEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", endpointListIDEntryCls);
            chip::JniClass endpointListIDJniClass(endpointListIDEntryCls);
            jmethodID endpointListIDEntryTypeCtor = env->GetMethodID(endpointListIDEntryCls, "<init>", "(I)V");
            endpointListID = env->NewObject(endpointListIDEntryCls, endpointListIDEntryTypeCtor, endpointListIDValue);
        }

        bool supportedCommandsNull     = false;
        bool supportedCommandsHasValue = true;

        uint16_t supportedCommandsValue = entry.supportedCommands;

        jobject supportedCommands = nullptr;
        if (!supportedCommandsNull && supportedCommandsHasValue)
        {
            jclass supportedCommandsEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", supportedCommandsEntryCls);
            chip::JniClass supportedCommandsJniClass(supportedCommandsEntryCls);
            jmethodID supportedCommandsEntryTypeCtor = env->GetMethodID(supportedCommandsEntryCls, "<init>", "(I)V");
            supportedCommands = env->NewObject(supportedCommandsEntryCls, supportedCommandsEntryTypeCtor, supportedCommandsValue);
        }

        bool statusNull     = false;
        bool statusHasValue = true;

        uint8_t statusValue = entry.status;

        jobject status = nullptr;
        if (!statusNull && statusHasValue)
        {
            jclass statusEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", statusEntryCls);
            chip::JniClass statusJniClass(statusEntryCls);
            jmethodID statusEntryTypeCtor = env->GetMethodID(statusEntryCls, "<init>", "(I)V");
            status                        = env->NewObject(statusEntryCls, statusEntryTypeCtor, statusValue);
        }

        jobject attributeObj =
            env->NewObject(attributeClass, attributeCtor, actionID, name, type, endpointListID, supportedCommands, status);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create ActionListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding ActionListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPBridgedActionsEndpointListAttributeCallback::CHIPBridgedActionsEndpointListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<BridgedActionsEndpointListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPBridgedActionsEndpointListAttributeCallback::~CHIPBridgedActionsEndpointListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPBridgedActionsEndpointListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType> &
        list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPBridgedActionsEndpointListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPBridgedActionsEndpointListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$BridgedActionsCluster$EndpointListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$BridgedActionsCluster$EndpointListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Integer;Ljava/lang/String;Ljava/lang/Integer;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find EndpointListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool endpointListIDNull     = false;
        bool endpointListIDHasValue = true;

        uint16_t endpointListIDValue = entry.endpointListID;

        jobject endpointListID = nullptr;
        if (!endpointListIDNull && endpointListIDHasValue)
        {
            jclass endpointListIDEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", endpointListIDEntryCls);
            chip::JniClass endpointListIDJniClass(endpointListIDEntryCls);
            jmethodID endpointListIDEntryTypeCtor = env->GetMethodID(endpointListIDEntryCls, "<init>", "(I)V");
            endpointListID = env->NewObject(endpointListIDEntryCls, endpointListIDEntryTypeCtor, endpointListIDValue);
        }

        bool nameNull     = false;
        bool nameHasValue = true;

        chip::CharSpan nameValue = entry.name;

        jstring name = nullptr;
        chip::UtfString nameStr(env, nameValue);
        if (!nameNull && nameHasValue)
        {
            name = jstring(nameStr.jniValue());
        }

        bool typeNull     = false;
        bool typeHasValue = true;

        uint8_t typeValue = entry.type;

        jobject type = nullptr;
        if (!typeNull && typeHasValue)
        {
            jclass typeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", typeEntryCls);
            chip::JniClass typeJniClass(typeEntryCls);
            jmethodID typeEntryTypeCtor = env->GetMethodID(typeEntryCls, "<init>", "(I)V");
            type                        = env->NewObject(typeEntryCls, typeEntryTypeCtor, typeValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, endpointListID, name, type);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create EndpointListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding EndpointListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPContentLauncherAcceptsHeaderListAttributeCallback::CHIPContentLauncherAcceptsHeaderListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<ContentLauncherAcceptsHeaderListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPContentLauncherAcceptsHeaderListAttributeCallback::~CHIPContentLauncherAcceptsHeaderListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPContentLauncherAcceptsHeaderListAttributeCallback::CallbackFn(
    void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPContentLauncherAcceptsHeaderListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPContentLauncherAcceptsHeaderListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry              = iter.GetValue();
        bool entryNull            = false;
        chip::ByteSpan entryValue = entry;

        jbyteArray entryObject = nullptr;
        if (!entryNull)
        {
            entryObject = env->NewByteArray(entryValue.size());
            env->SetByteArrayRegion(entryObject, 0, entryValue.size(), reinterpret_cast<const jbyte *>(entryValue.data()));
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding AcceptsHeaderListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPContentLauncherSupportedStreamingTypesAttributeCallback::CHIPContentLauncherSupportedStreamingTypesAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<ContentLauncherSupportedStreamingTypesListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPContentLauncherSupportedStreamingTypesAttributeCallback::~CHIPContentLauncherSupportedStreamingTypesAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPContentLauncherSupportedStreamingTypesAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::ContentLauncher::ContentLaunchStreamingType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPContentLauncherSupportedStreamingTypesAttributeCallback> cppCallback(
        reinterpret_cast<CHIPContentLauncherSupportedStreamingTypesAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry       = iter.GetValue();
        bool entryNull     = false;
        uint8_t entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding SupportedStreamingTypesAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPDescriptorDeviceListAttributeCallback::CHIPDescriptorDeviceListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<DescriptorDeviceListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPDescriptorDeviceListAttributeCallback::~CHIPDescriptorDeviceListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPDescriptorDeviceListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPDescriptorDeviceListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPDescriptorDeviceListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$DescriptorCluster$DeviceListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$DescriptorCluster$DeviceListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Long;Ljava/lang/Integer;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find DeviceListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool typeNull     = false;
        bool typeHasValue = true;

        chip::DeviceTypeId typeValue = entry.type;

        jobject type = nullptr;
        if (!typeNull && typeHasValue)
        {
            jclass typeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", typeEntryCls);
            chip::JniClass typeJniClass(typeEntryCls);
            jmethodID typeEntryTypeCtor = env->GetMethodID(typeEntryCls, "<init>", "(J)V");
            type                        = env->NewObject(typeEntryCls, typeEntryTypeCtor, typeValue);
        }

        bool revisionNull     = false;
        bool revisionHasValue = true;

        uint16_t revisionValue = entry.revision;

        jobject revision = nullptr;
        if (!revisionNull && revisionHasValue)
        {
            jclass revisionEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", revisionEntryCls);
            chip::JniClass revisionJniClass(revisionEntryCls);
            jmethodID revisionEntryTypeCtor = env->GetMethodID(revisionEntryCls, "<init>", "(I)V");
            revision                        = env->NewObject(revisionEntryCls, revisionEntryTypeCtor, revisionValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, type, revision);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create DeviceListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding DeviceListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPDescriptorServerListAttributeCallback::CHIPDescriptorServerListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<DescriptorServerListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPDescriptorServerListAttributeCallback::~CHIPDescriptorServerListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPDescriptorServerListAttributeCallback::CallbackFn(void * context,
                                                           const chip::app::DataModel::DecodableList<chip::ClusterId> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPDescriptorServerListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPDescriptorServerListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry               = iter.GetValue();
        bool entryNull             = false;
        chip::ClusterId entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(J)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding ServerListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPDescriptorClientListAttributeCallback::CHIPDescriptorClientListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<DescriptorClientListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPDescriptorClientListAttributeCallback::~CHIPDescriptorClientListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPDescriptorClientListAttributeCallback::CallbackFn(void * context,
                                                           const chip::app::DataModel::DecodableList<chip::ClusterId> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPDescriptorClientListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPDescriptorClientListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry               = iter.GetValue();
        bool entryNull             = false;
        chip::ClusterId entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(J)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding ClientListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPDescriptorPartsListAttributeCallback::CHIPDescriptorPartsListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<DescriptorPartsListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPDescriptorPartsListAttributeCallback::~CHIPDescriptorPartsListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPDescriptorPartsListAttributeCallback::CallbackFn(void * context,
                                                          const chip::app::DataModel::DecodableList<chip::EndpointId> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPDescriptorPartsListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPDescriptorPartsListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry                = iter.GetValue();
        bool entryNull              = false;
        chip::EndpointId entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding PartsListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPFixedLabelLabelListAttributeCallback::CHIPFixedLabelLabelListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<FixedLabelLabelListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPFixedLabelLabelListAttributeCallback::~CHIPFixedLabelLabelListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPFixedLabelLabelListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPFixedLabelLabelListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPFixedLabelLabelListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$FixedLabelCluster$LabelListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$FixedLabelCluster$LabelListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find LabelListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool labelNull     = false;
        bool labelHasValue = true;

        chip::CharSpan labelValue = entry.label;

        jstring label = nullptr;
        chip::UtfString labelStr(env, labelValue);
        if (!labelNull && labelHasValue)
        {
            label = jstring(labelStr.jniValue());
        }

        bool valueNull     = false;
        bool valueHasValue = true;

        chip::CharSpan valueValue = entry.value;

        jstring value = nullptr;
        chip::UtfString valueStr(env, valueValue);
        if (!valueNull && valueHasValue)
        {
            value = jstring(valueStr.jniValue());
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, label, value);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create LabelListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding LabelListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback::
    CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<GeneralCommissioningBasicCommissioningInfoListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback::
    ~CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPGeneralCommissioningBasicCommissioningInfoListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$GeneralCommissioningCluster$BasicCommissioningInfoListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl,
                     "Could not find class "
                     "chip/devicecontroller/ChipClusters$GeneralCommissioningCluster$BasicCommissioningInfoListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Long;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find BasicCommissioningInfoListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool failSafeExpiryLengthMsNull     = false;
        bool failSafeExpiryLengthMsHasValue = true;

        uint32_t failSafeExpiryLengthMsValue = entry.failSafeExpiryLengthMs;

        jobject failSafeExpiryLengthMs = nullptr;
        if (!failSafeExpiryLengthMsNull && failSafeExpiryLengthMsHasValue)
        {
            jclass failSafeExpiryLengthMsEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", failSafeExpiryLengthMsEntryCls);
            chip::JniClass failSafeExpiryLengthMsJniClass(failSafeExpiryLengthMsEntryCls);
            jmethodID failSafeExpiryLengthMsEntryTypeCtor = env->GetMethodID(failSafeExpiryLengthMsEntryCls, "<init>", "(J)V");
            failSafeExpiryLengthMs =
                env->NewObject(failSafeExpiryLengthMsEntryCls, failSafeExpiryLengthMsEntryTypeCtor, failSafeExpiryLengthMsValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, failSafeExpiryLengthMs);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create BasicCommissioningInfoListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding BasicCommissioningInfoListAttribute value: %" CHIP_ERROR_FORMAT,
                                iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback::CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<GeneralDiagnosticsNetworkInterfacesListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback::~CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback> cppCallback(
        reinterpret_cast<CHIPGeneralDiagnosticsNetworkInterfacesAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$GeneralDiagnosticsCluster$NetworkInterfacesAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(
            Zcl, "Could not find class chip/devicecontroller/ChipClusters$GeneralDiagnosticsCluster$NetworkInterfacesAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>",
                         "(Ljava/lang/String;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;[BLjava/lang/Integer;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find NetworkInterfacesAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool nameNull     = false;
        bool nameHasValue = true;

        chip::CharSpan nameValue = entry.name;

        jstring name = nullptr;
        chip::UtfString nameStr(env, nameValue);
        if (!nameNull && nameHasValue)
        {
            name = jstring(nameStr.jniValue());
        }

        bool fabricConnectedNull     = false;
        bool fabricConnectedHasValue = true;

        bool fabricConnectedValue = entry.fabricConnected;

        jobject fabricConnected = nullptr;
        if (!fabricConnectedNull && fabricConnectedHasValue)
        {
            jclass fabricConnectedEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", fabricConnectedEntryCls);
            chip::JniClass fabricConnectedJniClass(fabricConnectedEntryCls);
            jmethodID fabricConnectedEntryTypeCtor = env->GetMethodID(fabricConnectedEntryCls, "<init>", "(Z)V");
            fabricConnected = env->NewObject(fabricConnectedEntryCls, fabricConnectedEntryTypeCtor, fabricConnectedValue);
        }

        bool offPremiseServicesReachableIPv4Null     = false;
        bool offPremiseServicesReachableIPv4HasValue = true;

        bool offPremiseServicesReachableIPv4Value = entry.offPremiseServicesReachableIPv4;

        jobject offPremiseServicesReachableIPv4 = nullptr;
        if (!offPremiseServicesReachableIPv4Null && offPremiseServicesReachableIPv4HasValue)
        {
            jclass offPremiseServicesReachableIPv4EntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", offPremiseServicesReachableIPv4EntryCls);
            chip::JniClass offPremiseServicesReachableIPv4JniClass(offPremiseServicesReachableIPv4EntryCls);
            jmethodID offPremiseServicesReachableIPv4EntryTypeCtor =
                env->GetMethodID(offPremiseServicesReachableIPv4EntryCls, "<init>", "(Z)V");
            offPremiseServicesReachableIPv4 =
                env->NewObject(offPremiseServicesReachableIPv4EntryCls, offPremiseServicesReachableIPv4EntryTypeCtor,
                               offPremiseServicesReachableIPv4Value);
        }

        bool offPremiseServicesReachableIPv6Null     = false;
        bool offPremiseServicesReachableIPv6HasValue = true;

        bool offPremiseServicesReachableIPv6Value = entry.offPremiseServicesReachableIPv6;

        jobject offPremiseServicesReachableIPv6 = nullptr;
        if (!offPremiseServicesReachableIPv6Null && offPremiseServicesReachableIPv6HasValue)
        {
            jclass offPremiseServicesReachableIPv6EntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", offPremiseServicesReachableIPv6EntryCls);
            chip::JniClass offPremiseServicesReachableIPv6JniClass(offPremiseServicesReachableIPv6EntryCls);
            jmethodID offPremiseServicesReachableIPv6EntryTypeCtor =
                env->GetMethodID(offPremiseServicesReachableIPv6EntryCls, "<init>", "(Z)V");
            offPremiseServicesReachableIPv6 =
                env->NewObject(offPremiseServicesReachableIPv6EntryCls, offPremiseServicesReachableIPv6EntryTypeCtor,
                               offPremiseServicesReachableIPv6Value);
        }

        bool hardwareAddressNull     = false;
        bool hardwareAddressHasValue = true;

        chip::ByteSpan hardwareAddressValue = entry.hardwareAddress;

        jbyteArray hardwareAddress = nullptr;
        if (!hardwareAddressNull && hardwareAddressHasValue)
        {
            hardwareAddress = env->NewByteArray(hardwareAddressValue.size());
            env->SetByteArrayRegion(hardwareAddress, 0, hardwareAddressValue.size(),
                                    reinterpret_cast<const jbyte *>(hardwareAddressValue.data()));
        }

        bool typeNull     = false;
        bool typeHasValue = true;

        uint8_t typeValue = entry.type;

        jobject type = nullptr;
        if (!typeNull && typeHasValue)
        {
            jclass typeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", typeEntryCls);
            chip::JniClass typeJniClass(typeEntryCls);
            jmethodID typeEntryTypeCtor = env->GetMethodID(typeEntryCls, "<init>", "(I)V");
            type                        = env->NewObject(typeEntryCls, typeEntryTypeCtor, typeValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, name, fabricConnected, offPremiseServicesReachableIPv4,
                                              offPremiseServicesReachableIPv6, hardwareAddress, type);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create NetworkInterfacesAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding NetworkInterfacesAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPGeneralDiagnosticsActiveHardwareFaultsAttributeCallback::CHIPGeneralDiagnosticsActiveHardwareFaultsAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<GeneralDiagnosticsActiveHardwareFaultsListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPGeneralDiagnosticsActiveHardwareFaultsAttributeCallback::~CHIPGeneralDiagnosticsActiveHardwareFaultsAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPGeneralDiagnosticsActiveHardwareFaultsAttributeCallback::CallbackFn(
    void * context, const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPGeneralDiagnosticsActiveHardwareFaultsAttributeCallback> cppCallback(
        reinterpret_cast<CHIPGeneralDiagnosticsActiveHardwareFaultsAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry       = iter.GetValue();
        bool entryNull     = false;
        uint8_t entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ActiveHardwareFaultsAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPGeneralDiagnosticsActiveRadioFaultsAttributeCallback::CHIPGeneralDiagnosticsActiveRadioFaultsAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<GeneralDiagnosticsActiveRadioFaultsListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPGeneralDiagnosticsActiveRadioFaultsAttributeCallback::~CHIPGeneralDiagnosticsActiveRadioFaultsAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPGeneralDiagnosticsActiveRadioFaultsAttributeCallback::CallbackFn(void * context,
                                                                          const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPGeneralDiagnosticsActiveRadioFaultsAttributeCallback> cppCallback(
        reinterpret_cast<CHIPGeneralDiagnosticsActiveRadioFaultsAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry       = iter.GetValue();
        bool entryNull     = false;
        uint8_t entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ActiveRadioFaultsAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPGeneralDiagnosticsActiveNetworkFaultsAttributeCallback::CHIPGeneralDiagnosticsActiveNetworkFaultsAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<GeneralDiagnosticsActiveNetworkFaultsListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPGeneralDiagnosticsActiveNetworkFaultsAttributeCallback::~CHIPGeneralDiagnosticsActiveNetworkFaultsAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPGeneralDiagnosticsActiveNetworkFaultsAttributeCallback::CallbackFn(
    void * context, const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPGeneralDiagnosticsActiveNetworkFaultsAttributeCallback> cppCallback(
        reinterpret_cast<CHIPGeneralDiagnosticsActiveNetworkFaultsAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry       = iter.GetValue();
        bool entryNull     = false;
        uint8_t entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ActiveNetworkFaultsAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPGroupKeyManagementGroupsAttributeCallback::CHIPGroupKeyManagementGroupsAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<GroupKeyManagementGroupsListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPGroupKeyManagementGroupsAttributeCallback::~CHIPGroupKeyManagementGroupsAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPGroupKeyManagementGroupsAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupState::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPGroupKeyManagementGroupsAttributeCallback> cppCallback(
        reinterpret_cast<CHIPGroupKeyManagementGroupsAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$GroupKeyManagementCluster$GroupsAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$GroupKeyManagementCluster$GroupsAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Integer;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find GroupsAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool vendorIdNull     = false;
        bool vendorIdHasValue = true;

        uint16_t vendorIdValue = entry.vendorId;

        jobject vendorId = nullptr;
        if (!vendorIdNull && vendorIdHasValue)
        {
            jclass vendorIdEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", vendorIdEntryCls);
            chip::JniClass vendorIdJniClass(vendorIdEntryCls);
            jmethodID vendorIdEntryTypeCtor = env->GetMethodID(vendorIdEntryCls, "<init>", "(I)V");
            vendorId                        = env->NewObject(vendorIdEntryCls, vendorIdEntryTypeCtor, vendorIdValue);
        }

        bool vendorGroupIdNull     = false;
        bool vendorGroupIdHasValue = true;

        uint16_t vendorGroupIdValue = entry.vendorGroupId;

        jobject vendorGroupId = nullptr;
        if (!vendorGroupIdNull && vendorGroupIdHasValue)
        {
            jclass vendorGroupIdEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", vendorGroupIdEntryCls);
            chip::JniClass vendorGroupIdJniClass(vendorGroupIdEntryCls);
            jmethodID vendorGroupIdEntryTypeCtor = env->GetMethodID(vendorGroupIdEntryCls, "<init>", "(I)V");
            vendorGroupId = env->NewObject(vendorGroupIdEntryCls, vendorGroupIdEntryTypeCtor, vendorGroupIdValue);
        }

        bool groupKeySetIndexNull     = false;
        bool groupKeySetIndexHasValue = true;

        uint16_t groupKeySetIndexValue = entry.groupKeySetIndex;

        jobject groupKeySetIndex = nullptr;
        if (!groupKeySetIndexNull && groupKeySetIndexHasValue)
        {
            jclass groupKeySetIndexEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", groupKeySetIndexEntryCls);
            chip::JniClass groupKeySetIndexJniClass(groupKeySetIndexEntryCls);
            jmethodID groupKeySetIndexEntryTypeCtor = env->GetMethodID(groupKeySetIndexEntryCls, "<init>", "(I)V");
            groupKeySetIndex = env->NewObject(groupKeySetIndexEntryCls, groupKeySetIndexEntryTypeCtor, groupKeySetIndexValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, vendorId, vendorGroupId, groupKeySetIndex);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create GroupsAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding GroupsAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPGroupKeyManagementGroupKeysAttributeCallback::CHIPGroupKeyManagementGroupKeysAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<GroupKeyManagementGroupKeysListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPGroupKeyManagementGroupKeysAttributeCallback::~CHIPGroupKeyManagementGroupKeysAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPGroupKeyManagementGroupKeysAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPGroupKeyManagementGroupKeysAttributeCallback> cppCallback(
        reinterpret_cast<CHIPGroupKeyManagementGroupKeysAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$GroupKeyManagementCluster$GroupKeysAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$GroupKeyManagementCluster$GroupKeysAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>",
                                               "(Ljava/lang/Integer;Ljava/lang/Integer;[BLjava/lang/Long;Ljava/lang/Integer;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find GroupKeysAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool vendorIdNull     = false;
        bool vendorIdHasValue = true;

        uint16_t vendorIdValue = entry.vendorId;

        jobject vendorId = nullptr;
        if (!vendorIdNull && vendorIdHasValue)
        {
            jclass vendorIdEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", vendorIdEntryCls);
            chip::JniClass vendorIdJniClass(vendorIdEntryCls);
            jmethodID vendorIdEntryTypeCtor = env->GetMethodID(vendorIdEntryCls, "<init>", "(I)V");
            vendorId                        = env->NewObject(vendorIdEntryCls, vendorIdEntryTypeCtor, vendorIdValue);
        }

        bool groupKeyIndexNull     = false;
        bool groupKeyIndexHasValue = true;

        uint16_t groupKeyIndexValue = entry.groupKeyIndex;

        jobject groupKeyIndex = nullptr;
        if (!groupKeyIndexNull && groupKeyIndexHasValue)
        {
            jclass groupKeyIndexEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", groupKeyIndexEntryCls);
            chip::JniClass groupKeyIndexJniClass(groupKeyIndexEntryCls);
            jmethodID groupKeyIndexEntryTypeCtor = env->GetMethodID(groupKeyIndexEntryCls, "<init>", "(I)V");
            groupKeyIndex = env->NewObject(groupKeyIndexEntryCls, groupKeyIndexEntryTypeCtor, groupKeyIndexValue);
        }

        bool groupKeyRootNull     = false;
        bool groupKeyRootHasValue = true;

        chip::ByteSpan groupKeyRootValue = entry.groupKeyRoot;

        jbyteArray groupKeyRoot = nullptr;
        if (!groupKeyRootNull && groupKeyRootHasValue)
        {
            groupKeyRoot = env->NewByteArray(groupKeyRootValue.size());
            env->SetByteArrayRegion(groupKeyRoot, 0, groupKeyRootValue.size(),
                                    reinterpret_cast<const jbyte *>(groupKeyRootValue.data()));
        }

        bool groupKeyEpochStartTimeNull     = false;
        bool groupKeyEpochStartTimeHasValue = true;

        uint64_t groupKeyEpochStartTimeValue = entry.groupKeyEpochStartTime;

        jobject groupKeyEpochStartTime = nullptr;
        if (!groupKeyEpochStartTimeNull && groupKeyEpochStartTimeHasValue)
        {
            jclass groupKeyEpochStartTimeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", groupKeyEpochStartTimeEntryCls);
            chip::JniClass groupKeyEpochStartTimeJniClass(groupKeyEpochStartTimeEntryCls);
            jmethodID groupKeyEpochStartTimeEntryTypeCtor = env->GetMethodID(groupKeyEpochStartTimeEntryCls, "<init>", "(J)V");
            groupKeyEpochStartTime =
                env->NewObject(groupKeyEpochStartTimeEntryCls, groupKeyEpochStartTimeEntryTypeCtor, groupKeyEpochStartTimeValue);
        }

        bool groupKeySecurityPolicyNull     = false;
        bool groupKeySecurityPolicyHasValue = true;

        uint8_t groupKeySecurityPolicyValue = entry.groupKeySecurityPolicy;

        jobject groupKeySecurityPolicy = nullptr;
        if (!groupKeySecurityPolicyNull && groupKeySecurityPolicyHasValue)
        {
            jclass groupKeySecurityPolicyEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", groupKeySecurityPolicyEntryCls);
            chip::JniClass groupKeySecurityPolicyJniClass(groupKeySecurityPolicyEntryCls);
            jmethodID groupKeySecurityPolicyEntryTypeCtor = env->GetMethodID(groupKeySecurityPolicyEntryCls, "<init>", "(I)V");
            groupKeySecurityPolicy =
                env->NewObject(groupKeySecurityPolicyEntryCls, groupKeySecurityPolicyEntryTypeCtor, groupKeySecurityPolicyValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, vendorId, groupKeyIndex, groupKeyRoot,
                                              groupKeyEpochStartTime, groupKeySecurityPolicy);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create GroupKeysAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding GroupKeysAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPMediaInputMediaInputListAttributeCallback::CHIPMediaInputMediaInputListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<MediaInputMediaInputListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPMediaInputMediaInputListAttributeCallback::~CHIPMediaInputMediaInputListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPMediaInputMediaInputListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPMediaInputMediaInputListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPMediaInputMediaInputListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$MediaInputCluster$MediaInputListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$MediaInputCluster$MediaInputListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/String;Ljava/lang/String;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find MediaInputListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool indexNull     = false;
        bool indexHasValue = true;

        uint8_t indexValue = entry.index;

        jobject index = nullptr;
        if (!indexNull && indexHasValue)
        {
            jclass indexEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", indexEntryCls);
            chip::JniClass indexJniClass(indexEntryCls);
            jmethodID indexEntryTypeCtor = env->GetMethodID(indexEntryCls, "<init>", "(I)V");
            index                        = env->NewObject(indexEntryCls, indexEntryTypeCtor, indexValue);
        }

        bool inputTypeNull     = false;
        bool inputTypeHasValue = true;

        uint8_t inputTypeValue = entry.inputType;

        jobject inputType = nullptr;
        if (!inputTypeNull && inputTypeHasValue)
        {
            jclass inputTypeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", inputTypeEntryCls);
            chip::JniClass inputTypeJniClass(inputTypeEntryCls);
            jmethodID inputTypeEntryTypeCtor = env->GetMethodID(inputTypeEntryCls, "<init>", "(I)V");
            inputType                        = env->NewObject(inputTypeEntryCls, inputTypeEntryTypeCtor, inputTypeValue);
        }

        bool nameNull     = false;
        bool nameHasValue = true;

        chip::CharSpan nameValue = entry.name;

        jstring name = nullptr;
        chip::UtfString nameStr(env, nameValue);
        if (!nameNull && nameHasValue)
        {
            name = jstring(nameStr.jniValue());
        }

        bool descriptionNull     = false;
        bool descriptionHasValue = true;

        chip::CharSpan descriptionValue = entry.description;

        jstring description = nullptr;
        chip::UtfString descriptionStr(env, descriptionValue);
        if (!descriptionNull && descriptionHasValue)
        {
            description = jstring(descriptionStr.jniValue());
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, index, inputType, name, description);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create MediaInputListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding MediaInputListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPModeSelectSupportedModesAttributeCallback::CHIPModeSelectSupportedModesAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<ModeSelectSupportedModesListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPModeSelectSupportedModesAttributeCallback::~CHIPModeSelectSupportedModesAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPModeSelectSupportedModesAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPModeSelectSupportedModesAttributeCallback> cppCallback(
        reinterpret_cast<CHIPModeSelectSupportedModesAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$ModeSelectCluster$SupportedModesAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$ModeSelectCluster$SupportedModesAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/String;Ljava/lang/Integer;Ljava/lang/Long;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find SupportedModesAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool labelNull     = false;
        bool labelHasValue = true;

        chip::CharSpan labelValue = entry.label;

        jstring label = nullptr;
        chip::UtfString labelStr(env, labelValue);
        if (!labelNull && labelHasValue)
        {
            label = jstring(labelStr.jniValue());
        }

        bool modeNull     = false;
        bool modeHasValue = true;

        uint8_t modeValue = entry.mode;

        jobject mode = nullptr;
        if (!modeNull && modeHasValue)
        {
            jclass modeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", modeEntryCls);
            chip::JniClass modeJniClass(modeEntryCls);
            jmethodID modeEntryTypeCtor = env->GetMethodID(modeEntryCls, "<init>", "(I)V");
            mode                        = env->NewObject(modeEntryCls, modeEntryTypeCtor, modeValue);
        }

        bool semanticTagNull     = false;
        bool semanticTagHasValue = true;

        uint32_t semanticTagValue = entry.semanticTag;

        jobject semanticTag = nullptr;
        if (!semanticTagNull && semanticTagHasValue)
        {
            jclass semanticTagEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", semanticTagEntryCls);
            chip::JniClass semanticTagJniClass(semanticTagEntryCls);
            jmethodID semanticTagEntryTypeCtor = env->GetMethodID(semanticTagEntryCls, "<init>", "(J)V");
            semanticTag                        = env->NewObject(semanticTagEntryCls, semanticTagEntryTypeCtor, semanticTagValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, label, mode, semanticTag);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create SupportedModesAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding SupportedModesAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPOperationalCredentialsFabricsListAttributeCallback::CHIPOperationalCredentialsFabricsListAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<OperationalCredentialsFabricsListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPOperationalCredentialsFabricsListAttributeCallback::~CHIPOperationalCredentialsFabricsListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPOperationalCredentialsFabricsListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPOperationalCredentialsFabricsListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPOperationalCredentialsFabricsListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$OperationalCredentialsCluster$FabricsListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl,
                     "Could not find class chip/devicecontroller/ChipClusters$OperationalCredentialsCluster$FabricsListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(
        attributeClass, "<init>", "(Ljava/lang/Integer;[BLjava/lang/Integer;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/String;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find FabricsListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool fabricIndexNull     = false;
        bool fabricIndexHasValue = true;

        uint8_t fabricIndexValue = entry.fabricIndex;

        jobject fabricIndex = nullptr;
        if (!fabricIndexNull && fabricIndexHasValue)
        {
            jclass fabricIndexEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", fabricIndexEntryCls);
            chip::JniClass fabricIndexJniClass(fabricIndexEntryCls);
            jmethodID fabricIndexEntryTypeCtor = env->GetMethodID(fabricIndexEntryCls, "<init>", "(I)V");
            fabricIndex                        = env->NewObject(fabricIndexEntryCls, fabricIndexEntryTypeCtor, fabricIndexValue);
        }

        bool rootPublicKeyNull     = false;
        bool rootPublicKeyHasValue = true;

        chip::ByteSpan rootPublicKeyValue = entry.rootPublicKey;

        jbyteArray rootPublicKey = nullptr;
        if (!rootPublicKeyNull && rootPublicKeyHasValue)
        {
            rootPublicKey = env->NewByteArray(rootPublicKeyValue.size());
            env->SetByteArrayRegion(rootPublicKey, 0, rootPublicKeyValue.size(),
                                    reinterpret_cast<const jbyte *>(rootPublicKeyValue.data()));
        }

        bool vendorIdNull     = false;
        bool vendorIdHasValue = true;

        uint16_t vendorIdValue = entry.vendorId;

        jobject vendorId = nullptr;
        if (!vendorIdNull && vendorIdHasValue)
        {
            jclass vendorIdEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", vendorIdEntryCls);
            chip::JniClass vendorIdJniClass(vendorIdEntryCls);
            jmethodID vendorIdEntryTypeCtor = env->GetMethodID(vendorIdEntryCls, "<init>", "(I)V");
            vendorId                        = env->NewObject(vendorIdEntryCls, vendorIdEntryTypeCtor, vendorIdValue);
        }

        bool fabricIdNull     = false;
        bool fabricIdHasValue = true;

        chip::FabricId fabricIdValue = entry.fabricId;

        jobject fabricId = nullptr;
        if (!fabricIdNull && fabricIdHasValue)
        {
            jclass fabricIdEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", fabricIdEntryCls);
            chip::JniClass fabricIdJniClass(fabricIdEntryCls);
            jmethodID fabricIdEntryTypeCtor = env->GetMethodID(fabricIdEntryCls, "<init>", "(J)V");
            fabricId                        = env->NewObject(fabricIdEntryCls, fabricIdEntryTypeCtor, fabricIdValue);
        }

        bool nodeIdNull     = false;
        bool nodeIdHasValue = true;

        chip::NodeId nodeIdValue = entry.nodeId;

        jobject nodeId = nullptr;
        if (!nodeIdNull && nodeIdHasValue)
        {
            jclass nodeIdEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", nodeIdEntryCls);
            chip::JniClass nodeIdJniClass(nodeIdEntryCls);
            jmethodID nodeIdEntryTypeCtor = env->GetMethodID(nodeIdEntryCls, "<init>", "(J)V");
            nodeId                        = env->NewObject(nodeIdEntryCls, nodeIdEntryTypeCtor, nodeIdValue);
        }

        bool labelNull     = false;
        bool labelHasValue = true;

        chip::CharSpan labelValue = entry.label;

        jstring label = nullptr;
        chip::UtfString labelStr(env, labelValue);
        if (!labelNull && labelHasValue)
        {
            label = jstring(labelStr.jniValue());
        }

        jobject attributeObj =
            env->NewObject(attributeClass, attributeCtor, fabricIndex, rootPublicKey, vendorId, fabricId, nodeId, label);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create FabricsListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding FabricsListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback::
    CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<OperationalCredentialsTrustedRootCertificatesListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback::
    ~CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback::CallbackFn(
    void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback> cppCallback(
        reinterpret_cast<CHIPOperationalCredentialsTrustedRootCertificatesAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry              = iter.GetValue();
        bool entryNull            = false;
        chip::ByteSpan entryValue = entry;

        jbyteArray entryObject = nullptr;
        if (!entryNull)
        {
            entryObject = env->NewByteArray(entryValue.size());
            env->SetByteArrayRegion(entryObject, 0, entryValue.size(), reinterpret_cast<const jbyte *>(entryValue.data()));
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding TrustedRootCertificatesAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPPowerSourceActiveBatteryFaultsAttributeCallback::CHIPPowerSourceActiveBatteryFaultsAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<PowerSourceActiveBatteryFaultsListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPPowerSourceActiveBatteryFaultsAttributeCallback::~CHIPPowerSourceActiveBatteryFaultsAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPPowerSourceActiveBatteryFaultsAttributeCallback::CallbackFn(void * context,
                                                                     const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPPowerSourceActiveBatteryFaultsAttributeCallback> cppCallback(
        reinterpret_cast<CHIPPowerSourceActiveBatteryFaultsAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry       = iter.GetValue();
        bool entryNull     = false;
        uint8_t entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ActiveBatteryFaultsAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPSoftwareDiagnosticsThreadMetricsAttributeCallback::CHIPSoftwareDiagnosticsThreadMetricsAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<SoftwareDiagnosticsThreadMetricsListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPSoftwareDiagnosticsThreadMetricsAttributeCallback::~CHIPSoftwareDiagnosticsThreadMetricsAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPSoftwareDiagnosticsThreadMetricsAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> &
        list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPSoftwareDiagnosticsThreadMetricsAttributeCallback> cppCallback(
        reinterpret_cast<CHIPSoftwareDiagnosticsThreadMetricsAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$SoftwareDiagnosticsCluster$ThreadMetricsAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl,
                     "Could not find class chip/devicecontroller/ChipClusters$SoftwareDiagnosticsCluster$ThreadMetricsAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(
        attributeClass, "<init>", "(Ljava/lang/Long;Ljava/lang/String;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find ThreadMetricsAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool idNull     = false;
        bool idHasValue = true;

        uint64_t idValue = entry.id;

        jobject id = nullptr;
        if (!idNull && idHasValue)
        {
            jclass idEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", idEntryCls);
            chip::JniClass idJniClass(idEntryCls);
            jmethodID idEntryTypeCtor = env->GetMethodID(idEntryCls, "<init>", "(J)V");
            id                        = env->NewObject(idEntryCls, idEntryTypeCtor, idValue);
        }

        bool nameNull     = false;
        bool nameHasValue = true;

        chip::CharSpan nameValue = entry.name;

        jstring name = nullptr;
        chip::UtfString nameStr(env, nameValue);
        if (!nameNull && nameHasValue)
        {
            name = jstring(nameStr.jniValue());
        }

        bool stackFreeCurrentNull     = false;
        bool stackFreeCurrentHasValue = true;

        uint32_t stackFreeCurrentValue = entry.stackFreeCurrent;

        jobject stackFreeCurrent = nullptr;
        if (!stackFreeCurrentNull && stackFreeCurrentHasValue)
        {
            jclass stackFreeCurrentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", stackFreeCurrentEntryCls);
            chip::JniClass stackFreeCurrentJniClass(stackFreeCurrentEntryCls);
            jmethodID stackFreeCurrentEntryTypeCtor = env->GetMethodID(stackFreeCurrentEntryCls, "<init>", "(J)V");
            stackFreeCurrent = env->NewObject(stackFreeCurrentEntryCls, stackFreeCurrentEntryTypeCtor, stackFreeCurrentValue);
        }

        bool stackFreeMinimumNull     = false;
        bool stackFreeMinimumHasValue = true;

        uint32_t stackFreeMinimumValue = entry.stackFreeMinimum;

        jobject stackFreeMinimum = nullptr;
        if (!stackFreeMinimumNull && stackFreeMinimumHasValue)
        {
            jclass stackFreeMinimumEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", stackFreeMinimumEntryCls);
            chip::JniClass stackFreeMinimumJniClass(stackFreeMinimumEntryCls);
            jmethodID stackFreeMinimumEntryTypeCtor = env->GetMethodID(stackFreeMinimumEntryCls, "<init>", "(J)V");
            stackFreeMinimum = env->NewObject(stackFreeMinimumEntryCls, stackFreeMinimumEntryTypeCtor, stackFreeMinimumValue);
        }

        bool stackSizeNull     = false;
        bool stackSizeHasValue = true;

        uint32_t stackSizeValue = entry.stackSize;

        jobject stackSize = nullptr;
        if (!stackSizeNull && stackSizeHasValue)
        {
            jclass stackSizeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", stackSizeEntryCls);
            chip::JniClass stackSizeJniClass(stackSizeEntryCls);
            jmethodID stackSizeEntryTypeCtor = env->GetMethodID(stackSizeEntryCls, "<init>", "(J)V");
            stackSize                        = env->NewObject(stackSizeEntryCls, stackSizeEntryTypeCtor, stackSizeValue);
        }

        jobject attributeObj =
            env->NewObject(attributeClass, attributeCtor, id, name, stackFreeCurrent, stackFreeMinimum, stackSize);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create ThreadMetricsAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ThreadMetricsAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPTvChannelTvChannelListAttributeCallback::CHIPTvChannelTvChannelListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<TvChannelTvChannelListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPTvChannelTvChannelListAttributeCallback::~CHIPTvChannelTvChannelListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPTvChannelTvChannelListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPTvChannelTvChannelListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPTvChannelTvChannelListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$TvChannelCluster$TvChannelListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Could not find class chip/devicecontroller/ChipClusters$TvChannelCluster$TvChannelListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>",
                         "(Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find TvChannelListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool majorNumberNull     = false;
        bool majorNumberHasValue = true;

        uint16_t majorNumberValue = entry.majorNumber;

        jobject majorNumber = nullptr;
        if (!majorNumberNull && majorNumberHasValue)
        {
            jclass majorNumberEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", majorNumberEntryCls);
            chip::JniClass majorNumberJniClass(majorNumberEntryCls);
            jmethodID majorNumberEntryTypeCtor = env->GetMethodID(majorNumberEntryCls, "<init>", "(I)V");
            majorNumber                        = env->NewObject(majorNumberEntryCls, majorNumberEntryTypeCtor, majorNumberValue);
        }

        bool minorNumberNull     = false;
        bool minorNumberHasValue = true;

        uint16_t minorNumberValue = entry.minorNumber;

        jobject minorNumber = nullptr;
        if (!minorNumberNull && minorNumberHasValue)
        {
            jclass minorNumberEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", minorNumberEntryCls);
            chip::JniClass minorNumberJniClass(minorNumberEntryCls);
            jmethodID minorNumberEntryTypeCtor = env->GetMethodID(minorNumberEntryCls, "<init>", "(I)V");
            minorNumber                        = env->NewObject(minorNumberEntryCls, minorNumberEntryTypeCtor, minorNumberValue);
        }

        bool nameNull     = false;
        bool nameHasValue = true;

        chip::CharSpan nameValue = entry.name;

        jstring name = nullptr;
        chip::UtfString nameStr(env, nameValue);
        if (!nameNull && nameHasValue)
        {
            name = jstring(nameStr.jniValue());
        }

        bool callSignNull     = false;
        bool callSignHasValue = true;

        chip::CharSpan callSignValue = entry.callSign;

        jstring callSign = nullptr;
        chip::UtfString callSignStr(env, callSignValue);
        if (!callSignNull && callSignHasValue)
        {
            callSign = jstring(callSignStr.jniValue());
        }

        bool affiliateCallSignNull     = false;
        bool affiliateCallSignHasValue = true;

        chip::CharSpan affiliateCallSignValue = entry.affiliateCallSign;

        jstring affiliateCallSign = nullptr;
        chip::UtfString affiliateCallSignStr(env, affiliateCallSignValue);
        if (!affiliateCallSignNull && affiliateCallSignHasValue)
        {
            affiliateCallSign = jstring(affiliateCallSignStr.jniValue());
        }

        jobject attributeObj =
            env->NewObject(attributeClass, attributeCtor, majorNumber, minorNumber, name, callSign, affiliateCallSign);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create TvChannelListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding TvChannelListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPTargetNavigatorTargetNavigatorListAttributeCallback::CHIPTargetNavigatorTargetNavigatorListAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<TargetNavigatorTargetNavigatorListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPTargetNavigatorTargetNavigatorListAttributeCallback::~CHIPTargetNavigatorTargetNavigatorListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPTargetNavigatorTargetNavigatorListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPTargetNavigatorTargetNavigatorListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPTargetNavigatorTargetNavigatorListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$TargetNavigatorCluster$TargetNavigatorListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(
            Zcl, "Could not find class chip/devicecontroller/ChipClusters$TargetNavigatorCluster$TargetNavigatorListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Integer;Ljava/lang/String;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find TargetNavigatorListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool identifierNull     = false;
        bool identifierHasValue = true;

        uint8_t identifierValue = entry.identifier;

        jobject identifier = nullptr;
        if (!identifierNull && identifierHasValue)
        {
            jclass identifierEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", identifierEntryCls);
            chip::JniClass identifierJniClass(identifierEntryCls);
            jmethodID identifierEntryTypeCtor = env->GetMethodID(identifierEntryCls, "<init>", "(I)V");
            identifier                        = env->NewObject(identifierEntryCls, identifierEntryTypeCtor, identifierValue);
        }

        bool nameNull     = false;
        bool nameHasValue = true;

        chip::CharSpan nameValue = entry.name;

        jstring name = nullptr;
        chip::UtfString nameStr(env, nameValue);
        if (!nameNull && nameHasValue)
        {
            name = jstring(nameStr.jniValue());
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, identifier, name);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create TargetNavigatorListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding TargetNavigatorListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPTestClusterListInt8uAttributeCallback::CHIPTestClusterListInt8uAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<TestClusterListInt8uListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPTestClusterListInt8uAttributeCallback::~CHIPTestClusterListInt8uAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPTestClusterListInt8uAttributeCallback::CallbackFn(void * context,
                                                           const chip::app::DataModel::DecodableList<uint8_t> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPTestClusterListInt8uAttributeCallback> cppCallback(
        reinterpret_cast<CHIPTestClusterListInt8uAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry       = iter.GetValue();
        bool entryNull     = false;
        uint8_t entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding ListInt8uAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPTestClusterListOctetStringAttributeCallback::CHIPTestClusterListOctetStringAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<TestClusterListOctetStringListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPTestClusterListOctetStringAttributeCallback::~CHIPTestClusterListOctetStringAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPTestClusterListOctetStringAttributeCallback::CallbackFn(void * context,
                                                                 const chip::app::DataModel::DecodableList<chip::ByteSpan> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPTestClusterListOctetStringAttributeCallback> cppCallback(
        reinterpret_cast<CHIPTestClusterListOctetStringAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry              = iter.GetValue();
        bool entryNull            = false;
        chip::ByteSpan entryValue = entry;

        jbyteArray entryObject = nullptr;
        if (!entryNull)
        {
            entryObject = env->NewByteArray(entryValue.size());
            env->SetByteArrayRegion(entryObject, 0, entryValue.size(), reinterpret_cast<const jbyte *>(entryValue.data()));
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ListOctetStringAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPTestClusterListStructOctetStringAttributeCallback::CHIPTestClusterListStructOctetStringAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<TestClusterListStructOctetStringListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPTestClusterListStructOctetStringAttributeCallback::~CHIPTestClusterListStructOctetStringAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPTestClusterListStructOctetStringAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPTestClusterListStructOctetStringAttributeCallback> cppCallback(
        reinterpret_cast<CHIPTestClusterListStructOctetStringAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$TestClusterCluster$ListStructOctetStringAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl,
                     "Could not find class chip/devicecontroller/ChipClusters$TestClusterCluster$ListStructOctetStringAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Long;[B)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find ListStructOctetStringAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool fabricIndexNull     = false;
        bool fabricIndexHasValue = true;

        uint64_t fabricIndexValue = entry.fabricIndex;

        jobject fabricIndex = nullptr;
        if (!fabricIndexNull && fabricIndexHasValue)
        {
            jclass fabricIndexEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", fabricIndexEntryCls);
            chip::JniClass fabricIndexJniClass(fabricIndexEntryCls);
            jmethodID fabricIndexEntryTypeCtor = env->GetMethodID(fabricIndexEntryCls, "<init>", "(J)V");
            fabricIndex                        = env->NewObject(fabricIndexEntryCls, fabricIndexEntryTypeCtor, fabricIndexValue);
        }

        bool operationalCertNull     = false;
        bool operationalCertHasValue = true;

        chip::ByteSpan operationalCertValue = entry.operationalCert;

        jbyteArray operationalCert = nullptr;
        if (!operationalCertNull && operationalCertHasValue)
        {
            operationalCert = env->NewByteArray(operationalCertValue.size());
            env->SetByteArrayRegion(operationalCert, 0, operationalCertValue.size(),
                                    reinterpret_cast<const jbyte *>(operationalCertValue.data()));
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, fabricIndex, operationalCert);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create ListStructOctetStringAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ListStructOctetStringAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback::CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<TestClusterListNullablesAndOptionalsStructListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback::~CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback> cppCallback(
        reinterpret_cast<CHIPTestClusterListNullablesAndOptionalsStructAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$TestClusterCluster$ListNullablesAndOptionalsStructAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(
            Zcl,
            "Could not find class chip/devicecontroller/ChipClusters$TestClusterCluster$ListNullablesAndOptionalsStructAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(
        attributeClass, "<init>",
        "(Ljava/lang/Integer;Ljava/util/Optional;Ljava/util/Optional;Ljava/lang/String;Ljava/util/Optional;Ljava/util/Optional;)V");
    VerifyOrReturn(attributeCtor != nullptr,
                   ChipLogError(Zcl, "Could not find ListNullablesAndOptionalsStructAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool nullableIntNull     = false;
        bool nullableIntHasValue = true;
        uint16_t nullableIntValue;
        nullableIntNull = entry.nullableInt.IsNull();
        if (!nullableIntNull)
        {
            nullableIntValue = entry.nullableInt.Value();
        }

        jobject nullableInt = nullptr;
        if (!nullableIntNull && nullableIntHasValue)
        {
            jclass nullableIntEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", nullableIntEntryCls);
            chip::JniClass nullableIntJniClass(nullableIntEntryCls);
            jmethodID nullableIntEntryTypeCtor = env->GetMethodID(nullableIntEntryCls, "<init>", "(I)V");
            nullableInt                        = env->NewObject(nullableIntEntryCls, nullableIntEntryTypeCtor, nullableIntValue);
        }

        bool optionalIntNull     = false;
        bool optionalIntHasValue = true;

        uint16_t optionalIntValue;
        optionalIntHasValue = entry.optionalInt.HasValue();
        if (optionalIntHasValue)
        {
            optionalIntValue = entry.optionalInt.Value();
        }

        jobject optionalInt = nullptr;
        if (!optionalIntNull && optionalIntHasValue)
        {
            jclass optionalIntEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", optionalIntEntryCls);
            chip::JniClass optionalIntJniClass(optionalIntEntryCls);
            jmethodID optionalIntEntryTypeCtor = env->GetMethodID(optionalIntEntryCls, "<init>", "(I)V");
            optionalInt                        = env->NewObject(optionalIntEntryCls, optionalIntEntryTypeCtor, optionalIntValue);
        }

        jobject optionalIntOptional = nullptr;
        chip::JniReferences::GetInstance().CreateOptional(optionalInt, optionalIntOptional);
        bool nullableOptionalIntNull     = false;
        bool nullableOptionalIntHasValue = true;

        uint16_t nullableOptionalIntValue;
        nullableOptionalIntHasValue = entry.nullableOptionalInt.HasValue();
        if (nullableOptionalIntHasValue)
        {
            auto nullableOptionalIntValueFromOptional = entry.nullableOptionalInt.Value();
            nullableOptionalIntNull                   = nullableOptionalIntValueFromOptional.IsNull();
            if (!nullableOptionalIntNull)
            {
                nullableOptionalIntValue = nullableOptionalIntValueFromOptional.Value();
            }
        }

        jobject nullableOptionalInt = nullptr;
        if (!nullableOptionalIntNull && nullableOptionalIntHasValue)
        {
            jclass nullableOptionalIntEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", nullableOptionalIntEntryCls);
            chip::JniClass nullableOptionalIntJniClass(nullableOptionalIntEntryCls);
            jmethodID nullableOptionalIntEntryTypeCtor = env->GetMethodID(nullableOptionalIntEntryCls, "<init>", "(I)V");
            nullableOptionalInt =
                env->NewObject(nullableOptionalIntEntryCls, nullableOptionalIntEntryTypeCtor, nullableOptionalIntValue);
        }

        jobject nullableOptionalIntOptional = nullptr;
        chip::JniReferences::GetInstance().CreateOptional(nullableOptionalInt, nullableOptionalIntOptional);
        bool nullableStringNull     = false;
        bool nullableStringHasValue = true;
        chip::CharSpan nullableStringValue;
        nullableStringNull = entry.nullableString.IsNull();
        if (!nullableStringNull)
        {
            nullableStringValue = entry.nullableString.Value();
        }

        jstring nullableString = nullptr;
        chip::UtfString nullableStringStr(env, nullableStringValue);
        if (!nullableStringNull && nullableStringHasValue)
        {
            nullableString = jstring(nullableStringStr.jniValue());
        }

        bool optionalStringNull     = false;
        bool optionalStringHasValue = true;

        chip::CharSpan optionalStringValue;
        optionalStringHasValue = entry.optionalString.HasValue();
        if (optionalStringHasValue)
        {
            optionalStringValue = entry.optionalString.Value();
        }

        jstring optionalString = nullptr;
        chip::UtfString optionalStringStr(env, optionalStringValue);
        if (!optionalStringNull && optionalStringHasValue)
        {
            optionalString = jstring(optionalStringStr.jniValue());
        }

        jobject optionalStringOptional = nullptr;
        chip::JniReferences::GetInstance().CreateOptional(optionalString, optionalStringOptional);
        bool nullableOptionalStringNull     = false;
        bool nullableOptionalStringHasValue = true;

        chip::CharSpan nullableOptionalStringValue;
        nullableOptionalStringHasValue = entry.nullableOptionalString.HasValue();
        if (nullableOptionalStringHasValue)
        {
            auto nullableOptionalStringValueFromOptional = entry.nullableOptionalString.Value();
            nullableOptionalStringNull                   = nullableOptionalStringValueFromOptional.IsNull();
            if (!nullableOptionalStringNull)
            {
                nullableOptionalStringValue = nullableOptionalStringValueFromOptional.Value();
            }
        }

        jstring nullableOptionalString = nullptr;
        chip::UtfString nullableOptionalStringStr(env, nullableOptionalStringValue);
        if (!nullableOptionalStringNull && nullableOptionalStringHasValue)
        {
            nullableOptionalString = jstring(nullableOptionalStringStr.jniValue());
        }

        jobject nullableOptionalStringOptional = nullptr;
        chip::JniReferences::GetInstance().CreateOptional(nullableOptionalString, nullableOptionalStringOptional);

        jobject attributeObj =
            env->NewObject(attributeClass, attributeCtor, nullableInt, optionalIntOptional, nullableOptionalIntOptional,
                           nullableString, optionalStringOptional, nullableOptionalStringOptional);
        VerifyOrReturn(attributeObj != nullptr,
                       ChipLogError(Zcl, "Could not create ListNullablesAndOptionalsStructAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding ListNullablesAndOptionalsStructAttribute value: %" CHIP_ERROR_FORMAT,
                                iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback::CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<ThreadNetworkDiagnosticsNeighborTableListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback::~CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPThreadNetworkDiagnosticsNeighborTableListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$NeighborTableListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(
            Zcl,
            "Could not find class chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$NeighborTableListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>",
                         "(Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/"
                         "Integer;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/"
                         "Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find NeighborTableListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool extAddressNull     = false;
        bool extAddressHasValue = true;

        uint64_t extAddressValue = entry.extAddress;

        jobject extAddress = nullptr;
        if (!extAddressNull && extAddressHasValue)
        {
            jclass extAddressEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", extAddressEntryCls);
            chip::JniClass extAddressJniClass(extAddressEntryCls);
            jmethodID extAddressEntryTypeCtor = env->GetMethodID(extAddressEntryCls, "<init>", "(J)V");
            extAddress                        = env->NewObject(extAddressEntryCls, extAddressEntryTypeCtor, extAddressValue);
        }

        bool ageNull     = false;
        bool ageHasValue = true;

        uint32_t ageValue = entry.age;

        jobject age = nullptr;
        if (!ageNull && ageHasValue)
        {
            jclass ageEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", ageEntryCls);
            chip::JniClass ageJniClass(ageEntryCls);
            jmethodID ageEntryTypeCtor = env->GetMethodID(ageEntryCls, "<init>", "(J)V");
            age                        = env->NewObject(ageEntryCls, ageEntryTypeCtor, ageValue);
        }

        bool rloc16Null     = false;
        bool rloc16HasValue = true;

        uint16_t rloc16Value = entry.rloc16;

        jobject rloc16 = nullptr;
        if (!rloc16Null && rloc16HasValue)
        {
            jclass rloc16EntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", rloc16EntryCls);
            chip::JniClass rloc16JniClass(rloc16EntryCls);
            jmethodID rloc16EntryTypeCtor = env->GetMethodID(rloc16EntryCls, "<init>", "(I)V");
            rloc16                        = env->NewObject(rloc16EntryCls, rloc16EntryTypeCtor, rloc16Value);
        }

        bool linkFrameCounterNull     = false;
        bool linkFrameCounterHasValue = true;

        uint32_t linkFrameCounterValue = entry.linkFrameCounter;

        jobject linkFrameCounter = nullptr;
        if (!linkFrameCounterNull && linkFrameCounterHasValue)
        {
            jclass linkFrameCounterEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", linkFrameCounterEntryCls);
            chip::JniClass linkFrameCounterJniClass(linkFrameCounterEntryCls);
            jmethodID linkFrameCounterEntryTypeCtor = env->GetMethodID(linkFrameCounterEntryCls, "<init>", "(J)V");
            linkFrameCounter = env->NewObject(linkFrameCounterEntryCls, linkFrameCounterEntryTypeCtor, linkFrameCounterValue);
        }

        bool mleFrameCounterNull     = false;
        bool mleFrameCounterHasValue = true;

        uint32_t mleFrameCounterValue = entry.mleFrameCounter;

        jobject mleFrameCounter = nullptr;
        if (!mleFrameCounterNull && mleFrameCounterHasValue)
        {
            jclass mleFrameCounterEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", mleFrameCounterEntryCls);
            chip::JniClass mleFrameCounterJniClass(mleFrameCounterEntryCls);
            jmethodID mleFrameCounterEntryTypeCtor = env->GetMethodID(mleFrameCounterEntryCls, "<init>", "(J)V");
            mleFrameCounter = env->NewObject(mleFrameCounterEntryCls, mleFrameCounterEntryTypeCtor, mleFrameCounterValue);
        }

        bool lqiNull     = false;
        bool lqiHasValue = true;

        uint8_t lqiValue = entry.lqi;

        jobject lqi = nullptr;
        if (!lqiNull && lqiHasValue)
        {
            jclass lqiEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", lqiEntryCls);
            chip::JniClass lqiJniClass(lqiEntryCls);
            jmethodID lqiEntryTypeCtor = env->GetMethodID(lqiEntryCls, "<init>", "(I)V");
            lqi                        = env->NewObject(lqiEntryCls, lqiEntryTypeCtor, lqiValue);
        }

        bool averageRssiNull     = false;
        bool averageRssiHasValue = true;

        int8_t averageRssiValue = entry.averageRssi;

        jobject averageRssi = nullptr;
        if (!averageRssiNull && averageRssiHasValue)
        {
            jclass averageRssiEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", averageRssiEntryCls);
            chip::JniClass averageRssiJniClass(averageRssiEntryCls);
            jmethodID averageRssiEntryTypeCtor = env->GetMethodID(averageRssiEntryCls, "<init>", "(I)V");
            averageRssi                        = env->NewObject(averageRssiEntryCls, averageRssiEntryTypeCtor, averageRssiValue);
        }

        bool lastRssiNull     = false;
        bool lastRssiHasValue = true;

        int8_t lastRssiValue = entry.lastRssi;

        jobject lastRssi = nullptr;
        if (!lastRssiNull && lastRssiHasValue)
        {
            jclass lastRssiEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", lastRssiEntryCls);
            chip::JniClass lastRssiJniClass(lastRssiEntryCls);
            jmethodID lastRssiEntryTypeCtor = env->GetMethodID(lastRssiEntryCls, "<init>", "(I)V");
            lastRssi                        = env->NewObject(lastRssiEntryCls, lastRssiEntryTypeCtor, lastRssiValue);
        }

        bool frameErrorRateNull     = false;
        bool frameErrorRateHasValue = true;

        uint8_t frameErrorRateValue = entry.frameErrorRate;

        jobject frameErrorRate = nullptr;
        if (!frameErrorRateNull && frameErrorRateHasValue)
        {
            jclass frameErrorRateEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", frameErrorRateEntryCls);
            chip::JniClass frameErrorRateJniClass(frameErrorRateEntryCls);
            jmethodID frameErrorRateEntryTypeCtor = env->GetMethodID(frameErrorRateEntryCls, "<init>", "(I)V");
            frameErrorRate = env->NewObject(frameErrorRateEntryCls, frameErrorRateEntryTypeCtor, frameErrorRateValue);
        }

        bool messageErrorRateNull     = false;
        bool messageErrorRateHasValue = true;

        uint8_t messageErrorRateValue = entry.messageErrorRate;

        jobject messageErrorRate = nullptr;
        if (!messageErrorRateNull && messageErrorRateHasValue)
        {
            jclass messageErrorRateEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", messageErrorRateEntryCls);
            chip::JniClass messageErrorRateJniClass(messageErrorRateEntryCls);
            jmethodID messageErrorRateEntryTypeCtor = env->GetMethodID(messageErrorRateEntryCls, "<init>", "(I)V");
            messageErrorRate = env->NewObject(messageErrorRateEntryCls, messageErrorRateEntryTypeCtor, messageErrorRateValue);
        }

        bool rxOnWhenIdleNull     = false;
        bool rxOnWhenIdleHasValue = true;

        bool rxOnWhenIdleValue = entry.rxOnWhenIdle;

        jobject rxOnWhenIdle = nullptr;
        if (!rxOnWhenIdleNull && rxOnWhenIdleHasValue)
        {
            jclass rxOnWhenIdleEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", rxOnWhenIdleEntryCls);
            chip::JniClass rxOnWhenIdleJniClass(rxOnWhenIdleEntryCls);
            jmethodID rxOnWhenIdleEntryTypeCtor = env->GetMethodID(rxOnWhenIdleEntryCls, "<init>", "(Z)V");
            rxOnWhenIdle = env->NewObject(rxOnWhenIdleEntryCls, rxOnWhenIdleEntryTypeCtor, rxOnWhenIdleValue);
        }

        bool fullThreadDeviceNull     = false;
        bool fullThreadDeviceHasValue = true;

        bool fullThreadDeviceValue = entry.fullThreadDevice;

        jobject fullThreadDevice = nullptr;
        if (!fullThreadDeviceNull && fullThreadDeviceHasValue)
        {
            jclass fullThreadDeviceEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", fullThreadDeviceEntryCls);
            chip::JniClass fullThreadDeviceJniClass(fullThreadDeviceEntryCls);
            jmethodID fullThreadDeviceEntryTypeCtor = env->GetMethodID(fullThreadDeviceEntryCls, "<init>", "(Z)V");
            fullThreadDevice = env->NewObject(fullThreadDeviceEntryCls, fullThreadDeviceEntryTypeCtor, fullThreadDeviceValue);
        }

        bool fullNetworkDataNull     = false;
        bool fullNetworkDataHasValue = true;

        bool fullNetworkDataValue = entry.fullNetworkData;

        jobject fullNetworkData = nullptr;
        if (!fullNetworkDataNull && fullNetworkDataHasValue)
        {
            jclass fullNetworkDataEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", fullNetworkDataEntryCls);
            chip::JniClass fullNetworkDataJniClass(fullNetworkDataEntryCls);
            jmethodID fullNetworkDataEntryTypeCtor = env->GetMethodID(fullNetworkDataEntryCls, "<init>", "(Z)V");
            fullNetworkData = env->NewObject(fullNetworkDataEntryCls, fullNetworkDataEntryTypeCtor, fullNetworkDataValue);
        }

        bool isChildNull     = false;
        bool isChildHasValue = true;

        bool isChildValue = entry.isChild;

        jobject isChild = nullptr;
        if (!isChildNull && isChildHasValue)
        {
            jclass isChildEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", isChildEntryCls);
            chip::JniClass isChildJniClass(isChildEntryCls);
            jmethodID isChildEntryTypeCtor = env->GetMethodID(isChildEntryCls, "<init>", "(Z)V");
            isChild                        = env->NewObject(isChildEntryCls, isChildEntryTypeCtor, isChildValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, extAddress, age, rloc16, linkFrameCounter,
                                              mleFrameCounter, lqi, averageRssi, lastRssi, frameErrorRate, messageErrorRate,
                                              rxOnWhenIdle, fullThreadDevice, fullNetworkData, isChild);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create NeighborTableListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding NeighborTableListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback::CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<ThreadNetworkDiagnosticsRouteTableListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback::~CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType> &
        list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPThreadNetworkDiagnosticsRouteTableListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$RouteTableListAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(
            Zcl,
            "Could not find class chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$RouteTableListAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor =
        env->GetMethodID(attributeClass, "<init>",
                         "(Ljava/lang/Long;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/"
                         "Integer;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Boolean;Ljava/lang/Boolean;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find RouteTableListAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool extAddressNull     = false;
        bool extAddressHasValue = true;

        uint64_t extAddressValue = entry.extAddress;

        jobject extAddress = nullptr;
        if (!extAddressNull && extAddressHasValue)
        {
            jclass extAddressEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Long", extAddressEntryCls);
            chip::JniClass extAddressJniClass(extAddressEntryCls);
            jmethodID extAddressEntryTypeCtor = env->GetMethodID(extAddressEntryCls, "<init>", "(J)V");
            extAddress                        = env->NewObject(extAddressEntryCls, extAddressEntryTypeCtor, extAddressValue);
        }

        bool rloc16Null     = false;
        bool rloc16HasValue = true;

        uint16_t rloc16Value = entry.rloc16;

        jobject rloc16 = nullptr;
        if (!rloc16Null && rloc16HasValue)
        {
            jclass rloc16EntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", rloc16EntryCls);
            chip::JniClass rloc16JniClass(rloc16EntryCls);
            jmethodID rloc16EntryTypeCtor = env->GetMethodID(rloc16EntryCls, "<init>", "(I)V");
            rloc16                        = env->NewObject(rloc16EntryCls, rloc16EntryTypeCtor, rloc16Value);
        }

        bool routerIdNull     = false;
        bool routerIdHasValue = true;

        uint8_t routerIdValue = entry.routerId;

        jobject routerId = nullptr;
        if (!routerIdNull && routerIdHasValue)
        {
            jclass routerIdEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", routerIdEntryCls);
            chip::JniClass routerIdJniClass(routerIdEntryCls);
            jmethodID routerIdEntryTypeCtor = env->GetMethodID(routerIdEntryCls, "<init>", "(I)V");
            routerId                        = env->NewObject(routerIdEntryCls, routerIdEntryTypeCtor, routerIdValue);
        }

        bool nextHopNull     = false;
        bool nextHopHasValue = true;

        uint8_t nextHopValue = entry.nextHop;

        jobject nextHop = nullptr;
        if (!nextHopNull && nextHopHasValue)
        {
            jclass nextHopEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", nextHopEntryCls);
            chip::JniClass nextHopJniClass(nextHopEntryCls);
            jmethodID nextHopEntryTypeCtor = env->GetMethodID(nextHopEntryCls, "<init>", "(I)V");
            nextHop                        = env->NewObject(nextHopEntryCls, nextHopEntryTypeCtor, nextHopValue);
        }

        bool pathCostNull     = false;
        bool pathCostHasValue = true;

        uint8_t pathCostValue = entry.pathCost;

        jobject pathCost = nullptr;
        if (!pathCostNull && pathCostHasValue)
        {
            jclass pathCostEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", pathCostEntryCls);
            chip::JniClass pathCostJniClass(pathCostEntryCls);
            jmethodID pathCostEntryTypeCtor = env->GetMethodID(pathCostEntryCls, "<init>", "(I)V");
            pathCost                        = env->NewObject(pathCostEntryCls, pathCostEntryTypeCtor, pathCostValue);
        }

        bool LQIInNull     = false;
        bool LQIInHasValue = true;

        uint8_t LQIInValue = entry.LQIIn;

        jobject LQIIn = nullptr;
        if (!LQIInNull && LQIInHasValue)
        {
            jclass LQIInEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", LQIInEntryCls);
            chip::JniClass LQIInJniClass(LQIInEntryCls);
            jmethodID LQIInEntryTypeCtor = env->GetMethodID(LQIInEntryCls, "<init>", "(I)V");
            LQIIn                        = env->NewObject(LQIInEntryCls, LQIInEntryTypeCtor, LQIInValue);
        }

        bool LQIOutNull     = false;
        bool LQIOutHasValue = true;

        uint8_t LQIOutValue = entry.LQIOut;

        jobject LQIOut = nullptr;
        if (!LQIOutNull && LQIOutHasValue)
        {
            jclass LQIOutEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", LQIOutEntryCls);
            chip::JniClass LQIOutJniClass(LQIOutEntryCls);
            jmethodID LQIOutEntryTypeCtor = env->GetMethodID(LQIOutEntryCls, "<init>", "(I)V");
            LQIOut                        = env->NewObject(LQIOutEntryCls, LQIOutEntryTypeCtor, LQIOutValue);
        }

        bool ageNull     = false;
        bool ageHasValue = true;

        uint8_t ageValue = entry.age;

        jobject age = nullptr;
        if (!ageNull && ageHasValue)
        {
            jclass ageEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", ageEntryCls);
            chip::JniClass ageJniClass(ageEntryCls);
            jmethodID ageEntryTypeCtor = env->GetMethodID(ageEntryCls, "<init>", "(I)V");
            age                        = env->NewObject(ageEntryCls, ageEntryTypeCtor, ageValue);
        }

        bool allocatedNull     = false;
        bool allocatedHasValue = true;

        bool allocatedValue = entry.allocated;

        jobject allocated = nullptr;
        if (!allocatedNull && allocatedHasValue)
        {
            jclass allocatedEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", allocatedEntryCls);
            chip::JniClass allocatedJniClass(allocatedEntryCls);
            jmethodID allocatedEntryTypeCtor = env->GetMethodID(allocatedEntryCls, "<init>", "(Z)V");
            allocated                        = env->NewObject(allocatedEntryCls, allocatedEntryTypeCtor, allocatedValue);
        }

        bool linkEstablishedNull     = false;
        bool linkEstablishedHasValue = true;

        bool linkEstablishedValue = entry.linkEstablished;

        jobject linkEstablished = nullptr;
        if (!linkEstablishedNull && linkEstablishedHasValue)
        {
            jclass linkEstablishedEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", linkEstablishedEntryCls);
            chip::JniClass linkEstablishedJniClass(linkEstablishedEntryCls);
            jmethodID linkEstablishedEntryTypeCtor = env->GetMethodID(linkEstablishedEntryCls, "<init>", "(Z)V");
            linkEstablished = env->NewObject(linkEstablishedEntryCls, linkEstablishedEntryTypeCtor, linkEstablishedValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, extAddress, rloc16, routerId, nextHop, pathCost, LQIIn,
                                              LQIOut, age, allocated, linkEstablished);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create RouteTableListAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding RouteTableListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback::CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback(
    jobject javaCallback) :
    chip::Callback::Callback<ThreadNetworkDiagnosticsSecurityPolicyListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback::~CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback> cppCallback(
        reinterpret_cast<CHIPThreadNetworkDiagnosticsSecurityPolicyAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$SecurityPolicyAttribute", attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(
            Zcl,
            "Could not find class chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$SecurityPolicyAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(attributeClass, "<init>", "(Ljava/lang/Integer;Ljava/lang/Integer;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find SecurityPolicyAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool rotationTimeNull     = false;
        bool rotationTimeHasValue = true;

        uint16_t rotationTimeValue = entry.rotationTime;

        jobject rotationTime = nullptr;
        if (!rotationTimeNull && rotationTimeHasValue)
        {
            jclass rotationTimeEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", rotationTimeEntryCls);
            chip::JniClass rotationTimeJniClass(rotationTimeEntryCls);
            jmethodID rotationTimeEntryTypeCtor = env->GetMethodID(rotationTimeEntryCls, "<init>", "(I)V");
            rotationTime = env->NewObject(rotationTimeEntryCls, rotationTimeEntryTypeCtor, rotationTimeValue);
        }

        bool flagsNull     = false;
        bool flagsHasValue = true;

        uint16_t flagsValue = entry.flags;

        jobject flags = nullptr;
        if (!flagsNull && flagsHasValue)
        {
            jclass flagsEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", flagsEntryCls);
            chip::JniClass flagsJniClass(flagsEntryCls);
            jmethodID flagsEntryTypeCtor = env->GetMethodID(flagsEntryCls, "<init>", "(I)V");
            flags                        = env->NewObject(flagsEntryCls, flagsEntryTypeCtor, flagsValue);
        }

        jobject attributeObj = env->NewObject(attributeClass, attributeCtor, rotationTime, flags);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create SecurityPolicyAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding SecurityPolicyAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback::
    CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<ThreadNetworkDiagnosticsOperationalDatasetComponentsListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback::
    ~CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback::CallbackFn(
    void * context,
    const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback> cppCallback(
        reinterpret_cast<CHIPThreadNetworkDiagnosticsOperationalDatasetComponentsAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    jclass attributeClass;
    err = chip::JniReferences::GetInstance().GetClassRef(
        env, "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$OperationalDatasetComponentsAttribute",
        attributeClass);
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        ChipLogError(Zcl,
                     "Could not find class "
                     "chip/devicecontroller/ChipClusters$ThreadNetworkDiagnosticsCluster$OperationalDatasetComponentsAttribute"));
    chip::JniClass attributeJniClass(attributeClass);
    jmethodID attributeCtor = env->GetMethodID(
        attributeClass, "<init>",
        "(Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/"
        "lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;Ljava/lang/Boolean;)V");
    VerifyOrReturn(attributeCtor != nullptr, ChipLogError(Zcl, "Could not find OperationalDatasetComponentsAttribute constructor"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry = iter.GetValue();
        (void) entry;
        bool activeTimestampPresentNull     = false;
        bool activeTimestampPresentHasValue = true;

        bool activeTimestampPresentValue = entry.activeTimestampPresent;

        jobject activeTimestampPresent = nullptr;
        if (!activeTimestampPresentNull && activeTimestampPresentHasValue)
        {
            jclass activeTimestampPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", activeTimestampPresentEntryCls);
            chip::JniClass activeTimestampPresentJniClass(activeTimestampPresentEntryCls);
            jmethodID activeTimestampPresentEntryTypeCtor = env->GetMethodID(activeTimestampPresentEntryCls, "<init>", "(Z)V");
            activeTimestampPresent =
                env->NewObject(activeTimestampPresentEntryCls, activeTimestampPresentEntryTypeCtor, activeTimestampPresentValue);
        }

        bool pendingTimestampPresentNull     = false;
        bool pendingTimestampPresentHasValue = true;

        bool pendingTimestampPresentValue = entry.pendingTimestampPresent;

        jobject pendingTimestampPresent = nullptr;
        if (!pendingTimestampPresentNull && pendingTimestampPresentHasValue)
        {
            jclass pendingTimestampPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", pendingTimestampPresentEntryCls);
            chip::JniClass pendingTimestampPresentJniClass(pendingTimestampPresentEntryCls);
            jmethodID pendingTimestampPresentEntryTypeCtor = env->GetMethodID(pendingTimestampPresentEntryCls, "<init>", "(Z)V");
            pendingTimestampPresent =
                env->NewObject(pendingTimestampPresentEntryCls, pendingTimestampPresentEntryTypeCtor, pendingTimestampPresentValue);
        }

        bool masterKeyPresentNull     = false;
        bool masterKeyPresentHasValue = true;

        bool masterKeyPresentValue = entry.masterKeyPresent;

        jobject masterKeyPresent = nullptr;
        if (!masterKeyPresentNull && masterKeyPresentHasValue)
        {
            jclass masterKeyPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", masterKeyPresentEntryCls);
            chip::JniClass masterKeyPresentJniClass(masterKeyPresentEntryCls);
            jmethodID masterKeyPresentEntryTypeCtor = env->GetMethodID(masterKeyPresentEntryCls, "<init>", "(Z)V");
            masterKeyPresent = env->NewObject(masterKeyPresentEntryCls, masterKeyPresentEntryTypeCtor, masterKeyPresentValue);
        }

        bool networkNamePresentNull     = false;
        bool networkNamePresentHasValue = true;

        bool networkNamePresentValue = entry.networkNamePresent;

        jobject networkNamePresent = nullptr;
        if (!networkNamePresentNull && networkNamePresentHasValue)
        {
            jclass networkNamePresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", networkNamePresentEntryCls);
            chip::JniClass networkNamePresentJniClass(networkNamePresentEntryCls);
            jmethodID networkNamePresentEntryTypeCtor = env->GetMethodID(networkNamePresentEntryCls, "<init>", "(Z)V");
            networkNamePresent =
                env->NewObject(networkNamePresentEntryCls, networkNamePresentEntryTypeCtor, networkNamePresentValue);
        }

        bool extendedPanIdPresentNull     = false;
        bool extendedPanIdPresentHasValue = true;

        bool extendedPanIdPresentValue = entry.extendedPanIdPresent;

        jobject extendedPanIdPresent = nullptr;
        if (!extendedPanIdPresentNull && extendedPanIdPresentHasValue)
        {
            jclass extendedPanIdPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", extendedPanIdPresentEntryCls);
            chip::JniClass extendedPanIdPresentJniClass(extendedPanIdPresentEntryCls);
            jmethodID extendedPanIdPresentEntryTypeCtor = env->GetMethodID(extendedPanIdPresentEntryCls, "<init>", "(Z)V");
            extendedPanIdPresent =
                env->NewObject(extendedPanIdPresentEntryCls, extendedPanIdPresentEntryTypeCtor, extendedPanIdPresentValue);
        }

        bool meshLocalPrefixPresentNull     = false;
        bool meshLocalPrefixPresentHasValue = true;

        bool meshLocalPrefixPresentValue = entry.meshLocalPrefixPresent;

        jobject meshLocalPrefixPresent = nullptr;
        if (!meshLocalPrefixPresentNull && meshLocalPrefixPresentHasValue)
        {
            jclass meshLocalPrefixPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", meshLocalPrefixPresentEntryCls);
            chip::JniClass meshLocalPrefixPresentJniClass(meshLocalPrefixPresentEntryCls);
            jmethodID meshLocalPrefixPresentEntryTypeCtor = env->GetMethodID(meshLocalPrefixPresentEntryCls, "<init>", "(Z)V");
            meshLocalPrefixPresent =
                env->NewObject(meshLocalPrefixPresentEntryCls, meshLocalPrefixPresentEntryTypeCtor, meshLocalPrefixPresentValue);
        }

        bool delayPresentNull     = false;
        bool delayPresentHasValue = true;

        bool delayPresentValue = entry.delayPresent;

        jobject delayPresent = nullptr;
        if (!delayPresentNull && delayPresentHasValue)
        {
            jclass delayPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", delayPresentEntryCls);
            chip::JniClass delayPresentJniClass(delayPresentEntryCls);
            jmethodID delayPresentEntryTypeCtor = env->GetMethodID(delayPresentEntryCls, "<init>", "(Z)V");
            delayPresent = env->NewObject(delayPresentEntryCls, delayPresentEntryTypeCtor, delayPresentValue);
        }

        bool panIdPresentNull     = false;
        bool panIdPresentHasValue = true;

        bool panIdPresentValue = entry.panIdPresent;

        jobject panIdPresent = nullptr;
        if (!panIdPresentNull && panIdPresentHasValue)
        {
            jclass panIdPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", panIdPresentEntryCls);
            chip::JniClass panIdPresentJniClass(panIdPresentEntryCls);
            jmethodID panIdPresentEntryTypeCtor = env->GetMethodID(panIdPresentEntryCls, "<init>", "(Z)V");
            panIdPresent = env->NewObject(panIdPresentEntryCls, panIdPresentEntryTypeCtor, panIdPresentValue);
        }

        bool channelPresentNull     = false;
        bool channelPresentHasValue = true;

        bool channelPresentValue = entry.channelPresent;

        jobject channelPresent = nullptr;
        if (!channelPresentNull && channelPresentHasValue)
        {
            jclass channelPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", channelPresentEntryCls);
            chip::JniClass channelPresentJniClass(channelPresentEntryCls);
            jmethodID channelPresentEntryTypeCtor = env->GetMethodID(channelPresentEntryCls, "<init>", "(Z)V");
            channelPresent = env->NewObject(channelPresentEntryCls, channelPresentEntryTypeCtor, channelPresentValue);
        }

        bool pskcPresentNull     = false;
        bool pskcPresentHasValue = true;

        bool pskcPresentValue = entry.pskcPresent;

        jobject pskcPresent = nullptr;
        if (!pskcPresentNull && pskcPresentHasValue)
        {
            jclass pskcPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", pskcPresentEntryCls);
            chip::JniClass pskcPresentJniClass(pskcPresentEntryCls);
            jmethodID pskcPresentEntryTypeCtor = env->GetMethodID(pskcPresentEntryCls, "<init>", "(Z)V");
            pskcPresent                        = env->NewObject(pskcPresentEntryCls, pskcPresentEntryTypeCtor, pskcPresentValue);
        }

        bool securityPolicyPresentNull     = false;
        bool securityPolicyPresentHasValue = true;

        bool securityPolicyPresentValue = entry.securityPolicyPresent;

        jobject securityPolicyPresent = nullptr;
        if (!securityPolicyPresentNull && securityPolicyPresentHasValue)
        {
            jclass securityPolicyPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", securityPolicyPresentEntryCls);
            chip::JniClass securityPolicyPresentJniClass(securityPolicyPresentEntryCls);
            jmethodID securityPolicyPresentEntryTypeCtor = env->GetMethodID(securityPolicyPresentEntryCls, "<init>", "(Z)V");
            securityPolicyPresent =
                env->NewObject(securityPolicyPresentEntryCls, securityPolicyPresentEntryTypeCtor, securityPolicyPresentValue);
        }

        bool channelMaskPresentNull     = false;
        bool channelMaskPresentHasValue = true;

        bool channelMaskPresentValue = entry.channelMaskPresent;

        jobject channelMaskPresent = nullptr;
        if (!channelMaskPresentNull && channelMaskPresentHasValue)
        {
            jclass channelMaskPresentEntryCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Boolean", channelMaskPresentEntryCls);
            chip::JniClass channelMaskPresentJniClass(channelMaskPresentEntryCls);
            jmethodID channelMaskPresentEntryTypeCtor = env->GetMethodID(channelMaskPresentEntryCls, "<init>", "(Z)V");
            channelMaskPresent =
                env->NewObject(channelMaskPresentEntryCls, channelMaskPresentEntryTypeCtor, channelMaskPresentValue);
        }

        jobject attributeObj =
            env->NewObject(attributeClass, attributeCtor, activeTimestampPresent, pendingTimestampPresent, masterKeyPresent,
                           networkNamePresent, extendedPanIdPresent, meshLocalPrefixPresent, delayPresent, panIdPresent,
                           channelPresent, pskcPresent, securityPolicyPresent, channelMaskPresent);
        VerifyOrReturn(attributeObj != nullptr, ChipLogError(Zcl, "Could not create OperationalDatasetComponentsAttribute object"));

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, attributeObj);
    }
    VerifyOrReturn(iter.GetStatus() == CHIP_NO_ERROR,
                   ChipLogError(Zcl, "Error decoding OperationalDatasetComponentsAttribute value: %" CHIP_ERROR_FORMAT,
                                iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}

CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback::
    CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback(jobject javaCallback) :
    chip::Callback::Callback<ThreadNetworkDiagnosticsActiveNetworkFaultsListListAttributeCallback>(CallbackFn, this)
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
        return;
    }

    javaCallbackRef = env->NewGlobalRef(javaCallback);
    if (javaCallbackRef == nullptr)
    {
        ChipLogError(Zcl, "Could not create global reference for Java callback");
    }
}

CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback::
    ~CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback()
{
    JNIEnv * env = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    if (env == nullptr)
    {
        ChipLogError(Zcl, "Could not delete global reference for Java callback");
        return;
    }
    env->DeleteGlobalRef(javaCallbackRef);
}

void CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback::CallbackFn(
    void * context, const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> & list)
{
    chip::DeviceLayer::StackUnlock unlock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    JNIEnv * env   = chip::JniReferences::GetInstance().GetEnvForCurrentThread();
    jobject javaCallbackRef;

    VerifyOrReturn(env != nullptr, ChipLogError(Zcl, "Could not get JNI env"));

    std::unique_ptr<CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback> cppCallback(
        reinterpret_cast<CHIPThreadNetworkDiagnosticsActiveNetworkFaultsListAttributeCallback *>(context));

    // It's valid for javaCallbackRef to be nullptr if the Java code passed in a null callback.
    javaCallbackRef = cppCallback.get()->javaCallbackRef;
    VerifyOrReturn(javaCallbackRef != nullptr,
                   ChipLogProgress(Zcl, "Early return from attribute callback since Java callback is null"));

    jclass arrayListClass;
    err = chip::JniReferences::GetInstance().GetClassRef(env, "java/util/ArrayList", arrayListClass);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Error using Java ArrayList"));
    chip::JniClass arrayListJniClass(arrayListClass);
    jmethodID arrayListCtor      = env->GetMethodID(arrayListClass, "<init>", "()V");
    jmethodID arrayListAddMethod = env->GetMethodID(arrayListClass, "add", "(Ljava/lang/Object;)Z");
    VerifyOrReturn(arrayListCtor != nullptr && arrayListAddMethod != nullptr,
                   ChipLogError(Zcl, "Error finding Java ArrayList methods"));
    jobject arrayListObj = env->NewObject(arrayListClass, arrayListCtor);
    VerifyOrReturn(arrayListObj != nullptr, ChipLogError(Zcl, "Error creating Java ArrayList"));

    jmethodID javaMethod;
    err = chip::JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/util/List;)V", &javaMethod);
    VerifyOrReturn(err == CHIP_NO_ERROR, ChipLogError(Zcl, "Could not find onSuccess() method"));

    auto iter = list.begin();
    while (iter.Next())
    {
        auto & entry       = iter.GetValue();
        bool entryNull     = false;
        uint8_t entryValue = entry;

        jobject entryObject = nullptr;
        if (!entryNull)
        {
            jclass entryTypeCls;
            chip::JniReferences::GetInstance().GetClassRef(env, "java/lang/Integer", entryTypeCls);
            chip::JniClass jniClass(entryTypeCls);
            jmethodID entryTypeCtor = env->GetMethodID(entryTypeCls, "<init>", "(I)V");
            entryObject             = env->NewObject(entryTypeCls, entryTypeCtor, entryValue);
        }

        env->CallBooleanMethod(arrayListObj, arrayListAddMethod, entryObject);
    }
    VerifyOrReturn(
        iter.GetStatus() == CHIP_NO_ERROR,
        ChipLogError(Zcl, "Error decoding ActiveNetworkFaultsListAttribute value: %" CHIP_ERROR_FORMAT, iter.GetStatus().Format()));

    env->ExceptionClear();
    env->CallVoidMethod(javaCallbackRef, javaMethod, arrayListObj);
}
