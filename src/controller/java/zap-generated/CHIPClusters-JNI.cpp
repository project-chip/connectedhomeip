/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPReadCallbacks.h"

#include <app-common/zap-generated/cluster-objects.h>
#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

#include <controller/java/AndroidClusterExceptions.h>
#include <controller/java/CHIPDefaultCallbacks.h>
#include <jni.h>
#include <lib/support/CHIPJNIError.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/JniReferences.h>
#include <lib/support/JniTypeWrappers.h>
#include <lib/support/Span.h>
#include <platform/PlatformManager.h>

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

using namespace chip;
using namespace chip::Controller;

class CHIPAccountLoginClusterGetSetupPINResponseCallback : public Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback>
{
public:
    CHIPAccountLoginClusterGetSetupPINResponseCallback(jobject javaCallback) :
        Callback::Callback<AccountLoginClusterGetSetupPINResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPAccountLoginClusterGetSetupPINResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::CharSpan setupPIN)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPAccountLoginClusterGetSetupPINResponseCallback * cppCallback = nullptr;
        UtfString setupPINStr(env, setupPIN);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPAccountLoginClusterGetSetupPINResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, setupPINStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPApplicationLauncherClusterLaunchAppResponseCallback
    : public Callback::Callback<ApplicationLauncherClusterLaunchAppResponseCallback>
{
public:
    CHIPApplicationLauncherClusterLaunchAppResponseCallback(jobject javaCallback) :
        Callback::Callback<ApplicationLauncherClusterLaunchAppResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPApplicationLauncherClusterLaunchAppResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, chip::CharSpan data)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPApplicationLauncherClusterLaunchAppResponseCallback * cppCallback = nullptr;
        UtfString dataStr(env, data);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPApplicationLauncherClusterLaunchAppResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), dataStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPContentLauncherClusterLaunchContentResponseCallback
    : public Callback::Callback<ContentLauncherClusterLaunchContentResponseCallback>
{
public:
    CHIPContentLauncherClusterLaunchContentResponseCallback(jobject javaCallback) :
        Callback::Callback<ContentLauncherClusterLaunchContentResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPContentLauncherClusterLaunchContentResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::CharSpan data, uint8_t contentLaunchStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPContentLauncherClusterLaunchContentResponseCallback * cppCallback = nullptr;
        UtfString dataStr(env, data);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPContentLauncherClusterLaunchContentResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue(), static_cast<jint>(contentLaunchStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPContentLauncherClusterLaunchURLResponseCallback
    : public Callback::Callback<ContentLauncherClusterLaunchURLResponseCallback>
{
public:
    CHIPContentLauncherClusterLaunchURLResponseCallback(jobject javaCallback) :
        Callback::Callback<ContentLauncherClusterLaunchURLResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPContentLauncherClusterLaunchURLResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::CharSpan data, uint8_t contentLaunchStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPContentLauncherClusterLaunchURLResponseCallback * cppCallback = nullptr;
        UtfString dataStr(env, data);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPContentLauncherClusterLaunchURLResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(Ljava/lang/String;I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, dataStr.jniValue(), static_cast<jint>(contentLaunchStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback
    : public Callback::Callback<DiagnosticLogsClusterRetrieveLogsResponseCallback>
{
public:
    CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback(jobject javaCallback) :
        Callback::Callback<DiagnosticLogsClusterRetrieveLogsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, chip::ByteSpan content, uint32_t timeStamp, uint32_t timeSinceBoot)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback * cppCallback = nullptr;
        jbyteArray contentArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I[BJJ)V", &javaMethod);
        SuccessOrExit(err);

        contentArr = env->NewByteArray(content.size());
        VerifyOrExit(contentArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(contentArr, 0, content.size(), reinterpret_cast<const jbyte *>(content.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), contentArr, static_cast<jlong>(timeStamp),
                            static_cast<jlong>(timeSinceBoot));

        env->DeleteLocalRef(contentArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearAllPinsResponseCallback : public Callback::Callback<DoorLockClusterClearAllPinsResponseCallback>
{
public:
    CHIPDoorLockClusterClearAllPinsResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearAllPinsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearAllPinsResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearAllPinsResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearAllPinsResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearAllRfidsResponseCallback : public Callback::Callback<DoorLockClusterClearAllRfidsResponseCallback>
{
public:
    CHIPDoorLockClusterClearAllRfidsResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearAllRfidsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearAllRfidsResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearAllRfidsResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearAllRfidsResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearHolidayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearHolidayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearPinResponseCallback : public Callback::Callback<DoorLockClusterClearPinResponseCallback>
{
public:
    CHIPDoorLockClusterClearPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearPinResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearPinResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearRfidResponseCallback : public Callback::Callback<DoorLockClusterClearRfidResponseCallback>
{
public:
    CHIPDoorLockClusterClearRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearRfidResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearRfidResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearWeekdayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterClearYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterClearYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterClearYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterClearYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterClearYeardayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterClearYeardayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterClearYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetHolidayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint8_t status, uint32_t localStartTime, uint32_t localEndTime,
                           uint8_t operatingModeDuringHoliday)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetHolidayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIJJI)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(status),
                            static_cast<jlong>(localStartTime), static_cast<jlong>(localEndTime),
                            static_cast<jint>(operatingModeDuringHoliday));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetLogRecordResponseCallback : public Callback::Callback<DoorLockClusterGetLogRecordResponseCallback>
{
public:
    CHIPDoorLockClusterGetLogRecordResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetLogRecordResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetLogRecordResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t logEntryId, uint32_t timestamp, uint8_t eventType, uint8_t source,
                           uint8_t eventIdOrAlarmCode, uint16_t userId, chip::ByteSpan pin)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetLogRecordResponseCallback * cppCallback = nullptr;
        jbyteArray pinArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetLogRecordResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IJIIII[B)V", &javaMethod);
        SuccessOrExit(err);

        pinArr = env->NewByteArray(pin.size());
        VerifyOrExit(pinArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(pinArr, 0, pin.size(), reinterpret_cast<const jbyte *>(pin.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(logEntryId), static_cast<jlong>(timestamp),
                            static_cast<jint>(eventType), static_cast<jint>(source), static_cast<jint>(eventIdOrAlarmCode),
                            static_cast<jint>(userId), pinArr);

        env->DeleteLocalRef(pinArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetPinResponseCallback : public Callback::Callback<DoorLockClusterGetPinResponseCallback>
{
public:
    CHIPDoorLockClusterGetPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetPinResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userStatus, uint8_t userType, chip::ByteSpan pin)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetPinResponseCallback * cppCallback = nullptr;
        jbyteArray pinArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III[B)V", &javaMethod);
        SuccessOrExit(err);

        pinArr = env->NewByteArray(pin.size());
        VerifyOrExit(pinArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(pinArr, 0, pin.size(), reinterpret_cast<const jbyte *>(pin.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userStatus),
                            static_cast<jint>(userType), pinArr);

        env->DeleteLocalRef(pinArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetRfidResponseCallback : public Callback::Callback<DoorLockClusterGetRfidResponseCallback>
{
public:
    CHIPDoorLockClusterGetRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetRfidResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userStatus, uint8_t userType, chip::ByteSpan rfid)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetRfidResponseCallback * cppCallback = nullptr;
        jbyteArray rfidArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III[B)V", &javaMethod);
        SuccessOrExit(err);

        rfidArr = env->NewByteArray(rfid.size());
        VerifyOrExit(rfidArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(rfidArr, 0, rfid.size(), reinterpret_cast<const jbyte *>(rfid.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userStatus),
                            static_cast<jint>(userType), rfidArr);

        env->DeleteLocalRef(rfidArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetUserTypeResponseCallback : public Callback::Callback<DoorLockClusterGetUserTypeResponseCallback>
{
public:
    CHIPDoorLockClusterGetUserTypeResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetUserTypeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetUserTypeResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t userId, uint8_t userType)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetUserTypeResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetUserTypeResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(userId), static_cast<jint>(userType));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint16_t userId, uint8_t status, uint8_t daysMask, uint8_t startHour,
                           uint8_t startMinute, uint8_t endHour, uint8_t endMinute)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetWeekdayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIIIIII)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(userId),
                            static_cast<jint>(status), static_cast<jint>(daysMask), static_cast<jint>(startHour),
                            static_cast<jint>(startMinute), static_cast<jint>(endHour), static_cast<jint>(endMinute));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterGetYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterGetYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterGetYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterGetYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterGetYeardayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t scheduleId, uint16_t userId, uint8_t status, uint32_t localStartTime,
                           uint32_t localEndTime)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterGetYeardayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterGetYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIJJ)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(scheduleId), static_cast<jint>(userId),
                            static_cast<jint>(status), static_cast<jlong>(localStartTime), static_cast<jlong>(localEndTime));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterLockDoorResponseCallback : public Callback::Callback<DoorLockClusterLockDoorResponseCallback>
{
public:
    CHIPDoorLockClusterLockDoorResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterLockDoorResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterLockDoorResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterLockDoorResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterLockDoorResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetHolidayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetHolidayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetHolidayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetHolidayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetHolidayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetHolidayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetHolidayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetPinResponseCallback : public Callback::Callback<DoorLockClusterSetPinResponseCallback>
{
public:
    CHIPDoorLockClusterSetPinResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetPinResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetPinResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetPinResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetPinResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetRfidResponseCallback : public Callback::Callback<DoorLockClusterSetRfidResponseCallback>
{
public:
    CHIPDoorLockClusterSetRfidResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetRfidResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetRfidResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetRfidResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetRfidResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetUserTypeResponseCallback : public Callback::Callback<DoorLockClusterSetUserTypeResponseCallback>
{
public:
    CHIPDoorLockClusterSetUserTypeResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetUserTypeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetUserTypeResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetUserTypeResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetUserTypeResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetWeekdayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetWeekdayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetWeekdayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetWeekdayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetWeekdayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetWeekdayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterSetYeardayScheduleResponseCallback
    : public Callback::Callback<DoorLockClusterSetYeardayScheduleResponseCallback>
{
public:
    CHIPDoorLockClusterSetYeardayScheduleResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterSetYeardayScheduleResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterSetYeardayScheduleResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterSetYeardayScheduleResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterSetYeardayScheduleResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterUnlockDoorResponseCallback : public Callback::Callback<DoorLockClusterUnlockDoorResponseCallback>
{
public:
    CHIPDoorLockClusterUnlockDoorResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterUnlockDoorResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterUnlockDoorResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterUnlockDoorResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterUnlockDoorResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPDoorLockClusterUnlockWithTimeoutResponseCallback
    : public Callback::Callback<DoorLockClusterUnlockWithTimeoutResponseCallback>
{
public:
    CHIPDoorLockClusterUnlockWithTimeoutResponseCallback(jobject javaCallback) :
        Callback::Callback<DoorLockClusterUnlockWithTimeoutResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPDoorLockClusterUnlockWithTimeoutResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPDoorLockClusterUnlockWithTimeoutResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterArmFailSafeResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterArmFailSafeResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterArmFailSafeResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterArmFailSafeResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterArmFailSafeResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterCommissioningCompleteResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback
    : public Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>
{
public:
    CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback(jobject javaCallback) :
        Callback::Callback<GeneralCommissioningClusterSetRegulatoryConfigResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterAddGroupResponseCallback : public Callback::Callback<GroupsClusterAddGroupResponseCallback>
{
public:
    CHIPGroupsClusterAddGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterAddGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterAddGroupResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterAddGroupResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterAddGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterGetGroupMembershipResponseCallback
    : public Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback>
{
public:
    CHIPGroupsClusterGetGroupMembershipResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterGetGroupMembershipResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterGetGroupMembershipResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t capacity, uint8_t groupCount,
                           /* TYPE WARNING: array array defaults to */ uint8_t * groupList)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterGetGroupMembershipResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterGetGroupMembershipResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(capacity), static_cast<jint>(groupCount)
                            // groupList: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterRemoveGroupResponseCallback : public Callback::Callback<GroupsClusterRemoveGroupResponseCallback>
{
public:
    CHIPGroupsClusterRemoveGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterRemoveGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterRemoveGroupResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterRemoveGroupResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterRemoveGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPGroupsClusterViewGroupResponseCallback : public Callback::Callback<GroupsClusterViewGroupResponseCallback>
{
public:
    CHIPGroupsClusterViewGroupResponseCallback(jobject javaCallback) :
        Callback::Callback<GroupsClusterViewGroupResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPGroupsClusterViewGroupResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPGroupsClusterViewGroupResponseCallback * cppCallback = nullptr;
        UtfString groupNameStr(env, groupName);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPGroupsClusterViewGroupResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            groupNameStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPIdentifyClusterIdentifyQueryResponseCallback : public Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback>
{
public:
    CHIPIdentifyClusterIdentifyQueryResponseCallback(jobject javaCallback) :
        Callback::Callback<IdentifyClusterIdentifyQueryResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPIdentifyClusterIdentifyQueryResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint16_t timeout)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPIdentifyClusterIdentifyQueryResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPIdentifyClusterIdentifyQueryResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(timeout));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPKeypadInputClusterSendKeyResponseCallback : public Callback::Callback<KeypadInputClusterSendKeyResponseCallback>
{
public:
    CHIPKeypadInputClusterSendKeyResponseCallback(jobject javaCallback) :
        Callback::Callback<KeypadInputClusterSendKeyResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPKeypadInputClusterSendKeyResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPKeypadInputClusterSendKeyResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPKeypadInputClusterSendKeyResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaFastForwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaFastForwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaFastForwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaFastForwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaFastForwardResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaFastForwardResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaNextResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaNextResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaNextResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaNextResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaNextResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaNextResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaNextResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPauseResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaPauseResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPauseResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPauseResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPauseResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPauseResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPauseResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPlayResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaPlayResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPlayResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPlayResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPlayResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPlayResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPlayResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaPreviousResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaPreviousResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaPreviousResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaPreviousResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaPreviousResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaPreviousResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaPreviousResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaRewindResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaRewindResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaRewindResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaRewindResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaRewindResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaRewindResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaRewindResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSeekResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaSeekResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSeekResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSeekResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSeekResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSeekResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSeekResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaSkipBackwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSkipBackwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaSkipForwardResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaSkipForwardResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaStartOverResponseCallback
    : public Callback::Callback<MediaPlaybackClusterMediaStartOverResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaStartOverResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaStartOverResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaStartOverResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaStartOverResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaStartOverResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPMediaPlaybackClusterMediaStopResponseCallback : public Callback::Callback<MediaPlaybackClusterMediaStopResponseCallback>
{
public:
    CHIPMediaPlaybackClusterMediaStopResponseCallback(jobject javaCallback) :
        Callback::Callback<MediaPlaybackClusterMediaStopResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPMediaPlaybackClusterMediaStopResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t mediaPlaybackStatus)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPMediaPlaybackClusterMediaStopResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPMediaPlaybackClusterMediaStopResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(mediaPlaybackStatus));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterAddThreadNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterAddWiFiNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterDisableNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterDisableNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterDisableNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterDisableNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterDisableNetworkResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterEnableNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterEnableNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterEnableNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterEnableNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterEnableNetworkResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterRemoveNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterScanNetworksResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterScanNetworksResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterScanNetworksResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterScanNetworksResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText,
                           /* TYPE WARNING: array array defaults to */ uint8_t * wifiScanResults,
                           /* TYPE WARNING: array array defaults to */ uint8_t * threadScanResults)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterScanNetworksResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterScanNetworksResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue()
                            // wifiScanResults: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
                            // threadScanResults: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterUpdateThreadNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback
    : public Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>
{
public:
    CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback(jobject javaCallback) :
        Callback::Callback<NetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t errorCode, chip::CharSpan debugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback * cppCallback = nullptr;
        UtfString debugTextStr(env, debugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(errorCode), debugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback
    : public Callback::Callback<OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>
{
public:
    CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback(jobject javaCallback) :
        Callback::Callback<OtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t action, uint32_t delayedActionTime)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IJ)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(action), static_cast<jlong>(delayedActionTime));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback
    : public Callback::Callback<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback>
{
public:
    CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback(jobject javaCallback) :
        Callback::Callback<OtaSoftwareUpdateProviderClusterQueryImageResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint32_t delayedActionTime, chip::CharSpan imageURI,
                           uint32_t softwareVersion, chip::CharSpan softwareVersionString, chip::ByteSpan updateToken,
                           bool userConsentNeeded, chip::ByteSpan metadataForRequestor)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback * cppCallback = nullptr;
        UtfString imageURIStr(env, imageURI);
        UtfString softwareVersionStringStr(env, softwareVersionString);
        jbyteArray updateTokenArr;
        jbyteArray metadataForRequestorArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess",
                                                      "(IJLjava/lang/String;JLjava/lang/String;[BZ[B)V", &javaMethod);
        SuccessOrExit(err);

        updateTokenArr = env->NewByteArray(updateToken.size());
        VerifyOrExit(updateTokenArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(updateTokenArr, 0, updateToken.size(), reinterpret_cast<const jbyte *>(updateToken.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        metadataForRequestorArr = env->NewByteArray(metadataForRequestor.size());
        VerifyOrExit(metadataForRequestorArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(metadataForRequestorArr, 0, metadataForRequestor.size(),
                                reinterpret_cast<const jbyte *>(metadataForRequestor.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jlong>(delayedActionTime),
                            imageURIStr.jniValue(), static_cast<jlong>(softwareVersion), softwareVersionStringStr.jniValue(),
                            updateTokenArr, static_cast<jboolean>(userConsentNeeded), metadataForRequestorArr);

        env->DeleteLocalRef(updateTokenArr);
        env->DeleteLocalRef(metadataForRequestorArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterAttestationResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterAttestationResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterAttestationResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterAttestationResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterAttestationResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::ByteSpan AttestationElements, chip::ByteSpan Signature)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterAttestationResponseCallback * cppCallback = nullptr;
        jbyteArray AttestationElementsArr;
        jbyteArray SignatureArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterAttestationResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B[B)V", &javaMethod);
        SuccessOrExit(err);

        AttestationElementsArr = env->NewByteArray(AttestationElements.size());
        VerifyOrExit(AttestationElementsArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(AttestationElementsArr, 0, AttestationElements.size(),
                                reinterpret_cast<const jbyte *>(AttestationElements.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        SignatureArr = env->NewByteArray(Signature.size());
        VerifyOrExit(SignatureArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(SignatureArr, 0, Signature.size(), reinterpret_cast<const jbyte *>(Signature.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, AttestationElementsArr, SignatureArr);

        env->DeleteLocalRef(AttestationElementsArr);
        env->DeleteLocalRef(SignatureArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterCertificateChainResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterCertificateChainResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterCertificateChainResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterCertificateChainResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterCertificateChainResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::ByteSpan Certificate)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterCertificateChainResponseCallback * cppCallback = nullptr;
        jbyteArray CertificateArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterCertificateChainResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B)V", &javaMethod);
        SuccessOrExit(err);

        CertificateArr = env->NewByteArray(Certificate.size());
        VerifyOrExit(CertificateArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(CertificateArr, 0, Certificate.size(), reinterpret_cast<const jbyte *>(Certificate.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, CertificateArr);

        env->DeleteLocalRef(CertificateArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterNOCResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterNOCResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterNOCResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterNOCResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterNOCResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t StatusCode, uint8_t FabricIndex, chip::CharSpan DebugText)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterNOCResponseCallback * cppCallback = nullptr;
        UtfString DebugTextStr(env, DebugText);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterNOCResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(StatusCode), static_cast<jint>(FabricIndex),
                            DebugTextStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPOperationalCredentialsClusterOpCSRResponseCallback
    : public Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>
{
public:
    CHIPOperationalCredentialsClusterOpCSRResponseCallback(jobject javaCallback) :
        Callback::Callback<OperationalCredentialsClusterOpCSRResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPOperationalCredentialsClusterOpCSRResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::ByteSpan NOCSRElements, chip::ByteSpan AttestationSignature)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPOperationalCredentialsClusterOpCSRResponseCallback * cppCallback = nullptr;
        jbyteArray NOCSRElementsArr;
        jbyteArray AttestationSignatureArr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPOperationalCredentialsClusterOpCSRResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "([B[B)V", &javaMethod);
        SuccessOrExit(err);

        NOCSRElementsArr = env->NewByteArray(NOCSRElements.size());
        VerifyOrExit(NOCSRElementsArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(NOCSRElementsArr, 0, NOCSRElements.size(), reinterpret_cast<const jbyte *>(NOCSRElements.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);
        AttestationSignatureArr = env->NewByteArray(AttestationSignature.size());
        VerifyOrExit(AttestationSignatureArr != nullptr, err = CHIP_ERROR_NO_MEMORY);
        env->ExceptionClear();
        env->SetByteArrayRegion(AttestationSignatureArr, 0, AttestationSignature.size(),
                                reinterpret_cast<const jbyte *>(AttestationSignature.data()));
        VerifyOrExit(!env->ExceptionCheck(), err = CHIP_JNI_ERROR_EXCEPTION_THROWN);

        env->CallVoidMethod(javaCallbackRef, javaMethod, NOCSRElementsArr, AttestationSignatureArr);

        env->DeleteLocalRef(NOCSRElementsArr);
        env->DeleteLocalRef(AttestationSignatureArr);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterAddSceneResponseCallback : public Callback::Callback<ScenesClusterAddSceneResponseCallback>
{
public:
    CHIPScenesClusterAddSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterAddSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterAddSceneResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterAddSceneResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterAddSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterGetSceneMembershipResponseCallback
    : public Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback>
{
public:
    CHIPScenesClusterGetSceneMembershipResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterGetSceneMembershipResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterGetSceneMembershipResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint8_t capacity, uint16_t groupId, uint8_t sceneCount,
                           /* TYPE WARNING: array array defaults to */ uint8_t * sceneList)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterGetSceneMembershipResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterGetSceneMembershipResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIII)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(capacity),
                            static_cast<jint>(groupId), static_cast<jint>(sceneCount)
                            // sceneList: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterRemoveAllScenesResponseCallback : public Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback>
{
public:
    CHIPScenesClusterRemoveAllScenesResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterRemoveAllScenesResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterRemoveAllScenesResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterRemoveAllScenesResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterRemoveAllScenesResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterRemoveSceneResponseCallback : public Callback::Callback<ScenesClusterRemoveSceneResponseCallback>
{
public:
    CHIPScenesClusterRemoveSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterRemoveSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterRemoveSceneResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterRemoveSceneResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterRemoveSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterStoreSceneResponseCallback : public Callback::Callback<ScenesClusterStoreSceneResponseCallback>
{
public:
    CHIPScenesClusterStoreSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterStoreSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterStoreSceneResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterStoreSceneResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterStoreSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(III)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPScenesClusterViewSceneResponseCallback : public Callback::Callback<ScenesClusterViewSceneResponseCallback>
{
public:
    CHIPScenesClusterViewSceneResponseCallback(jobject javaCallback) :
        Callback::Callback<ScenesClusterViewSceneResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPScenesClusterViewSceneResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, uint16_t groupId, uint8_t sceneId, uint16_t transitionTime,
                           chip::CharSpan sceneName, /* TYPE WARNING: array array defaults to */ uint8_t * extensionFieldSets)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPScenesClusterViewSceneResponseCallback * cppCallback = nullptr;
        UtfString sceneNameStr(env, sceneName);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPScenesClusterViewSceneResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(IIIILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), static_cast<jint>(groupId),
                            static_cast<jint>(sceneId), static_cast<jint>(transitionTime), sceneNameStr.jniValue()
                            // extensionFieldSets: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTvChannelClusterChangeChannelResponseCallback : public Callback::Callback<TvChannelClusterChangeChannelResponseCallback>
{
public:
    CHIPTvChannelClusterChangeChannelResponseCallback(jobject javaCallback) :
        Callback::Callback<TvChannelClusterChangeChannelResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTvChannelClusterChangeChannelResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, /* TYPE WARNING: array array defaults to */ uint8_t * ChannelMatch, uint8_t ErrorType)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTvChannelClusterChangeChannelResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTvChannelClusterChangeChannelResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef,
                            javaMethod
                            // ChannelMatch: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
                            ,
                            static_cast<jint>(ErrorType));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTargetNavigatorClusterNavigateTargetResponseCallback
    : public Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback>
{
public:
    CHIPTargetNavigatorClusterNavigateTargetResponseCallback(jobject javaCallback) :
        Callback::Callback<TargetNavigatorClusterNavigateTargetResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTargetNavigatorClusterNavigateTargetResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t status, chip::CharSpan data)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTargetNavigatorClusterNavigateTargetResponseCallback * cppCallback = nullptr;
        UtfString dataStr(env, data);

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTargetNavigatorClusterNavigateTargetResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ILjava/lang/String;)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(status), dataStr.jniValue());

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterClusterTestAddArgumentsResponseCallback
    : public Callback::Callback<TestClusterClusterTestAddArgumentsResponseCallback>
{
public:
    CHIPTestClusterClusterTestAddArgumentsResponseCallback(jobject javaCallback) :
        Callback::Callback<TestClusterClusterTestAddArgumentsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTestClusterClusterTestAddArgumentsResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t returnValue)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTestClusterClusterTestAddArgumentsResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTestClusterClusterTestAddArgumentsResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(returnValue));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterClusterTestEnumsResponseCallback : public Callback::Callback<TestClusterClusterTestEnumsResponseCallback>
{
public:
    CHIPTestClusterClusterTestEnumsResponseCallback(jobject javaCallback) :
        Callback::Callback<TestClusterClusterTestEnumsResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTestClusterClusterTestEnumsResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, chip::VendorId arg1, uint8_t arg2)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTestClusterClusterTestEnumsResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTestClusterClusterTestEnumsResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(II)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(arg1), static_cast<jint>(arg2));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterClusterTestListInt8UReverseResponseCallback
    : public Callback::Callback<TestClusterClusterTestListInt8UReverseResponseCallback>
{
public:
    CHIPTestClusterClusterTestListInt8UReverseResponseCallback(jobject javaCallback) :
        Callback::Callback<TestClusterClusterTestListInt8UReverseResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTestClusterClusterTestListInt8UReverseResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, /* TYPE WARNING: array array defaults to */ uint8_t * arg1)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTestClusterClusterTestListInt8UReverseResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTestClusterClusterTestListInt8UReverseResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "()V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod
                            // arg1: /* TYPE WARNING: array array defaults to */ uint8_t *
                            // Conversion from this type to Java is not properly implemented yet
        );

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterClusterTestNullableOptionalResponseCallback
    : public Callback::Callback<TestClusterClusterTestNullableOptionalResponseCallback>
{
public:
    CHIPTestClusterClusterTestNullableOptionalResponseCallback(jobject javaCallback) :
        Callback::Callback<TestClusterClusterTestNullableOptionalResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTestClusterClusterTestNullableOptionalResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, bool wasPresent, bool wasNull, uint8_t value, uint8_t originalValue)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTestClusterClusterTestNullableOptionalResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTestClusterClusterTestNullableOptionalResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(ZZII)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jboolean>(wasPresent), static_cast<jboolean>(wasNull),
                            static_cast<jint>(value), static_cast<jint>(originalValue));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

class CHIPTestClusterClusterTestSpecificResponseCallback : public Callback::Callback<TestClusterClusterTestSpecificResponseCallback>
{
public:
    CHIPTestClusterClusterTestSpecificResponseCallback(jobject javaCallback) :
        Callback::Callback<TestClusterClusterTestSpecificResponseCallback>(CallbackFn, this)
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }

        javaCallbackRef = env->NewGlobalRef(javaCallback);
        if (javaCallbackRef == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
        }
    }
    ~CHIPTestClusterClusterTestSpecificResponseCallback()
    {
        JNIEnv * env = JniReferences::GetInstance().GetEnvForCurrentThread();
        if (env == nullptr)
        {
            ChipLogError(Zcl, "Could not create global reference for Java callback");
            return;
        }
        env->DeleteGlobalRef(javaCallbackRef);
    };

    static void CallbackFn(void * context, uint8_t returnValue)
    {
        chip::DeviceLayer::StackUnlock unlock;
        CHIP_ERROR err = CHIP_NO_ERROR;
        JNIEnv * env   = JniReferences::GetInstance().GetEnvForCurrentThread();
        jobject javaCallbackRef;
        jmethodID javaMethod;
        CHIPTestClusterClusterTestSpecificResponseCallback * cppCallback = nullptr;

        VerifyOrExit(env != nullptr, err = CHIP_JNI_ERROR_NO_ENV);

        cppCallback = reinterpret_cast<CHIPTestClusterClusterTestSpecificResponseCallback *>(context);
        VerifyOrExit(cppCallback != nullptr, err = CHIP_JNI_ERROR_NULL_OBJECT);

        javaCallbackRef = cppCallback->javaCallbackRef;
        VerifyOrExit(javaCallbackRef != nullptr, err = CHIP_NO_ERROR);

        err = JniReferences::GetInstance().FindMethod(env, javaCallbackRef, "onSuccess", "(I)V", &javaMethod);
        SuccessOrExit(err);

        env->CallVoidMethod(javaCallbackRef, javaMethod, static_cast<jint>(returnValue));

    exit:
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error invoking Java callback: %" CHIP_ERROR_FORMAT, err.Format());
        }
        if (cppCallback != nullptr)
        {
            cppCallback->Cancel();
            delete cppCallback;
        }
    }

private:
    jobject javaCallbackRef;
};

JNI_METHOD(void, BaseChipCluster, deleteCluster)(JNIEnv * env, jobject self, jlong clusterPtr)
{
    chip::DeviceLayer::StackLock lock;
    ClusterBase * cluster = reinterpret_cast<ClusterBase *>(clusterPtr);
    if (cluster != nullptr)
    {
        delete cluster;
    }
}

JNI_METHOD(jlong, AccountLoginCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AccountLoginCluster * cppCluster = new AccountLoginCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AccountLoginCluster, getSetupPIN)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    JniUtfString tempAccountIdentifierStr(env, tempAccountIdentifier);

    std::unique_ptr<CHIPAccountLoginClusterGetSetupPINResponseCallback,
                    void (*)(CHIPAccountLoginClusterGetSetupPINResponseCallback *)>
        onSuccess(Platform::New<CHIPAccountLoginClusterGetSetupPINResponseCallback>(callback),
                  Platform::Delete<CHIPAccountLoginClusterGetSetupPINResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetSetupPIN(onSuccess->Cancel(), onFailure->Cancel(),
                                  chip::CharSpan(tempAccountIdentifierStr.c_str(), strlen(tempAccountIdentifierStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, AccountLoginCluster, login)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring tempAccountIdentifier, jstring setupPIN)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AccountLoginCluster * cppCluster;

    JniUtfString tempAccountIdentifierStr(env, tempAccountIdentifier);
    JniUtfString setupPINStr(env, setupPIN);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<AccountLoginCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Login(onSuccess->Cancel(), onFailure->Cancel(),
                            chip::CharSpan(tempAccountIdentifierStr.c_str(), strlen(tempAccountIdentifierStr.c_str())),
                            chip::CharSpan(setupPINStr.c_str(), strlen(setupPINStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, AdministratorCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AdministratorCommissioningCluster * cppCluster = new AdministratorCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AdministratorCommissioningCluster, openBasicCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint commissioningTimeout)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OpenBasicCommissioningWindow(onSuccess->Cancel(), onFailure->Cancel(), commissioningTimeout);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, AdministratorCommissioningCluster, openCommissioningWindow)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint commissioningTimeout, jbyteArray PAKEVerifier,
 jint discriminator, jlong iterations, jbyteArray salt, jint passcodeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    JniByteArray PAKEVerifierArr(env, PAKEVerifier);
    JniByteArray saltArr(env, salt);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OpenCommissioningWindow(onSuccess->Cancel(), onFailure->Cancel(), commissioningTimeout,
                                              chip::ByteSpan((const uint8_t *) PAKEVerifierArr.data(), PAKEVerifierArr.size()),
                                              discriminator, iterations,
                                              chip::ByteSpan((const uint8_t *) saltArr.data(), saltArr.size()), passcodeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, AdministratorCommissioningCluster, revokeCommissioning)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AdministratorCommissioningCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<AdministratorCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RevokeCommissioning(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, ApplicationBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationBasicCluster * cppCluster = new ApplicationBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationBasicCluster, changeStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint status)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationBasicCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ApplicationBasicCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(status));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, ApplicationLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ApplicationLauncherCluster * cppCluster = new ApplicationLauncherCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ApplicationLauncherCluster, launchApp)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring data, jint catalogVendorId, jstring applicationId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ApplicationLauncherCluster * cppCluster;

    JniUtfString dataStr(env, data);
    JniUtfString applicationIdStr(env, applicationId);

    std::unique_ptr<CHIPApplicationLauncherClusterLaunchAppResponseCallback,
                    void (*)(CHIPApplicationLauncherClusterLaunchAppResponseCallback *)>
        onSuccess(Platform::New<CHIPApplicationLauncherClusterLaunchAppResponseCallback>(callback),
                  Platform::Delete<CHIPApplicationLauncherClusterLaunchAppResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ApplicationLauncherCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchApp(onSuccess->Cancel(), onFailure->Cancel(), chip::CharSpan(dataStr.c_str(), strlen(dataStr.c_str())),
                                catalogVendorId, chip::CharSpan(applicationIdStr.c_str(), strlen(applicationIdStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, AudioOutputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    AudioOutputCluster * cppCluster = new AudioOutputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, AudioOutputCluster, renameOutput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index, jstring name)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    JniUtfString nameStr(env, name);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RenameOutput(onSuccess->Cancel(), onFailure->Cancel(), index,
                                   chip::CharSpan(nameStr.c_str(), strlen(nameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, AudioOutputCluster, selectOutput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    AudioOutputCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<AudioOutputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SelectOutput(onSuccess->Cancel(), onFailure->Cancel(), index);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, BarrierControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BarrierControlCluster * cppCluster = new BarrierControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BarrierControlCluster, barrierControlGoToPercent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint percentOpen)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->BarrierControlGoToPercent(onSuccess->Cancel(), onFailure->Cancel(), percentOpen);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BarrierControlCluster, barrierControlStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BarrierControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BarrierControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->BarrierControlStop(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, BasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BasicCluster * cppCluster = new BasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BasicCluster, mfgSpecificPing)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BasicCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MfgSpecificPing(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, BasicCluster, writeUserLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeUserLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                              chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, writeLocationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeLocation(onSuccess->Cancel(), onFailure->Cancel(),
                                             chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicCluster, writeLocalConfigDisabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    BasicCluster * cppCluster = reinterpret_cast<BasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeLocalConfigDisabled(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, BinaryInputBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BinaryInputBasicCluster * cppCluster = new BinaryInputBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BinaryInputBasicCluster, writeOutOfServiceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOutOfService(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, writePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributePresentValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, subscribePresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePresentValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportPresentValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePresentValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, subscribeStatusFlagsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStatusFlags(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BinaryInputBasicCluster, reportStatusFlagsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BinaryInputBasicCluster * cppCluster = reinterpret_cast<BinaryInputBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStatusFlags(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BindingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BindingCluster * cppCluster = new BindingCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BindingCluster, bind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong nodeId, jint groupId, jint endpointId, jlong clusterId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Bind(onSuccess->Cancel(), onFailure->Cancel(), nodeId, groupId, endpointId, clusterId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BindingCluster, unbind)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong nodeId, jint groupId, jint endpointId, jlong clusterId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BindingCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BindingCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Unbind(onSuccess->Cancel(), onFailure->Cancel(), nodeId, groupId, endpointId, clusterId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, BooleanStateCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BooleanStateCluster * cppCluster = new BooleanStateCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BooleanStateCluster, subscribeStateValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeStateValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BooleanStateCluster, reportStateValueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    BooleanStateCluster * cppCluster = reinterpret_cast<BooleanStateCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeStateValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, BridgedActionsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BridgedActionsCluster * cppCluster = new BridgedActionsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedActionsCluster, disableAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->DisableAction(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, disableActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jlong duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->DisableActionWithDuration(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID, duration);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, enableAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnableAction(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, enableActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jlong duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnableActionWithDuration(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID, duration);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, instantAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->InstantAction(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, instantActionWithTransition)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jint transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->InstantActionWithTransition(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, pauseAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->PauseAction(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, pauseActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jlong duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->PauseActionWithDuration(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID, duration);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, resumeAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResumeAction(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, startAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StartAction(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, startActionWithDuration)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID, jlong duration)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StartActionWithDuration(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID, duration);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, BridgedActionsCluster, stopAction)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint actionID, jlong invokeID)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    BridgedActionsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<BridgedActionsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopAction(onSuccess->Cancel(), onFailure->Cancel(), actionID, invokeID);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, BridgedDeviceBasicCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    BridgedDeviceBasicCluster * cppCluster = new BridgedDeviceBasicCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, BridgedDeviceBasicCluster, writeUserLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                         = CHIP_NO_ERROR;
    BridgedDeviceBasicCluster * cppCluster = reinterpret_cast<BridgedDeviceBasicCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeUserLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                              chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ColorControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ColorControlCluster * cppCluster = new ColorControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ColorControlCluster, colorLoopSet)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint updateFlags, jint action, jint direction, jint time,
 jint startHue, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ColorLoopSet(onSuccess->Cancel(), onFailure->Cancel(), updateFlags, static_cast<uint8_t>(action),
                                   static_cast<uint8_t>(direction), time, startHue, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnhancedMoveHue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(moveMode), rate, optionsMask,
                                      optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint enhancedHue, jint direction, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnhancedMoveToHue(onSuccess->Cancel(), onFailure->Cancel(), enhancedHue, static_cast<uint8_t>(direction),
                                        transitionTime, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, enhancedMoveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint enhancedHue, jint saturation, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnhancedMoveToHueAndSaturation(onSuccess->Cancel(), onFailure->Cancel(), enhancedHue, saturation,
                                                     transitionTime, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, enhancedStepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnhancedStepHue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(stepMode), stepSize,
                                      transitionTime, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint rateX, jint rateY, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveColor(onSuccess->Cancel(), onFailure->Cancel(), rateX, rateY, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint colorTemperatureMinimum,
 jint colorTemperatureMaximum, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(moveMode), rate,
                                           colorTemperatureMinimum, colorTemperatureMaximum, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveHue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(moveMode), rate, optionsMask,
                              optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveSaturation(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(moveMode), rate, optionsMask,
                                     optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveToColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint colorX, jint colorY, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToColor(onSuccess->Cancel(), onFailure->Cancel(), colorX, colorY, transitionTime, optionsMask,
                                  optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveToColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint colorTemperature, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), colorTemperature, transitionTime,
                                             optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveToHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint hue, jint direction, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToHue(onSuccess->Cancel(), onFailure->Cancel(), hue, static_cast<uint8_t>(direction), transitionTime,
                                optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveToHueAndSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint hue, jint saturation, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToHueAndSaturation(onSuccess->Cancel(), onFailure->Cancel(), hue, saturation, transitionTime, optionsMask,
                                             optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, moveToSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint saturation, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToSaturation(onSuccess->Cancel(), onFailure->Cancel(), saturation, transitionTime, optionsMask,
                                       optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, stepColor)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepX, jint stepY, jint transitionTime, jint optionsMask,
 jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->StepColor(onSuccess->Cancel(), onFailure->Cancel(), stepX, stepY, transitionTime, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, stepColorTemperature)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint colorTemperatureMinimum, jint colorTemperatureMaximum, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepColorTemperature(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(stepMode), stepSize,
                                           transitionTime, colorTemperatureMinimum, colorTemperatureMaximum, optionsMask,
                                           optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, stepHue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepHue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(stepMode), stepSize, transitionTime,
                              optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, stepSaturation)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime,
 jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepSaturation(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(stepMode), stepSize,
                                     transitionTime, optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ColorControlCluster, stopMoveStep)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint optionsMask, jint optionsOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopMoveStep(onSuccess->Cancel(), onFailure->Cancel(), optionsMask, optionsOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentHueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentHue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentHueAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentHue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentSaturation(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentSaturationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentSaturation(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentXAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentX(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeCurrentYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportCurrentYAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentY(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, subscribeColorTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeColorTemperature(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, reportColorTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeColorTemperature(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorControlOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorControlOptions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeWhitePointX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeWhitePointYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeWhitePointY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointRX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointRY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointRIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointRIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointGX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointGY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointGIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointGIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBXAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointBX(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBYAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointBY(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeColorPointBIntensityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeColorPointBIntensity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ColorControlCluster, writeStartUpColorTemperatureMiredsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    ColorControlCluster * cppCluster = reinterpret_cast<ColorControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeStartUpColorTemperatureMireds(onSuccess->Cancel(), onFailure->Cancel(),
                                                                  static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ContentLauncherCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ContentLauncherCluster * cppCluster = new ContentLauncherCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ContentLauncherCluster, launchContent)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean autoPlay, jstring data)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster;

    JniUtfString dataStr(env, data);

    std::unique_ptr<CHIPContentLauncherClusterLaunchContentResponseCallback,
                    void (*)(CHIPContentLauncherClusterLaunchContentResponseCallback *)>
        onSuccess(Platform::New<CHIPContentLauncherClusterLaunchContentResponseCallback>(callback),
                  Platform::Delete<CHIPContentLauncherClusterLaunchContentResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchContent(onSuccess->Cancel(), onFailure->Cancel(), autoPlay,
                                    chip::CharSpan(dataStr.c_str(), strlen(dataStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ContentLauncherCluster, launchURL)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring contentURL, jstring displayString)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ContentLauncherCluster * cppCluster;

    JniUtfString contentURLStr(env, contentURL);
    JniUtfString displayStringStr(env, displayString);

    std::unique_ptr<CHIPContentLauncherClusterLaunchURLResponseCallback,
                    void (*)(CHIPContentLauncherClusterLaunchURLResponseCallback *)>
        onSuccess(Platform::New<CHIPContentLauncherClusterLaunchURLResponseCallback>(callback),
                  Platform::Delete<CHIPContentLauncherClusterLaunchURLResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ContentLauncherCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LaunchURL(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::CharSpan(contentURLStr.c_str(), strlen(contentURLStr.c_str())),
                                chip::CharSpan(displayStringStr.c_str(), strlen(displayStringStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, DescriptorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DescriptorCluster * cppCluster = new DescriptorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, DiagnosticLogsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DiagnosticLogsCluster * cppCluster = new DiagnosticLogsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DiagnosticLogsCluster, retrieveLogsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint intent, jint requestedProtocol,
 jbyteArray transferFileDesignator)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DiagnosticLogsCluster * cppCluster;

    JniByteArray transferFileDesignatorArr(env, transferFileDesignator);

    std::unique_ptr<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback,
                    void (*)(CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback *)>
        onSuccess(Platform::New<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>(callback),
                  Platform::Delete<CHIPDiagnosticLogsClusterRetrieveLogsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DiagnosticLogsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RetrieveLogsRequest(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(intent), static_cast<uint8_t>(requestedProtocol),
        chip::ByteSpan((const uint8_t *) transferFileDesignatorArr.data(), transferFileDesignatorArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, DoorLockCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    DoorLockCluster * cppCluster = new DoorLockCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, DoorLockCluster, clearAllPins)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterClearAllPinsResponseCallback, void (*)(CHIPDoorLockClusterClearAllPinsResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearAllPinsResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearAllPinsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearAllPins(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, clearAllRfids)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterClearAllRfidsResponseCallback, void (*)(CHIPDoorLockClusterClearAllRfidsResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearAllRfidsResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearAllRfidsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearAllRfids(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, clearHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterClearHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearHolidayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearHolidayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearHolidayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, clearPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterClearPinResponseCallback, void (*)(CHIPDoorLockClusterClearPinResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterClearPinResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterClearPinResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearPin(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, clearRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterClearRfidResponseCallback, void (*)(CHIPDoorLockClusterClearRfidResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearRfidResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearRfidResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearRfid(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, clearWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearWeekdayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearWeekdayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, clearYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterClearYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterClearYeardayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterClearYeardayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterClearYeardayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, getHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterGetHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetHolidayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetHolidayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, getLogRecord)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint logIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterGetLogRecordResponseCallback, void (*)(CHIPDoorLockClusterGetLogRecordResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetLogRecordResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetLogRecordResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetLogRecord(onSuccess->Cancel(), onFailure->Cancel(), logIndex);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, getPin)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterGetPinResponseCallback, void (*)(CHIPDoorLockClusterGetPinResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterGetPinResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterGetPinResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetPin(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, getRfid)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterGetRfidResponseCallback, void (*)(CHIPDoorLockClusterGetRfidResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterGetRfidResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterGetRfidResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetRfid(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, getUserType)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterGetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterGetUserTypeResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetUserTypeResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetUserTypeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetUserType(onSuccess->Cancel(), onFailure->Cancel(), userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, getWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetWeekdayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetWeekdayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, getYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterGetYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterGetYeardayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterGetYeardayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterGetYeardayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, lockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniByteArray pinArr(env, pin);

    std::unique_ptr<CHIPDoorLockClusterLockDoorResponseCallback, void (*)(CHIPDoorLockClusterLockDoorResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterLockDoorResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterLockDoorResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->LockDoor(onSuccess->Cancel(), onFailure->Cancel(),
                               chip::ByteSpan((const uint8_t *) pinArr.data(), pinArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, setHolidaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jlong localStartTime, jlong localEndTime,
 jint operatingModeDuringHoliday)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterSetHolidayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetHolidayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterSetHolidayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterSetHolidayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetHolidaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, localStartTime, localEndTime,
                                         operatingModeDuringHoliday);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, setPin)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userStatus, jint userType, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniByteArray pinArr(env, pin);

    std::unique_ptr<CHIPDoorLockClusterSetPinResponseCallback, void (*)(CHIPDoorLockClusterSetPinResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterSetPinResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterSetPinResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetPin(onSuccess->Cancel(), onFailure->Cancel(), userId, static_cast<uint8_t>(userStatus),
                             static_cast<uint8_t>(userType), chip::ByteSpan((const uint8_t *) pinArr.data(), pinArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, setRfid)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userStatus, jint userType, jbyteArray id)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniByteArray idArr(env, id);

    std::unique_ptr<CHIPDoorLockClusterSetRfidResponseCallback, void (*)(CHIPDoorLockClusterSetRfidResponseCallback *)> onSuccess(
        Platform::New<CHIPDoorLockClusterSetRfidResponseCallback>(callback),
        Platform::Delete<CHIPDoorLockClusterSetRfidResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetRfid(onSuccess->Cancel(), onFailure->Cancel(), userId, static_cast<uint8_t>(userStatus),
                              static_cast<uint8_t>(userType), chip::ByteSpan((const uint8_t *) idArr.data(), idArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, setUserType)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint userId, jint userType)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterSetUserTypeResponseCallback, void (*)(CHIPDoorLockClusterSetUserTypeResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterSetUserTypeResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterSetUserTypeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetUserType(onSuccess->Cancel(), onFailure->Cancel(), userId, static_cast<uint8_t>(userType));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, setWeekdaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId, jint daysMask, jint startHour,
 jint startMinute, jint endHour, jint endMinute)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetWeekdayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterSetWeekdayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetWeekdaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId, daysMask, startHour,
                                         startMinute, endHour, endMinute);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, setYeardaySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint scheduleId, jint userId, jlong localStartTime,
 jlong localEndTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    std::unique_ptr<CHIPDoorLockClusterSetYeardayScheduleResponseCallback,
                    void (*)(CHIPDoorLockClusterSetYeardayScheduleResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterSetYeardayScheduleResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterSetYeardayScheduleResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->SetYeardaySchedule(onSuccess->Cancel(), onFailure->Cancel(), scheduleId, userId, localStartTime, localEndTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, unlockDoor)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniByteArray pinArr(env, pin);

    std::unique_ptr<CHIPDoorLockClusterUnlockDoorResponseCallback, void (*)(CHIPDoorLockClusterUnlockDoorResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterUnlockDoorResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterUnlockDoorResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UnlockDoor(onSuccess->Cancel(), onFailure->Cancel(),
                                 chip::ByteSpan((const uint8_t *) pinArr.data(), pinArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, DoorLockCluster, unlockWithTimeout)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint timeoutInSeconds, jbyteArray pin)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster;

    JniByteArray pinArr(env, pin);

    std::unique_ptr<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback,
                    void (*)(CHIPDoorLockClusterUnlockWithTimeoutResponseCallback *)>
        onSuccess(Platform::New<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback>(callback),
                  Platform::Delete<CHIPDoorLockClusterUnlockWithTimeoutResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UnlockWithTimeout(onSuccess->Cancel(), onFailure->Cancel(), timeoutInSeconds,
                                        chip::ByteSpan((const uint8_t *) pinArr.data(), pinArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, DoorLockCluster, subscribeLockStateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLockState(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, DoorLockCluster, reportLockStateAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    DoorLockCluster * cppCluster = reinterpret_cast<DoorLockCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLockState(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ElectricalMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ElectricalMeasurementCluster * cppCluster = new ElectricalMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, EthernetNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    EthernetNetworkDiagnosticsCluster * cppCluster = new EthernetNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, EthernetNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    EthernetNetworkDiagnosticsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<EthernetNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetCounts(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, FixedLabelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    FixedLabelCluster * cppCluster = new FixedLabelCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, FlowMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    FlowMeasurementCluster * cppCluster = new FlowMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GeneralCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GeneralCommissioningCluster * cppCluster = new GeneralCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GeneralCommissioningCluster, armFailSafe)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint expiryLengthSeconds, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    std::unique_ptr<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterArmFailSafeResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterArmFailSafeResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ArmFailSafe(onSuccess->Cancel(), onFailure->Cancel(), expiryLengthSeconds, breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, GeneralCommissioningCluster, commissioningComplete)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    std::unique_ptr<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterCommissioningCompleteResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->CommissioningComplete(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, GeneralCommissioningCluster, setRegulatoryConfig)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint location, jstring countryCode, jlong breadcrumb,
 jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster;

    JniUtfString countryCodeStr(env, countryCode);

    std::unique_ptr<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback,
                    void (*)(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback *)>
        onSuccess(Platform::New<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>(callback),
                  Platform::Delete<CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetRegulatoryConfig(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(location),
                                          chip::CharSpan(countryCodeStr.c_str(), strlen(countryCodeStr.c_str())), breadcrumb,
                                          timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, GeneralCommissioningCluster, writeBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBreadcrumb(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, GeneralDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GeneralDiagnosticsCluster * cppCluster = new GeneralDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GroupKeyManagementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GroupKeyManagementCluster * cppCluster = new GroupKeyManagementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, GroupsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    GroupsCluster * cppCluster = new GroupsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, GroupsCluster, addGroup)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jstring groupName)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    JniUtfString groupNameStr(env, groupName);

    std::unique_ptr<CHIPGroupsClusterAddGroupResponseCallback, void (*)(CHIPGroupsClusterAddGroupResponseCallback *)> onSuccess(
        Platform::New<CHIPGroupsClusterAddGroupResponseCallback>(callback),
        Platform::Delete<CHIPGroupsClusterAddGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId,
                               chip::CharSpan(groupNameStr.c_str(), strlen(groupNameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, GroupsCluster, addGroupIfIdentifying)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jstring groupName)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    JniUtfString groupNameStr(env, groupName);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddGroupIfIdentifying(onSuccess->Cancel(), onFailure->Cancel(), groupId,
                                            chip::CharSpan(groupNameStr.c_str(), strlen(groupNameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, GroupsCluster, getGroupMembership)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupCount, jint groupList)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    std::unique_ptr<CHIPGroupsClusterGetGroupMembershipResponseCallback,
                    void (*)(CHIPGroupsClusterGetGroupMembershipResponseCallback *)>
        onSuccess(Platform::New<CHIPGroupsClusterGetGroupMembershipResponseCallback>(callback),
                  Platform::Delete<CHIPGroupsClusterGetGroupMembershipResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetGroupMembership(onSuccess->Cancel(), onFailure->Cancel(), groupCount, groupList);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, GroupsCluster, removeAllGroups)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveAllGroups(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, GroupsCluster, removeGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    std::unique_ptr<CHIPGroupsClusterRemoveGroupResponseCallback, void (*)(CHIPGroupsClusterRemoveGroupResponseCallback *)>
        onSuccess(Platform::New<CHIPGroupsClusterRemoveGroupResponseCallback>(callback),
                  Platform::Delete<CHIPGroupsClusterRemoveGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, GroupsCluster, viewGroup)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    GroupsCluster * cppCluster;

    std::unique_ptr<CHIPGroupsClusterViewGroupResponseCallback, void (*)(CHIPGroupsClusterViewGroupResponseCallback *)> onSuccess(
        Platform::New<CHIPGroupsClusterViewGroupResponseCallback>(callback),
        Platform::Delete<CHIPGroupsClusterViewGroupResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<GroupsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ViewGroup(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, IdentifyCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    IdentifyCluster * cppCluster = new IdentifyCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IdentifyCluster, identify)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint identifyTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Identify(onSuccess->Cancel(), onFailure->Cancel(), identifyTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, IdentifyCluster, identifyQuery)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    std::unique_ptr<CHIPIdentifyClusterIdentifyQueryResponseCallback, void (*)(CHIPIdentifyClusterIdentifyQueryResponseCallback *)>
        onSuccess(Platform::New<CHIPIdentifyClusterIdentifyQueryResponseCallback>(callback),
                  Platform::Delete<CHIPIdentifyClusterIdentifyQueryResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->IdentifyQuery(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, IdentifyCluster, triggerEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint effectIdentifier, jint effectVariant)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TriggerEffect(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(effectIdentifier),
                                    static_cast<uint8_t>(effectVariant));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, IdentifyCluster, writeIdentifyTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeIdentifyTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, IlluminanceMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    IlluminanceMeasurementCluster * cppCluster = new IlluminanceMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, IlluminanceMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, IlluminanceMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    IlluminanceMeasurementCluster * cppCluster = reinterpret_cast<IlluminanceMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, KeypadInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    KeypadInputCluster * cppCluster = new KeypadInputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, KeypadInputCluster, sendKey)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint keyCode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    KeypadInputCluster * cppCluster;

    std::unique_ptr<CHIPKeypadInputClusterSendKeyResponseCallback, void (*)(CHIPKeypadInputClusterSendKeyResponseCallback *)>
        onSuccess(Platform::New<CHIPKeypadInputClusterSendKeyResponseCallback>(callback),
                  Platform::Delete<CHIPKeypadInputClusterSendKeyResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<KeypadInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SendKey(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(keyCode));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, LevelControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    LevelControlCluster * cppCluster = new LevelControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LevelControlCluster, move)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate, jint optionMask, jint optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Move(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(moveMode), rate, optionMask,
                           optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, LevelControlCluster, moveToLevel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint level, jint transitionTime, jint optionMask,
 jint optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToLevel(onSuccess->Cancel(), onFailure->Cancel(), level, transitionTime, optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, LevelControlCluster, moveToLevelWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint level, jint transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveToLevelWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), level, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, LevelControlCluster, moveWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint moveMode, jint rate)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MoveWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(moveMode), rate);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, LevelControlCluster, step)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime, jint optionMask,
 jint optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Step(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(stepMode), stepSize, transitionTime,
                           optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, LevelControlCluster, stepWithOnOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint stepMode, jint stepSize, jint transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StepWithOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(stepMode), stepSize,
                                    transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, LevelControlCluster, stop)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint optionMask, jint optionOverride)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Stop(onSuccess->Cancel(), onFailure->Cancel(), optionMask, optionOverride);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, LevelControlCluster, stopWithOnOff)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopWithOnOff(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, LevelControlCluster, subscribeCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, reportCurrentLevelAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentLevel(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, LevelControlCluster, writeOptionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOptions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnOffTransitionTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOnTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnTransitionTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeOffTransitionTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOffTransitionTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeDefaultMoveRateAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeDefaultMoveRate(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LevelControlCluster, writeStartUpCurrentLevelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                   = CHIP_NO_ERROR;
    LevelControlCluster * cppCluster = reinterpret_cast<LevelControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeStartUpCurrentLevel(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, LowPowerCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    LowPowerCluster * cppCluster = new LowPowerCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, LowPowerCluster, sleep)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    LowPowerCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<LowPowerCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Sleep(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, MediaInputCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    MediaInputCluster * cppCluster = new MediaInputCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaInputCluster, hideInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->HideInputStatus(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaInputCluster, renameInput)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index, jstring name)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    JniUtfString nameStr(env, name);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RenameInput(onSuccess->Cancel(), onFailure->Cancel(), index,
                                  chip::CharSpan(nameStr.c_str(), strlen(nameStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaInputCluster, selectInput)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint index)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SelectInput(onSuccess->Cancel(), onFailure->Cancel(), index);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaInputCluster, showInputStatus)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaInputCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaInputCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ShowInputStatus(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, MediaPlaybackCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    MediaPlaybackCluster * cppCluster = new MediaPlaybackCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, MediaPlaybackCluster, mediaFastForward)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaFastForwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaFastForwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaFastForward(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaNext)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaNextResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaNextResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaNextResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaNextResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaNext(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPause)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPauseResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPauseResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPauseResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPauseResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPause(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPlay)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPlayResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPlayResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPlayResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPlayResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPlay(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaPrevious)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaPreviousResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaPreviousResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaPreviousResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaPrevious(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaRewind)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaRewindResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaRewindResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaRewindResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaRewindResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaRewind(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSeek)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong position)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSeekResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSeekResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSeekResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSeekResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSeek(onSuccess->Cancel(), onFailure->Cancel(), position);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipBackward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong deltaPositionMilliseconds)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSkipBackwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSkipBackward(onSuccess->Cancel(), onFailure->Cancel(), deltaPositionMilliseconds);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaSkipForward)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong deltaPositionMilliseconds)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaSkipForwardResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaSkipForward(onSuccess->Cancel(), onFailure->Cancel(), deltaPositionMilliseconds);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStartOver)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaStartOverResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaStartOverResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaStartOverResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaStartOver(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, MediaPlaybackCluster, mediaStop)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    MediaPlaybackCluster * cppCluster;

    std::unique_ptr<CHIPMediaPlaybackClusterMediaStopResponseCallback,
                    void (*)(CHIPMediaPlaybackClusterMediaStopResponseCallback *)>
        onSuccess(Platform::New<CHIPMediaPlaybackClusterMediaStopResponseCallback>(callback),
                  Platform::Delete<CHIPMediaPlaybackClusterMediaStopResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<MediaPlaybackCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->MediaStop(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, ModeSelectCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ModeSelectCluster * cppCluster = new ModeSelectCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ModeSelectCluster, changeToMode)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint newMode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeToMode(onSuccess->Cancel(), onFailure->Cancel(), newMode);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, ModeSelectCluster, subscribeCurrentModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                    static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ModeSelectCluster, reportCurrentModeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentMode(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ModeSelectCluster, writeOnModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ModeSelectCluster * cppCluster = reinterpret_cast<ModeSelectCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, NetworkCommissioningCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    NetworkCommissioningCluster * cppCluster = new NetworkCommissioningCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, NetworkCommissioningCluster, addThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray operationalDatasetArr(env, operationalDataset);

    std::unique_ptr<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterAddThreadNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddThreadNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                       chip::ByteSpan((const uint8_t *) operationalDatasetArr.data(), operationalDatasetArr.size()),
                                       breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, addWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jlong breadcrumb,
 jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);
    JniByteArray credentialsArr(env, credentials);

    std::unique_ptr<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterAddWiFiNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddWiFiNetwork(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()),
        chip::ByteSpan((const uint8_t *) credentialsArr.data(), credentialsArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, disableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);

    std::unique_ptr<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterDisableNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterDisableNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->DisableNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                     chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                     timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, enableNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);

    std::unique_ptr<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterEnableNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterEnableNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->EnableNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                    timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, removeNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray networkID, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray networkIDArr(env, networkID);

    std::unique_ptr<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterRemoveNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveNetwork(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::ByteSpan((const uint8_t *) networkIDArr.data(), networkIDArr.size()), breadcrumb,
                                    timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, scanNetworks)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);

    std::unique_ptr<CHIPNetworkCommissioningClusterScanNetworksResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterScanNetworksResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterScanNetworksResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ScanNetworks(onSuccess->Cancel(), onFailure->Cancel(),
                                   chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, updateThreadNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray operationalDataset, jlong breadcrumb, jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray operationalDatasetArr(env, operationalDataset);

    std::unique_ptr<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterUpdateThreadNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateThreadNetwork(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) operationalDatasetArr.data(), operationalDatasetArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, NetworkCommissioningCluster, updateWiFiNetwork)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray ssid, jbyteArray credentials, jlong breadcrumb,
 jlong timeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster;

    JniByteArray ssidArr(env, ssid);
    JniByteArray credentialsArr(env, credentials);

    std::unique_ptr<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback,
                    void (*)(CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback *)>
        onSuccess(Platform::New<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>(callback),
                  Platform::Delete<CHIPNetworkCommissioningClusterUpdateWiFiNetworkResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateWiFiNetwork(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) ssidArr.data(), ssidArr.size()),
        chip::ByteSpan((const uint8_t *) credentialsArr.data(), credentialsArr.size()), breadcrumb, timeoutMs);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, OtaSoftwareUpdateProviderCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateProviderCluster * cppCluster = new OtaSoftwareUpdateProviderCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, applyUpdateRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jlong newVersion)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniByteArray updateTokenArr(env, updateToken);

    std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback,
                    void (*)(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback *)>
        onSuccess(Platform::New<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>(callback),
                  Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err =
        cppCluster->ApplyUpdateRequest(onSuccess->Cancel(), onFailure->Cancel(),
                                       chip::ByteSpan((const uint8_t *) updateTokenArr.data(), updateTokenArr.size()), newVersion);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, notifyUpdateApplied)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray updateToken, jlong softwareVersion)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniByteArray updateTokenArr(env, updateToken);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->NotifyUpdateApplied(onSuccess->Cancel(), onFailure->Cancel(),
                                          chip::ByteSpan((const uint8_t *) updateTokenArr.data(), updateTokenArr.size()),
                                          softwareVersion);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OtaSoftwareUpdateProviderCluster, queryImage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint vendorId, jint productId, jlong softwareVersion,
 jint protocolsSupported, jint hardwareVersion, jstring location, jboolean requestorCanConsent, jbyteArray metadataForProvider)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateProviderCluster * cppCluster;

    JniUtfString locationStr(env, location);
    JniByteArray metadataForProviderArr(env, metadataForProvider);

    std::unique_ptr<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback,
                    void (*)(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback *)>
        onSuccess(Platform::New<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>(callback),
                  Platform::Delete<CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OtaSoftwareUpdateProviderCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->QueryImage(onSuccess->Cancel(), onFailure->Cancel(), static_cast<chip::VendorId>(vendorId), productId,
                                 softwareVersion, static_cast<uint8_t>(protocolsSupported), hardwareVersion,
                                 chip::CharSpan(locationStr.c_str(), strlen(locationStr.c_str())), requestorCanConsent,
                                 chip::ByteSpan((const uint8_t *) metadataForProviderArr.data(), metadataForProviderArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, OtaSoftwareUpdateRequestorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OtaSoftwareUpdateRequestorCluster * cppCluster = new OtaSoftwareUpdateRequestorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, announceOtaProvider)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong providerLocation, jint vendorId, jint announcementReason,
 jbyteArray metadataForNode)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster;

    JniByteArray metadataForNodeArr(env, metadataForNode);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AnnounceOtaProvider(onSuccess->Cancel(), onFailure->Cancel(), providerLocation,
                                          static_cast<chip::VendorId>(vendorId), static_cast<uint8_t>(announcementReason),
                                          chip::ByteSpan((const uint8_t *) metadataForNodeArr.data(), metadataForNodeArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, OtaSoftwareUpdateRequestorCluster, writeDefaultOtaProviderAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                 = CHIP_NO_ERROR;
    OtaSoftwareUpdateRequestorCluster * cppCluster = reinterpret_cast<OtaSoftwareUpdateRequestorCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeDefaultOtaProvider(onSuccess->Cancel(), onFailure->Cancel(),
                                                       chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, OccupancySensingCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OccupancySensingCluster * cppCluster = new OccupancySensingCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OccupancySensingCluster, subscribeOccupancyAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOccupancy(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OccupancySensingCluster, reportOccupancyAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    OccupancySensingCluster * cppCluster = reinterpret_cast<OccupancySensingCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOccupancy(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, OnOffCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OnOffCluster * cppCluster = new OnOffCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffCluster, off)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Off(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OnOffCluster, offWithEffect)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint effectId, jint effectVariant)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OffWithEffect(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(effectId),
                                    static_cast<uint8_t>(effectVariant));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OnOffCluster, on)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->On(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OnOffCluster, onWithRecallGlobalScene)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OnWithRecallGlobalScene(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OnOffCluster, onWithTimedOff)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint onOffControl, jint onTime, jint offWaitTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OnWithTimedOff(onSuccess->Cancel(), onFailure->Cancel(), onOffControl, onTime, offWaitTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OnOffCluster, toggle)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OnOffCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Toggle(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, OnOffCluster, subscribeOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                              static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, reportOnOffAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPBooleanAttributeCallback, void (*)(CHIPBooleanAttributeCallback *)> onReport(
        Platform::New<CHIPBooleanAttributeCallback>(callback, true), Platform::Delete<CHIPBooleanAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOnOff(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, OnOffCluster, writeOnTimeAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOnTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, writeOffWaitTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOffWaitTime(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, OnOffCluster, writeStartUpOnOffAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err            = CHIP_NO_ERROR;
    OnOffCluster * cppCluster = reinterpret_cast<OnOffCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeStartUpOnOff(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, OnOffSwitchConfigurationCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OnOffSwitchConfigurationCluster * cppCluster = new OnOffSwitchConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OnOffSwitchConfigurationCluster, writeSwitchActionsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                               = CHIP_NO_ERROR;
    OnOffSwitchConfigurationCluster * cppCluster = reinterpret_cast<OnOffSwitchConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeSwitchActions(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, OperationalCredentialsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    OperationalCredentialsCluster * cppCluster = new OperationalCredentialsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, OperationalCredentialsCluster, addNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray NOCValue, jbyteArray ICACValue, jbyteArray IPKValue,
 jlong caseAdminNode, jint adminVendorId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray NOCValueArr(env, NOCValue);
    JniByteArray ICACValueArr(env, ICACValue);
    JniByteArray IPKValueArr(env, IPKValue);

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddNOC(
        onSuccess->Cancel(), onFailure->Cancel(), chip::ByteSpan((const uint8_t *) NOCValueArr.data(), NOCValueArr.size()),
        chip::ByteSpan((const uint8_t *) ICACValueArr.data(), ICACValueArr.size()),
        chip::ByteSpan((const uint8_t *) IPKValueArr.data(), IPKValueArr.size()), caseAdminNode, adminVendorId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, addTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray rootCertificate)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray rootCertificateArr(env, rootCertificate);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddTrustedRootCertificate(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) rootCertificateArr.data(), rootCertificateArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, attestationRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray attestationNonce)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray attestationNonceArr(env, attestationNonce);

    std::unique_ptr<CHIPOperationalCredentialsClusterAttestationResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterAttestationResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterAttestationResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterAttestationResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AttestationRequest(onSuccess->Cancel(), onFailure->Cancel(),
                                         chip::ByteSpan((const uint8_t *) attestationNonceArr.data(), attestationNonceArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, certificateChainRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint certificateType)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    std::unique_ptr<CHIPOperationalCredentialsClusterCertificateChainResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterCertificateChainResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterCertificateChainResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->CertificateChainRequest(onSuccess->Cancel(), onFailure->Cancel(), certificateType);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, opCSRRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray CSRNonce)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray CSRNonceArr(env, CSRNonce);

    std::unique_ptr<CHIPOperationalCredentialsClusterOpCSRResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterOpCSRResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterOpCSRResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterOpCSRResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->OpCSRRequest(onSuccess->Cancel(), onFailure->Cancel(),
                                   chip::ByteSpan((const uint8_t *) CSRNonceArr.data(), CSRNonceArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, removeFabric)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint fabricIndex)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveFabric(onSuccess->Cancel(), onFailure->Cancel(), fabricIndex);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, removeTrustedRootCertificate)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray trustedRootIdentifier)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray trustedRootIdentifierArr(env, trustedRootIdentifier);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveTrustedRootCertificate(
        onSuccess->Cancel(), onFailure->Cancel(),
        chip::ByteSpan((const uint8_t *) trustedRootIdentifierArr.data(), trustedRootIdentifierArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, updateFabricLabel)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring label)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniUtfString labelStr(env, label);

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateFabricLabel(onSuccess->Cancel(), onFailure->Cancel(),
                                        chip::CharSpan(labelStr.c_str(), strlen(labelStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, OperationalCredentialsCluster, updateNOC)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray NOCValue, jbyteArray ICACValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    OperationalCredentialsCluster * cppCluster;

    JniByteArray NOCValueArr(env, NOCValue);
    JniByteArray ICACValueArr(env, ICACValue);

    std::unique_ptr<CHIPOperationalCredentialsClusterNOCResponseCallback,
                    void (*)(CHIPOperationalCredentialsClusterNOCResponseCallback *)>
        onSuccess(Platform::New<CHIPOperationalCredentialsClusterNOCResponseCallback>(callback),
                  Platform::Delete<CHIPOperationalCredentialsClusterNOCResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<OperationalCredentialsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpdateNOC(onSuccess->Cancel(), onFailure->Cancel(),
                                chip::ByteSpan((const uint8_t *) NOCValueArr.data(), NOCValueArr.size()),
                                chip::ByteSpan((const uint8_t *) ICACValueArr.data(), ICACValueArr.size()));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, PowerSourceCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PowerSourceCluster * cppCluster = new PowerSourceCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, PressureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PressureMeasurementCluster * cppCluster = new PressureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PressureMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PressureMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                          = CHIP_NO_ERROR;
    PressureMeasurementCluster * cppCluster = reinterpret_cast<PressureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, PumpConfigurationAndControlCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    PumpConfigurationAndControlCluster * cppCluster = new PumpConfigurationAndControlCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribePumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributePumpStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                   static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportPumpStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributePumpStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, subscribeCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCapacity(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                 static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, reportCapacityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCapacity(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeOperationModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOperationMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, PumpConfigurationAndControlCluster, writeControlModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    PumpConfigurationAndControlCluster * cppCluster = reinterpret_cast<PumpConfigurationAndControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeControlMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, RelativeHumidityMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    RelativeHumidityMeasurementCluster * cppCluster = new RelativeHumidityMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTolerance(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, RelativeHumidityMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                  = CHIP_NO_ERROR;
    RelativeHumidityMeasurementCluster * cppCluster = reinterpret_cast<RelativeHumidityMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTolerance(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, ScenesCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ScenesCluster * cppCluster = new ScenesCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ScenesCluster, addScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId, jint transitionTime, jstring sceneName,
 jlong clusterId, jint length, jint value)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    JniUtfString sceneNameStr(env, sceneName);

    std::unique_ptr<CHIPScenesClusterAddSceneResponseCallback, void (*)(CHIPScenesClusterAddSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterAddSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterAddSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->AddScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId, transitionTime,
                               chip::CharSpan(sceneNameStr.c_str(), strlen(sceneNameStr.c_str())), clusterId, length, value);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ScenesCluster, getSceneMembership)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    std::unique_ptr<CHIPScenesClusterGetSceneMembershipResponseCallback,
                    void (*)(CHIPScenesClusterGetSceneMembershipResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterGetSceneMembershipResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterGetSceneMembershipResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetSceneMembership(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ScenesCluster, recallScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId, jint transitionTime)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RecallScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId, transitionTime);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ScenesCluster, removeAllScenes)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    std::unique_ptr<CHIPScenesClusterRemoveAllScenesResponseCallback, void (*)(CHIPScenesClusterRemoveAllScenesResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterRemoveAllScenesResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterRemoveAllScenesResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveAllScenes(onSuccess->Cancel(), onFailure->Cancel(), groupId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ScenesCluster, removeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    std::unique_ptr<CHIPScenesClusterRemoveSceneResponseCallback, void (*)(CHIPScenesClusterRemoveSceneResponseCallback *)>
        onSuccess(Platform::New<CHIPScenesClusterRemoveSceneResponseCallback>(callback),
                  Platform::Delete<CHIPScenesClusterRemoveSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->RemoveScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ScenesCluster, storeScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    std::unique_ptr<CHIPScenesClusterStoreSceneResponseCallback, void (*)(CHIPScenesClusterStoreSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterStoreSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterStoreSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StoreScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ScenesCluster, viewScene)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint groupId, jint sceneId)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ScenesCluster * cppCluster;

    std::unique_ptr<CHIPScenesClusterViewSceneResponseCallback, void (*)(CHIPScenesClusterViewSceneResponseCallback *)> onSuccess(
        Platform::New<CHIPScenesClusterViewSceneResponseCallback>(callback),
        Platform::Delete<CHIPScenesClusterViewSceneResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ScenesCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ViewScene(onSuccess->Cancel(), onFailure->Cancel(), groupId, sceneId);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, SoftwareDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    SoftwareDiagnosticsCluster * cppCluster = new SoftwareDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SoftwareDiagnosticsCluster, resetWatermarks)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    SoftwareDiagnosticsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<SoftwareDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetWatermarks(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, SwitchCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    SwitchCluster * cppCluster = new SwitchCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, SwitchCluster, subscribeCurrentPositionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPosition(onSuccess->Cancel(), onFailure->Cancel(),
                                                        static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, SwitchCluster, reportCurrentPositionAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err             = CHIP_NO_ERROR;
    SwitchCluster * cppCluster = reinterpret_cast<SwitchCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPosition(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, TvChannelCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TvChannelCluster * cppCluster = new TvChannelCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TvChannelCluster, changeChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring match)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    JniUtfString matchStr(env, match);

    std::unique_ptr<CHIPTvChannelClusterChangeChannelResponseCallback,
                    void (*)(CHIPTvChannelClusterChangeChannelResponseCallback *)>
        onSuccess(Platform::New<CHIPTvChannelClusterChangeChannelResponseCallback>(callback),
                  Platform::Delete<CHIPTvChannelClusterChangeChannelResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeChannel(onSuccess->Cancel(), onFailure->Cancel(),
                                    chip::CharSpan(matchStr.c_str(), strlen(matchStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TvChannelCluster, changeChannelByNumber)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint majorNumber, jint minorNumber)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ChangeChannelByNumber(onSuccess->Cancel(), onFailure->Cancel(), majorNumber, minorNumber);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TvChannelCluster, skipChannel)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint count)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TvChannelCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TvChannelCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SkipChannel(onSuccess->Cancel(), onFailure->Cancel(), count);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, TargetNavigatorCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TargetNavigatorCluster * cppCluster = new TargetNavigatorCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TargetNavigatorCluster, navigateTarget)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint target, jstring data)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TargetNavigatorCluster * cppCluster;

    JniUtfString dataStr(env, data);

    std::unique_ptr<CHIPTargetNavigatorClusterNavigateTargetResponseCallback,
                    void (*)(CHIPTargetNavigatorClusterNavigateTargetResponseCallback *)>
        onSuccess(Platform::New<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>(callback),
                  Platform::Delete<CHIPTargetNavigatorClusterNavigateTargetResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TargetNavigatorCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->NavigateTarget(onSuccess->Cancel(), onFailure->Cancel(), target,
                                     chip::CharSpan(dataStr.c_str(), strlen(dataStr.c_str())));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, TemperatureMeasurementCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TemperatureMeasurementCluster * cppCluster = new TemperatureMeasurementCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TemperatureMeasurementCluster, subscribeMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeMeasuredValue(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                      static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportMeasuredValueAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeMeasuredValue(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, subscribeToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTolerance(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                  static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TemperatureMeasurementCluster, reportToleranceAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                             = CHIP_NO_ERROR;
    TemperatureMeasurementCluster * cppCluster = reinterpret_cast<TemperatureMeasurementCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTolerance(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
JNI_METHOD(jlong, TestClusterCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    TestClusterCluster * cppCluster = new TestClusterCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, TestClusterCluster, test)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->Test(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testAddArguments)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1, jint arg2)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPTestClusterClusterTestAddArgumentsResponseCallback,
                    void (*)(CHIPTestClusterClusterTestAddArgumentsResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestAddArgumentsResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestAddArgumentsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestAddArguments(onSuccess->Cancel(), onFailure->Cancel(), arg1, arg2);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testEnumsRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1, jint arg2)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPTestClusterClusterTestEnumsResponseCallback, void (*)(CHIPTestClusterClusterTestEnumsResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestEnumsResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestEnumsResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestEnumsRequest(onSuccess->Cancel(), onFailure->Cancel(), static_cast<chip::VendorId>(arg1),
                                       static_cast<uint8_t>(arg2));
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testListInt8UArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestListInt8UArgumentRequest(onSuccess->Cancel(), onFailure->Cancel(), arg1);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testListInt8UReverseRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPTestClusterClusterTestListInt8UReverseResponseCallback,
                    void (*)(CHIPTestClusterClusterTestListInt8UReverseResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestListInt8UReverseResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestListInt8UReverseRequest(onSuccess->Cancel(), onFailure->Cancel(), arg1);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testListStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint a, jboolean b, jint c, jbyteArray d, jstring e, jint f)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    JniByteArray dArr(env, d);
    JniUtfString eStr(env, e);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestListStructArgumentRequest(onSuccess->Cancel(), onFailure->Cancel(), a, b, static_cast<uint8_t>(c),
                                                    chip::ByteSpan((const uint8_t *) dArr.data(), dArr.size()),
                                                    chip::CharSpan(eStr.c_str(), strlen(eStr.c_str())), f);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testNotHandled)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestNotHandled(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testNullableOptionalRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint arg1)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPTestClusterClusterTestNullableOptionalResponseCallback,
                    void (*)(CHIPTestClusterClusterTestNullableOptionalResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestNullableOptionalResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestNullableOptionalResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestNullableOptionalRequest(onSuccess->Cancel(), onFailure->Cancel(), arg1);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testSpecific)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPTestClusterClusterTestSpecificResponseCallback,
                    void (*)(CHIPTestClusterClusterTestSpecificResponseCallback *)>
        onSuccess(Platform::New<CHIPTestClusterClusterTestSpecificResponseCallback>(callback),
                  Platform::Delete<CHIPTestClusterClusterTestSpecificResponseCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestSpecific(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testStructArgumentRequest)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint a, jboolean b, jint c, jbyteArray d, jstring e, jint f)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    JniByteArray dArr(env, d);
    JniUtfString eStr(env, e);

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestStructArgumentRequest(onSuccess->Cancel(), onFailure->Cancel(), a, b, static_cast<uint8_t>(c),
                                                chip::ByteSpan((const uint8_t *) dArr.data(), dArr.size()),
                                                chip::CharSpan(eStr.c_str(), strlen(eStr.c_str())), f);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, TestClusterCluster, testUnknownCommand)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->TestUnknownCommand(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, TestClusterCluster, writeBooleanAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBoolean(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBitmap8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBitmap16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap32Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBitmap32(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeBitmap64Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeBitmap64(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt8u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt16u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt32u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64uAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt64u(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt8sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt8s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt16sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt16s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt32sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt32s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeInt64sAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeInt64s(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum8Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeEnum8(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEnum16Attribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeEnum16(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongOctetStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jbyteArray value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniByteArray jniArr(env, value);
    err = cppCluster->WriteAttributeLongOctetString(onSuccess->Cancel(), onFailure->Cancel(),
                                                    chip::ByteSpan((const uint8_t *) jniArr.data(), jniArr.size()));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeCharString(onSuccess->Cancel(), onFailure->Cancel(),
                                               chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeLongCharStringAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    JniUtfString valueStr(env, value);
    err = cppCluster->WriteAttributeLongCharString(onSuccess->Cancel(), onFailure->Cancel(),
                                                   chip::CharSpan(valueStr.c_str(), strlen(valueStr.c_str())));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochUsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeEpochUs(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint64_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeEpochSAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jlong value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeEpochS(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint32_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeVendorIdAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeVendorId(onSuccess->Cancel(), onFailure->Cancel(), static_cast<chip::VendorId>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, TestClusterCluster, writeUnsupportedAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jboolean value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                  = CHIP_NO_ERROR;
    TestClusterCluster * cppCluster = reinterpret_cast<TestClusterCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeUnsupported(onSuccess->Cancel(), onFailure->Cancel(), static_cast<bool>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ThermostatCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatCluster * cppCluster = new ThermostatCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatCluster, clearWeeklySchedule)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ClearWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ThermostatCluster, getRelayStatusLog)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetRelayStatusLog(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ThermostatCluster, getWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint daysToReturn, jint modeToReturn)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GetWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel(), daysToReturn, modeToReturn);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ThermostatCluster, setWeeklySchedule)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint numberOfTransitionsForSequence, jint dayOfWeekForSequence,
 jint modeForSequence, jint payload)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetWeeklySchedule(onSuccess->Cancel(), onFailure->Cancel(), numberOfTransitionsForSequence,
                                        dayOfWeekForSequence, modeForSequence, payload);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, ThermostatCluster, setpointRaiseLower)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint mode, jint amount)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->SetpointRaiseLower(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(mode), amount);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, ThermostatCluster, subscribeLocalTemperatureAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeLocalTemperature(onSuccess->Cancel(), onFailure->Cancel(),
                                                         static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, reportLocalTemperatureAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16sAttributeCallback, void (*)(CHIPInt16sAttributeCallback *)> onReport(
        Platform::New<CHIPInt16sAttributeCallback>(callback, true), Platform::Delete<CHIPInt16sAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeLocalTemperature(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedCoolingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOccupiedCoolingSetpoint(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeOccupiedHeatingSetpointAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeOccupiedHeatingSetpoint(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMinHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxHeatSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMaxHeatSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMinCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMaxCoolSetpointLimitAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMaxCoolSetpointLimit(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int16_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeMinSetpointDeadBandAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMinSetpointDeadBand(onSuccess->Cancel(), onFailure->Cancel(), static_cast<int8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeControlSequenceOfOperationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err =
        cppCluster->WriteAttributeControlSequenceOfOperation(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatCluster, writeSystemModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                 = CHIP_NO_ERROR;
    ThermostatCluster * cppCluster = reinterpret_cast<ThermostatCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeSystemMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ThermostatUserInterfaceConfigurationCluster, initWithDevice)
(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThermostatUserInterfaceConfigurationCluster * cppCluster = new ThermostatUserInterfaceConfigurationCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeTemperatureDisplayModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeTemperatureDisplayMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeKeypadLockoutAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeKeypadLockout(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, ThermostatUserInterfaceConfigurationCluster, writeScheduleProgrammingVisibilityAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err = CHIP_NO_ERROR;
    ThermostatUserInterfaceConfigurationCluster * cppCluster =
        reinterpret_cast<ThermostatUserInterfaceConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeScheduleProgrammingVisibility(onSuccess->Cancel(), onFailure->Cancel(),
                                                                  static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}
JNI_METHOD(jlong, ThreadNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    ThreadNetworkDiagnosticsCluster * cppCluster = new ThreadNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, ThreadNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    ThreadNetworkDiagnosticsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<ThreadNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetCounts(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, WakeOnLanCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WakeOnLanCluster * cppCluster = new WakeOnLanCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(jlong, WiFiNetworkDiagnosticsCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WiFiNetworkDiagnosticsCluster * cppCluster = new WiFiNetworkDiagnosticsCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WiFiNetworkDiagnosticsCluster, resetCounts)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WiFiNetworkDiagnosticsCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<WiFiNetworkDiagnosticsCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->ResetCounts(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(jlong, WindowCoveringCluster, initWithDevice)(JNIEnv * env, jobject self, jlong devicePtr, jint endpointId)
{
    chip::DeviceLayer::StackLock lock;
    WindowCoveringCluster * cppCluster = new WindowCoveringCluster();

    cppCluster->Associate(reinterpret_cast<Device *>(devicePtr), endpointId);
    return reinterpret_cast<jlong>(cppCluster);
}

JNI_METHOD(void, WindowCoveringCluster, downOrClose)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->DownOrClose(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint liftPercentageValue, jint liftPercent100thsValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GoToLiftPercentage(onSuccess->Cancel(), onFailure->Cancel(), liftPercentageValue, liftPercent100thsValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, WindowCoveringCluster, goToLiftValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint liftValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GoToLiftValue(onSuccess->Cancel(), onFailure->Cancel(), liftValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltPercentage)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint tiltPercentageValue, jint tiltPercent100thsValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GoToTiltPercentage(onSuccess->Cancel(), onFailure->Cancel(), tiltPercentageValue, tiltPercent100thsValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, WindowCoveringCluster, goToTiltValue)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint tiltValue)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->GoToTiltValue(onSuccess->Cancel(), onFailure->Cancel(), tiltValue);
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, WindowCoveringCluster, stopMotion)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->StopMotion(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}
JNI_METHOD(void, WindowCoveringCluster, upOrOpen)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    CHIP_ERROR err = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster;

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrExit(onSuccess.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);
    VerifyOrExit(onFailure.get() != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrExit(cppCluster != nullptr, err = CHIP_ERROR_INCORRECT_STATE);

    err = cppCluster->UpOrOpen(onSuccess->Cancel(), onFailure->Cancel());
    SuccessOrExit(err);

exit:
    if (err != CHIP_NO_ERROR)
    {
        jthrowable exception;
        jmethodID method;

        err = JniReferences::GetInstance().FindMethod(env, callback, "onError", "(Ljava/lang/Exception;)V", &method);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }

        err = chip::AndroidClusterExceptions::GetInstance().CreateIllegalStateException(env, "Error invoking cluster", err,
                                                                                        exception);
        if (err != CHIP_NO_ERROR)
        {
            ChipLogError(Zcl, "Error throwing IllegalStateException %" CHIP_ERROR_FORMAT, err.Format());
            return;
        }
        env->CallVoidMethod(callback, method, exception);
    }
    else
    {
        onSuccess.release();
        onFailure.release();
    }
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionLiftPercentage(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionLiftPercentage(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionTiltPercentage(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltPercentageAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionTiltPercentage(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeOperationalStatus(onSuccess->Cancel(), onFailure->Cancel(),
                                                          static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportOperationalStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt8uAttributeCallback, void (*)(CHIPInt8uAttributeCallback *)> onReport(
        Platform::New<CHIPInt8uAttributeCallback>(callback, true), Platform::Delete<CHIPInt8uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeOperationalStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTargetPositionLiftPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTargetPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTargetPositionLiftPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeTargetPositionTiltPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportTargetPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeTargetPositionTiltPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionLiftPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionLiftPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionLiftPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeCurrentPositionTiltPercent100ths(
        onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval), static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportCurrentPositionTiltPercent100thsAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeCurrentPositionTiltPercent100ths(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}

JNI_METHOD(void, WindowCoveringCluster, writeModeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint value)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->WriteAttributeMode(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint8_t>(value));
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, subscribeSafetyStatusAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jint minInterval, jint maxInterval)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->SubscribeAttributeSafetyStatus(onSuccess->Cancel(), onFailure->Cancel(), static_cast<uint16_t>(minInterval),
                                                     static_cast<uint16_t>(maxInterval));
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error subscribing to attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, WindowCoveringCluster, reportSafetyStatusAttribute)(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback)
{
    chip::DeviceLayer::StackLock lock;
    std::unique_ptr<CHIPInt16uAttributeCallback, void (*)(CHIPInt16uAttributeCallback *)> onReport(
        Platform::New<CHIPInt16uAttributeCallback>(callback, true), Platform::Delete<CHIPInt16uAttributeCallback>);
    VerifyOrReturn(onReport.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native report callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                     = CHIP_NO_ERROR;
    WindowCoveringCluster * cppCluster = reinterpret_cast<WindowCoveringCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    err = cppCluster->ReportAttributeSafetyStatus(onReport->Cancel());
    VerifyOrReturn(err == CHIP_NO_ERROR,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error registering for attribute reporting", err));

    onReport.release();
}
